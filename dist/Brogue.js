/*
	This is Brogue.js, A simple JS roguelike micro-framework for developers new to programming and or JS.
	Version 1.7.5, generated on Sat Oct  3 10:08:34 CDT 2020.
*/
/////////////////////////
// Brogue.js
/////////////////////////
(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD
        define([/* dependencies (as strings) */], factory);
    } else if (typeof exports === 'object') {
        // Node, CommonJS-like
        module.exports = factory(/* dependencies (from requires) */);
    } else {
        // Browser globals (root is window)
        Object.assign(root, factory(/* root.jQuery, root._ */));
    }
}(this, function () {
//
//  RogueMain.h
//  Brogue
//
//  Created by Brian Walker on 12/26/08.
//  Copyright 2012. All rights reserved.
//
//  This file is part of Brogue.
//
//  This program is free software: you can redistribute it and/or modify
//  it under the terms of the GNU Affero General Public License as
//  published by the Free Software Foundation, either version 3 of the
//  License, or (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU Affero General Public License for more details.
//
//  You should have received a copy of the GNU Affero General Public License
//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
//

// #include <stdio.h>
// #include <stdlib.h>
// #include <string.h>
// #include "PlatformDefines.h"


// unicode: comment this line to revert to ASCII

const USE_UNICODE = true;
const NULL = null;

// version string -- no more than 16 bytes:
const BROGUE_VERSION_STRING = "1.7.5-js";

// debug macros -- define DEBUGGING as 1 to enable wizard mode.

const DEBUGGING = 0;	// use 1 || 0

const DEBUG = console.debug;
const printf = function(...args) {
	args = args.map( (a) => {
		if (a instanceof BrogueString) return a.text;
		return a;
	});
	console.log(...args);
}

const MONSTERS_ENABLED = (!DEBUGGING || 1); // Quest room monsters can be generated regardless.
const ITEMS_ENABLED    = (!DEBUGGING || 1);

const D_BULLET_TIME =					(DEBUGGING && 0);
const D_WORMHOLING =					(DEBUGGING && 1);
const D_IMMORTAL =						(DEBUGGING && 1);

const D_SAFETY_VISION =								(DEBUGGING && 0);
const D_SCENT_VISION =                (DEBUGGING && 0);
const D_DISABLE_BACKGROUND_COLORS =		(DEBUGGING && 0);

const D_INSPECT_LEVELGEN =				 (DEBUGGING && 0);
const D_INSPECT_ROOM_ADD =         (D_INSPECT_LEVELGEN && 0);
const D_INSPECT_DOORS =            (D_INSPECT_ROOM_ADD && 0);
const D_INSPECT_LAKES =         	 (D_INSPECT_LEVELGEN && 0);
const D_INSPECT_AUTOGENERATORS =   (D_INSPECT_LEVELGEN && 0);
const D_INSPECT_MACHINES =				 (D_INSPECT_LEVELGEN && 0);
const D_INSPECT_MACHINE_FEATURES = (D_INSPECT_MACHINES && 0);
const D_INSPECT_ITEM_GEN = 				 (D_INSPECT_LEVELGEN && 0);
const D_INSPECT_MON_GEN  = 				 (D_INSPECT_LEVELGEN && 0);

const D_INSPECT_MONSTER_SPAWN = 				(DEBUGGING && 0);

const D_MESSAGE_ITEM_GENERATION =       (DEBUGGING && 0);
const D_MESSAGE_MONSTER_GENERATION =    (DEBUGGING && 0);
const D_MESSAGE_MACHINE_GENERATION =    (DEBUGGING && 0);

const D_MONSTER_OMNISCIENCE 			 = 		(DEBUGGING && 0);
const D_ITEM_OMNISCIENCE 					 = 		(DEBUGGING && 0);

// set to false to allow multiple loads from the same saved file:
const DELETE_SAVE_FILE_AFTER_LOADING	= true;

// set to false to disable references to keystrokes (e.g. for a tablet port)
const KEYBOARD_LABELS = true;

//#define BROGUE_ASSERTS		// introduces several assert()s -- useful to find certain array overruns and other bugs
//#define AUDIT_RNG             // VERY slow, but sometimes necessary to debug out-of-sync recording errors
//#define GENERATE_FONT_FILES	// Displays font in grid upon startup, which can be screen-captured into font files for PC.


function assert(v) {
	if (!v) throw new Error('Assertion failed');
}

function brogueAssert(v) {
	if (!v) {
		throw new Error('Assert failed.');
	}
}


// function clone(x) {
// 	if (Array.isArray(x)) {
// 		return x.slice();
// 	}
// 	else if (typeof x === 'object') {
// 		return Object.assign({}, x);
// 	}
// 	return x;
// }

function cloneDeep(x) {
	if (Array.isArray(x)) {
		return x.map( (v) => cloneDeep(v) );
	}
	else if (typeof x === 'object') {
		const entries = Object.entries(x);
		const out = {};
		entries.forEach( ([key, value]) => {
			out[key] = cloneDeep(value);
		});
		return out;
	}
	return x;
}


const PI = 3.14159265;

// const FLOAT_FUDGE = 0.00001;

const FP_BASE  = 16; // Don't change this without recalculating all of the power tables throughout the code!
const FP_FACTOR  = (1 << FP_BASE);


// recording and save filenames
const LAST_GAME_PATH =			"LastGame.broguesave";
const LAST_GAME_NAME =          "LastGame";
const LAST_RECORDING_NAME =     "LastRecording";
const RECORDING_SUFFIX =		".broguerec";
const GAME_SUFFIX =				".broguesave";
const ANNOTATION_SUFFIX =		".txt";
const RNG_LOG =					"RNGLog.txt";

const BROGUE_FILENAME_MAX		= 255; // (Math.min(1024*4, FILENAME_MAX))

// Allows unicode characters:
// #define uchar					unsigned short

const MESSAGE_LINES	=		3;

// Size of the entire terminal window. These need to be hard-coded here and in Viewport.h
const COLS =					100;
const ROWS =					(31 + MESSAGE_LINES);

const MESSAGE_ARCHIVE_LINES	= ROWS;

const STAT_BAR_WIDTH =		20;			// number of characters in the stats bar to the left of the map

// Size of the portion of the terminal window devoted to displaying the dungeon:
const DCOLS =					(COLS - STAT_BAR_WIDTH - 1); // n columns on the left for the sidebar;
                                                            // one column to separate the sidebar from the map.
const DROWS =					(ROWS - MESSAGE_LINES - 2);	// n lines at the top for messages;
															// one line at the bottom for flavor text;
															// another line at the bottom for the menu bar.


const LOS_SLOPE_GRANULARITY =	32768;		// how finely we divide up the squares when calculating slope;
											// higher numbers mean fewer artifacts but more memory and processing
const INTERFACE_OPACITY =		95;

const LIGHT_SMOOTHING_THRESHOLD = 150;       // light components higher than this magnitude will be toned down a little

const MAX_BOLT_LENGTH =			DCOLS*10;

const VISIBILITY_THRESHOLD =	50;			// how bright cumulative light has to be before the cell is marked visible

const AMULET_LEVEL =			26;			// how deep before the amulet appears
const DEEPEST_LEVEL =           40;          // how deep the universe goes

const MACHINES_FACTOR =         1.0;         // use this to adjust machine frequency

const MACHINES_BUFFER_LENGTH =  200;

// const DEFENSE_FACTOR =                      0.987;		// Each point of armor multiplies enemy attackers' accuracy by this value.
//                                                         // (displayed armor value is 10% of the real value)
// const WEAPON_ENCHANT_DAMAGE_FACTOR =        1.065;		// Each marginal point of weapon enchantment
//                                                         // multiplies damage by this factor.
// const WEAPON_ENCHANT_ACCURACY_FACTOR =      1.065;		// Each marginal point of weapon enchantment
//                                                         // multiplies accuracy by this factor.

const WEAPON_KILLS_TO_AUTO_ID =	20;
const ARMOR_DELAY_TO_AUTO_ID =	1000;
const RING_DELAY_TO_AUTO_ID =	1500;

const FALL_DAMAGE_MIN =         8;
const FALL_DAMAGE_MAX =         10;

const INPUT_RECORD_BUFFER =		1000;		// how many bytes of input data to keep in memory before saving it to disk
const DEFAULT_PLAYBACK_DELAY =	50;

const HIGH_SCORES_COUNT =		30;

// color escapes
const COLOR_ESCAPE =			25;
const COLOR_END    =      26;
const COLOR_VALUE_INTERCEPT =	25;


function centerText(bstring, len) {
	const totalPad = (len - bstring.textLength);
	const leftPad = Math.round(totalPad/2);
	return bstring.padStart(leftPad + bstring.textlength, ' ').padEnd(len, ' ');
}

function capitalize(bstring) {
	bstring = STRING(bstring);
	return bstring.capitalize();
}


// display characters:

// #ifdef USE_UNICODE

const FLOOR_CHAR =		'\u00b7';
const LIQUID_CHAR =		'~';
const CHASM_CHAR =		'\u2237';
const TRAP_CHAR =		'\u25c7';
const FIRE_CHAR =		'\u22CF';
const GRASS_CHAR =		'"';
const BRIDGE_CHAR =		'=';
const DESCEND_CHAR =	'>';
const ASCEND_CHAR =		'<';
const WALL_CHAR =		'#';
const DOOR_CHAR =		'+';
const OPEN_DOOR_CHAR =	'\'';
const ASH_CHAR =		'\'';
const BONES_CHAR =		',';
const MUD_CHAR =		',';
const WEB_CHAR =		':';
//const FOLIAGE_CHAR =	'\u03A8' // upper-case psi;
//const FOLIAGE_CHAR =	'\u2648' // Aries symbol (not supported on many browsers);
const FOLIAGE_CHAR =	'\u03C8' // lower case psi
const VINE_CHAR =       ':';
const ALTAR_CHAR =		'|';
const LEVER_CHAR =      '/';
const LEVER_PULLED_CHAR = '\\';
const STATUE_CHAR =		'\u00df';
const VENT_CHAR =		'=';
const DEWAR_CHAR =      '&';

const TRAMPLED_FOLIAGE_CHAR =	'"'		// '\u2034' // '\u2037';

const PLAYER_CHAR =		'@';

const AMULET_CHAR =		'\u2640';
const FOOD_CHAR =		';';
const SCROLL_CHAR =		'\u266A'//'?'		// '\u039E';
//const RING_CHAR =		'\u26AA' //'\uffee';
const RING_CHAR =		'o';
const CHARM_CHAR =      '\u03DE';
const POTION_CHAR =		'!';
const ARMOR_CHAR =		'[';
const WEAPON_CHAR =		'\u2191';
const STAFF_CHAR =		'\\';
const WAND_CHAR =		'~';
const GOLD_CHAR =		'*';
const GEM_CHAR =		'\u25cf';
const TOTEM_CHAR =		'\u26b2'; // 1.7.4 = '\u2641';
const TURRET_CHAR =		'\u25cf';
const UNICORN_CHAR =    '\u00da';
const KEY_CHAR =		'-';
const ELECTRIC_CRYSTAL_CHAR = '\u00a4'; // 1.7.4 = 164;

const UP_ARROW_CHAR =		'\u2191';
const DOWN_ARROW_CHAR =		'\u2193';
const LEFT_ARROW_CHAR =		'\u2190';
const RIGHT_ARROW_CHAR =	'\u2192';
const UP_TRIANGLE_CHAR =	'\u2206';
const DOWN_TRIANGLE_CHAR =	'\u2207';
const OMEGA_CHAR =			'\u03A9';
const THETA_CHAR =			'\u03B8';
const LAMDA_CHAR =			'\u03BB';
const KOPPA_CHAR =			'\u03DF'//'\u03DE';
const LOZENGE_CHAR =		'\u29eb'; // 1.7.4 = '\u25C6';
const CROSS_PRODUCT_CHAR =	'\u2A2F';

const CHAIN_TOP_LEFT =		'\\';
const CHAIN_BOTTOM_RIGHT =	'\\';
const CHAIN_TOP_RIGHT =		'/';
const CHAIN_BOTTOM_LEFT =	'/';
const CHAIN_TOP =			'|';
const CHAIN_BOTTOM =		'|';
const CHAIN_LEFT =			'-';
const CHAIN_RIGHT =			'-';

const BAD_MAGIC_CHAR =		'\u29f2'; // 1.7.4 = '\u25C6';
const GOOD_MAGIC_CHAR =		'\u29f3'; // 1.7.4 = '\u25C7';

// #else

// #define FLOOR_CHAR		'.'
// #define LIQUID_CHAR		'~'
// #define CHASM_CHAR		':'
// #define TRAP_CHAR		'%'
// #define FIRE_CHAR		'^'
// #define GRASS_CHAR		'"'
// #define BRIDGE_CHAR		'='
// #define DESCEND_CHAR	'>'
// #define ASCEND_CHAR		'<'
// #define WALL_CHAR		'#'
// #define DOOR_CHAR		'+'
// #define OPEN_DOOR_CHAR	'\''
// #define ASH_CHAR		'\''
// #define BONES_CHAR		','
// #define MUD_CHAR		','
// #define WEB_CHAR		':'
// #define FOLIAGE_CHAR	'&'
// #define VINE_CHAR       ':'
// #define ALTAR_CHAR		'|'
// #define LEVER_CHAR      '/'
// #define LEVER_PULLED_CHAR '\\'
// #define STATUE_CHAR		'&'
// #define VENT_CHAR		'='
// #define DEWAR_CHAR      '&'
//
// #define TRAMPLED_FOLIAGE_CHAR	'"'
//
// #define PLAYER_CHAR		'@'
//
// #define AMULET_CHAR		','
// #define FOOD_CHAR		';'
// #define SCROLL_CHAR		'?'
// #define RING_CHAR		'='
// #define CHARM_CHAR      '+'
// #define POTION_CHAR		'!'
// #define ARMOR_CHAR		'['
// #define WEAPON_CHAR		'('
// #define STAFF_CHAR		'\\'
// #define WAND_CHAR		'~'
// #define GOLD_CHAR		'*'
// #define GEM_CHAR		'+'
// #define TOTEM_CHAR		'0'
// #define TURRET_CHAR		'*'
// #define UNICORN_CHAR    'U'
// #define KEY_CHAR		'-'
// #define ELECTRIC_CRYSTAL_CHAR '$'
//
// #define UP_ARROW_CHAR		'^'
// #define DOWN_ARROW_CHAR		'v'
// #define LEFT_ARROW_CHAR		'<'
// #define RIGHT_ARROW_CHAR	'>'
// #define UP_TRIANGLE_CHAR	'^'
// #define DOWN_TRIANGLE_CHAR	'v'
// #define OMEGA_CHAR			'^'
// #define THETA_CHAR			'0'
// #define LAMDA_CHAR			'\\'
// #define KOPPA_CHAR			'k'
// #define LOZENGE_CHAR		'+'
// #define CROSS_PRODUCT_CHAR	'x'
//
// #define CHAIN_TOP_LEFT		'\\'
// #define CHAIN_BOTTOM_RIGHT	'\\'
// #define CHAIN_TOP_RIGHT		'/'
// #define CHAIN_BOTTOM_LEFT	'/'
// #define CHAIN_TOP			'|'
// #define CHAIN_BOTTOM		'|'
// #define CHAIN_LEFT			'-'
// #define CHAIN_RIGHT			'-'
//
// #define BAD_MAGIC_CHAR		'+'
// #define GOOD_MAGIC_CHAR		'$'
//
// #endif

const GLOBAL = (typeof global !== 'undefined') ? global : this;	// this === window

class Enum {
	constructor() {

	}

	toString(v) {
		if (v === undefined) return enumName;
		return Object.entries(out).reduce( (out, [key, value]) => (value == v) ? key : out, '?' );
	}
}

function ENUM(enumName, ...names) {

	const out = new Enum();
	let offset = 0;
	if (typeof names[0] === 'number') {
		offset = names.shift();
	}
	names.forEach( (name, index) => {
		GLOBAL[name] = index + offset;
		out[name] = index + offset;
	});

	GLOBAL[enumName] = out;
	return out;
}


ENUM('eventTypes',
	'UPDATE',
	'KEYSTROKE',
	'MOUSE_UP',
	'MOUSE_DOWN',
	'RIGHT_MOUSE_DOWN',
	'RIGHT_MOUSE_UP',
	'MOUSE_ENTERED_CELL',
	'RNG_CHECK',
	'SAVED_GAME_LOADED',
	'END_OF_RECORDING',
	'EVENT_ERROR',
	'NUMBER_OF_EVENT_TYPES', // unused
);

// 1.7.4
ENUM('notificationEventTypes',
	'GAMEOVER_QUIT',
	'GAMEOVER_DEATH',
	'GAMEOVER_VICTORY',
	'GAMEOVER_SUPERVICTORY',
	'GAMEOVER_RECORDING'
);


class RogueEvent {
	constructor(type, p1, p2, ctrl, shift) {
		/* ENUM eventTypes */ this.eventType = type || 0;
		/* signed long */ this.param1 = p1 || 0;
		/* signed long */ this.param2 = p2 || 0;
		/* boolean */ this.controlKey = ctrl || false;
		/* boolean */ this.shiftKey = shift || false;
	}

	copy(other) {
		Object.assign(this, other);
	}

	clone() {
		return new RogueEvent(this.eventType, this.param1, this.param2, this.controlKey, this.shiftKey);
	}
}

function rogueEvent(type, p1, p2, ctrl, shift) {
	return new RogueEvent(type, p1, p2, ctrl, shift);
}


class RogueHighScoresEntry {
	constructor() {
		this.score = 0;
		this.date = STRING();
		this.description = STRING();
	}

	clear() {
		this.score = 0;
		strcpy(this.date, "");
		strcpy(this.description, "");
	}

	copy(other) {
		this.score = other.score;
		strcpy(this.date, other.date);
		strcpy(this.description, other.description);
	}
}

function rogueHighScoresEntry() {
	return new RogueHighScoresEntry();
}


function fileEntry() {
	return {
		path: '',
		date: ''
	}
}


ENUM('RNGs',
	'RNG_SUBSTANTIVE',
	'RNG_COSMETIC',
	'NUMBER_OF_RNGS',
);

ENUM('displayDetailValues', 0,
	'DV_UNLIT',
	'DV_LIT',
	'DV_DARK',
);

ENUM('directions', -1,
  'NO_DIRECTION',

	// Cardinal directions; must be 0-3:
	'UP',
	'DOWN',
	'LEFT',
	'RIGHT',

	// Secondary directions; must be 4-7:
	'UPLEFT',
	'DOWNLEFT',
	'UPRIGHT',
	'DOWNRIGHT',

  'DIRECTION_COUNT',
);

ENUM('whipAttackResult', 0,
	'WHIP_FAILED',
	'WHIP_SUCCESS',
	'WHIP_ABORTED'
);

ENUM('boltResult', 0,
	'BR_CONTINUES',
	'BR_DONE',
	'BR_AUTO_ID',
	'BR_LIGHTING_CHANGED'
);

ENUM('textEntryTypes', 0,
	'TEXT_INPUT_NORMAL',
	'TEXT_INPUT_FILENAME',
	'TEXT_INPUT_NUMBERS',
	'TEXT_INPUT_TYPES',
);

// const NUMBER_DYNAMIC_COLORS	= 6;

ENUM('tileType', 0,
	'NOTHING',
	'GRANITE',
	'FLOOR',
	'FLOOR_FLOODABLE',
	'CARPET',
	'MARBLE_FLOOR',
	'WALL',
	'DOOR',
	'OPEN_DOOR',
	'SECRET_DOOR',
	'LOCKED_DOOR',
	'OPEN_IRON_DOOR_INERT',
	'DOWN_STAIRS',
	'UP_STAIRS',
	'DUNGEON_EXIT',
  'DUNGEON_PORTAL',
	'TORCH_WALL', // wall lit with a torch
	'CRYSTAL_WALL',
	'PORTCULLIS_CLOSED',
	'PORTCULLIS_DORMANT',
	'WOODEN_BARRICADE',
	'PILOT_LIGHT_DORMANT',
	'PILOT_LIGHT',
  'HAUNTED_TORCH_DORMANT',
  'HAUNTED_TORCH_TRANSITIONING',
  'HAUNTED_TORCH',
  'WALL_LEVER_HIDDEN',
  'WALL_LEVER',
  'WALL_LEVER_PULLED',
  'WALL_LEVER_HIDDEN_DORMANT',
	'STATUE_INERT',
	'STATUE_DORMANT',
	'STATUE_CRACKING',
  'STATUE_INSTACRACK',
	'PORTAL',
	'TURRET_DORMANT',
	'WALL_MONSTER_DORMANT',
	'DARK_FLOOR_DORMANT',
	'DARK_FLOOR_DARKENING',
	'DARK_FLOOR',
	'MACHINE_TRIGGER_FLOOR',
	'ALTAR_INERT',
	'ALTAR_KEYHOLE',
	'ALTAR_CAGE_OPEN',
	'ALTAR_CAGE_CLOSED',
	'ALTAR_SWITCH',
	'ALTAR_SWITCH_RETRACTING',
	'ALTAR_CAGE_RETRACTABLE',
	'PEDESTAL',
	'MONSTER_CAGE_OPEN',
	'MONSTER_CAGE_CLOSED',
	'COFFIN_CLOSED',
	'COFFIN_OPEN',	////
	'GAS_TRAP_POISON_HIDDEN',
	'GAS_TRAP_POISON',
	'TRAP_DOOR_HIDDEN',
	'TRAP_DOOR',
	'GAS_TRAP_PARALYSIS_HIDDEN',
	'GAS_TRAP_PARALYSIS',
  'MACHINE_PARALYSIS_VENT_HIDDEN',
  'MACHINE_PARALYSIS_VENT',
	'GAS_TRAP_CONFUSION_HIDDEN',
	'GAS_TRAP_CONFUSION',
	'FLAMETHROWER_HIDDEN',
	'FLAMETHROWER',
	'FLOOD_TRAP_HIDDEN',
	'FLOOD_TRAP',
  'NET_TRAP_HIDDEN',
  'NET_TRAP',
  'ALARM_TRAP_HIDDEN',
  'ALARM_TRAP',
	'MACHINE_POISON_GAS_VENT_HIDDEN',
	'MACHINE_POISON_GAS_VENT_DORMANT',
	'MACHINE_POISON_GAS_VENT',
	'MACHINE_METHANE_VENT_HIDDEN',
	'MACHINE_METHANE_VENT_DORMANT',
	'MACHINE_METHANE_VENT',
	'STEAM_VENT',
	'MACHINE_PRESSURE_PLATE',
  'MACHINE_PRESSURE_PLATE_USED',
  'MACHINE_GLYPH',
  'MACHINE_GLYPH_INACTIVE',
  'DEWAR_CAUSTIC_GAS',
  'DEWAR_CONFUSION_GAS',
  'DEWAR_PARALYSIS_GAS',
  'DEWAR_METHANE_GAS',	////
	'DEEP_WATER',
	'SHALLOW_WATER',
	'MUD',
	'CHASM',
	'CHASM_EDGE',
	'MACHINE_COLLAPSE_EDGE_DORMANT',
	'MACHINE_COLLAPSE_EDGE_SPREADING',
	'LAVA',
	'LAVA_RETRACTABLE',
	'LAVA_RETRACTING',
	'SUNLIGHT_POOL',
	'DARKNESS_PATCH',
	'ACTIVE_BRIMSTONE',
	'INERT_BRIMSTONE',
	'OBSIDIAN',
	'BRIDGE',
  'BRIDGE_FALLING',
	'BRIDGE_EDGE',
	'STONE_BRIDGE',
	'MACHINE_FLOOD_WATER_DORMANT',
	'MACHINE_FLOOD_WATER_SPREADING',
	'MACHINE_MUD_DORMANT',	///
	'ICE_DEEP',							// 1.7.5
	'ICE_DEEP_MELT',				// 1.7.5
	'ICE_SHALLOW',					// 1.7.5
	'ICE_SHALLOW_MELT',			// 1.7.5
	'HOLE',
	'HOLE_GLOW',
	'HOLE_EDGE',
	'FLOOD_WATER_DEEP',
	'FLOOD_WATER_SHALLOW',
	'GRASS',
	'DEAD_GRASS',
	'GRAY_FUNGUS',
	'LUMINESCENT_FUNGUS',
	'LICHEN',
	'HAY',
	'RED_BLOOD',
	'GREEN_BLOOD',
	'PURPLE_BLOOD',
	'ACID_SPLATTER',
	'VOMIT',
	'URINE',
	'UNICORN_POOP',
	'WORM_BLOOD',
	'ASH',
	'BURNED_CARPET',
	'PUDDLE',
	'BONES',
	'RUBBLE',
	'JUNK',
  'BROKEN_GLASS',
	'ECTOPLASM',
	'EMBERS',
	'SPIDERWEB',
	'NETTING',
	'FOLIAGE',
	'DEAD_FOLIAGE',
	'TRAMPLED_FOLIAGE',
	'FUNGUS_FOREST',
	'TRAMPLED_FUNGUS_FOREST',
	'FORCEFIELD',
  'FORCEFIELD_MELT',
  'SACRED_GLYPH',
	'MANACLE_TL',
	'MANACLE_BR',
	'MANACLE_TR',
	'MANACLE_BL',
	'MANACLE_T',
	'MANACLE_B',
	'MANACLE_L',
	'MANACLE_R',
	'PORTAL_LIGHT',
  'GUARDIAN_GLOW',	///
	'PLAIN_FIRE',
	'BRIMSTONE_FIRE',
	'FLAMEDANCER_FIRE',
	'GAS_FIRE',
	'GAS_EXPLOSION',
	'DART_EXPLOSION',
  'ITEM_FIRE',
  'CREATURE_FIRE', ///
	'POISON_GAS',
	'CONFUSION_GAS',
	'ROT_GAS',
  'STENCH_SMOKE_GAS',
	'PARALYSIS_GAS',
	'METHANE_GAS',
	'STEAM',
	'DARKNESS_CLOUD',
  'HEALING_CLOUD',	///
  'BLOODFLOWER_STALK',
  'BLOODFLOWER_POD',	///
  'HAVEN_BEDROLL',	///
  'DEEP_WATER_ALGAE_WELL',
  'DEEP_WATER_ALGAE_1',
  'DEEP_WATER_ALGAE_2',	///
  'ANCIENT_SPIRIT_VINES',
  'ANCIENT_SPIRIT_GRASS',	///
	'AMULET_SWITCH',	///
  'COMMUTATION_ALTAR',
  'COMMUTATION_ALTAR_INERT',
  'PIPE_GLOWING',
  'PIPE_INERT',	///
  'RESURRECTION_ALTAR',
  'RESURRECTION_ALTAR_INERT',
  'MACHINE_TRIGGER_FLOOR_REPEATING',	///
	'SACRIFICE_ALTAR_DORMANT',	// 1.7.5
	'SACRIFICE_ALTAR', 					// 1.7.5
	'SACRIFICE_LAVA',						// 1.7.5
	'SACRIFICE_CAGE_DORMANT',		// 1.7.5
	'DEMONIC_STATUE',						// 1.7.5
	'STATUE_INERT_DOORWAY',
	'STATUE_DORMANT_DOORWAY', ///
	'CHASM_WITH_HIDDEN_BRIDGE',
	'CHASM_WITH_HIDDEN_BRIDGE_ACTIVE',
	'MACHINE_CHASM_EDGE', ///
  'RAT_TRAP_WALL_DORMANT',
  'RAT_TRAP_WALL_CRACKING',	///
  'ELECTRIC_CRYSTAL_OFF',
  'ELECTRIC_CRYSTAL_ON',
  'TURRET_LEVER',	///
  'WORM_TUNNEL_MARKER_DORMANT',
  'WORM_TUNNEL_MARKER_ACTIVE',
  'WORM_TUNNEL_OUTER_WALL',	///
  'BRAZIER', ///
  'MUD_FLOOR',
  'MUD_WALL',
  'MUD_DOORWAY',	///
	'NUMBER_TILETYPES',
);

ENUM('lightType',
	'NO_LIGHT',
	'MINERS_LIGHT',
	'BURNING_CREATURE_LIGHT',
	'WISP_LIGHT',
	'SALAMANDER_LIGHT',
	'IMP_LIGHT',
	'PIXIE_LIGHT',
	'LICH_LIGHT',
	'FLAMEDANCER_LIGHT',
	'SENTINEL_LIGHT',
	'UNICORN_LIGHT',
	'IFRIT_LIGHT',
	'PHOENIX_LIGHT',
	'PHOENIX_EGG_LIGHT',
  'YENDOR_LIGHT',
	'SPECTRAL_BLADE_LIGHT',
	'SPECTRAL_IMAGE_LIGHT',
	'SPARK_TURRET_LIGHT',
  'EXPLOSIVE_BLOAT_LIGHT',
	'BOLT_LIGHT_SOURCE',
	'TELEPATHY_LIGHT',
	'SACRIFICE_MARK_LIGHT',	// 1.7.5
  'SCROLL_PROTECTION_LIGHT',
  'SCROLL_ENCHANTMENT_LIGHT',
  'POTION_STRENGTH_LIGHT',
  'EMPOWERMENT_LIGHT',
  'GENERIC_FLASH_LIGHT',
  'FALLEN_TORCH_FLASH_LIGHT',
  'SUMMONING_FLASH_LIGHT',
  'EXPLOSION_FLARE_LIGHT',
  'QUIETUS_FLARE_LIGHT',
  'SLAYING_FLARE_LIGHT',
  'CHARGE_FLASH_LIGHT',
	'TORCH_LIGHT',
	'LAVA_LIGHT',
	'SUN_LIGHT',
	'DARKNESS_PATCH_LIGHT',
	'FUNGUS_LIGHT',
	'FUNGUS_FOREST_LIGHT',
  'LUMINESCENT_ALGAE_BLUE_LIGHT',
  'LUMINESCENT_ALGAE_GREEN_LIGHT',
	'ECTOPLASM_LIGHT',
	'UNICORN_POOP_LIGHT',
	'EMBER_LIGHT',
	'FIRE_LIGHT',
	'BRIMSTONE_FIRE_LIGHT',
	'EXPLOSION_LIGHT',
	'INCENDIARY_DART_LIGHT',
	'PORTAL_ACTIVATE_LIGHT',
	'CONFUSION_GAS_LIGHT',
	'DARKNESS_CLOUD_LIGHT',
	'FORCEFIELD_LIGHT',
	'CRYSTAL_WALL_LIGHT',
	'CANDLE_LIGHT',
  'HAUNTED_TORCH_LIGHT',
  'GLYPH_LIGHT_DIM',
  'GLYPH_LIGHT_BRIGHT',
  'SACRED_GLYPH_LIGHT',
  'DESCENT_LIGHT',
	'DEMONIC_STATUE_LIGHT',	// 1.7.5
	'NUMBER_LIGHT_KINDS'
);


function Fl(N) { return (1 << N); }
function flagToText(flagObj, value) {
	const inverse = Object.entries(flagObj).reduce( (out, [key, value]) => {
		out[value] = key;
		return out;
	}, {});

	const out = [];
	for(let index = 0; index < 32; ++index) {
		const fl = (1 << index);
		if (value & fl) {
			out.push(inverse[fl]);
		}
	}
	return out;
}

function FLAG(flagName, values) {
	Object.entries(values).forEach( ([key, value]) => {
		if (Array.isArray(value)) {
			value = value.reduce( (out, name) => {
      	return out | values[name];
      }, 0);
		}
    values[key] = value;
		GLOBAL[key] = value;
	});

	values.toString = function(v) {
		if (!v) return flagName;
		return flagToText(values, v);
	}

	GLOBAL[flagName] = values;
	return values;
}


// Item categories
FLAG('itemCategory', {
	FOOD				: Fl(0),
	WEAPON			: Fl(1),
	ARMOR				: Fl(2),
	POTION			: Fl(3),
	SCROLL			: Fl(4),
	STAFF				: Fl(5),
	WAND				: Fl(6),
	RING				: Fl(7),
  CHARM       : Fl(8),
	GOLD				: Fl(9),
	AMULET			: Fl(10),
	GEM					: Fl(11),
	KEY					: Fl(12),

	CAN_BE_DETECTED		  : ['WEAPON', 'ARMOR', 'POTION', 'SCROLL', 'RING', 'CHARM', 'WAND', 'STAFF', 'AMULET'],
	PRENAMED_CATEGORY	  : ['FOOD', 'GOLD', 'AMULET', 'GEM', 'KEY'],
  NEVER_IDENTIFIABLE  : ['FOOD', 'CHARM', 'GOLD', 'AMULET', 'GEM', 'KEY'],
  // COUNTS_TOWARD_SCORE : ['GOLD', 'AMULET', 'GEM'],		// 1.7.4
  CAN_BE_SWAPPED      : ['WEAPON', 'ARMOR', 'STAFF', 'CHARM', 'RING'],
	ALL_ITEMS						: ['FOOD', 'POTION', 'WEAPON', 'ARMOR', 'STAFF', 'WAND', 'SCROLL', 'RING', 'CHARM', 'GOLD', 'AMULET', 'GEM', 'KEY'],
});

ENUM('keyKind',
	'KEY_DOOR',
	'KEY_CAGE',
	'KEY_PORTAL',
	'NUMBER_KEY_TYPES'
);

ENUM('foodKind',
	'RATION',
	'FRUIT',
	'NUMBER_FOOD_KINDS'
);

ENUM('potionKind',
	'POTION_LIFE',
	'POTION_STRENGTH',
	'POTION_TELEPATHY',
	'POTION_LEVITATION',
	'POTION_DETECT_MAGIC',
	'POTION_HASTE_SELF',
	'POTION_FIRE_IMMUNITY',
	'POTION_INVISIBILITY',
	'POTION_POISON',
	'POTION_PARALYSIS',
	'POTION_HALLUCINATION',
	'POTION_CONFUSION',
	'POTION_INCINERATION',
	'POTION_DARKNESS',
	'POTION_DESCENT',
	'POTION_LICHEN',
	'NUMBER_POTION_KINDS'
);

ENUM('weaponKind',
	'DAGGER',
	'SWORD',
	'BROADSWORD',
  'WHIP',
  'RAPIER',
  'FLAIL',
	'MACE',
	'HAMMER',
	'SPEAR',
	'PIKE',
	'AXE',
	'WAR_AXE',
	'DART',
	'INCENDIARY_DART',
	'JAVELIN',
	'NUMBER_WEAPON_KINDS'
);

ENUM('weaponEnchants',
	'W_SPEED',
	'W_QUIETUS',
	'W_PARALYSIS',
	'W_MULTIPLICITY',
	'W_SLOWING',
	'W_CONFUSION',
  'W_FORCE',
	'W_SLAYING',
	'W_MERCY',
	'W_PLENTY',
	'NUMBER_WEAPON_RUNIC_KINDS'
);

const NUMBER_GOOD_WEAPON_ENCHANT_KINDS = weaponEnchants.NUMBER_GOOD_WEAPON_ENCHANT_KINDS = W_MERCY;	// Everything before this one...


ENUM('armorKind',
	'LEATHER_ARMOR',
	'SCALE_MAIL',
	'CHAIN_MAIL',
	'BANDED_MAIL',
	'SPLINT_MAIL',
	'PLATE_MAIL',
	'NUMBER_ARMOR_KINDS'
);

ENUM('armorEnchants',
	'A_MULTIPLICITY',
	'A_MUTUALITY',
	'A_ABSORPTION',
	'A_REPRISAL',
	'A_IMMUNITY',
	'A_REFLECTION',
  'A_RESPIRATION',
  'A_DAMPENING',
	'A_BURDEN',
	'A_VULNERABILITY',
  'A_IMMOLATION',
	'NUMBER_ARMOR_ENCHANT_KINDS',
);

const NUMBER_GOOD_ARMOR_ENCHANT_KINDS = armorEnchants.NUMBER_GOOD_ARMOR_ENCHANT_KINDS = A_BURDEN;	// everything before this

ENUM('wandKind',
	'WAND_TELEPORT',
	'WAND_SLOW',
	'WAND_POLYMORPH',
	'WAND_NEGATION',
	'WAND_DOMINATION',
	'WAND_BECKONING',
	'WAND_PLENTY',
	'WAND_INVISIBILITY',
  'WAND_EMPOWERMENT',
	'NUMBER_WAND_KINDS'
);

ENUM('staffKind',
	'STAFF_LIGHTNING',
	'STAFF_FIRE',
	'STAFF_POISON',
	'STAFF_TUNNELING',
	'STAFF_BLINKING',
	'STAFF_ENTRANCEMENT',
	'STAFF_OBSTRUCTION',
	'STAFF_DISCORD',
	'STAFF_CONJURATION',
	'STAFF_HEALING',
	'STAFF_HASTE',
	'STAFF_PROTECTION',
	'NUMBER_STAFF_KINDS'
);

// these must be wand bolts, in order, and then staff bolts, in order:
ENUM('boltType',
  'BOLT_NONE',
	'BOLT_TELEPORT',
	'BOLT_SLOW',
	'BOLT_POLYMORPH',
	'BOLT_NEGATION',
	'BOLT_DOMINATION',
	'BOLT_BECKONING',
	'BOLT_PLENTY',
	'BOLT_INVISIBILITY',
  'BOLT_EMPOWERMENT',
	'BOLT_LIGHTNING',
	'BOLT_FIRE',
	'BOLT_POISON',
	'BOLT_TUNNELING',
	'BOLT_BLINKING',
	'BOLT_ENTRANCEMENT',
	'BOLT_OBSTRUCTION',
	'BOLT_DISCORD',
	'BOLT_CONJURATION',
	'BOLT_HEALING',
	'BOLT_HASTE',
  'BOLT_SLOW_2',
	'BOLT_SHIELDING',
  'BOLT_SPIDERWEB',
  'BOLT_SPARK',
  'BOLT_DRAGONFIRE',
  'BOLT_DISTANCE_ATTACK',
  'BOLT_POISON_DART',
  // 'BOLT_ACID_TURRET_ATTACK',	// 1.7.4	TODO - ADD BACK IN CUSTOM
  'BOLT_ANCIENT_SPIRIT_VINES',
  'BOLT_WHIP',
	'NUMBER_BOLT_KINDS'
);

ENUM('ringKind',
	'RING_CLAIRVOYANCE',
	'RING_STEALTH',
	'RING_REGENERATION',
	'RING_TRANSFERENCE',
	'RING_LIGHT',
	'RING_AWARENESS',
	'RING_WISDOM',
  'RING_REAPING',
	'NUMBER_RING_KINDS'
);

ENUM('charmKind',
	'CHARM_HEALTH',
  'CHARM_PROTECTION',
  'CHARM_HASTE',
  'CHARM_FIRE_IMMUNITY',
  'CHARM_INVISIBILITY',
  'CHARM_TELEPATHY',
  'CHARM_LEVITATION',
  'CHARM_SHATTERING',
  'CHARM_GUARDIAN',
  'CHARM_TELEPORTATION',
  'CHARM_RECHARGING',
  'CHARM_NEGATION',
  'NUMBER_CHARM_KINDS'
);

ENUM('scrollKind',
	'SCROLL_ENCHANTING',
	'SCROLL_IDENTIFY',
	'SCROLL_TELEPORT',
	'SCROLL_REMOVE_CURSE',
	'SCROLL_RECHARGING',
	'SCROLL_PROTECT_ARMOR',
	'SCROLL_PROTECT_WEAPON',
  'SCROLL_SANCTUARY',
	'SCROLL_MAGIC_MAPPING',
	'SCROLL_NEGATION',
	'SCROLL_SHATTERING',
  'SCROLL_DISCORD',
	'SCROLL_AGGRAVATE_MONSTER',
	'SCROLL_SUMMON_MONSTER',
	'NUMBER_SCROLL_KINDS'
);

const MAX_PACK_ITEMS =				26;

ENUM('monsterTypes',
	'MK_YOU',
	'MK_RAT',
	'MK_KOBOLD',
	'MK_JACKAL',
	'MK_EEL',
	'MK_MONKEY',
	'MK_BLOAT',
	'MK_PIT_BLOAT',
	'MK_GOBLIN',
	'MK_GOBLIN_CONJURER',
	'MK_GOBLIN_MYSTIC',
	'MK_GOBLIN_TOTEM',
	'MK_PINK_JELLY',
	'MK_TOAD',
	'MK_VAMPIRE_BAT',
	'MK_ARROW_TURRET',
	'MK_ACID_MOUND',
	'MK_CENTIPEDE',
	'MK_OGRE',
	'MK_BOG_MONSTER',
	'MK_OGRE_TOTEM',
	'MK_SPIDER',
	'MK_SPARK_TURRET',
	'MK_WILL_O_THE_WISP',
	'MK_WRAITH',
	'MK_ZOMBIE',
	'MK_TROLL',
	'MK_OGRE_SHAMAN',
	'MK_NAGA',
	'MK_SALAMANDER',
	'MK_EXPLOSIVE_BLOAT',
	'MK_DAR_BLADEMASTER',
	'MK_DAR_PRIESTESS',
	'MK_DAR_BATTLEMAGE',
	'MK_ACID_JELLY',
	'MK_CENTAUR',
	'MK_UNDERWORM',
	'MK_SENTINEL',
	// 'MK_ACID_TURRET', // 1.7.4 -- TODO: ADD BACK IN CUSTOM
	'MK_DART_TURRET',
	'MK_KRAKEN',
	'MK_LICH',
	'MK_PHYLACTERY',
	'MK_PIXIE',
	'MK_PHANTOM',
	'MK_FLAME_TURRET',
	'MK_IMP',
	'MK_FURY',
	'MK_REVENANT',
	'MK_TENTACLE_HORROR',
	'MK_GOLEM',
	'MK_DRAGON',
	'MK_GOBLIN_CHIEFTAN',
	'MK_BLACK_JELLY',
	'MK_VAMPIRE',
	'MK_FLAMEDANCER',
	'MK_SPECTRAL_BLADE',
	'MK_SPECTRAL_IMAGE',
  'MK_GUARDIAN',
  'MK_WINGED_GUARDIAN',
  'MK_CHARM_GUARDIAN',
  'MK_WARDEN_OF_YENDOR',
  'MK_ELDRITCH_TOTEM',
  'MK_MIRRORED_TOTEM',
	'MK_UNICORN',
	'MK_IFRIT',
	'MK_PHOENIX',
	'MK_PHOENIX_EGG',
  'MK_ANCIENT_SPIRIT',
	'NUMBER_MONSTER_KINDS'
);

const NUMBER_MUTATORS 		=          8;
const MONSTER_CLASS_COUNT =         13;

// flavors

const NUMBER_ITEM_COLORS =			21;
const NUMBER_TITLE_PHONEMES =		21;
const NUMBER_ITEM_WOODS =				21;
const NUMBER_POTION_DESCRIPTIONS =	18;
const NUMBER_ITEM_METALS =			12;
const NUMBER_ITEM_GEMS =				18;

// Dungeon flags
FLAG('tileFlags', {
	DISCOVERED					: Fl(0),
	VISIBLE							: Fl(1),	// cell has sufficient light and is in field of view, ready to draw.
	HAS_PLAYER					: Fl(2),
	HAS_MONSTER					: Fl(3),
	HAS_DORMANT_MONSTER	: Fl(4),	// hidden monster on the square
	HAS_ITEM						: Fl(5),
	IN_FIELD_OF_VIEW		: Fl(6),	// player has unobstructed line of sight whether or not there is enough light
	WAS_VISIBLE					: Fl(7),
	HAS_STAIRS					: Fl(8),
	SEARCHED_FROM_HERE	: Fl(9),	// Player already auto-searched from here; can't auto search here again
	IS_IN_SHADOW				: Fl(10),	// so that a player gains an automatic stealth bonus
	MAGIC_MAPPED				: Fl(11),
	ITEM_DETECTED				: Fl(12),
	CLAIRVOYANT_VISIBLE			: Fl(13),
	WAS_CLAIRVOYANT_VISIBLE	: Fl(14),
	CLAIRVOYANT_DARKENED		: Fl(15),	// magical blindness from a cursed ring of clairvoyance
	CAUGHT_FIRE_THIS_TURN		: Fl(16),	// so that fire does not spread asymmetrically
	PRESSURE_PLATE_DEPRESSED	: Fl(17),	// so that traps do not trigger repeatedly while you stand on them
	STABLE_MEMORY						: Fl(18),	// redraws will simply be pulled from the memory array, not recalculated
	KNOWN_TO_BE_TRAP_FREE		: Fl(19),	// keep track of where the player has stepped as he knows no traps are there
	IS_IN_PATH					: Fl(20),	// the yellow trail leading to the cursor
	IN_LOOP							: Fl(21),	// this cell is part of a terrain loop
	IS_CHOKEPOINT				: Fl(22),	// if this cell is blocked, part of the map will be rendered inaccessible
	IS_GATE_SITE				: Fl(23),	// consider placing a locked door here
	IS_IN_ROOM_MACHINE	: Fl(24),
	IS_IN_AREA_MACHINE	: Fl(25),
	IS_POWERED					: Fl(26),	// has been activated by machine power this turn (can probably be eliminate if needed)
	IMPREGNABLE					: Fl(27),	// no tunneling allowed!
	TERRAIN_COLORS_DANCING	: Fl(28),	// colors here will sparkle when the game is idle
	TELEPATHIC_VISIBLE			: Fl(29),	// potions of telepathy let you see through other creatures' eyes
	WAS_TELEPATHIC_VISIBLE	: Fl(30),	// potions of telepathy let you see through other creatures' eyes

	IS_IN_MACHINE				: ['IS_IN_ROOM_MACHINE', 'IS_IN_AREA_MACHINE'], 	// sacred ground; don't generate items here, or teleport randomly to it

	PERMANENT_TILE_FLAGS : ['DISCOVERED', 'MAGIC_MAPPED', 'ITEM_DETECTED', 'HAS_ITEM', 'HAS_DORMANT_MONSTER',
							'HAS_STAIRS', 'SEARCHED_FROM_HERE', 'PRESSURE_PLATE_DEPRESSED',
							'STABLE_MEMORY', 'KNOWN_TO_BE_TRAP_FREE', 'IN_LOOP',
							'IS_CHOKEPOINT', 'IS_GATE_SITE', 'IS_IN_MACHINE', 'IMPREGNABLE'],

	ANY_KIND_OF_VISIBLE			: ['VISIBLE', 'CLAIRVOYANT_VISIBLE', 'TELEPATHIC_VISIBLE'],
});

const TURNS_FOR_FULL_REGEN =	300;
const STOMACH_SIZE =					2150;
const HUNGER_THRESHOLD =			(STOMACH_SIZE - 1800);
const WEAK_THRESHOLD =				150;
const FAINT_THRESHOLD =				50;
const MAX_EXP_LEVEL =					20;
const MAX_EXP =								100000000;

// XPXP required to enable telepathic awareness with the ally
const XPXP_NEEDED_FOR_TELEPATHIC_BOND =     1400 ;

const ROOM_MIN_WIDTH =						4;
const ROOM_MAX_WIDTH =						20;
const ROOM_MIN_HEIGHT =						3;
const ROOM_MAX_HEIGHT =						7;
const HORIZONTAL_CORRIDOR_MIN_LENGTH =	5;
const HORIZONTAL_CORRIDOR_MAX_LENGTH =	15;
const VERTICAL_CORRIDOR_MIN_LENGTH =		2;
const VERTICAL_CORRIDOR_MAX_LENGTH =		9;
const CROSS_ROOM_MIN_WIDTH =				3;
const CROSS_ROOM_MAX_WIDTH =				12;
const CROSS_ROOM_MIN_HEIGHT =				2;
const CROSS_ROOM_MAX_HEIGHT =				5;
const MIN_SCALED_ROOM_DIMENSION =		2;

const ROOM_TYPE_COUNT =             8;

const CORRIDOR_WIDTH =						  1;

const WAYPOINT_SIGHT_RADIUS =				10;
const MAX_WAYPOINT_COUNT =          40;

const MAX_ITEMS_IN_MONSTER_ITEMS_HOPPER =   100;

// Making these larger means cave generation will take more trials; set them too high and the program will hang.
const CAVE_MIN_WIDTH =						50;
const CAVE_MIN_HEIGHT =						20;

// Keyboard commands:
const UP_KEY =				'k';
const DOWN_KEY =			'j';
const LEFT_KEY =			'h';
const RIGHT_KEY =			'l';
const UPLEFT_KEY =			'y';
const UPRIGHT_KEY =			'u';
const DOWNLEFT_KEY =		'b';
const DOWNRIGHT_KEY =		'n';

const UP_ARROW =			'ArrowUp'; // 63232;
const LEFT_ARROW =			'ArrowLeft'; // 63234;
const DOWN_ARROW =			'ArrowDown'; // 63233;
const RIGHT_ARROW =			'ArrowRight'; // 63235;

const SHIFT_UP_KEY      =			'K';
const SHIFT_DOWN_KEY    =			'J';
const SHIFT_LEFT_KEY    =			'H';
const SHIFT_RIGHT_KEY   =			'L';
const SHIFT_UPLEFT_KEY =			'Y';
const SHIFT_UPRIGHT_KEY =			'U';
const SHIFT_DOWNLEFT_KEY =		'B';
const SHIFT_DOWNRIGHT_KEY =		'N';
const SHIFT_UP_ARROW    =			'ARROWUP'; // 63232;
const SHIFT_LEFT_ARROW  =			'ARROWLEFT'; // 63234;
const SHIFT_DOWN_ARROW  =			'ARROWDOWN'; // 63233;
const SHIFT_RIGHT_ARROW =			'ARROWRIGHT'; // 63235;

const DESCEND_KEY =			'>';
const ASCEND_KEY =			'<';
const REST_KEY =			'z';
const AUTO_REST_KEY =		'Z';
const SEARCH_KEY =			's';
const INVENTORY_KEY =		'i';
const ACKNOWLEDGE_KEY =		' ';
const EQUIP_KEY =			'e';
const UNEQUIP_KEY =			'r';
const APPLY_KEY =			'a';
const THROW_KEY =			't';
const RELABEL_KEY =         'R';
const TRUE_COLORS_KEY =		'\\';
const AGGRO_DISPLAY_KEY =   ']';
// const WARNING_PAUSE_KEY =   '[';	// REMOVED in 1.7.5
const DROP_KEY =			'd';
const CALL_KEY =			'c';
const QUIT_KEY =			'Q';
const MESSAGE_ARCHIVE_KEY =	'M';
const HELP_KEY =			'?';
const DISCOVERIES_KEY =		'D';
const EXPLORE_KEY =			'x';
const AUTOPLAY_KEY =		'A';
const SEED_KEY =			'~';
const EASY_MODE_KEY =		'&';
const ESCAPE_KEY =			'Escape'; // '\033';
const RETURN_KEY =			'Enter';  // '\015';
const ENTER_KEY =				'Enter';  // '\012';
const DELETE_KEY =			'Delete'; // '\177';
const BACKSPACE_KEY =		'Backspace';
const TAB_KEY =					'Tab'; 		// '\t';
// Cocoa reports shift-tab this way for some reason.
const SHIFT_TAB_KEY =   'TAB'; // 25 ;
const PERIOD_KEY =			'.';
const VIEW_RECORDING_KEY =	'V';
const LOAD_SAVED_GAME_KEY =	'O';
const SAVE_GAME_KEY =		'S';
const NEW_GAME_KEY =		'N';
const NUMPAD_0 =			'Numpad0'; // 48;
const NUMPAD_1 =			'Numpad1'; // 49;
const NUMPAD_2 =			'Numpad2'; // 50;
const NUMPAD_3 =			'Numpad3'; // 51;
const NUMPAD_4 =			'Numpad4'; // 52;
const NUMPAD_5 =			'Numpad5'; // 53;
const NUMPAD_6 =			'Numpad6'; // 54;
const NUMPAD_7 =			'Numpad7'; // 55;
const NUMPAD_8 =			'Numpad8'; // 56;
const NUMPAD_9 =			'Numpad9'; // 57;
const PAGE_UP_KEY =			'PageUp'; // 63276;
const PAGE_DOWN_KEY =		'PageDown'; // 63277;

const TEST_KEY = 'T';

const UNKNOWN_KEY =			(128+19);

const min = Math.min;
const max = Math.max;
const pow = Math.pow;
const abs = Math.abs;
const cos = Math.cos;
const sin = Math.sin;
const sqrt = Math.sqrt;
const log10 = Math.log10;

function clamp(x, low, hi)	{ return min(hi, max(x, low)); } // pins x to the [y, z] interval

function terrainFlags(x, y)	{
	return (tileCatalog[pmap[x][y].layers[DUNGEON]].flags
				| tileCatalog[pmap[x][y].layers[LIQUID]].flags
				| tileCatalog[pmap[x][y].layers[SURFACE]].flags
				| tileCatalog[pmap[x][y].layers[GAS]].flags);
}

function terrainMechFlags(x, y)	{
	return (tileCatalog[pmap[x][y].layers[DUNGEON]].mechFlags
        | tileCatalog[pmap[x][y].layers[LIQUID]].mechFlags
        | tileCatalog[pmap[x][y].layers[SURFACE]].mechFlags
        | tileCatalog[pmap[x][y].layers[GAS]].mechFlags);
}


// #ifdef BROGUE_ASSERTS
// boolean cellHasTerrainFlag(short x, short y, unsigned long flagMask);
// #else
function cellHasTerrainFlag(x, y, flagMask)	{
	return (flagMask & terrainFlags(x, y)) ? true : false;
}
// #endif

function cellHasTMFlag(x, y, flagMask) {
	return (flagMask & terrainMechFlags(x, y)) ? true : false;
}

function cellHasTerrainType(x, y, terrain)	{
	return (pmap[x][y].layers[DUNGEON] === terrain
 			 || pmap[x][y].layers[LIQUID] === terrain
			 || pmap[x][y].layers[SURFACE] === terrain
			 || pmap[x][y].layers[GAS] === terrain) ? true : false;
}

function cellHasKnownTerrainFlag(x, y, flagMask) {
		return (flagMask & pmap[x][y].rememberedTerrainFlags) ? true : false;
}

function cellIsPassableOrDoor(x, y)	{
		return (!cellHasTerrainFlag(x, y, T_PATHING_BLOCKER)
					  || (cellHasTMFlag(x, y, (TM_IS_SECRET | TM_PROMOTES_WITH_KEY | TM_CONNECTS_LEVEL))
						    && cellHasTerrainFlag(x, y, T_OBSTRUCTS_PASSABILITY)));
}

function coordinatesAreInMap(x, y)    { return ((x) >= 0 && (x) < DCOLS	&& (y) >= 0 && (y) < DROWS); }
function coordinatesAreInWindow(x, y) { return ((x) >= 0 && (x) < COLS		&& (y) >= 0 && (y) < ROWS); }
function mapToWindowX(x)						  { return ((x) + STAT_BAR_WIDTH + 1); }
function mapToWindowY(y)						  { return ((y) + MESSAGE_LINES); }
function windowToMapX(x)						  { return ((x) - STAT_BAR_WIDTH - 1); }
function windowToMapY(y)						  { return ((y) - MESSAGE_LINES); }

function playerCanDirectlySee(x, y)	  { return (pmap[x][y].flags & VISIBLE); }
function playerCanSee(x, y)					  { return (pmap[x][y].flags & ANY_KIND_OF_VISIBLE); }
function playerCanSeeOrSense(x, y)		{
	return ((pmap[x][y].flags & ANY_KIND_OF_VISIBLE)
					 || (rogue.playbackOmniscience
               && (pmap[x][y].layers[DUNGEON] != GRANITE || (pmap[x][y].flags & DISCOVERED))));
}

// TODO ????
function CYCLE_MONSTERS_AND_PLAYERS(fn)	{
	let v;
	for (v = player; v != NULL; v = (v === player ? monsters.nextCreature : v.nextCreature)) {
		fn(v);
	}
}

var RNG_STACK = [];
function assureCosmeticRNG()	{
	RNG_STACK.push(rogue.RNG);
	rogue.RNG = RNG_COSMETIC;
}

function restoreRNG()					{
	rogue.RNG = RNG_STACK.length ? RNG_STACK.pop() : RNG_SUBSTANTIVE;
}


const MIN_COLOR_DIFF =			600;
// weighted sum of the squares of the component differences. Weights are according to color perception.
function COLOR_DIFF(f, b)		 {
	return ((f.red - b.red) * (f.red - b.red) * 0.2126
		+ (f.green - b.green) * (f.green - b.green) * 0.7152
		+ (f.blue - b.blue) * (f.blue - b.blue) * 0.0722);
}

// game data formulae:

// function staffDamageLow(enchant) 			{ return (Math.floor(3 * (2 + (enchant)) / 4 + FLOAT_FUDGE)); }
// function staffDamageHigh(enchant) 		{ return (Math.floor(4 + 5 * (enchant) / 2 + FLOAT_FUDGE)); }
// function staffDamage(enchant) 				{ return (randClumpedRange(staffDamageLow(enchant), staffDamageHigh(enchant), 1 + (enchant) / 3)); }
// function staffPoison(enchant) 				{ return (Math.floor(5 * pow(1.3, (enchant) - 2) + FLOAT_FUDGE)); }
// function staffBlinkDistance(enchant) 	{ return (Math.floor((enchant) * 2 + 2 + FLOAT_FUDGE)); }
// function staffHasteDuration(enchant) 	{ return (Math.floor(2 + (enchant) * 4 + FLOAT_FUDGE)); }
// function staffBladeCount(enchant) 		{ return (Math.floor((enchant) * 3 / 2 + FLOAT_FUDGE)); }
// function staffDiscordDuration(enchant) { return	(Math.floor((enchant) * 4 + FLOAT_FUDGE)); }
// function staffProtection(enchant) 		{ return (Math.floor(50 * pow(1.53, (enchant) - 2) + FLOAT_FUDGE)); }
// function staffEntrancementDuration(enchant) { return	(Math.floor((enchant) * 3 + FLOAT_FUDGE)); }
//
// function ringWisdomMultiplier(enchant) { return Math.floor(10 * pow(1.3, min(27, (enchant))) + FLOAT_FUDGE); }
//
// function charmHealing(enchant)           { return (Math.floor(clamp(20 * (enchant), 0, 100) + FLOAT_FUDGE)); }
// function charmProtection(enchant)				 { return (Math.floor(150 * pow(1.35, (double) (enchant) - 1) + FLOAT_FUDGE)); }
// function charmShattering(enchant)        { return (Math.floor(4 + (enchant) + FLOAT_FUDGE)); }
// function charmGuardianLifespan(enchant)  { return (Math.floor(4 + (2 * (enchant)) + FLOAT_FUDGE)); }
// function charmNegationRadius(enchant)    { return (Math.floor(1 + (3 * (enchant)) + FLOAT_FUDGE)); }
//
// function wandDominate(monst) {
// 	return ((monst.currentHP * 5 < monst.info.maxHP) ? 100 : max(0, 100 * (monst.info.maxHP - monst.currentHP) / monst.info.maxHP));
// }
//
// function weaponParalysisDuration(enchant)	{ return (max(2, Math.floor(2 + ((enchant) / 2) + FLOAT_FUDGE))); }
// function weaponConfusionDuration(enchant)	{ return (max(3, Math.floor(1.5 * (enchant) + FLOAT_FUDGE))); }
// function weaponForceDistance(enchant)			{ return (max(4, ((Math.floor(enchant + FLOAT_FUDGE)) * 2 + 2))); } // Depends on definition of staffBlinkDistance() above.;
// function weaponSlowDuration(enchant)			{ return (max(3, Math.floor(((enchant) + 2) * ((enchant) + 2) / 3 + FLOAT_FUDGE))); }
// function weaponImageCount(enchant)				{ return (clamp(Math.floor((enchant) / 3 + FLOAT_FUDGE), 1, 7)); }
// function weaponImageDuration(enchant)			{ return 3; }										//(max((int) (1 + (enchant) / 3), 2));
//
// function armorReprisalPercent(enchant)	{ return (max(5, Math.floor((enchant) * 5 + FLOAT_FUDGE))); }
// function armorAbsorptionMax(enchant)		{ return 	(max(1, Math.floor((enchant) + FLOAT_FUDGE))); }
// function armorImageCount(enchant)		{ return 	(clamp(Math.floor((enchant) / 3 + FLOAT_FUDGE), 1, 5)); }
// function reflectionChance(enchant)		{ return 	(clamp((100 - Math.floor(100 * pow(0.85, (enchant)) + FLOAT_FUDGE)), 1, 100)); }
//
// // This will max out at full regeneration in about two turns.
// // This is the Syd nerf, after Syd broke the game over his knee with a +18 ring of regeneration.
// function turnsForFullRegen(bonus)			{ return (Math.floor(1000 * TURNS_FOR_FULL_REGEN * pow(0.75, (bonus)) + 2000 + FLOAT_FUDGE)); }

// structs

ENUM('dungeonLayers', -1,
  'NO_LAYER',
	'DUNGEON',		// dungeon-level tile	(e.g. walls)
	'LIQUID',				// liquid-level tile	(e.g. lava)
	'GAS',				// gas-level tile		(e.g. fire, smoke, swamp gas)
	'SURFACE',			// surface-level tile	(e.g. grass)
	'NUMBER_TERRAIN_LAYERS'
);

class CellDisplayBuffer {
	constructor() {
		this.char = '';
		this.foreColorComponents = []; // [3];
		this.backColorComponents = []; // [3];
		this.opacity = 0;
		this.needsUpdate = false;
	}

	copy(other) {
		this.char = other.char;
		for(let i = 0; i < 3; ++i) {
			this.foreColorComponents[i] = other.foreColorComponents[i];
			this.backColorComponents[i] = other.backColorComponents[i];
		}
		this.opacity = other.opacity;
		this.needsUpdate = other.needsUpdate;
	}
}

// keeps track of graphics so we only redraw if the cell has changed:
function cellDisplayBuffer() {
	return new CellDisplayBuffer();
}

class PCell {
	constructor() {
		this.layers = []; // [NUMBER_TERRAIN_LAYERS];	// terrain  /* ENUM tileType */
		this.flags = 0;							// non-terrain cell flags
		this.volume = 0;						// quantity of gas in cell
		this.machineNumber = 0;
		this.rememberedAppearance = cellDisplayBuffer();			// how the player remembers the cell to look
		this.rememberedItemCategory = 0;		// what category of item the player remembers lying there
		this.rememberedItemKind = 0;        // what kind of item the player remembers lying there
	  this.rememberedItemQuantity = 0;    // how many of the item the player remembers lying there
		this.rememberedTerrain = 0;					// what the player remembers as the terrain (i.e. highest priority terrain upon last seeing)
	  this.rememberedCellFlags = 0;       // map cell flags the player remembers from that spot
	  this.rememberedTerrainFlags = 0;    // terrain flags the player remembers from that spot
	  this.rememberedTMFlags = 0;         // TM flags the player remembers from that spot
	}

	copy(other) {
		this.layers = other.layers.slice();
		this.flags = other.flags;
		this.volume = other.volume;						// quantity of gas in cell
		this.machineNumber = other.machineNumber;
		this.rememberedAppearance.copy(other.rememberedAppearance);			// how the player remembers the cell to look
		this.rememberedItemCategory = other.rememberedItemCategory;		// what category of item the player remembers lying there
		this.rememberedItemKind = other.rememberedItemKind;        // what kind of item the player remembers lying there
	  this.rememberedItemQuantity = other.rememberedItemQuantity;    // how many of the item the player remembers lying there
		this.rememberedTerrain = other.rememberedTerrain;					// what the player remembers as the terrain (i.e. highest priority terrain upon last seeing)
	  this.rememberedCellFlags = other.rememberedCellFlags;       // map cell flags the player remembers from that spot
	  this.rememberedTerrainFlags = other.rememberedTerrainFlags;    // terrain flags the player remembers from that spot
	  this.rememberedTMFlags = other.rememberedTMFlags;         // TM flags the player remembers from that spot
	}
}

function pcell() {								// permanent cell; have to remember this stuff to save levels
	return new PCell();
}

function tcell() {			// transient cell; stuff we don't need to remember between levels
	return {
		light: [0, 0, 0], // [3];				// RGB components of lighting
		oldLight: [0, 0, 0], // [3];			// compare with subsequent lighting to determine whether to refresh cell
	}
}

class RandomRange {
	constructor(lower, upper, clump) {
		this.lowerBound = lower || 0;
		this.upperBound = upper || 0;
		this.clumpFactor = clump || 0;
	}

	copy(other) {
		this.lowerBound = other.lowerBound;
		this.upperBound = other.upperBound;
		this.clumpFactor = other.clumpFactor;
	}
}

function randomRange(lower, upper, clump) {
	if (arguments.length == 1) {
		if (Array.isArray(lower)) {
			clump = lower[2];
			upper = lower[1];
			lower = lower[0];
		}
		else {
			clump = lower.clumpFactor;
			upper = lower.upperBound;
			lower = lower.lowerBound;
		}
	}
	return new RandomRange(lower, upper, clump);
}

class Color {
	constructor(r, g, b, rr, gr, br, rnd, d) {
		// base RGB components:
		this.red = r || 0;
		this.green = g || 0;
		this.blue = b || 0;

		// random RGB components to add to base components:
		this.redRand = rr || 0;
		this.greenRand = gr || 0;
		this.blueRand = br || 0;

		// random scalar to add to all components:
		this.rand = rnd || 0;

		// Flag: this color "dances" with every refresh:
		this.colorDances = d || false;
	}

	copy(other) {
		Object.assign(this, other);
	}

	clone() {
		return new Color(this.red, this.green, this.blue,
				this.redRand, this.greenRand, this.blueRand, this.rand,
				this.colorDances);
	}
}

function color(r, g, b, rr, gr, br, rnd, d) {
	if (arguments.length == 1 && r instanceof Color) {
		const n = r.clone();
		return n;
	}
	return new Color(r, g, b, rr, gr, br, rnd, d);
}

FLAG('itemFlags', {
	ITEM_IDENTIFIED			: Fl(0),
	ITEM_EQUIPPED				: Fl(1),
	ITEM_CURSED					: Fl(2),
	ITEM_PROTECTED			: Fl(3),
	// unused               : Fl(4),
	ITEM_RUNIC					: Fl(5),
	ITEM_RUNIC_HINTED		: Fl(6),
	ITEM_RUNIC_IDENTIFIED		: Fl(7),
	ITEM_CAN_BE_IDENTIFIED	: Fl(8),
	ITEM_PREPLACED					: Fl(9),
	ITEM_FLAMMABLE					: Fl(10),
	ITEM_MAGIC_DETECTED			: Fl(11),
	ITEM_MAX_CHARGES_KNOWN	: Fl(12),
	ITEM_IS_KEY							: Fl(13),

	// ITEM_ATTACKS_HIT_SLOWLY		: Fl(14),	// mace, hammer		1.7.4
	ITEM_ATTACKS_STAGGER			: Fl(14),		// mace, hammer
  ITEM_ATTACKS_EXTEND     	: Fl(15),   // whip
  ITEM_ATTACKS_QUICKLY    	: Fl(16),   // rapier
	ITEM_ATTACKS_PENETRATE		: Fl(17),	// spear, pike
	ITEM_ATTACKS_ALL_ADJACENT : Fl(18),	// axe, war axe
  ITEM_LUNGE_ATTACKS      	: Fl(19),   // rapier
  ITEM_SNEAK_ATTACK_BONUS 	: Fl(20),   // dagger
  ITEM_PASS_ATTACKS       	: Fl(21),   // flail
	ITEM_KIND_AUTO_ID       	: Fl(22),	// the item type will become known when the item is picked up.
	ITEM_PLAYER_AVOIDS				: Fl(23),	// explore and travel will try to avoid picking the item up
});

const KEY_ID_MAXIMUM	= 20;

function keyLocationProfile() {
	return {
		x: 0,
		y: 0,
		machine: 0,
		disposableHere: false
	};
}


function item() {
	return {
		category: 0,
		kind: 0,
		flags: 0,
		/* randomRange */ damage: randomRange(),
		armor: 0,
		charges: 0,
		enchant1: 0,
		enchant2: 0,
	  timesEnchanted: 0,
		/* ENUM monsterTypes */vorpalEnemy: 0,
		strengthRequired: 0,
		quiverNumber: 0,
		displayChar: '',
		foreColor: null,
		inventoryColor: null,
		quantity: 0,
		inventoryLetter: '',
		inscription: STRING(), // [DCOLS];
		xLoc: 0,
		yLoc: 0,
		/* keyLocationProfile */ keyLoc: ARRAY(KEY_ID_MAXIMUM, keyLocationProfile), // [KEY_ID_MAXIMUM];
		originDepth: 0,
		/* struct item */ nextItem: null,
	};
}

function itemTable(name, flavor, title, freq, value, str, range, ident, called, desc) {
	range = range || [];
	return {
		name: name || '',
		flavor: flavor || '',
		callTitle: STRING(title || ''), // [30];
		frequency: freq || 0,
		marketValue: value || 0,
		strengthRequired: str || 0,
		range: randomRange(range),
		identified: ident || false,
		called: called || false,
		description: desc || '', // [1500];
	};
}


ENUM('dungeonFeatureTypes',
	'DF_NONE',
	'DF_GRANITE_COLUMN',
	'DF_CRYSTAL_WALL',
	'DF_LUMINESCENT_FUNGUS',
	'DF_GRASS',
	'DF_DEAD_GRASS',
	'DF_BONES',
	'DF_RUBBLE',
	'DF_FOLIAGE',
	'DF_FUNGUS_FOREST',
	'DF_DEAD_FOLIAGE',

	'DF_SUNLIGHT',
	'DF_DARKNESS',

	'DF_SHOW_DOOR',
	'DF_SHOW_POISON_GAS_TRAP',
	'DF_SHOW_PARALYSIS_GAS_TRAP',
	'DF_SHOW_TRAPDOOR_HALO',
	'DF_SHOW_TRAPDOOR',
	'DF_SHOW_CONFUSION_GAS_TRAP',
	'DF_SHOW_FLAMETHROWER_TRAP',
	'DF_SHOW_FLOOD_TRAP',
  'DF_SHOW_NET_TRAP',
  'DF_SHOW_ALARM_TRAP',

	'DF_RED_BLOOD',
	'DF_GREEN_BLOOD',
	'DF_PURPLE_BLOOD',
	'DF_WORM_BLOOD',
	'DF_ACID_BLOOD',
	'DF_ASH_BLOOD',
	'DF_EMBER_BLOOD',
	'DF_ECTOPLASM_BLOOD',
	'DF_RUBBLE_BLOOD',
	'DF_ROT_GAS_BLOOD',

	'DF_VOMIT',
	'DF_BLOAT_DEATH',
	'DF_BLOAT_EXPLOSION',
	'DF_BLOOD_EXPLOSION',
	'DF_FLAMEDANCER_CORONA',

	'DF_MUTATION_EXPLOSION',
  'DF_MUTATION_LICHEN',

	'DF_REPEL_CREATURES',
	'DF_ROT_GAS_PUFF',
	'DF_STEAM_PUFF',
	'DF_STEAM_ACCUMULATION',
	'DF_METHANE_GAS_PUFF',
	'DF_SALAMANDER_FLAME',
	'DF_URINE',
	'DF_UNICORN_POOP',
	'DF_PUDDLE',
	'DF_ASH',
	'DF_ECTOPLASM_DROPLET',
	'DF_FORCEFIELD',
  'DF_FORCEFIELD_MELT',
  'DF_SACRED_GLYPHS',
	'DF_LICHEN_GROW',
	'DF_TUNNELIZE',
  'DF_SHATTERING_SPELL',

  // spiderwebs
  'DF_WEB_SMALL',
  'DF_WEB_LARGE',

  // ancient spirit
  'DF_ANCIENT_SPIRIT_VINES',
  'DF_ANCIENT_SPIRIT_GRASS',

  // foliage
	'DF_TRAMPLED_FOLIAGE',
	'DF_SMALL_DEAD_GRASS',
	'DF_FOLIAGE_REGROW',
	'DF_TRAMPLED_FUNGUS_FOREST',
	'DF_FUNGUS_FOREST_REGROW',

  // brimstone
	'DF_ACTIVE_BRIMSTONE',
	'DF_INERT_BRIMSTONE',

  // bloodwort
  'DF_BLOODFLOWER_PODS_GROW_INITIAL',
  'DF_BLOODFLOWER_PODS_GROW',
  'DF_BLOODFLOWER_POD_BURST',

  // dewars
  'DF_DEWAR_CAUSTIC',
  'DF_DEWAR_CONFUSION',
  'DF_DEWAR_PARALYSIS',
  'DF_DEWAR_METHANE',
  'DF_DEWAR_GLASS',
  'DF_CARPET_AREA',

  // algae
  'DF_BUILD_ALGAE_WELL',
  'DF_ALGAE_1',
  'DF_ALGAE_2',
  'DF_ALGAE_REVERT',

	'DF_OPEN_DOOR',
	'DF_CLOSED_DOOR',
	'DF_OPEN_IRON_DOOR_INERT',
	'DF_ITEM_CAGE_OPEN',
	'DF_ITEM_CAGE_CLOSE',
	'DF_ALTAR_INERT',
	'DF_ALTAR_RETRACT',
	'DF_PORTAL_ACTIVATE',
  'DF_INACTIVE_GLYPH',
  'DF_ACTIVE_GLYPH',
  'DF_SILENT_GLYPH_GLOW',
  'DF_GUARDIAN_STEP',
  'DF_MIRROR_TOTEM_STEP',
  'DF_GLYPH_CIRCLE',
  'DF_REVEAL_LEVER',
  'DF_PULL_LEVER',
  'DF_CREATE_LEVER',

  'DF_BRIDGE_FALL_PREP',
  'DF_BRIDGE_FALL',

	'DF_PLAIN_FIRE',
	'DF_GAS_FIRE',
	'DF_EXPLOSION_FIRE',
	'DF_DART_EXPLOSION',
	'DF_BRIMSTONE_FIRE',
	'DF_BRIDGE_FIRE',
	'DF_FLAMETHROWER',
	'DF_EMBERS',
	'DF_EMBERS_PATCH',
	'DF_OBSIDIAN',
  'DF_ITEM_FIRE',
  'DF_CREATURE_FIRE',

	'DF_FLOOD',
	'DF_FLOOD_2',
	'DF_FLOOD_DRAIN',
	'DF_HOLE_2',
	'DF_HOLE_DRAIN',

	// 1.7.5
	'DF_DEEP_WATER_FREEZE',
	'DF_ALGAE_1_FREEZE',
	'DF_ALGAE_2_FREEZE',
	'DF_DEEP_WATER_MELTING',
	'DF_DEEP_WATER_THAW',
	'DF_SHALLOW_WATER_FREEZE',
	'DF_SHALLOW_WATER_MELTING',
	'DF_SHALLOW_WATER_THAW',

	'DF_POISON_GAS_CLOUD',
	'DF_CONFUSION_GAS_TRAP_CLOUD',
  'DF_NET',
  'DF_AGGRAVATE_TRAP',
	'DF_METHANE_GAS_ARMAGEDDON',

	// potions
	'DF_POISON_GAS_CLOUD_POTION',
	'DF_PARALYSIS_GAS_CLOUD_POTION',
	'DF_CONFUSION_GAS_CLOUD_POTION',
	'DF_INCINERATION_POTION',
	'DF_DARKNESS_POTION',
	'DF_HOLE_POTION',
	'DF_LICHEN_PLANTED',

  // other items
  'DF_ARMOR_IMMOLATION',
  'DF_STAFF_HOLE',
  'DF_STAFF_HOLE_EDGE',

  // commutation altar
  'DF_ALTAR_COMMUTE',
  'DF_MAGIC_PIPING',
  'DF_INERT_PIPE',

  // resurrection altar
  'DF_ALTAR_RESURRECT',
  'DF_MACHINE_FLOOR_TRIGGER_REPEATING',

	// sacrifice altar	1.7.5
	'DF_SACRIFICE_ALTAR',
	'DF_SACRIFICE_COMPLETE',
	'DF_SACRIFICE_CAGE_ACTIVE',

	// vampire in coffin
	'DF_COFFIN_BURSTS',
	'DF_COFFIN_BURNS',
	'DF_TRIGGER_AREA',

	// throwing tutorial -- button in chasm
	'DF_CAGE_DISAPPEARS',
	'DF_MEDIUM_HOLE',
	'DF_MEDIUM_LAVA_POND',
  'DF_MACHINE_PRESSURE_PLATE_USED',

  // rat trap
  'DF_WALL_CRACK',

	// wooden barricade at entrance
	'DF_WOODEN_BARRICADE_BURN',

	// wooden barricade around altar, dead grass all around
	'DF_SURROUND_WOODEN_BARRICADE',

	// pools of water that, when triggered, slowly expand to fill the room
	'DF_SPREADABLE_WATER',
	'DF_SHALLOW_WATER',
	'DF_WATER_SPREADS',
	'DF_SPREADABLE_WATER_POOL',
	'DF_SPREADABLE_DEEP_WATER_POOL',

	// when triggered, the ground gradually turns into chasm:
	'DF_SPREADABLE_COLLAPSE',
	'DF_COLLAPSE',
	'DF_COLLAPSE_SPREADS',
	'DF_ADD_MACHINE_COLLAPSE_EDGE_DORMANT',

	// when triggered, a bridge appears:
  'DF_BRIDGE_ACTIVATE',
  'DF_BRIDGE_ACTIVATE_ANNOUNCE',
	'DF_BRIDGE_APPEARS',
  'DF_ADD_DORMANT_CHASM_HALO',

	// when triggered, the lava retracts:
  'DF_LAVA_RETRACTABLE',
	'DF_RETRACTING_LAVA',
	'DF_OBSIDIAN_WITH_STEAM',

	// when triggered, the door seals and caustic gas fills the room
	'DF_SHOW_POISON_GAS_VENT',
	'DF_POISON_GAS_VENT_OPEN',
	'DF_ACTIVATE_PORTCULLIS',
	'DF_OPEN_PORTCULLIS',
	'DF_VENT_SPEW_POISON_GAS',

	// when triggered, pilot light ignites and explosive gas fills the room
	'DF_SHOW_METHANE_VENT',
	'DF_METHANE_VENT_OPEN',
	'DF_VENT_SPEW_METHANE',
	'DF_PILOT_LIGHT',

    // paralysis trap: trigger plate with gas vents nearby
	'DF_DISCOVER_PARALYSIS_VENT',
	'DF_PARALYSIS_VENT_SPEW',
	'DF_REVEAL_PARALYSIS_VENT_SILENTLY',

	// thematic dungeon
	'DF_AMBIENT_BLOOD',

	// statues crack for a few turns and then shatter, revealing the monster inside
	'DF_CRACKING_STATUE',
	'DF_STATUE_SHATTER',

	// a turret appears:
	'DF_TURRET_EMERGE',

  // an elaborate worm catacomb opens up
  'DF_WORM_TUNNEL_MARKER_DORMANT',
  'DF_WORM_TUNNEL_MARKER_ACTIVE',
  'DF_GRANITE_CRUMBLES',
  'DF_WALL_OPEN',

	// the room gradually darkens
	'DF_DARKENING_FLOOR',
	'DF_DARK_FLOOR',
  'DF_HAUNTED_TORCH_TRANSITION',
  'DF_HAUNTED_TORCH',

	// bubbles rise from the mud and bog monsters spawn
	'DF_MUD_DORMANT',
	'DF_MUD_ACTIVATE',

  // crystals charge when hit by lightning
  'DF_ELECTRIC_CRYSTAL_ON',
  'DF_TURRET_LEVER',

	// idyll:
	'DF_SHALLOW_WATER_POOL',
  'DF_DEEP_WATER_POOL',

	// swamp:
	'DF_SWAMP_WATER',
	'DF_SWAMP',
	'DF_SWAMP_MUD',

	// camp:
	'DF_HAY',
	'DF_JUNK',

	// remnants:
	'DF_REMNANT',
	'DF_REMNANT_ASH',

	// chasm catwalk:
	'DF_CHASM_HOLE',
	'DF_CATWALK_BRIDGE',

	// lake catwalk:
	'DF_LAKE_CELL',
	'DF_LAKE_HALO',

	// worm den:
	'DF_WALL_SHATTER',

	// monster cages open:
	'DF_MONSTER_CAGE_OPENS',

  // goblin warren:
  'DF_STENCH_BURN',
  'DF_STENCH_SMOLDER',

	'NUMBER_DUNGEON_FEATURES',
);

ENUM('dungeonProfileTypes',
    'DP_BASIC',
    'DP_BASIC_FIRST_ROOM',
    'DP_GOBLIN_WARREN',
    'DP_SENTINEL_SANCTUARY',
    'NUMBER_DUNGEON_PROFILES',
);


class LightSource {
	constructor(color, range, fadeTo, pass) {
		this.lightColor = color || null;	/* color */
		this.lightRadius = randomRange(range);
		this.radialFadeToPercent = fadeTo || 0;
		this.passThroughCreatures = pass || false; // generally no, but miner light does
	}

	copy(other) {
		this.lightColor = other.lightColor;
		this.lightRadius.copy(other.lightRadius);
		this.radialFadeToPercent = other.radialFadeToPercent;
		this.passThroughCreatures = other.passThroughCreatures;
	}
}


function lightSource(color, range, fadeTo, pass) {
	if (arguments.length == 1 && color.lightColor) {
		pass = color.passThroughCreatures;
		fadeTo = color.radialFadeToPercent;
		range = color.lightRadius;
		color = color.lightColor;
	}

	range = range || [];
	return new LightSource(color, range, fadeTo, pass);
}


function flare() {
	return {
    /* lightSource */ light: null,      // Flare light
    coeffChangeAmount: 0,    // The constant amount by which the coefficient changes per frame, e.g. -25 means it gets 25% dimmer per frame.
    coeffLimit: 0,           // Flare ends if the coefficient passes this percentage (whether going up or down).
    xLoc: 0, yLoc: 0,        // Current flare location.
    coeff: 0,                // Current flare coefficient; always starts at 100.
    turnNumber: 0,           // So we can eliminate those that fired one or more turns ago.
	};
}

FLAG('DFFlags', {
	DFF_EVACUATE_CREATURES_FIRST	: Fl(0),	// Creatures in the DF area get moved outside of it
	DFF_SUBSEQ_EVERYWHERE			: Fl(1),	// Subsequent DF spawns in every cell that this DF spawns in, instead of only the origin
	DFF_TREAT_AS_BLOCKING			: Fl(2),	// If filling the footprint of this DF with walls would disrupt level connectivity, then abort.
	DFF_PERMIT_BLOCKING				: Fl(3),	// Generate this DF without regard to level connectivity.
	DFF_ACTIVATE_DORMANT_MONSTER	: Fl(4),	// Dormant monsters on this tile will appear -- e.g. when a statue bursts to reveal a monster.
	DFF_CLEAR_OTHER_TERRAIN			: Fl(5),	// Erase other terrain in the footprint of this DF.
	DFF_BLOCKED_BY_OTHER_LAYERS		: Fl(6),	// Will not propagate into a cell if any layer in that cell has a superior priority.
	DFF_SUPERPRIORITY				: Fl(7),	// Will overwrite terrain of a superior priority.
    DFF_AGGRAVATES_MONSTERS         : Fl(8),    // Will act as though an aggravate monster scroll of effectRadius radius had been read at that point.
    DFF_RESURRECT_ALLY              : Fl(9),    // Will bring back to life your most recently deceased ally.
});

ENUM('boltEffects',
    'BE_NONE',
    'BE_ATTACK',
    'BE_TELEPORT',
    'BE_SLOW',
    'BE_POLYMORPH',
    'BE_NEGATION',
    'BE_DOMINATION',
    'BE_BECKONING',
    'BE_PLENTY',
    'BE_INVISIBILITY',
    'BE_EMPOWERMENT',
    'BE_DAMAGE',
    'BE_POISON',
    'BE_TUNNELING',
    'BE_BLINKING',
    'BE_ENTRANCEMENT',
    'BE_OBSTRUCTION',
    'BE_DISCORD',
    'BE_CONJURATION',
    'BE_HEALING',
    'BE_HASTE',
    'BE_SHIELDING',
);

FLAG('boltFlags', {
	BF_PASSES_THRU_CREATURES        : Fl(0),		// Bolt continues through creatures (e.g. lightning and tunneling)
  BF_HALTS_BEFORE_OBSTRUCTION     : Fl(1),    // Bolt takes effect the space before it terminates (e.g. conjuration, obstruction, blinking)
  BF_TARGET_ALLIES                : Fl(2),    // Staffs/wands/creatures that shoot this bolt will auto-target allies.
  BF_TARGET_ENEMIES               : Fl(3),    // Staffs/wands/creatures that shoot this bolt will auto-target enemies.
  BF_FIERY                        : Fl(4),    // Bolt will light flammable terrain on fire as it passes, and will ignite monsters hit.
  BF_NEVER_REFLECTS               : Fl(6),    // Bolt will never reflect (e.g. spiderweb, arrows).
  BF_NOT_LEARNABLE                : Fl(7),    // This technique cannot be absorbed by empowered allies.
  BF_NOT_NEGATABLE                : Fl(8),    // Won't be erased by negation.
  BF_ELECTRIC                     : Fl(9),    // Activates terrain that has TM_PROMOTES_ON_ELECTRICITY
  BF_DISPLAY_CHAR_ALONG_LENGTH    : Fl(10),		// Display the character along the entire length of the bolt instead of just at the front.
});


class Bolt {
	constructor(name, desc, abDesc, ch, fg, bg, effect, mag, path, target, forbid, flags) {
		this.name = name || ''; // [DCOLS];
    this.description = desc || ''; // [COLS];
    this.abilityDescription = abDesc || ''; // [COLS*2];
    this.theChar = ch || '';
    this.foreColor = fg || null;
    this.backColor = bg || null;
    this.boltEffect = effect || 0;
    this.magnitude = mag || 0;
    this.pathDF = path || 0;
    this.targetDF = target || 0;
    this.forbiddenMonsterFlags = forbid || 0;
    this.flags = flags || 0;
	}

	copy(other) {
		Object.assign(this, other);
	}
}

function bolt(...args) {
	return new Bolt(...args);
}

// Level profiles, affecting what rooms get chosen and how they're connected:
// Room frequencies:
//      0. Cross room
//      1. Small symmetrical cross room
//      2. Small room
//      3. Circular room
//      4. Chunky room
//      5. Cave
//      6. Cavern (the kind that fills a level)
//      7. Entrance room (the big upside-down T room at the start of depth 1)
function dungeonProfile(rooms, corridors) {
	return {
    // Room type weights (in the natural dungeon, these are also adjusted based on depth):
    roomFrequencies: rooms || [], // [ROOM_TYPE_COUNT];
    corridorChance: corridors || 0,
	};
}


// Dungeon features, spawned from Architect.c:
function dungeonFeature(tile, layer, start, decr, flag, text, flare, color, radius, propTile, subDF) {
	return {
		// tile info:
		/* ENUM tileType */ tile: tile || 0,
		/* ENUM dungeonLayers */ layer: layer || 0,

		// spawning pattern:
		startProbability: start || 0,
		probabilityDecrement: decr || 0,
		flags: flag || 0,
		description: text || '', // [DCOLS];
	  /* ENUM lightType */ lightFlare: flare || 0,
		/* color */ flashColor: color || null,
		effectRadius: radius || 0,
		/* ENUM tileType */ propagationTerrain: propTile || 0,
		/* ENUM dungeonFeatureTypes */ subsequentDF: subDF || 0,
		messageDisplayed: false,
	};
}


// Terrain types:
function floorTileType(char, fg, bg, priority, chance, fire, discover, promote, promChance, light, flag, mech, desc, flavor) {
	return {
		// appearance:
		displayChar: char || '',
		foreColor: fg || null,
		backColor: bg || null,
		drawPriority: priority || 0,                     // priority (lower number means higher priority); governs drawing as well as tile replacement comparisons.
		chanceToIgnite: chance || 0,					// chance to burn if a flame terrain is on one of the four cardinal neighbors
		/* ENUM dungeonFeatureTypes */ fireType: fire || 0,		// spawn this DF when the terrain ignites (or, if it's T_IS_DF_TRAP, when the pressure plate clicks)
		/* ENUM dungeonFeatureTypes */ discoverType: discover || 0,	// spawn this DF when successfully searched if T_IS_SECRET is set
		/* ENUM dungeonFeatureTypes */ promoteType: promote || 0,	// creates this dungeon spawn type when it promotes for some other reason (random promotion or promotion through machine activation)
		promoteChance: promChance || 0,					// percent chance per turn to spawn the promotion type; will also vanish upon doing so if T_VANISHES_UPON_PROMOTION is set
		glowLight: light || 0,						// if it glows, this is the ID of the light type
		flags: flag || 0,
	  mechFlags: mech || 0,
		description: desc || '', // [COLS];
		flavorText: flavor || '', // [COLS];
	};
}


FLAG('terrainFlagCatalog', {
	T_OBSTRUCTS_PASSABILITY	: Fl(0),		// cannot be walked through
	T_OBSTRUCTS_VISION			: Fl(1),		// blocks line of sight
	T_OBSTRUCTS_ITEMS				: Fl(2),		// items can't be on this tile
	T_OBSTRUCTS_SURFACE_EFFECTS		: Fl(3),		// grass, blood, etc. cannot exist on this tile
	T_OBSTRUCTS_GAS					: Fl(4),		// blocks the permeation of gas
  T_OBSTRUCTS_DIAGONAL_MOVEMENT : Fl(5),    // can't step diagonally around this tile
	T_SPONTANEOUSLY_IGNITES	: Fl(6),		// monsters avoid unless chasing player or immune to fire
	T_AUTO_DESCENT					: Fl(7),		// automatically drops creatures down a depth level and does some damage (2d6)
	T_LAVA_INSTA_DEATH			: Fl(8),		// kills any non-levitating non-fire-immune creature instantly
	T_CAUSES_POISON					: Fl(9),		// any non-levitating creature gets 10 poison
	T_IS_FLAMMABLE					: Fl(10),		// terrain can catch fire
	T_IS_FIRE								: Fl(11),		// terrain is a type of fire; ignites neighboring flammable cells
	T_ENTANGLES							: Fl(12),		// entangles players and monsters like a spiderweb
	T_IS_DEEP_WATER					: Fl(13),		// steals items 50% of the time and moves them around randomly
	T_CAUSES_DAMAGE					: Fl(14),		// anything on the tile takes max(1-2, 10%) damage per turn
	T_CAUSES_NAUSEA					: Fl(15),		// any creature on the tile becomes nauseous
	T_CAUSES_PARALYSIS			: Fl(16),		// anything caught on this tile is paralyzed
	T_CAUSES_CONFUSION			: Fl(17),		// causes creatures on this tile to become confused
  T_CAUSES_HEALING   	    : Fl(18),   // heals 20% max HP per turn for any player or non-inanimate monsters
	T_IS_DF_TRAP						: Fl(19),		// spews gas of type specified in fireType when stepped on
	T_CAUSES_EXPLOSIVE_DAMAGE		: Fl(20),		// is an explosion; deals higher of 15-20 or 50% damage instantly, but not again for five turns
  T_SACRED                : Fl(21),   // monsters that aren't allies of the player will avoid stepping here

	T_OBSTRUCTS_SCENT				: ['T_OBSTRUCTS_PASSABILITY', 'T_OBSTRUCTS_VISION', 'T_AUTO_DESCENT', 'T_LAVA_INSTA_DEATH', 'T_IS_DEEP_WATER', 'T_SPONTANEOUSLY_IGNITES'],
	T_PATHING_BLOCKER				: ['T_OBSTRUCTS_PASSABILITY', 'T_AUTO_DESCENT', 'T_IS_DF_TRAP', 'T_LAVA_INSTA_DEATH', 'T_IS_DEEP_WATER', 'T_IS_FIRE', 'T_SPONTANEOUSLY_IGNITES'],
  T_DIVIDES_LEVEL       	: ['T_OBSTRUCTS_PASSABILITY', 'T_AUTO_DESCENT', 'T_IS_DF_TRAP', 'T_LAVA_INSTA_DEATH', 'T_IS_DEEP_WATER'],
	T_LAKE_PATHING_BLOCKER	: ['T_AUTO_DESCENT', 'T_LAVA_INSTA_DEATH', 'T_IS_DEEP_WATER', 'T_SPONTANEOUSLY_IGNITES'],
	T_WAYPOINT_BLOCKER			: ['T_OBSTRUCTS_PASSABILITY', 'T_AUTO_DESCENT', 'T_IS_DF_TRAP', 'T_LAVA_INSTA_DEATH', 'T_IS_DEEP_WATER', 'T_SPONTANEOUSLY_IGNITES'],
	T_MOVES_ITEMS						: ['T_IS_DEEP_WATER', 'T_LAVA_INSTA_DEATH'],
	T_CAN_BE_BRIDGED				: ['T_AUTO_DESCENT'],
	T_OBSTRUCTS_EVERYTHING	: ['T_OBSTRUCTS_PASSABILITY', 'T_OBSTRUCTS_VISION', 'T_OBSTRUCTS_ITEMS', 'T_OBSTRUCTS_GAS', 'T_OBSTRUCTS_SURFACE_EFFECTS', 'T_OBSTRUCTS_DIAGONAL_MOVEMENT'],
	T_HARMFUL_TERRAIN				: ['T_CAUSES_POISON', 'T_IS_FIRE', 'T_CAUSES_DAMAGE', 'T_CAUSES_PARALYSIS', 'T_CAUSES_CONFUSION', 'T_CAUSES_EXPLOSIVE_DAMAGE'],
  T_RESPIRATION_IMMUNITIES  : ['T_CAUSES_DAMAGE', 'T_CAUSES_CONFUSION', 'T_CAUSES_PARALYSIS', 'T_CAUSES_NAUSEA'],
});


FLAG('terrainMechanicalFlagCatalog', {
  TM_IS_SECRET							: Fl(0),		// successful search or being stepped on while visible transforms it into discoverType
	TM_PROMOTES_WITH_KEY			: Fl(1),		// promotes if the key is present on the tile (in your pack, carried by monster, or lying on the ground)
	TM_PROMOTES_WITHOUT_KEY		: Fl(2),		// promotes if the key is NOT present on the tile (in your pack, carried by monster, or lying on the ground)
	TM_PROMOTES_ON_STEP				: Fl(3),		// promotes when a creature, player or item is on the tile (whether or not levitating)
	TM_PROMOTES_ON_ITEM_PICKUP		: Fl(4),		// promotes when an item is lifted from the tile (primarily for altars)
	TM_PROMOTES_ON_PLAYER_ENTRY		: Fl(5),		// promotes when the player enters the tile (whether or not levitating)
	TM_PROMOTES_ON_SACRIFICE_ENTRY: Fl(6),		// promotes when the sacrifice target enters the tile (whether or not levitating)
  TM_PROMOTES_ON_ELECTRICITY    : Fl(7),    // promotes when hit by a lightning bolt
	TM_ALLOWS_SUBMERGING					: Fl(8),		// allows submersible monsters to submerge in this terrain
	TM_IS_WIRED										: Fl(9),		// if wired, promotes when powered, and sends power when promoting
  TM_IS_CIRCUIT_BREAKER 				: Fl(10),        // prevents power from circulating in its machine
	TM_GAS_DISSIPATES							: Fl(11),		// does not just hang in the air forever
	TM_GAS_DISSIPATES_QUICKLY			: Fl(12),		// dissipates quickly
	TM_EXTINGUISHES_FIRE					: Fl(13),		// extinguishes burning terrain or creatures
	TM_VANISHES_UPON_PROMOTION		: Fl(14),		// vanishes when creating promotion dungeon feature, even if the replacement terrain priority doesn't require it
  TM_REFLECTS_BOLTS           	: Fl(15),       // magic bolts reflect off of its surface randomly (similar to pmap flag IMPREGNABLE)
  TM_STAND_IN_TILE            	: Fl(16),		// earthbound creatures will be said to stand "in" the tile, not on it
  TM_LIST_IN_SIDEBAR          	: Fl(17),       // terrain will be listed in the sidebar with a description of the terrain type
  TM_VISUALLY_DISTINCT        	: Fl(18),       // terrain will be color-adjusted if necessary so the character stands out from the background
  TM_BRIGHT_MEMORY            	: Fl(19),       // no blue fade when this tile is out of sight
  TM_EXPLOSIVE_PROMOTE        	: Fl(20),       // when burned, will promote to promoteType instead of burningType if surrounded by tiles with T_IS_FIRE or TM_EXPLOSIVE_PROMOTE
  TM_CONNECTS_LEVEL           	: Fl(21),       // will be treated as passable for purposes of calculating level connectedness, irrespective of other aspects of this terrain layer
  TM_INTERRUPT_EXPLORATION_WHEN_SEEN : Fl(22),    // will generate a message when discovered during exploration to interrupt exploration
  TM_INVERT_WHEN_HIGHLIGHTED  	: Fl(23),       // will flip fore and back colors when highlighted with pathing
  TM_SWAP_ENCHANTS_ACTIVATION 	: Fl(24),       // in machine, swap item enchantments when two suitable items are on this terrain, and activate the machine when that happens
});

ENUM('statusEffects',
	'STATUS_SEARCHING',	// 1.7.5
  'STATUS_DONNING',
	'STATUS_WEAKENED',
	'STATUS_TELEPATHIC',
	'STATUS_HALLUCINATING',
	'STATUS_LEVITATING',
	'STATUS_SLOWED',
	'STATUS_HASTED',
	'STATUS_CONFUSED',
	'STATUS_BURNING',
	'STATUS_PARALYZED',
	'STATUS_POISONED',
	'STATUS_STUCK',
	'STATUS_NAUSEOUS',
	'STATUS_DISCORDANT',
	'STATUS_IMMUNE_TO_FIRE',
	'STATUS_EXPLOSION_IMMUNITY',
	'STATUS_NUTRITION',
	'STATUS_ENTERS_LEVEL_IN',
	'STATUS_MAGICAL_FEAR',
	'STATUS_ENTRANCED',
	'STATUS_DARKNESS',
	'STATUS_LIFESPAN_REMAINING',
	'STATUS_SHIELDED',
  'STATUS_INVISIBLE',
  'STATUS_AGGRAVATING',
	'NUMBER_OF_STATUS_EFFECTS',
);

const statusStrings = [
	"Searching",	// 1.7.5
	"Donning Armor",
	"Weakened: -",
	"Telepathic",
	"Hallucinating",
	"Levitating",
	"Slowed",
	"Hasted",
	"Confused",
	"Burning",
	"Paralyzed",
	"Poisoned",
	"Stuck",
	"Nauseous",
	"Discordant",
	"Immune to Fire",
	"", // STATUS_EXPLOSION_IMMUNITY,
	"", // STATUS_NUTRITION,
	"", // STATUS_ENTERS_LEVEL_IN,
	"Frightened",
	"Entranced",
	"Darkened",
	"Lifespan",
	"Shielded",
	"Invisible",
	"", // STATUS_AGGRAVATING
];


const hallucinationStrings = [
	"     (Dancing)      ",
	"     (Singing)      ",
	"  (Pontificating)   ",
	"     (Skipping)     ",
	"     (Spinning)     ",
	"      (Crying)      ",
	"     (Laughing)     ",
	"     (Humming)      ",
	"    (Whistling)     ",
	"    (Quivering)     ",
	"    (Muttering)     ",
	"    (Gibbering)     ",
	"     (Giggling)     ",
	"     (Moaning)      ",
	"    (Shrieking)     ",
	"   (Caterwauling)   ",
];




FLAG('hordeFlags', {
	HORDE_DIES_ON_LEADER_DEATH		: Fl(0),	// if the leader dies, the horde will die instead of electing new leader
	HORDE_IS_SUMMONED				: Fl(1),	// minions summoned when any creature is the same species as the leader and casts summon
  HORDE_SUMMONED_AT_DISTANCE      : Fl(2),    // summons will appear across the level, and will naturally path back to the leader
	HORDE_LEADER_CAPTIVE			: Fl(3),	// the leader is in chains and the followers are guards
	HORDE_NO_PERIODIC_SPAWN			: Fl(4),	// can spawn only when the level begins -- not afterwards
	HORDE_ALLIED_WITH_PLAYER		: Fl(5),

	HORDE_MACHINE_BOSS				: Fl(6),	// used in machines for a boss challenge
	HORDE_MACHINE_WATER_MONSTER		: Fl(7),	// used in machines where the room floods with shallow water
	HORDE_MACHINE_CAPTIVE			: Fl(8),	// powerful captive monsters without any captors
	HORDE_MACHINE_STATUE			: Fl(9),	// the kinds of monsters that make sense in a statue
	HORDE_MACHINE_TURRET			: Fl(10),	// turrets, for hiding in walls
	HORDE_MACHINE_MUD					: Fl(11),	// bog monsters, for hiding in mud
	HORDE_MACHINE_KENNEL			: Fl(12),	// monsters that can appear in cages in kennels
	HORDE_VAMPIRE_FODDER			: Fl(13),	// monsters that are prone to capture and farming by vampires
	HORDE_MACHINE_LEGENDARY_ALLY	: Fl(14),	// legendary allies
  HORDE_NEVER_OOD             : Fl(15),   // Horde cannot be generated out of depth
  HORDE_MACHINE_THIEF         : Fl(16),   // monsters that can be generated in the key thief area machines
  HORDE_MACHINE_GOBLIN_WARREN : Fl(17),   // can spawn in goblin warrens
	HORDE_SACRIFICE_TARGET			: Fl(18),		// can be the target of an assassination challenge; leader will get scary light.

	HORDE_MACHINE_ONLY	: ['HORDE_MACHINE_BOSS', 'HORDE_MACHINE_WATER_MONSTER',
									  'HORDE_MACHINE_CAPTIVE', 'HORDE_MACHINE_STATUE',
									  'HORDE_MACHINE_TURRET', 'HORDE_MACHINE_MUD',
									  'HORDE_MACHINE_KENNEL', 'HORDE_VAMPIRE_FODDER',
									  'HORDE_MACHINE_LEGENDARY_ALLY', 'HORDE_MACHINE_THIEF',
                    'HORDE_MACHINE_GOBLIN_WARREN',
										'HORDE_SACRIFICE_TARGET'],
});


FLAG('monsterBehaviorFlags', {
	MONST_INVISIBLE					: Fl(0),	// monster is invisible
	MONST_INANIMATE					: Fl(1),	// monster has abbreviated stat bar display and is immune to many things
	MONST_IMMOBILE					: Fl(2),	// monster won't move or perform melee attacks
	MONST_CARRY_ITEM_100			: Fl(3),	// monster carries an item 100% of the time
	MONST_CARRY_ITEM_25				: Fl(4),	// monster carries an item 25% of the time
	MONST_ALWAYS_HUNTING			: Fl(5),	// monster is never asleep or in wandering mode
	MONST_FLEES_NEAR_DEATH			: Fl(6),	// monster flees when under 25% health and re-engages when over 75%
	MONST_ATTACKABLE_THRU_WALLS		: Fl(7),	// can be attacked when embedded in a wall
	MONST_DEFEND_DEGRADE_WEAPON		: Fl(8),	// hitting the monster damages the weapon
	MONST_IMMUNE_TO_WEAPONS			: Fl(9),	// weapons ineffective
	MONST_FLIES						: Fl(10),	// permanent levitation
	MONST_FLITS						: Fl(11),	// moves randomly a third of the time
	MONST_IMMUNE_TO_FIRE			: Fl(12),	// won't burn, won't die in lava
	MONST_CAST_SPELLS_SLOWLY		: Fl(13),	// takes twice the attack duration to cast a spell
	MONST_IMMUNE_TO_WEBS			: Fl(14),	// monster passes freely through webs
	MONST_REFLECT_4					: Fl(15),	// monster reflects projectiles as though wearing +4 armor of reflection
	MONST_NEVER_SLEEPS				: Fl(16),	// monster is always awake
	MONST_FIERY						: Fl(17),	// monster carries an aura of flame (but no automatic fire light)
	MONST_INVULNERABLE              : Fl(18),	// monster is immune to absolutely everything
	MONST_IMMUNE_TO_WATER			: Fl(19),	// monster moves at full speed in deep water and (if player) doesn't drop items
	MONST_RESTRICTED_TO_LIQUID		: Fl(20),	// monster can move only on tiles that allow submersion
	MONST_SUBMERGES					: Fl(21),	// monster can submerge in appropriate terrain
	MONST_MAINTAINS_DISTANCE		: Fl(22),	// monster tries to keep a distance of 3 tiles between it and player
	MONST_WILL_NOT_USE_STAIRS		: Fl(23),	// monster won't chase the player between levels
	MONST_DIES_IF_NEGATED			: Fl(24),	// monster will die if exposed to negation magic
	MONST_MALE						: Fl(25),	// monster is male (or 50% likely to be male if also has MONST_FEMALE)
	MONST_FEMALE					: Fl(26),	// monster is female (or 50% likely to be female if also has MONST_MALE)
  MONST_NOT_LISTED_IN_SIDEBAR     : Fl(27),   // monster doesn't show up in the sidebar
  MONST_GETS_TURN_ON_ACTIVATION   : Fl(28),   // monster never gets a turn, except when its machine is activated
  MONST_ALWAYS_USE_ABILITY        : Fl(29),   // monster will never fail to use special ability if eligible (no random factor)
  MONST_NO_POLYMORPH              : Fl(30),   // monster cannot result from a polymorph spell (liches, phoenixes and Warden of Yendor)

	NEGATABLE_TRAITS	: ['MONST_INVISIBLE', 'MONST_DEFEND_DEGRADE_WEAPON', 'MONST_IMMUNE_TO_WEAPONS', 'MONST_FLIES',
									   'MONST_FLITS', 'MONST_IMMUNE_TO_FIRE', 'MONST_REFLECT_4', 'MONST_FIERY', 'MONST_MAINTAINS_DISTANCE'],
	MONST_TURRET			: ['MONST_IMMUNE_TO_WEBS', 'MONST_NEVER_SLEEPS', 'MONST_IMMOBILE', 'MONST_INANIMATE',
									     'MONST_ATTACKABLE_THRU_WALLS', 'MONST_WILL_NOT_USE_STAIRS'],
	LEARNABLE_BEHAVIORS				: ['MONST_INVISIBLE', 'MONST_FLIES', 'MONST_IMMUNE_TO_FIRE', 'MONST_REFLECT_4'],
	MONST_NEVER_VORPAL_ENEMY	: ['MONST_INANIMATE', 'MONST_INVULNERABLE', 'MONST_IMMOBILE', 'MONST_RESTRICTED_TO_LIQUID', 'MONST_GETS_TURN_ON_ACTIVATION', 'MONST_MAINTAINS_DISTANCE'],
  MONST_NEVER_MUTATED       : ['MONST_INVISIBLE', 'MONST_INANIMATE', 'MONST_IMMOBILE', 'MONST_INVULNERABLE'],
});


FLAG('monsterAbilityFlags', {
	MA_HIT_HALLUCINATE		: Fl(0),	// monster can hit to cause hallucinations
	MA_HIT_STEAL_FLEE			: Fl(1),	// monster can steal an item and then run away
	MA_HIT_BURN						: Fl(2),	// monster can hit to set you on fire
	MA_ENTER_SUMMONS			: Fl(3),	// monster will "become" its summoned leader, reappearing when that leader is defeated
	MA_HIT_DEGRADE_ARMOR	: Fl(4),	// monster damages armor
	MA_CAST_SUMMON				: Fl(5),	// requires that there be one or more summon hordes with this monster type as the leader
	MA_SEIZES							: Fl(6),	// monster seizes enemies before attacking
	MA_POISONS						: Fl(7),	// monster's damage is dealt in the form of poison
	MA_DF_ON_DEATH				: Fl(8),	// monster spawns its DF when it dies
	MA_CLONE_SELF_ON_DEFEND	: Fl(9),	// monster splits in two when struck
	MA_KAMIKAZE						: Fl(10),	// monster dies instead of attacking
	MA_TRANSFERENCE				: Fl(11),	// monster recovers 40 or 90% of the damage that it inflicts as health
	MA_CAUSES_WEAKNESS		: Fl(12),	// monster attacks cause weakness status in target
  MA_ATTACKS_PENETRATE     : Fl(13),   // monster attacks all adjacent enemies, like an axe
  MA_ATTACKS_ALL_ADJACENT  : Fl(14),   // monster attacks penetrate one layer of enemies, like a spear
  MA_ATTACKS_EXTEND        : Fl(15),   // monster attacks from a distance in a cardinal direction, like a whip
	MA_ATTACKS_STAGGER			 : Fl(16),	 // monster attacks will push the player backward by one space if there is room
  MA_AVOID_CORRIDORS       : Fl(17),   // monster will avoid corridors when hunting

	SPECIAL_HIT						: ['MA_HIT_HALLUCINATE', 'MA_HIT_STEAL_FLEE', 'MA_HIT_DEGRADE_ARMOR', 'MA_POISONS', 'MA_TRANSFERENCE', 'MA_CAUSES_WEAKNESS', 'MA_HIT_BURN', 'MA_ATTACKS_STAGGER'],
	LEARNABLE_ABILITIES		: ['MA_TRANSFERENCE', 'MA_CAUSES_WEAKNESS'],

  MA_NON_NEGATABLE_ABILITIES      : ['MA_ATTACKS_PENETRATE', 'MA_ATTACKS_ALL_ADJACENT', 'MA_ATTACKS_EXTEND', 'MA_ATTACKS_STAGGER'],
  MA_NEVER_VORPAL_ENEMY           : ['MA_KAMIKAZE'],
  MA_NEVER_MUTATED                : ['MA_KAMIKAZE'],
});


FLAG('monsterBookkeepingFlags', {
	MB_WAS_VISIBLE				: Fl(0),	// monster was visible to player last turn
	MB_TELEPATHICALLY_REVEALED  : Fl(1),    // player can magically see monster and adjacent cells
	MB_PREPLACED                : Fl(2),	// monster dropped onto the level and requires post-processing
	MB_APPROACHING_UPSTAIRS		: Fl(3),	// following the player up the stairs
	MB_APPROACHING_DOWNSTAIRS	: Fl(4),	// following the player down the stairs
	MB_APPROACHING_PIT	: Fl(5),	// following the player down a pit
	MB_LEADER						: Fl(6),	// monster is the leader of a horde
	MB_FOLLOWER					: Fl(7),	// monster is a member of a horde
	MB_CAPTIVE					: Fl(8),	// monster is all tied up
	MB_SEIZED						: Fl(9),	// monster is being held
	MB_SEIZING					: Fl(10),	// monster is holding another creature immobile
	MB_SUBMERGED				: Fl(11),	// monster is currently submerged and hence invisible until it attacks
	MB_JUST_SUMMONED		: Fl(12),	// used to mark summons so they can be post-processed
	MB_WILL_FLASH				: Fl(13),	// this monster will flash as soon as control is returned to the player
	MB_BOUND_TO_LEADER	: Fl(14),	// monster will die if the leader dies or becomes separated from the leader
	MB_MARKED_FOR_SACRIFICE 	: Fl(15),		// scary glow, monster can be sacrificed in the appropriate machine
	MB_ABSORBING							: Fl(16),	// currently learning a skill by absorbing an enemy corpse
	MB_DOES_NOT_TRACK_LEADER	: Fl(17),	// monster will not follow its leader around
	MB_IS_FALLING							: Fl(18),	// monster is plunging downward at the end of the turn
	MB_IS_DYING								: Fl(19),	// monster has already been killed and is awaiting the end-of-turn graveyard sweep (or in purgatory)
	MB_GIVEN_UP_ON_SCENT			: Fl(20),	// to help the monster remember that the scent map is a dead end
	MB_IS_DORMANT							: Fl(21),	// lurking, waiting to burst out
  MB_HAS_SOUL               : Fl(22),   // slaying the monster will count toward weapon auto-ID
  MB_ALREADY_SEEN           : Fl(23),   // seeing this monster won't interrupt exploration
});


// Defines all creatures, which include monsters and the player:
function creatureType(id, name, ch, fg, hp, def, acc, dmg, regen, move, attack, blood, light, chance, feature, bolts, flags, abilities) {
	dmg = dmg || [];
	return {
		/* ENUM monsterTypes */ monsterID: id || 0, // index number for the monsterCatalog
		monsterName: STRING(name || ''), // [COLS];
		displayChar: ch || '',
		foreColor: fg || null,
		maxHP: hp || 0,
		defense: def || 0,
		accuracy: acc || 0,
		damage: randomRange(dmg),
		turnsBetweenRegen: regen || 0,		// turns to wait before regaining 1 HP
		movementSpeed: move || 0,
		attackSpeed: attack || 0,
		/* ENUM dungeonFeatureTypes */ bloodType: blood || 0,
		/* ENUM lightType */ intrinsicLightType: light || 0,
		DFChance: chance || 0,						// percent chance to spawn the dungeon feature per awake turn
		/* ENUM dungeonFeatureTypes */ DFType: feature || 0,	// kind of dungeon feature
	  /* ENUM boltType */ bolts: bolts || [], // [20];
		flags: flags || 0,
		abilityFlags: abilities || 0,
	};
}


function monsterWords(flavor, absorb, status, attacks, feature, summon) {
	return {
		flavorText: flavor || '', // [COLS*5];
		absorbing: absorb || '', // [40];
		absorbStatus: status || '', // [40];
		attack: attacks || [], // [5][30];
		DFMessage: feature || '', // [DCOLS * 2];
		summonMessage: summon || '', // [DCOLS * 2];
	};
}


ENUM('creatureStates',
	'MONSTER_SLEEPING',
	'MONSTER_TRACKING_SCENT',
	'MONSTER_WANDERING',
	'MONSTER_FLEEING',
	'MONSTER_ALLY',
);

ENUM('creatureModes',
	'MODE_NORMAL',
	'MODE_PERM_FLEEING'
);


function mutation(name, fg, hp, move, attack, def, dmg, chance, feature, light, flags, abilities, noFlags, noAbilities, desc) {
	return {
    title: name || '', // [100];
    textColor: fg || null,
    healthFactor: hp || 0,
    moveSpeedFactor: move || 0,
    attackSpeedFactor: attack || 0,
    defenseFactor: def || 0,
    damageFactor: dmg || 0,
    DFChance: chance || 0,
    /* ENUM dungeonFeatureTypes */ DFType: feature || 0,
    /* ENUM lightType */ light: light || 0,
    monsterFlags: flags || 0,
    monsterAbilityFlags: abilities || 0,
    forbiddenFlags: noFlags || 0,
    forbiddenAbilityFlags: noAbilities || 0,
    description: desc || '', // [1000];
	};
}


function hordeType(leader, count, types, number, minLevel, maxLevel, freq, spawn, machine, flags) {
	number = number || [];
	return {
		/* ENUM monsterTypes */ leaderType: leader || 0,

		// membership information
		numberOfMemberTypes: count || 0,
		/* ENUM monsterTypes */ memberType: types || [],	// [5]
		memberCount: number.map( (v) => randomRange(v) ), // randomRange[5];

		// spawning information
		minLevel: minLevel || 0,
		maxLevel: maxLevel || 0,
		frequency: freq || 0,
		/* ENUM tileType */ spawnsIn: spawn || 0,
		machine: machine || 0,

		/* ENUM hordeFlags */ flags: flags || 0,
	};
}


function monsterClass(name, freq, depth, members) {
	return {
    name: name || '', // [30];
    frequency: freq || 0,
    maxDepth: depth || 0,
    /* ENUM monsterTypes */ memberList: members || [], // [15];
	};
}


function creature() {
	return {
		/* creatureType */ info: creatureType(),
		xLoc: 0,
		yLoc: 0,
		depth: 0,
		currentHP: 0,
		turnsUntilRegen: 0,
		regenPerTurn: 0,					// number of HP to regenerate every single turn
		weaknessAmount: 0,				// number of points of weakness that are inflicted by the weakness status
    poisonAmount: 0,                 // number of points of damage per turn from poison
		/* ENUM creatureStates */ creatureState: 0,	// current behavioral state
		/* ENUM creatureModes */ creatureMode: 0,	// current behavioral mode (higher-level than state)

    mutationIndex: -1,                // what mutation the monster has (or -1 for none)

    // Waypoints:
    targetWaypointIndex: 0,          // the index number of the waypoint we're pathing toward
    waypointAlreadyVisited: [], // [MAX_WAYPOINT_COUNT]; // checklist of waypoints
    lastSeenPlayerAt: [], // [2];          // last location at which the monster hunted the player

    targetCorpseLoc: [], // [2];			// location of the corpse that the monster is approaching to gain its abilities
		targetCorpseName: STRING(), // char[30];			// name of the deceased monster that we're approaching to gain its abilities
		absorptionFlags: 0,		// ability/behavior flags that the monster will gain when absorption is complete
		absorbBehavior: false,				// above flag is behavior instead of ability (ignored if absorptionBolt is set)
	  absorptionBolt: 0,               // bolt index that the monster will learn to cast when absorption is complete
		corpseAbsorptionCounter: 0,		// used to measure both the time until the monster stops being interested in the corpse,
											// and, later, the time until the monster finishes absorbing the corpse.
		mapToMe: null,					// if a pack leader, this is a periodically updated pathing map to get to the leader
		safetyMap: null,					// fleeing monsters store their own safety map when out of player FOV to avoid omniscience
		ticksUntilTurn: 0,				// how long before the creature gets its next move

		// Locally cached statistics that may be temporarily modified:
		movementSpeed: 0,
		attackSpeed: 0,

		previousHealthPoints: 0,			// remembers what your health proportion was at the start of the turn
		turnsSpentStationary: 0,			// how many (subjective) turns it's been since the creature moved between tiles
		flashStrength: 0,				// monster will flash soon; this indicates the percent strength of flash
		flashColor: color(),					// the color that the monster will flash
		status: [], // [NUMBER_OF_STATUS_EFFECTS];
		maxStatus: [], // [NUMBER_OF_STATUS_EFFECTS]; // used to set the max point on the status bars
		bookkeepingFlags: 0,
		spawnDepth: 0,					// keep track of the depth of the machine to which they relate (for activation monsters)
	  machineHome: 0,                  // monsters that spawn in a machine keep track of the machine number here (for activation monsters)
		xpxp: 0,							// exploration experience (used to time telepathic bonding for allies)
		newPowerCount: 0,                // how many more times this monster can absorb a fallen monster
	  totalPowerCount: 0,              // how many times has the monster been empowered? Used to recover abilities when negated.
		/* struct creature */ leader: null,			// only if monster is a follower
		/* struct creature */ carriedMonster: null,	// when vampires turn into bats, one of the bats restores the vampire when it dies
		/* struct creature */ nextCreature: null,
		/* struct item */ carriedItem: null,			// only used for monsters
	};
}


ENUM('NGCommands',
	'NG_NOTHING',
	'NG_NEW_GAME',
	'NG_NEW_GAME_WITH_SEED',
	'NG_OPEN_GAME',
	'NG_VIEW_RECORDING',
	'NG_HIGH_SCORES',
  'NG_SCUM',
	'NG_QUIT',
);

ENUM('featTypes',
  'FEAT_PURE_MAGE',
  'FEAT_PURE_WARRIOR',
  'FEAT_PACIFIST',
  'FEAT_ARCHIVIST',
  'FEAT_COMPANION',
  'FEAT_SPECIALIST',
  'FEAT_JELLYMANCER',
  'FEAT_INDOMITABLE',
  'FEAT_MYSTIC',
  'FEAT_DRAGONSLAYER',
  'FEAT_PALADIN',
  'FEAT_COUNT',
);


// these are basically global variables pertaining to the game state and player's unique variables:
function playerCharacter() {
	return {
		depthLevel: 0,					// which dungeon level are we on
	  deepestLevel: 0,
		disturbed: false,					// player should stop auto-acting
		gameHasEnded: false,				// stop everything and go to death screen
		highScoreSaved: false,				// so that it saves the high score only once
		blockCombatText: false,			// busy auto-fighting
		autoPlayingLevel: false,			// seriously, don't interrupt
		automationActive: false,			// cut some corners during redraws to speed things up
		justRested: false,					// previous turn was a rest -- used in stealth
		justSearched: false,				// previous turn was a search -- used in manual searches
		cautiousMode: false,				// used to prevent careless deaths caused by holding down a key
		receivedLevitationWarning: false,	// only warn you once when you're hovering dangerously over liquid
		updatedSafetyMapThisTurn: false,	// so it's updated no more than once per turn
		updatedAllySafetyMapThisTurn: false,	// so it's updated no more than once per turn
		updatedMapToSafeTerrainThisTurn: false,// so it's updated no more than once per turn
		updatedMapToShoreThisTurn: false,		// so it's updated no more than once per turn
		easyMode: false,					// enables easy mode
		inWater: false,					// helps with the blue water filter effect
		heardCombatThisTurn: false,		// so you get only one "you hear combat in the distance" per turn
		creaturesWillFlashThisTurn: false,	// there are creatures out there that need to flash before the turn ends
		staleLoopMap: false,				// recalculate the loop map at the end of the turn
		alreadyFell: false,				// so the player can fall only one depth per turn
		eligibleToUseStairs: false,		// so the player uses stairs only when he steps onto them
		trueColorMode: false,				// whether lighting effects are disabled
	  displayAggroRangeMode: false,      // whether your stealth range is displayed
	  // warningPauseMode: false,	// 1.7.4
		quit: false,						// to skip the typical end-game theatrics when the player quits
		seed: 0,					// the master seed for generating the entire dungeon
		RNG: 0,							// which RNG are we currently using
		gold: 0,					// how much gold we have
		goldGenerated: 0,		// how much gold has been generated on the levels, not counting gold held by monsters
		strength: 0,
		monsterSpawnFuse: 0,	// how much longer till a random monster spawns

		/* item */ weapon: null,
		/* item */ armor: null,
		/* item */ ringLeft: null,
		/* item */ ringRight: null,

	  /* flare */ flares: [],
	  flareCount: 0,
	  flareCapacity: 0,

	  /* creature */ yendorWarden: null,

		/* lightSource */ minersLight: lightSource(),
		minersLightRadius: 0,
		ticksTillUpdateEnvironment: 0,	// so that some periodic things happen in objective time
		scentTurnNumber: 0,		// helps make scent-casting work
		playerTurnNumber: 0,     // number of input turns in recording. Does not increment during paralysis.
	  absoluteTurnNumber: 0,   // number of turns since the beginning of time. Always increments.
		milliseconds: 0,			// milliseconds since launch, to decide whether to engage cautious mode
		xpxpThisTurn: 0,					// how many squares the player explored this turn
	  aggroRange: 0,                   // distance from which monsters will notice you

		// previousHealthPercent: 0,        // remembers what your health proportion was at the start of the turn,		// removed 1.7.5
	  previousPoisonPercent: 0,        // and your poison proportion, to display percentage alerts for each

		upLoc: [0, 0], // [2]						// upstairs location this level
		downLoc: [0, 0], // [2]					// downstairs location this level

		cursorLoc: [0, 0], // [2]					// used for the return key functionality
		/* creature */ lastTarget: null,				// to keep track of the last monster the player has thrown at or zapped
		rewardRoomsGenerated: 0,			// to meter the number of reward machines
		machineNumber: 0,				// so each machine on a level gets a unique number
		sidebarLocationList: ARRAY(ROWS*2, () => [0,0]), // [ROWS*2][2];	// to keep track of which location each line of the sidebar references

		// maps
		mapToShore: null,					// how many steps to get back to shore
		mapToSafeTerrain: null,			// so monsters can get to safety

		// recording info
		playbackMode: false,				// whether we're viewing a recording instead of playing
		currentTurnNumber: 0,	// how many turns have elapsed
		howManyTurns: 0,			// how many turns are in this recording
		howManyDepthChanges: 0,			// how many times the player changes depths
		playbackDelayPerTurn: 0,			// base playback speed; modified per turn by events
		playbackDelayThisTurn: 0,		// playback speed as modified
		playbackPaused: false,
		playbackFastForward: false,		// for loading saved games and such -- disables drawing and prevents pauses
		playbackOOS: false,				// playback out of sync -- no unpausing allowed
		playbackOmniscience: false,		// whether to reveal all the map during playback
		playbackBetweenTurns: false,		// i.e. waiting for a top-level input -- iff, permit playback commands
		nextAnnotationTurn: 0,	// the turn number during which to display the next annotation
		nextAnnotation: '', // [5000];			// the next annotation
		locationInAnnotationFile: 0, // how far we've read in the annotations file

		// metered items
		foodSpawned: 0,					// amount of nutrition units spawned so far this game
		lifePotionFrequency: 0,
	  lifePotionsSpawned: 0,
		strengthPotionFrequency: 0,
		enchantScrollFrequency: 0,

		// ring bonuses:
		clairvoyance: 0,
		stealthBonus: 0,
		regenerationBonus: 0,
		lightMultiplier: 0,
		awarenessBonus: 0,
		transference: 0,
		wisdomBonus: 0,
	  reaping: 0,

	  // feats:
	  featRecord: [], // bool[FEAT_COUNT];

	  // waypoints:
	  wpDistance: [], //short**[MAX_WAYPOINT_COUNT];
	  wpCount: 0,
	  wpCoordinates: [], // short[MAX_WAYPOINT_COUNT][2];
	  wpRefreshTicker: 0,

		// cursor trail:
		cursorPathIntensity: 0,
	  cursorMode: false,

		// What do you want to do, player -- play, play with seed, resume, recording, high scores or quit?
		/* ENUM NGCommands */ nextGame: 0,
		nextGamePath: '', // char[BROGUE_FILENAME_MAX];
		nextGameSeed: 0,
	};
}


// Stores the necessary info about a level so it can be regenerated:
function levelData() {

	const storage = GRID(DCOLS, DROWS, () => pcell() );

	return {
		visited: false,
		mapStorage: storage, // pcell[DCOLS][DROWS];
		items: null,	// item * => points to first item, use nextItem on that item to walk chain
		monsters: null, // creature * => points to first monster, use nextMonster on that monster to walk chain
		dormantMonsters: null, // creature * => see above.
	  scentMap: null,
		levelSeed: 0,
		upStairsLoc: [], // short[2];
		downStairsLoc: [], // short[2];
		playerExitedVia: [], // short[2];
		awaySince: 0,
	};
}


FLAG('machineFeatureFlags', {
	MF_GENERATE_ITEM				: Fl(0),	// feature entails generating an item (overridden if the machine is adopting an item)
	MF_OUTSOURCE_ITEM_TO_MACHINE	: Fl(1),	// item must be adopted by another machine
	MF_BUILD_VESTIBULE      : Fl(2),	// call this at the origin of a door room to create a new door guard machine there
	MF_ADOPT_ITEM						: Fl(3),	// this feature will take the adopted item (be it from another machine or a previous feature)
	MF_NO_THROWING_WEAPONS	: Fl(4),	// the generated item cannot be a throwing weapon
	MF_GENERATE_HORDE				: Fl(5),	// generate a monster horde that has all of the horde flags
	MF_BUILD_AT_ORIGIN			: Fl(6),	// generate this feature at the room entrance
	// unused                       : Fl(7),	//
	MF_PERMIT_BLOCKING			: Fl(8),	// permit the feature to block the map's passability (e.g. to add a locked door)
	MF_TREAT_AS_BLOCKING		: Fl(9),	// treat this terrain as though it blocks, for purposes of deciding whether it can be placed there
	MF_NEAR_ORIGIN					: Fl(10),	// feature must spawn in the rough quarter of tiles closest to the origin
	MF_FAR_FROM_ORIGIN			: Fl(11),	// feature must spawn in the rough quarter of tiles farthest from the origin
	MF_MONSTER_TAKE_ITEM		: Fl(12),	// the item associated with this feature (including if adopted) will be in possession of the horde leader that's generated
	MF_MONSTER_SLEEPING			: Fl(13),	// the monsters should be asleep when generated
  MF_MONSTER_FLEEING      : Fl(14),   // the monsters should be permanently fleeing when generated
	MF_EVERYWHERE						: Fl(15),	// generate the feature on every tile of the machine (e.g. carpeting)
	MF_ALTERNATIVE					: Fl(16),	// build only one feature that has this flag per machine; the rest are skipped
	MF_ALTERNATIVE_2				: Fl(17),	// same as MF_ALTERNATIVE, but provides for a second set of alternatives of which only one will be chosen
	MF_REQUIRE_GOOD_RUNIC		: Fl(18),	// generated item must be uncursed runic
	MF_MONSTERS_DORMANT			: Fl(19),	// monsters are dormant, and appear when a dungeon feature with DFF_ACTIVATE_DORMANT_MONSTER spawns on their tile
	// unused                       : Fl(20),	//
	MF_BUILD_IN_WALLS				: Fl(21),	// build in an impassable tile that is adjacent to the interior
	MF_BUILD_ANYWHERE_ON_LEVEL		: Fl(22),	// build anywhere on the level that is not inside the machine
	MF_REPEAT_UNTIL_NO_PROGRESS		: Fl(23),	// keep trying to build this feature set until no changes are made
	MF_IMPREGNABLE					: Fl(24),	// this feature's location will be immune to tunneling
	MF_IN_VIEW_OF_ORIGIN		: Fl(25),	// this feature must be in view of the origin
	MF_IN_PASSABLE_VIEW_OF_ORIGIN	: Fl(26),	// this feature must be in view of the origin, where "view" is blocked by pathing blockers
	MF_NOT_IN_HALLWAY				: Fl(27),	// the feature location must have a passableArcCount of <= 1
	MF_NOT_ON_LEVEL_PERIMETER			: Fl(28),	// don't build it in the outermost walls of the level
	MF_SKELETON_KEY					: Fl(29),	// if a key is generated or adopted by this feature, it will open all locks in this machine.
	MF_KEY_DISPOSABLE				: Fl(30),	// if a key is generated or adopted, it will self-destruct after being used at this current location.
});


function machineFeature(feature, tile, layer, count, minCount, item, kind, monster, space, horde, itemFlags, flags) {
	return {
		// terrain
		/* ENUM dungeonFeatureTypes */ featureDF: feature || 0,	// generate this DF at the feature location (0 for none)
		/* ENUM tileType */ terrain: tile || 0,				// generate this terrain tile at the feature location (0 for none)
		/* ENUM dungeonLayers */ layer: layer || 0,			// generate the terrain tile in this layer

		instanceCountRange: count || [], // short[2];		// generate this range of instances of this feature
		minimumInstanceCount: minCount || 0,			// abort if fewer than this

		// items: these will be ignored if the feature is adopting an item
		itemCategory: item || 0,					// generate this category of item (or -1 for random)
		itemKind: kind || 0,						// generate this kind of item (or -1 for random)

		monsterID: monster || 0,					// generate a monster of this kind if MF_GENERATE_MONSTER is set

		personalSpace: space || 0,				// subsequent features must be generated more than this many tiles away from this feature
		hordeFlags: horde || 0,			// choose a monster horde based on this
		itemFlags: itemFlags || 0,			// assign these flags to the item
		flags: flags || 0,				// feature flags
	};
}


FLAG('blueprintFlags', {
	BP_ADOPT_ITEM         : Fl(0),	// the machine must adopt an item (e.g. a door key)
  BP_VESTIBULE          : Fl(1),    // spawns in a doorway (location must be given) and expands outward, to guard the room
	BP_PURGE_PATHING_BLOCKERS	: Fl(2),	// clean out traps and other T_PATHING_BLOCKERs
	BP_PURGE_INTERIOR			: Fl(3),	// clean out all of the terrain in the interior before generating the machine
	BP_PURGE_LIQUIDS			: Fl(4),	// clean out all of the liquids in the interior before generating the machine
	BP_SURROUND_WITH_WALLS		: Fl(5),	// fill in any impassable gaps in the perimeter (e.g. water, lava, brimstone, traps) with wall
	BP_IMPREGNABLE				: Fl(6),	// impassable perimeter and interior tiles are locked; tunneling bolts will bounce off harmlessly
	BP_REWARD							: Fl(7),	// metered reward machines
	BP_OPEN_INTERIOR			: Fl(8),	// clear out walls in the interior, widen the interior until convex or bumps into surrounding areas
  BP_MAXIMIZE_INTERIOR  : Fl(9),    // same as BP_OPEN_INTERIOR but expands the room as far as it can go, potentially surrounding the whole level.
	BP_ROOM								: Fl(10),	// spawns in a dead-end room that is dominated by a chokepoint of the given size (as opposed to a random place of the given size)
	BP_TREAT_AS_BLOCKING	: Fl(11),	// abort the machine if, were it filled with wall tiles, it would disrupt the level connectivity
	BP_REQUIRE_BLOCKING		: Fl(12),	// abort the machine unless, were it filled with wall tiles, it would disrupt the level connectivity
	BP_NO_INTERIOR_FLAG		: Fl(13),	// don't flag the area as being part of a machine
  BP_REDESIGN_INTERIOR  : Fl(14),   // nuke and pave -- delete all terrain in the interior and build entirely new rooms within the bounds
});


function blueprint(depth, size, freq, count, profile, flags, features) {
	depth = depth || [];
	size = size || [];
	features = features || [];
	count = count || 0;

	if (count != features.length) {
		console.warn('blueprint feature count != features array length');
		console.log(depth, size, freq, count, profile, flags, features);
		count = features.length;
	}

	return {
		depthRange: depth, // short[2];				// machine must be built between these dungeon depths
		roomSize: size, // short[2];					// machine must be generated in a room of this size
		frequency: freq || 0,					// frequency (number of tickets this blueprint enters in the blueprint selection raffle)
		featureCount: count || 0,					// how many different types of features follow (max of 20)
	  dungeonProfileType: profile || 0,           // if BP_REDESIGN_INTERIOR is set, which dungeon profile do we use?
		flags: flags || 0,				// blueprint flags
		feature: features.map( (v) => machineFeature(...v) ), // machineFeature[20];			// the features themselves
	};
}


ENUM('machineTypes',
  'MT_NONE',
	// Reward rooms:
	'MT_REWARD_MULTI_LIBRARY',
	'MT_REWARD_MONO_LIBRARY',
	'MT_REWARD_CONSUMABLES',
	'MT_REWARD_PEDESTALS_PERMANENT',
	'MT_REWARD_PEDESTALS_CONSUMABLE',
	'MT_REWARD_COMMUTATION_ALTARS',
	'MT_REWARD_RESURRECTION_ALTAR',
  'MT_REWARD_ADOPTED_ITEM',
	'MT_REWARD_DUNGEON',
	'MT_REWARD_KENNEL',
	'MT_REWARD_VAMPIRE_LAIR',
	'MT_REWARD_ASTRAL_PORTAL',
  'MT_REWARD_GOBLIN_WARREN',
  'MT_REWARD_SENTINEL_SANCTUARY',

  // Amulet holder:
  'MT_AMULET_AREA',

  // Door guard machines:
  'MT_LOCKED_DOOR_VESTIBULE',
  'MT_SECRET_DOOR_VESTIBULE',
  'MT_SECRET_LEVER_VESTIBULE',
	'MT_FLAMMABLE_BARRICADE_VESTIBULE',
	'MT_STATUE_SHATTERING_VESTIBULE',
	'MT_STATUE_MONSTER_VESTIBULE',
	'MT_THROWING_TUTORIAL_VESTIBULE',
  'MT_PIT_TRAPS_VESTIBULE',
  'MT_BECKONING_OBSTACLE_VESTIBULE',
  'MT_GUARDIAN_VESTIBULE',

	// Key guard machines:
	'MT_KEY_REWARD_LIBRARY',
	'MT_KEY_SECRET_ROOM',
	'MT_KEY_THROWING_TUTORIAL_AREA',
  'MT_KEY_RAT_TRAP_ROOM',
	'MT_KEY_FIRE_TRANSPORTATION_ROOM',
	'MT_KEY_FLOOD_TRAP_ROOM',
  'MT_KEY_FIRE_TRAP_ROOM',
  'MT_KEY_THIEF_AREA',
	'MT_KEY_COLLAPSING_FLOOR_AREA',
	'MT_KEY_PIT_TRAP_ROOM',
	'MT_KEY_LEVITATION_ROOM',
	'MT_KEY_WEB_CLIMBING_ROOM',
	'MT_KEY_LAVA_MOAT_ROOM',
	'MT_KEY_LAVA_MOAT_AREA',
	'MT_KEY_POISON_GAS_TRAP_ROOM',
	'MT_KEY_EXPLOSIVE_TRAP_ROOM',
	'MT_KEY_BURNING_TRAP_ROOM',
	'MT_KEY_STATUARY_TRAP_AREA',
  'MT_KEY_GUARDIAN_WATER_PUZZLE_ROOM',
  'MT_KEY_GUARDIAN_GAUNTLET_ROOM',
  'MT_KEY_GUARDIAN_CORRIDOR_ROOM',
	'MT_KEY_SACRIFICE_ROOM',	// 1.7.5
  'MT_KEY_SUMMONING_CIRCLE_ROOM',
  'MT_KEY_BECKONING_OBSTACLE_ROOM',
	'MT_KEY_WORM_TRAP_AREA',
	'MT_KEY_MUD_TRAP_ROOM',
  'MT_KEY_ELECTRIC_CRYSTALS_ROOM',
	'MT_KEY_ZOMBIE_TRAP_ROOM',
	'MT_KEY_PHANTOM_TRAP_ROOM',
  'MT_KEY_WORM_TUNNEL_ROOM',
	'MT_KEY_TURRET_TRAP_ROOM',
	'MT_KEY_BOSS_ROOM',

	// Thematic machines:
	'MT_BLOODFLOWER_AREA',
  'MT_SHRINE_AREA',
  'MT_IDYLL_AREA',
	'MT_SWAMP_AREA',
	'MT_CAMP_AREA',
	'MT_REMNANT_AREA',
	'MT_DISMAL_AREA',
	'MT_BRIDGE_TURRET_AREA',
	'MT_LAKE_PATH_TURRET_AREA',
  'MT_PARALYSIS_TRAP_AREA',
  'MT_PARALYSIS_TRAP_HIDDEN_AREA',
	'MT_TRICK_STATUE_AREA',
	'MT_WORM_AREA',
	'MT_SENTINEL_AREA',

	'NUMBER_BLUEPRINTS',
);


function autoGenerator(tile, layer, df, mach, reqTile, reqLiquid, minD, maxD, freq, int, slope, max) {
	return {
		// What spawns:
		/* ENUM tileType */ terrain: tile || 0,
		/* ENUM dungeonLayers */ layer: layer || 0,

		/* ENUM dungeonFeatureTypes */ DFType: df || 0,

		/* ENUM machineTypes */ machine: mach || 0, // Machine placement also respects BP_ placement flags in the machine blueprint

		// Parameters governing when and where it spawns:
		/* ENUM tileType */ requiredDungeonFoundationType: reqTile || 0,
		/* ENUM tileType */ requiredLiquidFoundationType: reqLiquid || 0,
		minDepth: minD || 0,
		maxDepth: maxD || 0,
		frequency: freq || 0,
		minNumberIntercept: int || 0, // actually intercept * 100
		minNumberSlope: slope || 0, // actually slope * 100
		maxNumber: max || 0,
	};
}


// const NUMBER_AUTOGENERATORS = 49;

function feat(name, desc, value) {
	return {
		name: name || '', // char[100];
    description: desc || '', // char[200];
    initialValue: value || false,
	};
}



const PDS_FORBIDDEN   = -1;
const PDS_OBSTRUCTION = -2;
function PDS_CELL(map, x, y) {
	return (map.links[x + DCOLS * y]);
}

// function pdsLink() {
// 	return {};
// };
// function pdsMap() {
// 	return {};
// };


function brogueButton() {
	return {
		text: STRING(), // char[COLS*3];			// button label; can include color escapes
		x: 0,					// button's leftmost cell will be drawn at (x, y)
		y: 0,
		hotkey: [], // long[10];		// up to 10 hotkeys to trigger the button
		buttonColor: color(),			// background of the button; further gradient-ized when displayed
		opacity: 0,				// further reduced by 50% if not enabled
		symbol: [], // uchar[COLS];			// Automatically replace the nth asterisk in the button label text with
									// the nth character supplied here, if one is given.
									// (Primarily to display magic character and item symbols in the inventory display.)
		flags: 0,
	};
}


ENUM('buttonDrawStates',
	'BUTTON_NORMAL',
	'BUTTON_HOVER',
	'BUTTON_PRESSED',
);

FLAG('BUTTON_FLAGS', {
	B_DRAW					: Fl(0),
	B_ENABLED				: Fl(1),
	B_GRADIENT				: Fl(2),
	B_HOVER_ENABLED			: Fl(3),
	B_WIDE_CLICK_AREA		: Fl(4),
	B_KEYPRESS_HIGHLIGHT	: Fl(5),
});


function buttonState() {

	const dbuf = [];
	const rbuf = [];

	for(let i = 0; i < COLS; ++i) {
		const drow = dbuf[i] = [];
		const rrow = rbuf[i] = [];
		for(let j = 0; j < ROWS; ++j) {
			drow.push(cellDisplayBuffer());
			rrow.push(cellDisplayBuffer());
		}
	}

	return {
		// Indices of the buttons that are doing stuff:
		buttonFocused: 0,
		buttonDepressed: 0,

		// Index of the selected button:
		buttonChosen: 0,

		// The buttons themselves:
		buttonCount: 0,
		buttons: [], // brogueButton [50];

		// The window location, to determine whether a click is a cancelation:
		winX: 0,
		winY: 0,
		winWidth: 0,
		winHeight: 0,

		// Graphical buffers:
		dbuf, // cellDisplayBuffer [COLS][ROWS]; // Where buttons are drawn.
		rbuf, // cellDisplayBuffer [COLS][ROWS]; // Reversion screen state.
	};
}
// As of v1.7.5, Brogue uses this open-source fixed-point square root function
// by Mads A. Elvheim.
// Original file is available here:
// https://gist.github.com/Madsy/1088393/ee0e6c2ca940c25149a08d525d6e713b68636773
// clz() function is taken from a comment by "ruslan-cray" on the same page.

/*
Copyright (c) 2011, Mads A. Elvheim
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the organization nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Mads A. Elvheim BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// #include <stdio.h>
// #include <stdlib.h>
// #include "Rogue.h"

const BIG_BASE = BigInt(FP_BASE);

/* Computing the number of leading zeros in a word. */
function clz(x)
{
    let n;

    /* See "Hacker's Delight" book for more details */
    if (x == 0) return 32;
    n = 0;
    if (x <= 0x0000FFFF) {n = n +16; x = (x <<16) >>> 0;}
    if (x <= 0x00FFFFFF) {n = n + 8; x = (x << 8) >>> 0;}
    if (x <= 0x0FFFFFFF) {n = n + 4; x = (x << 4) >>> 0;}
    if (x <= 0x3FFFFFFF) {n = n + 2; x = (x << 2) >>> 0;}
    if (x <= 0x7FFFFFFF) {n = n + 1;}

    return n;
}


function fp_sqrt(val)
{
    let x;
    let bitpos;
    let v;		// int64

    if(!val)
        return val;

    if (val < 0) {
    	throw new Error('MATH OVERFLOW - limit is 32767 << FP_BASE (about 181 * 181)! Received: ' + val);
    }

    /* clz = count-leading-zeros. bitpos is the position of the most significant bit,
        relative to "1" or 1 << FP_BASE */
    bitpos = FP_BASE - clz(val);

    /* Calculate our first estimate.
        We use the identity 2^a * 2^a = 2^(2*a) or:
         sqrt(2^a) = 2^(a/2)
    */
    if(bitpos > 0) /* val > 1 */
        x = BigInt((1<<FP_BASE) << (bitpos >> 1));
    else if(bitpos < 0) /* 0 < val < 1 */
        x = BigInt((1<<FP_BASE) << ((~bitpos) << 1));
    else /* val == 1 */
        x = BigInt((1<<FP_BASE));

    /* We need to scale val with FP_BASE due to the division.
       Also val /= 2, hence the subtraction of one*/
    v = BigInt(val) << (BIG_BASE - 1n);  // v = val <<  (FP_BASE - 1);

    /* The actual iteration */
    x = (x >> 1n) + (v/x);
    x = (x >> 1n) + (v/x);
    x = (x >> 1n) + (v/x);
    x = (x >> 1n) + (v/x);

    return Number(x);
}
/*
 *  RogueMain.c
 *  Brogue
 *
 *  Created by Brian Walker on 12/26/08.
 *  Copyright 2012. All rights reserved.
 *
 *  This file is part of Brogue.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

// #include <math.h>
// #include <time.h>
// #include <limits.h>
// #include <stdint.h> // C99
//
// #include "Rogue.h"
// #include "IncludeGlobals.h"

function randClump(/* randomRange */ theRange) {
	return randClumpedRange(theRange.lowerBound, theRange.upperBound, theRange.clumpFactor);
}

// Get a random int between lowerBound and upperBound, inclusive, with probability distribution
// affected by clumpFactor.
function randClumpedRange(lowerBound, upperBound, clumpFactor) {
	if (upperBound <= lowerBound) {
		return lowerBound;
	}
	if (clumpFactor <= 1) {
		return rand_range(lowerBound, upperBound);
	}

	let i, total = 0, numSides = Math.floor((upperBound - lowerBound) / clumpFactor);

	for(i=0; i < (upperBound - lowerBound) % clumpFactor; i++) {
		total += rand_range(0, numSides + 1);
	}

	for(; i < clumpFactor; i++) {
		total += rand_range(0, numSides);
	}

	return (total + lowerBound);
}

// Get a random int between lowerBound and upperBound, inclusive
function rand_percent(percent) {
	return (rand_range(0, 99) < clamp(percent, 0, 100));
}

function shuffleList(list, fromIndex, toIndex) {
	if (arguments.length == 2) {
		toIndex = fromIndex;
		fromIndex = 0;
	}

	let i, r, buf;
	toIndex = toIndex || list.length;
	fromIndex = fromIndex || 0;

	for (i = fromIndex; i < toIndex; i++) {
		r = rand_range(fromIndex, toIndex-1);
		if (i != r) {
			buf = list[r];
			list[r] = list[i];
			list[i] = buf;
		}
	}
}

function fillSequentialList(list, listLength) {
    let i;
    for (i=0; i<listLength; i++) {
        list[i] = i;
    }
}

//typedef unsigned long int  u4;
// typedef uint32_t u4;
function ranctx() {
	return { a: 0, b: 0, c: 0, d: 0 };
}

var negRandom = 0;

const RNGState = [ranctx(), ranctx()];

function rot(x,k) { return ( (x << k) | (x >>> (32-k)) ) >>> 0; }

function ranval( /* ranctx */ x ) {

	const rb = rot(x.b, 27);
  const rc = rot(x.c, 17);
  const e = (x.a - rb) >>> 0;
  x.a = (x.b ^ rc) >>> 0;
  x.b = ((x.c + x.d) & 0xFFFFFFFF) >>> 0;
  x.c = ((x.d + e) & 0xFFFFFFFF) >>> 0;
  x.d = ((e + x.a) & 0xFFFFFFFF) >>> 0;

	// if (x.d < 0) {
	// 	++ negRandom;
	// 	return ranval(x);
	// }
  return x.d;
}

// // This is for debugging the random number generator
// function ranval_print( /* ranctx */ x ) {
//
// 	const rb = rot(x.b, 27);
//   const rc = rot(x.c, 17);
//   const e = (x.a - rb) >>> 0;
//   x.a = (x.b ^ rc) >>> 0;
//   x.b = ((x.c + x.d) & 0xFFFFFFFF) >>> 0;
//   x.c = ((x.d + e) & 0xFFFFFFFF) >>> 0;
//   x.d = ((e + x.a) & 0xFFFFFFFF) >>> 0;
//
// 	console.log('ranval');
// 	console.log(' rb => ', rb);
// 	console.log(' rc => ', rc);
// 	console.log('  e => ', e);
// 	console.log('  a => ', x.a);
// 	console.log('  b => ', x.b);
// 	console.log('  c => ', x.c);
// 	console.log('  d => ', x.d);
//
// 	// if (x.d < 0) {
// 	// 	++ negRandom;
// 	// 	return ranval(x);
// 	// }
//   return x.d;
// }


function raninit( /* ranctx */ x, seed ) {
    let i;

    x.a = 0xf1ea5eed, x.b = x.c = x.d = (seed & 0xFFFFFFFF) >>> 0;

		// if (x === RNGState[0]) {
		// 	console.log("raninit", seed);
		// 	logRNG();
		// }
    for (i=0; i<20; ++i) {
			ranval(x);
			// if (x === RNGState[0]) {
			// 	logRNG();
			// }
    }
}

function logRNG() {
	const r = RNGState[0];

	console.log("RNG = ", r.a, r.b, r.c, r.d);
}


/* ----------------------------------------------------------------------
 range

 returns a number between 0 and N-1
 without any bias.

 */

const RAND_MAX_COMBO = 4294967295; // Number.MAX_SAFE_INTEGER; // ((unsigned long) UINT32_MAX)
const INT_MAX = 4294967295; // Number.MAX_SAFE_INTEGER;

function range(n, RNG) {
	let div;
	let r;
	const rng = RNGState[RNG];

	div = (RAND_MAX_COMBO/n) >>> 0;

	do {
		// r = ranval(rng) % n;
		r = (ranval(rng) / div) >>> 0;
	} while (r >= n);

	return r;
}

// Get a random int between lowerBound and upperBound, inclusive, with uniform probability distribution

// #ifdef AUDIT_RNG // debug version
// int rand_range(int lowerBound, int upperBound) {
// 	int retval;
// 	char RNGMessage[100];
//
//     brogueAssert(lowerBound <= INT_MAX && upperBound <= INT_MAX);
//
// 	if (upperBound <= lowerBound) {
// 		return lowerBound;
// 	}
// 	retval = lowerBound + range(upperBound-lowerBound+1, rogue.RNG);
// 	if (rogue.RNG == RNG_SUBSTANTIVE) {
// 		randomNumbersGenerated++;
// 		if (1) { //randomNumbersGenerated >= 1128397) {
// 			sprintf(RNGMessage, "\n#%lu, %i to %i: %i", randomNumbersGenerated, lowerBound, upperBound, retval);
// 			RNGLog(RNGMessage);
// 		}
// 	}
// 	return retval;
// }
// #else // normal version
function rand_range(lowerBound, upperBound) {
  brogueAssert(lowerBound <= INT_MAX && upperBound <= INT_MAX);
	if (upperBound <= lowerBound) {
		return lowerBound;
	}
	if (rogue.RNG == RNG_SUBSTANTIVE) {
		randomNumbersGenerated++;
	}
	return lowerBound + range(upperBound-lowerBound+1, rogue.RNG);
}
// #endif


function cosmetic_range(lowerBound, upperBound) {
  brogueAssert(lowerBound <= INT_MAX && upperBound <= INT_MAX);
	if (upperBound <= lowerBound) {
		return lowerBound;
	}
	return lowerBound + range(upperBound-lowerBound+1, RNG_COSMETIC);
}


// seeds with the time if called with a parameter of 0; returns the seed regardless.
// All RNGs are seeded simultaneously and identically.
function seedRandomGenerator(seed) {
	if (!seed) {
		seed = Date.now() - 1352700000;
	}
	seed = seed % RAND_MAX_COMBO;

	raninit(RNGState[RNG_SUBSTANTIVE], seed);
	raninit(RNGState[RNG_COSMETIC], seed);
	return seed;
}

seedRandomGenerator();
/*
 *  Grid
 *  Brogue
 *
 *  Created by Brian Walker on 12/7/12.
 *  Copyright 2012. All rights reserved.
 *
 *  This file is part of Brogue.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

// #include "Rogue.h"
// #include "IncludeGlobals.h"


const GRID_CACHE = [];




// mallocing two-dimensional arrays! dun dun DUN!
function allocGrid() {

	if (GRID_CACHE.length) return GRID_CACHE.pop();

	// return GRID(DCOLS, DROWS, () => 0);

	let grid = [];
	for( let i = 0; i < DCOLS; ++i) {
		grid[i] = new Array(DROWS).fill(0); // new Uint16Array(DROWS);	// 16 b/c we assign Unicode chars and value of 30000
	}
	return grid;

}

function freeGrid(grid) {
	GRID_CACHE.push(grid);
}

function copyGrid(to, from) {
	let i, j;

	for(i = 0; i < DCOLS; i++) {
		for(j = 0; j < DROWS; j++) {
			to[i][j] = from[i][j];
		}
	}
}

function fillGrid(grid, fillValue) {
	let i, j;

	for(i = 0; i < DCOLS; i++) {
		for(j = 0; j < DROWS; j++) {
			grid[i][j] = fillValue;
		}
	}
}


function dumpGrid(grid) {
	let i, j;

	for(j = 0; j < DROWS; j++) {
		let line = '';
		for(i = 0; i < DCOLS; i++) {
			const v = grid[i][j];
			if (v === false) {
				line += ' ';
			}
			else if (v === true) {
				line += 'T';
			}
			else if (v < 10) {
				line += '' + v;
			}
			else if (v < 36) {
				line += String.fromCharCode( 'a'.charCodeAt(0) + v - 10);
			}
			else if (v < 62) {
				line += String.fromCharCode( 'A'.charCodeAt(0) + v - 10 - 26);
			}
			else {
				line += '#';
			}
		}
		console.log(line);
	}
}

// Highlight the portion indicated by hiliteCharGrid with the hiliteColor at the hiliteStrength -- both latter arguments are optional.
function hiliteGrid(grid, /* color */ hiliteColor, hiliteStrength) {
	let i, j, x, y;
	let hCol;	// color

	// assureCosmeticRNG();

	if (hiliteColor) {
		hCol = hiliteColor.clone();
	} else {
		hCol = yellow.clone();
	}

	bakeColor(hCol);

	if (!hiliteStrength) {
		hiliteStrength = 75;
	}

	for (i=0; i<DCOLS; i++) {
		for (j=0; j<DROWS; j++) {
			if (grid[i][j]) {
				x = mapToWindowX(i);
				y = mapToWindowY(j);

				displayBuffer[x][y].needsUpdate = true;
				displayBuffer[x][y].backColorComponents[0] = clamp(displayBuffer[x][y].backColorComponents[0] + hCol.red * hiliteStrength / 100, 0, 100);
				displayBuffer[x][y].backColorComponents[1] = clamp(displayBuffer[x][y].backColorComponents[1] + hCol.green * hiliteStrength / 100, 0, 100);
				displayBuffer[x][y].backColorComponents[2] = clamp(displayBuffer[x][y].backColorComponents[2] + hCol.blue * hiliteStrength / 100, 0, 100);
				displayBuffer[x][y].foreColorComponents[0] = clamp(displayBuffer[x][y].foreColorComponents[0] + hCol.red * hiliteStrength / 100, 0, 100);
				displayBuffer[x][y].foreColorComponents[1] = clamp(displayBuffer[x][y].foreColorComponents[1] + hCol.green * hiliteStrength / 100, 0, 100);
				displayBuffer[x][y].foreColorComponents[2] = clamp(displayBuffer[x][y].foreColorComponents[2] + hCol.blue * hiliteStrength / 100, 0, 100);
			}
		}
	}
	// restoreRNG();
}

function findReplaceGrid(grid, findValueMin, findValueMax, fillValue) {
	let i, j;

	for(i = 0; i < DCOLS; i++) {
		for(j = 0; j < DROWS; j++) {
            if (grid[i][j] >= findValueMin && grid[i][j] <= findValueMax) {
                grid[i][j] = fillValue;
            }
		}
	}
}

// Flood-fills the grid from (x, y) along cells that are within the eligible range.
// Returns the total count of filled cells.
function floodFillGrid(grid, x, y, eligibleValueMin, eligibleValueMax, fillValue) {
  let dir;
	let newX, newY, fillCount = 1;

  brogueAssert(fillValue < eligibleValueMin || fillValue > eligibleValueMax);

  grid[x][y] = fillValue;
  for (dir = 0; dir < 4; dir++) {
      newX = x + nbDirs[dir][0];
      newY = y + nbDirs[dir][1];
      if (coordinatesAreInMap(newX, newY)
          && grid[newX][newY] >= eligibleValueMin
          && grid[newX][newY] <= eligibleValueMax)
			{
          fillCount += floodFillGrid(grid, newX, newY, eligibleValueMin, eligibleValueMax, fillValue);
      }
  }
  return fillCount;
}

function drawRectangleOnGrid(grid, x, y, width, height, value) {
    let i, j;

    for (i=x; i < x+width; i++) {
        for (j=y; j<y+height; j++) {
            grid[i][j] = value;
        }
    }
}


function drawCircleOnGrid(grid, x, y, radius, value) {
    let i, j;

    for (i=max(0, x - radius - 1); i < max(DCOLS, x + radius); i++) {
        for (j=max(0, y - radius - 1); j < max(DROWS, y + radius); j++) {
            if ((i-x)*(i-x) + (j-y)*(j-y) < radius * radius + radius) {
                grid[i][j] = value;
            }
        }
    }
}

function intersectGrids(onto, from) {
  let i, j;
	for(i = 0; i < DCOLS; i++) {
		for(j = 0; j < DROWS; j++) {
            if (onto[i][j] && from[i][j]) {
                onto[i][j] = true;
            } else {
                onto[i][j] = false;
            }
        }
    }
}

function uniteGrids(onto, from) {
  let i, j;
	for(i = 0; i < DCOLS; i++) {
		for(j = 0; j < DROWS; j++) {
            if (!onto[i][j] && from[i][j]) {
                onto[i][j] = from[i][j];
            }
        }
    }
}

function invertGrid(grid) {
  let i, j;
	for(i = 0; i < DCOLS; i++) {
		for(j = 0; j < DROWS; j++) {
            grid[i][j] = !grid[i][j];
        }
    }
}

// Fills grid locations with the given value if they match any terrain flags or map flags.
// Otherwise does not change the grid location.
function getTerrainGrid(grid, value, terrainFlags, mapFlags) {
  let i, j;
	for(i = 0; i < DCOLS; i++) {
		for(j = 0; j < DROWS; j++) {
            if (grid[i][j] != value && cellHasTerrainFlag(i, j, terrainFlags) || (pmap[i][j].flags & mapFlags)) {
                grid[i][j] = value;
            }
        }
    }
}

function getTMGrid(grid, value, TMflags) {
  let i, j;
	for(i = 0; i < DCOLS; i++) {
		for(j = 0; j < DROWS; j++) {
            if (grid[i][j] != value && cellHasTMFlag(i, j, TMflags)) {
                grid[i][j] = value;
            }
        }
    }
}

function getPassableArcGrid(grid, minPassableArc, maxPassableArc, value) {
  let i, j, count;
	for(i = 0; i < DCOLS; i++) {
		for(j = 0; j < DROWS; j++) {
            if (grid[i][j] != value) {
                count = passableArcCount(i, j);
                if (count >= minPassableArc && count <= maxPassableArc) {
                    grid[i][j] = value;
                }
            }
        }
    }
}

function validLocationCount(grid, validValue) {
  let i, j, count;
  count = 0;
	for(i = 0; i < DCOLS; i++) {
		for(j = 0; j < DROWS; j++) {
            if (grid[i][j] == validValue) {
                count++;
            }
        }
    }
    return count;
}

function leastPositiveValueInGrid(grid) {
  let i, j, leastPositiveValue = 0;
	for(i = 0; i < DCOLS; i++) {
		for(j = 0; j < DROWS; j++) {
            if (grid[i][j] > 0 && (leastPositiveValue == 0 || grid[i][j] < leastPositiveValue)) {
                leastPositiveValue = grid[i][j];
            }
        }
    }
    return leastPositiveValue;
}

// Takes a grid as a mask of valid locations, chooses one randomly and returns it as (x, y).
// If there are no valid locations, returns (-1, -1).
function randomLocationInGrid(grid, validValue) {
  const locationCount = validLocationCount(grid, validValue);
  let i, j;

  if (locationCount <= 0) {
      return [-1, -1];
  }
  let index = rand_range(0, locationCount - 1);
	for(i = 0; i < DCOLS && index >= 0; i++) {
		for(j = 0; j < DROWS && index >= 0; j++) {
            if (grid[i][j] == validValue) {
                if (index == 0) {
                    return [i, j];
                }
                index--;
            }
        }
    }
    return [-1,-1];
}

// Finds the lowest positive number in a grid, chooses one location with that number randomly and returns it as (x, y).
// If there are no valid locations, returns (-1, -1).
function randomLeastPositiveLocationInGrid(grid, deterministic) {
  const targetValue = leastPositiveValueInGrid(grid);
  let locationCount;
  let i, j, index;

  if (targetValue == 0) {
		return [-1,-1];
  }

  locationCount = 0;
	for(i = 0; i < DCOLS; i++) {
		for(j = 0; j < DROWS; j++) {
            if (grid[i][j] == targetValue) {
                locationCount++;
            }
        }
    }

    if (deterministic) {
        index = Math.floor(locationCount / 2);
    } else {
        index = rand_range(0, locationCount - 1);
    }

	for(i = 0; i < DCOLS && index >= 0; i++) {
		for(j = 0; j < DROWS && index >= 0; j++) {
            if (grid[i][j] == targetValue) {
                if (index == 0) {
									return [i,j];
                }
                index--;
            }
        }
    }
		return [-1,-1];
}

function getQualifyingPathLocNear(/* short *retValX, short *retValY, */
                                 x, y,
                                 hallwaysAllowed,
                                 blockingTerrainFlags,
                                 blockingMapFlags,
                                 forbiddenTerrainFlags,
                                 forbiddenMapFlags,
                                 deterministic)
{
    let grid, costMap;
    let loc;

    // First check the given location to see if it works, as an optimization.
    if (!cellHasTerrainFlag(x, y, blockingTerrainFlags | forbiddenTerrainFlags)
        && !(pmap[x][y].flags & (blockingMapFlags | forbiddenMapFlags))
        && (hallwaysAllowed || passableArcCount(x, y) <= 1))
		{
			return [ x, y ];
    }

    // Allocate the grids.
    grid = allocGrid();
    costMap = allocGrid();

    // Start with a base of a high number everywhere.
    fillGrid(grid, 30000);
    fillGrid(costMap, 1);

    // Block off the pathing blockers.
    getTerrainGrid(costMap, PDS_FORBIDDEN, blockingTerrainFlags, blockingMapFlags);
    if (blockingTerrainFlags & (T_OBSTRUCTS_DIAGONAL_MOVEMENT | T_OBSTRUCTS_PASSABILITY)) {
        getTerrainGrid(costMap, PDS_OBSTRUCTION, T_OBSTRUCTS_DIAGONAL_MOVEMENT, 0);
    }

    // Run the distance scan.
    grid[x][y] = 1;
    costMap[x][y] = 1;
    dijkstraScan(grid, costMap, true);
    findReplaceGrid(grid, 30000, 30000, 0);

    // Block off invalid targets that aren't pathing blockers.
    getTerrainGrid(grid, 0, forbiddenTerrainFlags, forbiddenMapFlags);
    if (!hallwaysAllowed) {
        getPassableArcGrid(grid, 2, 10, 0);
    }

    // Get the solution.
    loc = randomLeastPositiveLocationInGrid(grid, deterministic);

//    dumpLevelToScreen();
//    displayGrid(grid);
//    if (coordinatesAreInMap(*retValX, *retValY)) {
//        hiliteCell(*retValX, *retValY, &yellow, 100, true);
//    }
//    temporaryMessage("Qualifying path selected:", true);

    freeGrid(grid);
    freeGrid(costMap);

    // Fall back to a pathing-agnostic alternative if there are no solutions.
    if (loc[0] == -1 && loc[1] == -1) {
				// look for secondary solution
        return getQualifyingLocNear(x, y, hallwaysAllowed, NULL,
                                 (blockingTerrainFlags | forbiddenTerrainFlags),
                                 (blockingMapFlags | forbiddenMapFlags),
                                 false, deterministic);
    } else {
        return loc; // Found a primary solution.
    }
}

function cellularAutomataRound(grid, birthParameters /* char[9] */, survivalParameters /* char[9] */) {
    let i, j, nbCount, newX, newY;
    let dir;
    let buffer2;

    buffer2 = allocGrid();
    copyGrid(buffer2, grid); // Make a backup of grid in buffer2, so that each generation is isolated.

    for(i=0; i<DCOLS; i++) {
        for(j=0; j<DROWS; j++) {
            nbCount = 0;
            for (dir=0; dir< DIRECTION_COUNT; dir++) {
                newX = i + nbDirs[dir][0];
                newY = j + nbDirs[dir][1];
                if (coordinatesAreInMap(newX, newY)
                    && buffer2[newX][newY])
								{
                    nbCount++;
                }
            }
            if (!buffer2[i][j] && birthParameters[nbCount] == 't') {
                grid[i][j] = 1;	// birth
            } else if (buffer2[i][j] && survivalParameters[nbCount] == 't') {
                // survival
            } else {
                grid[i][j] = 0;	// death
            }
        }
    }

    freeGrid(buffer2);
}

// Marks a cell as being a member of blobNumber, then recursively iterates through the rest of the blob
function fillContiguousRegion(grid, x, y, fillValue) {
  let dir;
	let newX, newY, numberOfCells = 1;

	grid[x][y] = fillValue;

	// Iterate through the four cardinal neighbors.
	for (dir=0; dir<4; dir++) {
		newX = x + nbDirs[dir][0];
		newY = y + nbDirs[dir][1];
		if (!coordinatesAreInMap(newX, newY)) {
			break;
		}
		if (grid[newX][newY] == 1) { // If the neighbor is an unmarked region cell,
			numberOfCells += fillContiguousRegion(grid, newX, newY, fillValue); // then recurse.
		}
	}
	return numberOfCells;
}

// Loads up **grid with the results of a cellular automata simulation.
function createBlobOnGrid(grid,
                      /* short *retMinX, short *retMinY, short *retWidth, short *retHeight, */
                      roundCount,
                      minBlobWidth, minBlobHeight,
					  maxBlobWidth, maxBlobHeight, percentSeeded,
					  birthParameters /* char[9] */, survivalParameters /* char[9] */)
{
	let i, j, k;
	let blobNumber, blobSize, topBlobNumber, topBlobSize;

  let topBlobMinX, topBlobMinY, topBlobMaxX, topBlobMaxY, blobWidth, blobHeight;
	//short buffer2[maxBlobWidth][maxBlobHeight]; // buffer[][] is already a global short array
	let foundACellThisLine;

	// Generate blobs until they satisfy the minBlobWidth and minBlobHeight restraints
	do {
		// Clear buffer.
    fillGrid(grid, 0);

		// Fill relevant portion with noise based on the percentSeeded argument.
		for(i=0; i<maxBlobWidth; i++) {
			for(j=0; j<maxBlobHeight; j++) {
				grid[i][j] = (rand_percent(percentSeeded) ? 1 : 0);
			}
		}

//        colorOverDungeon(&darkGray);
//        hiliteGrid(grid, &white, 100);
//        temporaryMessage("Random starting noise:", true);

		// Some iterations of cellular automata
		for (k=0; k<roundCount; k++) {
			cellularAutomataRound(grid, birthParameters, survivalParameters);

//            colorOverDungeon(&darkGray);
//            hiliteGrid(grid, &white, 100);
//            temporaryMessage("Cellular automata progress:", true);
		}

//        colorOverDungeon(&darkGray);
//        hiliteGrid(grid, &white, 100);
//        temporaryMessage("Cellular automata result:", true);

		// Now to measure the result. These are best-of variables; start them out at worst-case values.
		topBlobSize =   0;
		topBlobNumber = 0;
		topBlobMinX =   maxBlobWidth;
		topBlobMaxX =   0;
		topBlobMinY =   maxBlobHeight;
		topBlobMaxY =   0;

		// Fill each blob with its own number, starting with 2 (since 1 means floor), and keeping track of the biggest:
		blobNumber = 2;

		for(i=0; i<DCOLS; i++) {
			for(j=0; j<DROWS; j++) {
				if (grid[i][j] == 1) { // an unmarked blob
					// Mark all the cells and returns the total size:
					blobSize = fillContiguousRegion(grid, i, j, blobNumber);
					if (blobSize > topBlobSize) { // if this blob is a new record
						topBlobSize = blobSize;
						topBlobNumber = blobNumber;
					}
					blobNumber++;
				}
			}
		}

		// Figure out the top blob's height and width:
		// First find the max & min x:
		for(i=0; i<DCOLS; i++) {
			foundACellThisLine = false;
			for(j=0; j<DROWS; j++) {
				if (grid[i][j] == topBlobNumber) {
					foundACellThisLine = true;
					break;
				}
			}
			if (foundACellThisLine) {
				if (i < topBlobMinX) {
					topBlobMinX = i;
				}
				if (i > topBlobMaxX) {
					topBlobMaxX = i;
				}
			}
		}

		// Then the max & min y:
		for(j=0; j<DROWS; j++) {
			foundACellThisLine = false;
			for(i=0; i<DCOLS; i++) {
				if (grid[i][j] == topBlobNumber) {
					foundACellThisLine = true;
					break;
				}
			}
			if (foundACellThisLine) {
				if (j < topBlobMinY) {
					topBlobMinY = j;
				}
				if (j > topBlobMaxY) {
					topBlobMaxY = j;
				}
			}
		}

		blobWidth =		(topBlobMaxX - topBlobMinX) + 1;
		blobHeight =	(topBlobMaxY - topBlobMinY) + 1;

	} while (blobWidth < minBlobWidth
             || blobHeight < minBlobHeight
             || topBlobNumber == 0);

	// Replace the winning blob with 1's, and everything else with 0's:
    for(i=0; i<DCOLS; i++) {
        for(j=0; j<DROWS; j++) {
			if (grid[i][j] == topBlobNumber) {
				grid[i][j] = 1;
			} else {
				grid[i][j] = 0;
			}
		}
	}

    // Populate the returned variables.
	return { x: topBlobMinX, y: topBlobMinY, width: blobWidth, height: blobHeight };
}


var SCREEN = null;


function fillBg(css) {
    SCREEN.ctx.fillStyle = css || '#000';
    SCREEN.ctx.fillRect(
        0,
        0,
        SCREEN.canvas.width,
        SCREEN.canvas.height
    );
}


function plotChar(char, x, y, fr, fg, fb, br, bg, bb) {
  fr = Math.floor(fr * 2.55);
  fg = Math.floor(fg * 2.55);
  fb = Math.floor(fb * 2.55);
  br = Math.floor(br * 2.55);
  bg = Math.floor(bg * 2.55);
  bb = Math.floor(bb * 2.55);

  const backCss = `#${br.toString(16).padStart(2,'0')}${bg.toString(16).padStart(2,'0')}${bb.toString(16).padStart(2,'0')}`;

  const ctx = SCREEN.ctx;
  const tileSize = SCREEN.tileSize * SCREEN.devicePixelRatio;

  ctx.fillStyle = backCss;
  ctx.fillRect(
    x * tileSize,
    y * tileSize,
    tileSize,
    tileSize
  );

  if (char && char !== ' ') {
    const foreCss = `#${fr.toString(16).padStart(2,'0')}${fg.toString(16).padStart(2,'0')}${fb.toString(16).padStart(2,'0')}`;
    const textX = x * tileSize + tileSize * 0.5;  // TODO - offsetX
    const textY = y * tileSize + tileSize * 0.5;  // TODO - offsetY
    ctx.fillStyle = foreCss;

    ctx.fillText(
      char,
      textX,
      textY
    );
  }

}


function setFont(size, name) {
  SCREEN.font = name || SCREEN.font || 'monospace';
  SCREEN.ctx.font = (size * SCREEN.devicePixelRatio) + 'px ' + SCREEN.font;
  SCREEN.ctx.textAlign = 'center';
  SCREEN.ctx.textBaseline = 'middle';
}

var EVENTS_QUEUE = [];

async function handleEvents(handler) {
  let resolveFn = null;

  _pushHandler( (theEvent) => {
    handler(theEvent, (result) => {
      _popHandler();
      resolveFn(result);
    });
  });

  return new Promise( (resolve, reject) => {
    resolveFn = resolve;
  });
}

function _pushHandler(handler) {
  SCREEN.handlerStack.push(this.inputHandler);
  SCREEN.inputHandler = handler;
}

function _popHandler(theEvent) {
  SCREEN.inputHandler = SCREEN.handlerStack.pop() || handleSilentEvent;
  if (theEvent) {
    SCREEN.inputHandler(theEvent);
  }
}

function handleSilentEvent(theEvent) {
  if (EVENTS_QUEUE.length) {
    const lastEvent = EVENTS_QUEUE[EVENTS_QUEUE.length - 1];
    if (lastEvent.eventType === MOUSE_ENTERED_CELL) {
      lastEvent.copy(theEvent);
      return;
    }
  }
  EVENTS_QUEUE.push(theEvent);
}

function animationTimer(t) {
  requestAnimationFrame(animationTimer);

  if (SCREEN) {
    let i, j;

  	for (i=0; i<COLS; i++) {
  		for (j=0; j<ROWS; j++) {
  			if (displayBuffer[i][j].needsUpdate) {
  				plotChar(displayBuffer[i][j].char, i, j,
  						 displayBuffer[i][j].foreColorComponents[0],
  						 displayBuffer[i][j].foreColorComponents[1],
  						 displayBuffer[i][j].foreColorComponents[2],
  						 displayBuffer[i][j].backColorComponents[0],
  						 displayBuffer[i][j].backColorComponents[1],
  						 displayBuffer[i][j].backColorComponents[2]);
  				displayBuffer[i][j].needsUpdate = false;
  			}
  		}
  	}
  }
}


function handleKeyDownEvent(event) {
  let key = event.key;
  if(['Ctrl', 'Alt', 'Meta', 'Shift'].includes(key)) {
      key = event.code;
  }
  else {
    if (event.shiftKey) {
      key = key.toUpperCase();
    }
    if (event.metaKey) {
      key = '#' + key;
    }
    if (event.ctrlKey) {
      key = '^' + key;
    }
  }

  if (event.key === 'Escape' && EVENTS_QUEUE.length) {
    EVENTS_QUEUE.length = 0;
    console.log('Cleared Events queue.');
  }

  const theEvent = rogueEvent(KEYSTROKE, key, null, event.ctrlKey, event.shiftKey);
  theEvent.time = performance.now();
  if (SCREEN) {
    SCREEN.ctrlKey = event.ctrlKey;
    SCREEN.metaKey = event.metaKey;
    SCREEN.shiftKey = event.shiftKey;
    SCREEN.inputHandler(theEvent);
  }
  else {
    console.log('keypress', key);
  }
  event.preventDefault();
  return false;
}

function handleKeyUpEvent(event) {
  if (SCREEN) {
    SCREEN.ctrlKey = event.ctrlKey;
    SCREEN.metaKey = event.metaKey;
    SCREEN.shiftKey = event.shiftKey;
  }
  event.preventDefault();
}


function handleMouseEvent(e) {
  if (!SCREEN) {
    console.log(e.type, e.clientX, e.clientY);
    return;
  }

  let mouseX = Math.floor(e.clientX / SCREEN.mouseWidth);
  let mouseY = Math.floor(e.clientY / SCREEN.mouseHeight);

  if (e.type === 'mouseleave') {
    x = null;
    y = null;
  }

  const time = performance.now();

  if(e.type === 'click'){
    let theEvent = rogueEvent(MOUSE_DOWN, mouseX, mouseY);
    theEvent.time = time;
    SCREEN.inputHandler(theEvent);
    theEvent = rogueEvent(MOUSE_UP, mouseX, mouseY);
    theEvent.time = time;
    SCREEN.inputHandler(theEvent);
  }
  else {
    let theEvent = rogueEvent(MOUSE_ENTERED_CELL, mouseX, mouseY);
    theEvent.time = time;
    SCREEN.inputHandler(theEvent);
  }
}

function handleResizeEvent() {

  SCREEN.tileSize = Math.min(Math.floor(window.innerWidth / COLS), Math.floor(window.innerHeight / ROWS));
  const rect = SCREEN.canvas.getBoundingClientRect();
  SCREEN.mouseWidth = rect.width / COLS;
  SCREEN.mouseHeight = rect.height / ROWS;

  console.log('resize', window.innerWidth, window.innerHeight, SCREEN.tileSize, SCREEN.mouseWidth, SCREEN.mouseHeight);

  let width = COLS * SCREEN.tileSize;
  let height = ROWS * SCREEN.tileSize;

  const devicePixelRatio = window.devicePixelRatio || 1;
  if (devicePixelRatio !== 1) {
      SCREEN.canvas.style.width = width + 'px';
      SCREEN.canvas.style.height = height + 'px';

      width = Math.floor(width * devicePixelRatio);
      height = Math.floor(height * devicePixelRatio);
  }

  SCREEN.devicePixelRatio = devicePixelRatio;
  SCREEN.canvas.width = width;
  SCREEN.canvas.height = height;

  setFont(SCREEN.tileSize, SCREEN.font);
  fillBg('#000');

  for (let i=0; i<COLS; i++) {
		for (let j=0; j<ROWS; j++) {
			displayBuffer[i][j].needsUpdate = true;
    }
  }

}


async function pauseForMilliseconds( milliseconds, wantMouseMoves ) {

  while (EVENTS_QUEUE.length) {
    if (wantMouseMoves || (EVENTS_QUEUE[0].eventType != MOUSE_ENTERED_CELL) ) {
		    return true;  // interrupted
    }
    EVENTS_QUEUE.shift();
	}

	let resolveFn = null;
	let timeout = null;
	let interrupted = false;

	function complete() {
		_popHandler();
		if (interrupted) {
			clearTimeout(timeout);
		}
		resolveFn(interrupted || false);
	}

	timeout = setTimeout( complete, milliseconds );

	handleEvents( (e) => {
		if (e.eventType !== UPDATE && (wantMouseMoves || (e.eventType !== MOUSE_ENTERED_CELL)) ) {
			interrupted = true;
      EVENTS_QUEUE.push(e.clone()); // save the event
			complete();
		}
	});

	const p = new Promise( (resolve) => {
		resolveFn = resolve;
	});

	await p;

	return interrupted;
}


async function nextKeyOrMouseEvent(returnEvent, textInput, colorsDance) {

	let finished = false;

	if (EVENTS_QUEUE.length) {
		const e = EVENTS_QUEUE.shift();
		returnEvent.copy(e);
		return;
	}

	await handleEvents( (theEvent, done) => {
		if (theEvent.eventType === UPDATE) {
			if (colorsDance) {
				shuffleTerrainColors(3, true);
			}
			return;
		}

		if (finished) {
			// console.log('I need to queue this one!', theEvent.eventType);
			if (EVENTS_QUEUE.length) {
				const e = EVENTS_QUEUE[EVENTS_QUEUE.length - 1];	// last one
				if (e.eventType === theEvent.eventType && theEvent.eventType === MOUSE_ENTERED_CELL) {
					e.copy(theEvent);
					return;
				}
			}
			EVENTS_QUEUE.push(theEvent.clone());
			return;
		}
		// console.log('nextKeyOrMouseEvent', theEvent.eventType);
		finished = true;
		returnEvent.copy(theEvent);
		done();
	});

}

function controlKeyIsDown() {
  return SCREEN && SCREEN.ctrlKey;
}

var HIGH_SCORE_LIST = [];

function getHighScoresList( returnList /* rogueHighScoresEntry[HIGH_SCORES_COUNT] */) {
	let i, mostRecentLineNumber = 0;

  returnList.forEach( (e) => e.clear() );

  HIGH_SCORE_LIST.forEach( (e, i) => {
    if (i < returnList.length) {
      returnList[i].copy(e);
    }
  });

	return 0; // ??? mostRecentLineNumber;
}

function saveHighScore(entry) {
  const copy = Object.assign({}, entry);
  HIGH_SCORE_LIST.push(copy);
  HIGH_SCORE_LIST.sort((a, b) => b.score - a.score);
  return HIGH_SCORE_LIST.length;
}


function notifyEvent(/* short */ eventId, /* int */ data1, /* int */ data2, str1, str2) {
	// TODO - ????
}


async function launch() {

  document.addEventListener('keydown', handleKeyDownEvent);
  document.addEventListener('keyup', handleKeyUpEvent);
  window.addEventListener('resize', handleResizeEvent);

  const canvas = document.getElementById('game');
  canvas.addEventListener('mousemove', handleMouseEvent);
  canvas.addEventListener('mouseenter', handleMouseEvent);
  canvas.addEventListener('mouseleave', handleMouseEvent);
  canvas.addEventListener('click', handleMouseEvent);

  SCREEN = {
    canvas,
    tileSize: 16,
    ctrlKey: false,
    shiftKey: false,
    metaKey: false,
    ctx: canvas.getContext('2d'),
    inputHandler: handleSilentEvent,
    handlerStack: [],
    font: 'monospace',
    devicePixelRatio: window.devicePixelRatio
  }

  handleResizeEvent();
  requestAnimationFrame( animationTimer );

  await mainBrogueJunction();
}



window.onload = function() {
  // RL.Game.start(gameConfig);
  setTimeout( launch, 0 );
};




class BrogueString {
	constructor(value) {
  	this.text = value || '';
    this._textLength = -1;
  }

  get fullLength() { return this.text.length; }

  get length() {
    throw new Error('Convert to fullLength or textLength');
  }

  get textLength() {
    if (this._textLength > -1) return this._textLength;

		let length = 0;

  	for(let i = 0; i < this.text.length; ++i) {
    	const ch = this.text.charCodeAt(i);
      if (ch === COLOR_ESCAPE) {
          i += 3;	// skip color parts
      }
      else if (ch === COLOR_END) {
      		// skip
      }
      else {
      	++length;
      }
    }

		this._textLength = length;
    return this._textLength;
  }

  eachChar(callback) {
  	let color = null;
    const components = [100, 100, 100];
    let index = 0;

  	for(let i = 0; i < this.text.length; ++i) {
    	const ch = this.text.charCodeAt(i);
      if (ch === COLOR_ESCAPE) {
          components[0] = this.text.charCodeAt(i + 1) - COLOR_VALUE_INTERCEPT;
          components[1] = this.text.charCodeAt(i + 2) - COLOR_VALUE_INTERCEPT;
          components[2] = this.text.charCodeAt(i + 3) - COLOR_VALUE_INTERCEPT;
          color = colorFromComponents(components);
          i += 3;
      }
      else if (ch === COLOR_END) {
      	color = null;
      }
      else {
      	callback(this.text[i], color, index);
      	++index;
      }
    }

  }

  encodeColor(color, i) {
    let colorText;
  	if (!color) {
    	colorText = String.fromCharCode(COLOR_END);
    }
    else {
	  	colorText = String.fromCharCode(COLOR_ESCAPE, color.red + COLOR_VALUE_INTERCEPT, color.green + COLOR_VALUE_INTERCEPT, color.blue + COLOR_VALUE_INTERCEPT);
    }
    if (i == 0) {
      this.text = colorText;
    }
    else if (i < this.text.length) {
      this.splice(i, 4, colorText);
    }
    else {
      this.text += colorText;
    }
    return this;
  }

  setText(value) {
  	if (value instanceof BrogueString) {
    	this.text = value.text;
      this._textLength = value._textLength;
      return this;
    }

		this.text = value;
    this._textLength = -1;
    return this;
  }

  append(value) {
  	if (value instanceof BrogueString) {
    	this.text += value.text;
      this._textLength += value._textLength;
      return this;
    }

		this.text += value;
    this._textLength = -1;
    return this;
  }

	clear() {
  	this.text = '';
    this._textLength = 0;
    return this;
  }

  capitalize() {
  	if (!this.text.length) return;

    let index = 0;
    let ch = this.text.charCodeAt(index);
    while (ch === COLOR_ESCAPE) {
    	index += 4;
      ch = this.text.charCodeAt(index);
    }

		const preText = index ? this.text.substring(0, index) : '';
    this.text = preText + this.text[index].toUpperCase() + this.text.substring(index + 1);
		return this;
  }

	padStart(finalLength) {
		const diff = (finalLength - this.textLength);
		if (diff <= 0) return this;
		this.text = this.text.padStart(diff + this.text.length, ' ');
		this._textLength += diff;
		return this;
	}

	padEnd(finalLength) {
		const diff = (finalLength - this.textLength);
		if (diff <= 0) return this;
		this.text = this.text.padEnd(diff + this.text.length, ' ');
		this._textLength += diff;
		return this;
	}

	toString() {
		return this.text;
	}

	charAt(index) {
		return this.text.charAt(index);
	}

	charCodeAt(index) {
		return this.text.charCodeAt(index);
	}

	copy(other) {
		this.text = other.text;
		this._textLength = other._textLength;
		return this;
	}

	splice(begin, length, add) {
  	const preText = this.text.substring(0, begin);
    const postText = this.text.substring(begin + length);
		add = (add && add.text) ? add.text : (add || '');

    this.text = preText + add + postText;
    this._textLength = -1;
  }

  toString() {
    return this.text;
  }

}


// return a new string object
function STRING(text) {
	if (text instanceof BrogueString) return text;
	return new BrogueString(text);
}

function strlen(bstring) {
  if (!bstring) return 0;
  if (typeof bstring === 'string') return bstring.length;
	return bstring.fullLength;
}

function strcat(bstring, txt) {
	bstring.append(txt);
}

function strncat(bstring, txt, n) {
	txt = STRING(txt);
	bstring.append(txt.text.substring(0, n));
}

function sprintf(bstring, fmt, ...args) {

  const map = FORMAT_MAP;

  var replacer = function replacer(match, group1, group2, index) {
    // if (message.charAt(index - 1) == "%") {
    //   return match.substring(1);
    // }

    if (!args.length) {
      return match;
    }

    var obj = args[0];
    var group = group1 || group2;
    var parts = group.split(",");
    var name = parts.shift() || "";
    var method = map[name];

    if (!method) {
      // TODO - Need to check less than full length...
      // for instance %lucky should check:
      // lucky -> luck -> luc -> lu -> l -> FAIL
      return match;
    }

    let result;
    obj = args.shift();
    if (typeof method === 'function') {
      result = method(obj, ...parts);
    }
    else {
      result = '' + obj;
    }

    return result;
  };

  const txt = fmt.replace(/%(?:([\w]+)|(?:{([^}]+)}))/g, replacer);

  bstring.setText(txt);
}



FORMAT_MAP = {};

FORMAT_MAP['s'] = function(value) { return '' + value; }

FORMAT_MAP['i'] = function(value) {
  if (typeof value === 'number') return '' + Math.round(value);
  return '?';
}

FORMAT_MAP['d']  = FORMAT_MAP['i'];
FORMAT_MAP['li'] = FORMAT_MAP['i'];
FORMAT_MAP['lu'] = FORMAT_MAP['i'];
FORMAT_MAP['l']  = FORMAT_MAP['i'];
FORMAT_MAP['u']  = FORMAT_MAP['i'];
FORMAT_MAP['c']  = function(value) {
  if (!value) return '?';
  if (typeof value === 'number') { value = '' + number; }
  if (typeof value === 'string') { return value.length ? value[0] : '?'; }
  if (value.toString) {
    return value.toString()[0];
  }
  return '?';
}

FORMAT_MAP['f'] = function(value, decimals) {
  if (typeof value === 'number') {
    console.log('format float', value, decimals);
    if (decimals === undefined) {
      return '' + value;
    }

    return value.toFixed(decimals);
  }
  return '?';
}



function strncat(bstring, n, txt) {
	if (n !== bstring.fullLength) throw new Error('Rewrite this using strcat.');
  bstring.append(txt);
}

function strcpy(bstring, txt) {
	bstring.setText(txt);
}

function strcmp(a, b) {
	a = STRING(a);
	b = STRING(b);

	if (a.text == b.text) return 0;
	return (a.text < b.text) ? -1 : 1;
}


// function eachChar(bstring, callback) {
// 	bstring = STRING(bstring);
// 	return bstring.eachChar(callback);
// }
/*
 *  PowerTables.c
 *  Brogue
 *
 *  Created by Brian Walker on 4/9/17.
 *  Copyright 2017. All rights reserved.
 *
 *  This file is part of Brogue.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

// #include "Rogue.h"

// As of v1.7.5, Brogue does not use floating-point math in any calculations
// that have an effect on substantive gameplay. The two operations that were
// annoying to convert were sqrt() (handled by an open source fixed point sqrt
// implementation in Sqrt.c) and especially pow(). I could not find a fixed point
// pow implementation that was good enough for the wide range of fractional bases
// and exponents. Fortunately, all uses of pow() involved a fixed base and an exponent
// that varied by increments of at least 0.25 (or really 0.1 for armor calculations but
// I fudged that), or a fixed exponent and base that varied similarly. The one exception
// were runic weapon activation chances, which modified the base by the damage of the weapon
// and varied the exponent by the level, but I moved the damage modification into the exponent
// without much affecting the results. So now pow() has been replaced by lookup tables.
// Hopefully this will help with out of sync errors for saved games and recordings...

// game data formulae:

function wandDominate(/* creature */ monst)	{
  if (monst.currentHP * 5 < monst.info.maxHP) {
    return 100;
  }
  else {
    return max(0, 100 * Math.floor((monst.info.maxHP - monst.currentHP) / monst.info.maxHP));
  }
}

// All "enchant" parameters must already be multiplied by FP_FACTOR:
function fp_staffDamageLow(enchant)            {return Math.floor((3 * (2 + (enchant)) / 4 >> FP_BASE));}
function fp_staffDamageHigh(enchant)           {return Math.floor((4 + (5 * (enchant) / 2) >> FP_BASE));}
function fp_staffDamage(enchant)               {return Math.floor(randClumpedRange(fp_staffDamageLow(enchant), fp_staffDamageHigh(enchant), 1 + (enchant) / 3));}
function fp_staffBlinkDistance(enchant)		     {return Math.floor((((enchant) * 2 >> FP_BASE) + 2));}
function fp_staffHasteDuration(enchant)        {return Math.floor((2 + (enchant) * 4 >> FP_BASE));}
function fp_staffBladeCount(enchant)           {return Math.floor(((enchant) * 3 / 2 >> FP_BASE));}
function fp_staffDiscordDuration(enchant)		   {return Math.floor(((enchant) * 4 >> FP_BASE));}
function fp_staffEntrancementDuration(enchant) {return Math.floor(((enchant) * 3 >> FP_BASE));}


const POW_STAFF_PROTECTION = [
    // 1.53^x << FP_BASE, with x from 0 to 50 in increments of 1:
    65536, 100270, 153413, 234722, 359125, 549461, 840675, 1286233, 1967937, 3010944, 4606745, 7048320, 10783931, 16499414, 25244104, 38623479, 59093923,
    90413702, 138332964, 211649436, 323823637, 495450165, 758038753, 1159799292, 1774492917, 2714974163, 4153910470, 6355483019, 9723889019, 14877550199,
    22762651805, 34826857262, 53285091611, 81526190166, 124735070954, 190844658559, 291992327596, 446748261222, 683524839670, 1045793004696, 1600063297185,
    2448096844694, 3745588172382, 5730749903744, 8768047352729, 13415112449676, 20525122048004, 31403436733446, 48047258202173, 73512305049325, 112473826725468];


function fp_staffProtection(enchant) {
    return Number(BigInt(50 * POW_STAFF_PROTECTION[(enchant >> FP_BASE) - 2]) >> BIG_BASE);
}

const POW_POISON = [
    // 1.3^x << FP_BASE, with x from 0 to 50 in increments of 1:
    65536, 85196, 110755, 143982, 187177, 243330, 316329, 411228, 534597, 694976, 903469, 1174510, 1526863, 1984922, 2580398, 3354518, 4360874, 5669136, 7369877,
    9580840, 12455093, 16191620, 21049107, 27363839, 35572991, 46244888, 60118355, 78153861, 101600020, 132080026, 171704034, 223215244, 290179818, 377233763,
    490403892, 637525060, 828782579, 1077417352, 1400642558, 1820835326, 2367085924, 3077211701, 4000375211, 5200487775, 6760634107, 8788824340, 11425471642,
    14853113134, 19309047075, 25101761197, 32632289557];


function fp_staffPoison(enchant) {
    enchant = (enchant >> FP_BASE) - 2;
    return Number(BigInt(5 * POW_POISON[enchant]) >> BIG_BASE);
}

const POW_WISDOM = [
    // 1.3^x << FP_BASE, with x from -10 to 30 in increments of 1:
    4753, 6180, 8034, 10444, 13577, 17650, 22945, 29829, 38778, 50412, 65536, 85196, 110755, 143982, 187177, 243330, 316329, 411228, 534597, 694976, 903469,
    1174510, 1526863, 1984922, 2580398, 3354518, 4360874, 5669136, 7369877, 9580840, 12455093, 16191620, 21049107, 27363839, 35572991, 46244888, 60118355,
    78153861, 101600020, 132080026, 171704034];

function fp_ringWisdomMultiplier( enchant) {
    enchant = min(27, enchant >> FP_BASE) + 10;
    return Number(BigInt(10 * POW_WISDOM[enchant]) >> BIG_BASE);
}

function fp_charmHealing(enchant)              {return Math.floor(clamp(20 * (enchant) >> FP_BASE, 0, 100));}
function fp_charmShattering(enchant)           {return Math.floor((4 + (enchant) >> FP_BASE));}
function fp_charmGuardianLifespan(enchant)     {return Math.floor((4 + 2 * (enchant) >> FP_BASE));}
function fp_charmNegationRadius(enchant)       {return Math.floor((1 + 3 * (enchant) >> FP_BASE));}

const POW_CHARM_PROTECTION = [
    // 1.35^x << FP_BASE, with x from 0 to 50 in increments of 1:
    65536, 88473, 119439, 161243, 217678, 293865, 396718, 535570, 723019, 976076, 1317703, 1778899, 2401514, 3242044, 4376759, 5908625, 7976644, 10768469,
    14537434, 19625536, 26494473, 35767539, 48286178, 65186341, 88001560, 118802106, 160382844, 216516839, 292297733, 394601940, 532712620, 719162037, 970868750,
    1310672812, 1769408297, 2388701201, 3224746621, 4353407939, 5877100717, 7934085969, 10711016058, 14459871678, 19520826766, 26353116134, 35576706781,
    48028554155, 64838548109, 87532039948, 118168253930, 159527142806, 215361642788];


function fp_charmProtection(enchant) {
    enchant = (enchant >> FP_BASE);
    return Number(BigInt(150 * POW_CHARM_PROTECTION[enchant]) >> BIG_BASE);
}

function fp_weaponParalysisDuration(enchant)   {return (max(2, Math.floor(2 + ((enchant) / 2 >> FP_BASE))));}
function fp_weaponConfusionDuration(enchant)   {return (max(3, Math.floor((enchant) * 3/2 >> FP_BASE)));}
function fp_weaponForceDistance(enchant)       {return (max(4, Math.floor(((enchant) * 2 >> FP_BASE) + 2)));} // Depends on definition of staffBlinkDistance() above.
function fp_weaponSlowDuration(enchant)		     {return (max(3, Math.floor((((enchant) >> FP_BASE) + 2) * ((enchant) + (2 << FP_BASE))) / 3 >> FP_BASE));}
function fp_weaponImageCount(enchant)			     {return (clamp(Math.floor((enchant) / 3 >> FP_BASE), 1, 7));}
function fp_weaponImageDuration(enchant)       {return 3;}

function fp_armorReprisalPercent(enchant)		   {return (max(5, Math.floor((enchant) * 5 >> FP_BASE)));}
function fp_armorAbsorptionMax(enchant)		     {return (max(1, Math.floor((enchant) >> FP_BASE)));}
function fp_armorImageCount(enchant)           {return (clamp(Math.floor((enchant) / 3 >> FP_BASE), 1, 5));}

const POW_REFLECT = [
    // 0.85^x << FP_BASE, with x from 1 to 50 in increments of 0.25:
    62926, 60421, 58015, 55705, 53487, 51358, 49313, 47349, 45464, 43654, 41916, 40247, 38644, 37106, 35628, 34210, 32848, 31540, 30284, 29078, 27920,
    26809, 25741, 24716, 23732, 22787, 21880, 21009, 20172, 19369, 18598, 17857, 17146, 16464, 15808, 15179, 14574, 13994, 13437, 12902, 12388, 11895, 11421,
    10967, 10530, 10111, 9708, 9321, 8950, 8594, 8252, 7923, 7608, 7305, 7014, 6735, 6466, 6209, 5962, 5724, 5496, 5278, 5067, 4866, 4672, 4486, 4307, 4136,
    3971, 3813, 3661, 3515, 3375, 3241, 3112, 2988, 2869, 2755, 2645, 2540, 2439, 2341, 2248, 2159, 2073, 1990, 1911, 1835, 1762, 1692, 1624, 1559, 1497, 1438,
    1380, 1325, 1273, 1222, 1173, 1127, 1082, 1039, 997, 958, 919, 883, 848, 814, 781, 750, 720, 692, 664, 638, 612, 588, 564, 542, 520, 500, 480, 461, 442,
    425, 408, 391, 376, 361, 346, 333, 319, 307, 294, 283, 271, 261, 250, 240, 231, 221, 213, 204, 196, 188, 181, 173, 166, 160, 153, 147, 141, 136, 130, 125,
    120, 115, 111, 106, 102, 98, 94, 90, 87, 83, 80, 77, 74, 71, 68, 65, 62, 60, 58, 55, 53, 51, 49, 47, 45, 43, 41, 40, 38, 37, 35, 34, 32, 31, 30, 29, 27,
    26, 25, 24, 23, 22, 21, 21, 20, 19];


function fp_reflectionChance(enchant) {
    enchant = enchant * 4 >> FP_BASE;
    return clamp(100 - Number(BigInt(100 * POW_REFLECT[enchant - 1]) >> BIG_BASE), 1, 100);
}

const POW_REGEN = [
    // 0.75^x << FP_BASE, with x from -10 to 50 in increments of 1:
    1163770, 872827, 654620, 490965, 368224, 276168, 207126, 155344, 116508, 87381, 65536, 49152, 36864, 27648, 20736, 15552, 11664, 8748, 6561, 4920, 3690,
    2767, 2075, 1556, 1167, 875, 656, 492, 369, 277, 207, 155, 116, 87, 65, 49, 36, 27, 20, 15, 11, 8, 6, 4, 3, 2, 2, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];

function fp_turnsForFullRegenInThousandths(bonus) {
    // This will max out at full regeneration in about two turns.
    // This is the Syd nerf, after Syd broke the game over his knee with a +18 ring of regeneration.
    bonus = (bonus >> FP_BASE) + 10;
    bonus = clamp(bonus, -10, 50);
    return Number(BigInt(1000 * TURNS_FOR_FULL_REGEN * POW_REGEN[bonus]) >> BIG_BASE) + 2000;
}

const POW_DAMAGE_FRACTION = [
    // 1.065^x << FP_BASE, with x representing a change in 0.25 weapon enchantment points, ranging from -20 to 50.
    18598, 18894, 19193, 19498, 19807, 20122, 20441, 20765, 21095, 21430, 21770, 22115, 22466, 22823, 23185, 23553, 23926, 24306, 24692, 25084, 25482, 25886,
    26297, 26714, 27138, 27569, 28006, 28451, 28902, 29361, 29827, 30300, 30781, 31269, 31765, 32269, 32781, 33302, 33830, 34367, 34912, 35466, 36029, 36601,
    37182, 37772, 38371, 38980, 39598, 40227, 40865, 41514, 42172, 42842, 43521, 44212, 44914, 45626, 46350, 47086, 47833, 48592, 49363, 50146, 50942, 51751,
    52572, 53406, 54253, 55114, 55989, 56877, 57780, 58697, 59628, 60574, 61536, 62512, 63504, 64512, 65536, 66575, 67632, 68705, 69795, 70903, 72028, 73171,
    74332, 75512, 76710, 77927, 79164, 80420, 81696, 82992, 84309, 85647, 87006, 88387, 89789, 91214, 92662, 94132, 95626, 97143, 98685, 100251, 101842, 103458,
    105099, 106767, 108461, 110182, 111931, 113707, 115511, 117344, 119206, 121098, 123020, 124972, 126955, 128969, 131016, 133095, 135207, 137352, 139532,
    141746, 143995, 146280, 148602, 150960, 153355, 155789, 158261, 160772, 163323, 165915, 168548, 171222, 173939, 176699, 179503, 182352, 185245, 188185,
    191171, 194205, 197286, 200417, 203597, 206828, 210110, 213444, 216831, 220272, 223767, 227318, 230925, 234589, 238312, 242094, 245935, 249838, 253802,
    257830, 261921, 266077, 270300, 274589, 278946, 283372, 287869, 292437, 297078, 301792, 306581, 311445, 316388, 321408, 326508, 331689, 336953, 342300,
    347731, 353249, 358855, 364549, 370334, 376211, 382180, 388245, 394406, 400664, 407022, 413481, 420042, 426707, 433479, 440357, 447345, 454443, 461655,
    468980, 476422, 483982, 491662, 499464, 507390, 515441, 523620, 531929, 540370, 548945, 557656, 566505, 575494, 584626, 593903, 603328, 612901, 622627,
    632507, 642544, 652740, 663098, 673620, 684309, 695168, 706199, 717406, 728790, 740354, 752102, 764037, 776161, 788477, 800989, 813699, 826611, 839728,
    853053, 866590, 880341, 894311, 908502, 922918, 937563, 952441, 967555, 982908, 998505, 1014350, 1030446, 1046797, 1063408, 1080282, 1097425, 1114839,
    1132529, 1150501, 1168757, 1187303, 1206144, 1225283, 1244726, 1264478, 1284543, 1304927, 1325634, 1346669, 1368039, 1389747, 1411800, 1434203, 1456961,
    1480081, 1503567, 1527426];


function fp_damageFraction(netEnchant) {
    netEnchant = clamp(netEnchant, -20 << FP_BASE, 50 << FP_BASE);
    const index = ((netEnchant + (20 << FP_BASE)) * 4) >> FP_BASE;
    return POW_DAMAGE_FRACTION[index];
}

const POW_ACCURACY_FRACTION = [
    // 1.065^x << FP_BASE, with x representing a change in 0.25 weapon enchantment points (as displayed), ranging from -20 to 50.
    18598, 18894, 19193, 19498, 19807, 20122, 20441, 20765, 21095, 21430, 21770, 22115, 22466, 22823, 23185, 23553, 23926, 24306, 24692, 25084, 25482, 25886,
    26297, 26714, 27138, 27569, 28006, 28451, 28902, 29361, 29827, 30300, 30781, 31269, 31765, 32269, 32781, 33302, 33830, 34367, 34912, 35466, 36029, 36601,
    37182, 37772, 38371, 38980, 39598, 40227, 40865, 41514, 42172, 42842, 43521, 44212, 44914, 45626, 46350, 47086, 47833, 48592, 49363, 50146, 50942, 51751,
    52572, 53406, 54253, 55114, 55989, 56877, 57780, 58697, 59628, 60574, 61536, 62512, 63504, 64512, 65536, 66575, 67632, 68705, 69795, 70903, 72028, 73171,
    74332, 75512, 76710, 77927, 79164, 80420, 81696, 82992, 84309, 85647, 87006, 88387, 89789, 91214, 92662, 94132, 95626, 97143, 98685, 100251, 101842, 103458,
    105099, 106767, 108461, 110182, 111931, 113707, 115511, 117344, 119206, 121098, 123020, 124972, 126955, 128969, 131016, 133095, 135207, 137352, 139532,
    141746, 143995, 146280, 148602, 150960, 153355, 155789, 158261, 160772, 163323, 165915, 168548, 171222, 173939, 176699, 179503, 182352, 185245, 188185,
    191171, 194205, 197286, 200417, 203597, 206828, 210110, 213444, 216831, 220272, 223767, 227318, 230925, 234589, 238312, 242094, 245935, 249838, 253802,
    257830, 261921, 266077, 270300, 274589, 278946, 283372, 287869, 292437, 297078, 301792, 306581, 311445, 316388, 321408, 326508, 331689, 336953, 342300,
    347731, 353249, 358855, 364549, 370334, 376211, 382180, 388245, 394406, 400664, 407022, 413481, 420042, 426707, 433479, 440357, 447345, 454443, 461655,
    468980, 476422, 483982, 491662, 499464, 507390, 515441, 523620, 531929, 540370, 548945, 557656, 566505, 575494, 584626, 593903, 603328, 612901, 622627,
    632507, 642544, 652740, 663098, 673620, 684309, 695168, 706199, 717406, 728790, 740354, 752102, 764037, 776161, 788477, 800989, 813699, 826611, 839728,
    853053, 866590, 880341, 894311, 908502, 922918, 937563, 952441, 967555, 982908, 998505, 1014350, 1030446, 1046797, 1063408, 1080282, 1097425, 1114839,
    1132529, 1150501, 1168757, 1187303, 1206144, 1225283, 1244726, 1264478, 1284543, 1304927, 1325634, 1346669, 1368039, 1389747, 1411800, 1434203, 1456961,
    1480081, 1503567, 1527426];

function fp_accuracyFraction(netEnchant) {
    netEnchant = clamp(netEnchant, -20 << FP_BASE, 50 << FP_BASE);
    const index = ((netEnchant + (20 << FP_BASE)) * 4) >> FP_BASE;
    return POW_ACCURACY_FRACTION[index];
}

const POW_DEFENSE_FRACTION = [
    // 0.9678^x << FP_BASE, with x representing a change in 0.25 armor points (as displayed), ranging from -20 to 50.
    897530, 868644, 840688, 813632, 787446, 762103, 737575, 713837, 690863, 668629, 647110, 626283, 606127, 586619, 567740, 549468,
    531784, 514669, 498105, 482074, 466559, 451543, 437011, 422946, 409334, 396160, 383410, 371071, 359128, 347570, 336384, 325558,
    315080, 304940, 295125, 285627, 276435, 267538, 258927, 250594, 242529, 234724, 227169, 219858, 212782, 205934, 199306, 192892,
    186684, 180676, 174861, 169233, 163786, 158515, 153414, 148476, 143698, 139073, 134597, 130265, 126073, 122015, 118088, 114288,
    110609, 107050, 103604, 100270, 97043, 93920, 90897, 87971, 85140, 82400, 79748, 77181, 74697, 72293, 69967, 67715, 65536, 63426,
    61385, 59409, 57497, 55647, 53856, 52123, 50445, 48822, 47250, 45730, 44258, 42833, 41455, 40121, 38829, 37580, 36370, 35200, 34067,
    32970, 31909, 30882, 29888, 28926, 27995, 27094, 26222, 25378, 24562, 23771, 23006, 22266, 21549, 20855, 20184, 19535, 18906, 18297,
    17709, 17139, 16587, 16053, 15536, 15036, 14552, 14084, 13631, 13192, 12768, 12357, 11959, 11574, 11201, 10841, 10492, 10154, 9828,
    9511, 9205, 8909, 8622, 8345, 8076, 7816, 7565, 7321, 7085, 6857, 6637, 6423, 6216, 6016, 5823, 5635, 5454, 5278, 5108, 4944, 4785,
    4631, 4482, 4337, 4198, 4063, 3932, 3805, 3683, 3564, 3450, 3339, 3231, 3127, 3026, 2929, 2835, 2744, 2655, 2570, 2487, 2407, 2329,
    2255, 2182, 2112, 2044, 1978, 1914, 1853, 1793, 1735, 1679, 1625, 1573, 1522, 1473, 1426, 1380, 1336, 1293, 1251, 1211, 1172, 1134,
    1097, 1062, 1028, 995, 963, 932, 902, 873, 845, 817, 791, 766, 741, 717, 694, 672, 650, 629, 609, 589, 570, 552, 534, 517, 500, 484,
    469, 453, 439, 425, 411, 398, 385, 373, 361, 349, 338, 327, 316, 306, 296, 287, 277, 268, 260, 251, 243, 235, 228, 221, 213, 207,
    200, 193, 187, 181, 175, 170, 164, 159, 154, 149, 144, 139, 135, 130, 126, 122, 118, 114, 111, 107, 104, 100, 97, 94];


function fp_defenseFraction(netDefense) {
    let tableIndex;
    netDefense = clamp(Math.floor((netDefense << FP_BASE) / 10), -20 << FP_BASE, 50 << FP_BASE);
    tableIndex = ((netDefense + (20 << FP_BASE)) * 4) >> FP_BASE;
    tableIndex = clamp(tableIndex, 0, (20+50)*4);
    return POW_DEFENSE_FRACTION[tableIndex];
}

const POW_0_CHARM_INCREMENT = new Array(50).fill(0);  // [50] = {0};
const POW_120_CHARM_INCREMENT = [ // 1.20^x << FP_BASE, with x from 1 to 50 in increments of 1:
    78643, 94371, 113246, 135895, 163074, 195689, 234827, 281792, 338151, 405781, 486937, 584325, 701190, 841428, 1009714, 1211657,
    1453988, 1744786, 2093744, 2512492, 3014991, 3617989, 4341587, 5209905, 6251886, 7502263, 9002716, 10803259, 12963911, 15556694,
    18668032, 22401639, 26881967, 32258360, 38710033, 46452039, 55742447, 66890937, 80269124, 96322949, 115587539, 138705047, 166446056,
    199735268, 239682321, 287618785, 345142543, 414171051, 497005262, 596406314, 715687577];
const POW_125_CHARM_INCREMENT = [ // 1.25^x << FP_BASE, with x from 1 to 50 in increments of 1:
    81920, 102400, 128000, 160000, 200000, 250000, 312500, 390625, 488281, 610351, 762939, 953674, 1192092, 1490116, 1862645, 2328306,
    2910383, 3637978, 4547473, 5684341, 7105427, 8881784, 11102230, 13877787, 17347234, 21684043, 27105054, 33881317, 42351647, 52939559,
    66174449, 82718061, 103397576, 129246970, 161558713, 201948391, 252435489, 315544362, 394430452, 493038065, 616297582, 770371977,
    962964972, 1203706215, 1504632769, 1880790961, 2350988701, 2938735877, 3673419846, 4591774807, 5739718509];
const CHARM_EFFECT_DURATION = [
    3,  // Health
    20, // Protection
    7,  // Haste
    10, // Fire immunity
    5,  // Invisibility
    25, // Telepathy
    10, // Levitation
    0,  // Shattering
    18, // Guardian
    0,  // Teleportation
    0,  // Recharging
    0,  // Negation
];
const CHARM_EFFECT_INCREMENT = [
    POW_0_CHARM_INCREMENT,      // Health
    POW_0_CHARM_INCREMENT,      // Protection
    POW_120_CHARM_INCREMENT,    // Haste
    POW_125_CHARM_INCREMENT,    // Fire immunity
    POW_120_CHARM_INCREMENT,    // Invisibility
    POW_125_CHARM_INCREMENT,    // Telepathy
    POW_125_CHARM_INCREMENT,    // Levitation
    POW_0_CHARM_INCREMENT,      // Shattering
    POW_0_CHARM_INCREMENT,      // Guardian
    POW_0_CHARM_INCREMENT,      // Teleportation
    POW_0_CHARM_INCREMENT,      // Recharging
    POW_0_CHARM_INCREMENT,      // Negation
];

function charmEffectDuration(charmKind, enchant) {
    enchant = clamp(enchant, 1, 50) - 1;
    return Number(BigInt(CHARM_EFFECT_DURATION[charmKind] * CHARM_EFFECT_INCREMENT[charmKind][enchant]) >> BIG_BASE);
}

const POW_30_CHARM_DECREMENT = [ // 0.7^x << FP_BASE, with x from 1 to 50 in increments of 1:
    45875, 32112, 22478, 15735, 11014, 7710, 5397, 3778, 2644, 1851, 1295, 907, 634, 444, 311, 217, 152, 106, 74, 52, 36, 25,
    17, 12, 8, 6, 4, 3, 2, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
const POW_35_CHARM_DECREMENT = [ // 0.65^x << FP_BASE, with x from 1 to 50 in increments of 1:
    42598, 27688, 17997, 11698, 7604, 4942, 3212, 2088, 1357, 882, 573, 372, 242, 157, 102, 66, 43, 28, 18, 11, 7, 5, 3, 2, 1,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
const POW_40_CHARM_DECREMENT = [ // 0.60^x << FP_BASE, with x from 1 to 50 in increments of 1:
    39321, 23592, 14155, 8493, 5096, 3057, 1834, 1100, 660, 396, 237, 142, 85, 51, 30, 18, 11, 6, 3, 2, 1, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
const POW_45_CHARM_DECREMENT = [ // 0.55^x << FP_BASE, with x from 1 to 50 in increments of 1:
    36044, 19824, 10903, 5996, 3298, 1814, 997, 548, 301, 165, 91, 50, 27, 15, 8, 4, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];

const CHARM_RECHARGE_DURATION = [
    2500,   // Health
    1000,   // Protection
    800,    // Haste
    800,    // Fire immunity
    800,    // Invisibility
    800,    // Telepathy
    800,    // Levitation
    2500,   // Shattering
    700,    // Guardian
    1000,   // Teleportation
    10000,  // Recharging
    2500,   // Negation
];
const CHARM_RECHARGE_INCREMENT = [
    POW_45_CHARM_DECREMENT, // Health
    POW_40_CHARM_DECREMENT, // Protection
    POW_35_CHARM_DECREMENT, // Haste
    POW_40_CHARM_DECREMENT, // Fire immunity
    POW_35_CHARM_DECREMENT, // Invisibility
    POW_35_CHARM_DECREMENT, // Telepathy
    POW_35_CHARM_DECREMENT, // Levitation
    POW_40_CHARM_DECREMENT, // Shattering
    POW_30_CHARM_DECREMENT, // Guardian
    POW_45_CHARM_DECREMENT, // Teleportation
    POW_45_CHARM_DECREMENT, // Recharging
    POW_40_CHARM_DECREMENT, // Negation
];


function charmRechargeDelay(charmKind, enchant) {
    enchant = clamp(enchant, 1, 50) - 1;
    const delay = charmEffectDuration(charmKind, enchant) + Number(BigInt(CHARM_RECHARGE_DURATION[charmKind] * CHARM_RECHARGE_INCREMENT[charmKind][enchant]) >> BIG_BASE);
    return max(1, delay);
}


const POW_16_RUNIC_DECREMENT = [ // (1-0.16)^x << FP_BASE, with x from 0 to 50 in increments of 0.25:
    65536, 62740, 60064, 57502, 55050, 52702, 50454, 48302, 46242, 44269, 42381, 40574, 38843, 37186, 35600, 34082, 32628, 31236, 29904,
    28629, 27407, 26238, 25119, 24048, 23022, 22040, 21100, 20200, 19339, 18514, 17724, 16968, 16244, 15551, 14888, 14253, 13645, 13063,
    12506, 11972, 11462, 10973, 10505, 10057, 9628, 9217, 8824, 8448, 8087, 7742, 7412, 7096, 6793, 6503, 6226, 5961, 5706, 5463, 5230,
    5007, 4793, 4589, 4393, 4206, 4026, 3854, 3690, 3533, 3382, 3238, 3100, 2967, 2841, 2720, 2604, 2492, 2386, 2284, 2187, 2094, 2004,
    1919, 1837, 1759, 1684, 1612, 1543, 1477, 1414, 1354, 1296, 1241, 1188, 1137, 1089, 1042, 998, 955, 914, 875, 838, 802, 768, 735,
    704, 674, 645, 617, 591, 566, 542, 519, 496, 475, 455, 436, 417, 399, 382, 366, 350, 335, 321, 307, 294, 281, 269, 258, 247, 236,
    226, 217, 207, 198, 190, 182, 174, 167, 159, 153, 146, 140, 134, 128, 123, 117, 112, 108, 103, 99, 94, 90, 86, 83, 79, 76, 73, 69,
    66, 64, 61, 58, 56, 53, 51, 49, 47, 45, 43, 41, 39, 37, 36, 34, 33, 31, 30, 29, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 18, 17, 16,
    15, 15, 14, 13, 13, 12, 12, 11, 11, 10];
const POW_15_RUNIC_DECREMENT = [ // (1-0.15)^x << FP_BASE, with x from 0 to 50 in increments of 0.25:
    65536, 62926, 60421, 58015, 55705, 53487, 51358, 49313, 47349, 45464, 43654, 41916, 40247, 38644, 37106, 35628, 34210, 32848, 31540,
    30284, 29078, 27920, 26809, 25741, 24716, 23732, 22787, 21880, 21009, 20172, 19369, 18598, 17857, 17146, 16464, 15808, 15179, 14574,
    13994, 13437, 12902, 12388, 11895, 11421, 10967, 10530, 10111, 9708, 9321, 8950, 8594, 8252, 7923, 7608, 7305, 7014, 6735, 6466, 6209,
    5962, 5724, 5496, 5278, 5067, 4866, 4672, 4486, 4307, 4136, 3971, 3813, 3661, 3515, 3375, 3241, 3112, 2988, 2869, 2755, 2645, 2540,
    2439, 2341, 2248, 2159, 2073, 1990, 1911, 1835, 1762, 1692, 1624, 1559, 1497, 1438, 1380, 1325, 1273, 1222, 1173, 1127, 1082, 1039,
    997, 958, 919, 883, 848, 814, 781, 750, 720, 692, 664, 638, 612, 588, 564, 542, 520, 500, 480, 461, 442, 425, 408, 391, 376, 361, 346,
    333, 319, 307, 294, 283, 271, 261, 250, 240, 231, 221, 213, 204, 196, 188, 181, 173, 166, 160, 153, 147, 141, 136, 130, 125, 120, 115,
    111, 106, 102, 98, 94, 90, 87, 83, 80, 77, 74, 71, 68, 65, 62, 60, 58, 55, 53, 51, 49, 47, 45, 43, 41, 40, 38, 37, 35, 34, 32, 31, 30,
    29, 27, 26, 25, 24, 23, 22, 21, 21, 20, 19];
const POW_14_RUNIC_DECREMENT = [ // (1-0.14)^x << FP_BASE, with x from 0 to 50 in increments of 0.25:
    65536, 63110, 60775, 58526, 56360, 54275, 52267, 50332, 48470, 46676, 44949, 43286, 41684, 40142, 38656, 37226, 35848, 34522, 33244,
    32014, 30829, 29689, 28590, 27532, 26513, 25532, 24587, 23677, 22801, 21958, 21145, 20363, 19609, 18883, 18185, 17512, 16864, 16240,
    15639, 15060, 14503, 13966, 13449, 12952, 12472, 12011, 11566, 11138, 10726, 10329, 9947, 9579, 9224, 8883, 8554, 8238, 7933, 7639,
    7357, 7084, 6822, 6570, 6327, 6092, 5867, 5650, 5441, 5239, 5046, 4859, 4679, 4506, 4339, 4179, 4024, 3875, 3732, 3593, 3460, 3332,
    3209, 3090, 2976, 2866, 2760, 2658, 2559, 2465, 2373, 2285, 2201, 2119, 2041, 1965, 1893, 1823, 1755, 1690, 1628, 1567, 1509, 1454,
    1400, 1348, 1298, 1250, 1204, 1159, 1116, 1075, 1035, 997, 960, 924, 890, 857, 825, 795, 765, 737, 710, 684, 658, 634, 610, 588, 566,
    545, 525, 505, 487, 469, 451, 435, 418, 403, 388, 374, 360, 346, 334, 321, 309, 298, 287, 276, 266, 256, 247, 237, 229, 220, 212, 204,
    197, 189, 182, 176, 169, 163, 157, 151, 145, 140, 135, 130, 125, 120, 116, 111, 107, 103, 99, 96, 92, 89, 85, 82, 79, 76, 73, 71, 68,
    66, 63, 61, 58, 56, 54, 52, 50, 48, 47, 45, 43, 42, 40, 38, 37, 36, 34];
const POW_11_RUNIC_DECREMENT = [ // (1-0.11)^x << FP_BASE, with x from 0 to 50 in increments of 0.25:
    65536, 63654, 61826, 60051, 58327, 56652, 55025, 53445, 51911, 50420, 48972, 47566, 46200, 44874, 43585, 42334, 41118, 39938, 38791,
    37677, 36595, 35544, 34524, 33533, 32570, 31634, 30726, 29844, 28987, 28155, 27346, 26561, 25798, 25058, 24338, 23639, 22960, 22301,
    21661, 21039, 20435, 19848, 19278, 18725, 18187, 17665, 17157, 16665, 16186, 15721, 15270, 14832, 14406, 13992, 13590, 13200, 12821,
    12453, 12095, 11748, 11411, 11083, 10765, 10456, 10155, 9864, 9581, 9305, 9038, 8779, 8527, 8282, 8044, 7813, 7589, 7371, 7159, 6954,
    6754, 6560, 6372, 6189, 6011, 5838, 5671, 5508, 5350, 5196, 5047, 4902, 4761, 4624, 4492, 4363, 4237, 4116, 3997, 3883, 3771, 3663,
    3558, 3456, 3356, 3260, 3166, 3075, 2987, 2901, 2818, 2737, 2658, 2582, 2508, 2436, 2366, 2298, 2232, 2168, 2106, 2045, 1986, 1929,
    1874, 1820, 1768, 1717, 1668, 1620, 1573, 1528, 1484, 1442, 1400, 1360, 1321, 1283, 1246, 1210, 1176, 1142, 1109, 1077, 1046, 1016,
    987, 959, 931, 904, 878, 853, 829, 805, 782, 759, 737, 716, 696, 676, 656, 637, 619, 601, 584, 567, 551, 535, 520, 505, 490, 476, 462,
    449, 436, 424, 412, 400, 388, 377, 366, 356, 345, 336, 326, 317, 307, 299, 290, 282, 274, 266, 258, 251, 243, 236, 230, 223, 217, 210,
    204, 198, 193];
const POW_7_RUNIC_DECREMENT = [ // (1-0.07)^x << FP_BASE, with x from 0 to 50 in increments of 0.25:
    65536, 64357, 63200, 62064, 60948, 59852, 58776, 57719, 56682, 55662, 54662, 53679, 52714, 51766, 50835, 49921, 49024, 48142, 47277,
    46427, 45592, 44772, 43967, 43177, 42401, 41638, 40890, 40155, 39433, 38724, 38027, 37344, 36672, 36013, 35365, 34730, 34105, 33492,
    32890, 32298, 31718, 31147, 30587, 30038, 29497, 28967, 28446, 27935, 27433, 26939, 26455, 25979, 25512, 25054, 24603, 24161, 23726,
    23300, 22881, 22470, 22066, 21669, 21279, 20897, 20521, 20152, 19790, 19434, 19084, 18741, 18404, 18073, 17748, 17429, 17116, 16808,
    16506, 16209, 15918, 15632, 15351, 15075, 14804, 14537, 14276, 14019, 13767, 13520, 13277, 13038, 12804, 12573, 12347, 12125, 11907,
    11693, 11483, 11276, 11074, 10875, 10679, 10487, 10299, 10113, 9931, 9753, 9578, 9405, 9236, 9070, 8907, 8747, 8590, 8435, 8284, 8135,
    7988, 7845, 7704, 7565, 7429, 7296, 7164, 7036, 6909, 6785, 6663, 6543, 6425, 6310, 6196, 6085, 5976, 5868, 5763, 5659, 5557, 5457,
    5359, 5263, 5168, 5075, 4984, 4894, 4806, 4720, 4635, 4552, 4470, 4390, 4311, 4233, 4157, 4082, 4009, 3937, 3866, 3796, 3728, 3661,
    3595, 3531, 3467, 3405, 3344, 3283, 3224, 3166, 3110, 3054, 2999, 2945, 2892, 2840, 2789, 2739, 2689, 2641, 2594, 2547, 2501, 2456,
    2412, 2369, 2326, 2284, 2243, 2203, 2163, 2124, 2086, 2048, 2012, 1975, 1940, 1905, 1871, 1837, 1804, 1772, 1740];
const POW_6_RUNIC_DECREMENT = [ // (1-0.06)^x << FP_BASE, with x from 0 to 50 in increments of 0.25:
    65536, 64530, 63539, 62564, 61603, 60658, 59727, 58810, 57907, 57018, 56143, 55281, 54433, 53597, 52774, 51964, 51167, 50381, 49608,
    48846, 48097, 47358, 46631, 45916, 45211, 44517, 43833, 43161, 42498, 41846, 41203, 40571, 39948, 39335, 38731, 38137, 37551, 36975,
    36407, 35848, 35298, 34756, 34223, 33698, 33180, 32671, 32169, 31676, 31189, 30711, 30239, 29775, 29318, 28868, 28425, 27989, 27559,
    27136, 26719, 26309, 25905, 25508, 25116, 24731, 24351, 23977, 23609, 23247, 22890, 22539, 22193, 21852, 21516, 21186, 20861, 20541,
    20225, 19915, 19609, 19308, 19012, 18720, 18433, 18150, 17871, 17597, 17327, 17061, 16799, 16541, 16287, 16037, 15791, 15549, 15310,
    15075, 14843, 14616, 14391, 14170, 13953, 13739, 13528, 13320, 13116, 12914, 12716, 12521, 12329, 12139, 11953, 11770, 11589, 11411,
    11236, 11063, 10894, 10726, 10562, 10400, 10240, 10083, 9928, 9776, 9625, 9478, 9332, 9189, 9048, 8909, 8772, 8638, 8505, 8374, 8246,
    8119, 7995, 7872, 7751, 7632, 7515, 7400, 7286, 7174, 7064, 6956, 6849, 6744, 6640, 6538, 6438, 6339, 6242, 6146, 6052, 5959, 5867,
    5777, 5688, 5601, 5515, 5430, 5347, 5265, 5184, 5105, 5026, 4949, 4873, 4798, 4725, 4652, 4581, 4510, 4441, 4373, 4306, 4240, 4175,
    4111, 4047, 3985, 3924, 3864, 3805, 3746, 3689, 3632, 3576, 3521, 3467, 3414, 3362, 3310, 3259, 3209, 3160, 3111, 3064, 3017, 2970];

const POW_RUNIC_CHANCE = [
    POW_16_RUNIC_DECREMENT,	// W_SPEED
    POW_6_RUNIC_DECREMENT,	// W_QUIETUS
    POW_7_RUNIC_DECREMENT,	// W_PARALYSIS
    POW_15_RUNIC_DECREMENT,	// W_MULTIPLICITY
    POW_14_RUNIC_DECREMENT,	// W_SLOWING
    POW_11_RUNIC_DECREMENT,	// W_CONFUSION
    POW_15_RUNIC_DECREMENT, // W_FORCE
    0,		// W_SLAYING
    0,		// W_MERCY
    0,		// W_PLENTY
];

function runicWeaponChance(/* item */ theItem, customEnchantLevel, enchantLevel) {

    let modifier;
    let runicType = theItem.enchant2;
    let chance, adjustedBaseDamage, tableIndex;

    if (runicType == W_SLAYING) {
        return 0;
    }
    if (runicType >= NUMBER_GOOD_WEAPON_ENCHANT_KINDS) { // bad runic
        return 15;
    }
    if (!customEnchantLevel) {
        enchantLevel = fp_netEnchant(theItem);
    }

    // Innately high-damage weapon types are less likely to trigger runic effects.
    adjustedBaseDamage = (tableForItemCategory(theItem.category, NULL)[theItem.kind].range.lowerBound
                          + Math.floor(tableForItemCategory(theItem.category, NULL)[theItem.kind].range.upperBound) / 2);

    if (theItem.flags & ITEM_ATTACKS_STAGGER) {
        adjustedBaseDamage = Math.floor(adjustedBaseDamage / 2); // Normalize as though they attacked once per turn instead of every other turn.
    }
    //    if (theItem->flags & ITEM_ATTACKS_QUICKLY) {
    //		adjustedBaseDamage *= 2; // Normalize as though they attacked once per turn instead of twice per turn.
    //	} // Testing disabling this for balance reasons...

    modifier = FP_FACTOR - min(Math.floor( (99 << FP_BASE)/100), Math.floor((adjustedBaseDamage << FP_BASE) / 18));
    //	rootChance = rootChance * modifier >> FP_BASE;

    if (enchantLevel < 0) {
        chance = 0;
    } else {
        tableIndex = enchantLevel * modifier * 4 >> FP_BASE >> FP_BASE;
        tableIndex = clamp(tableIndex, 0, 50 * 4);
        chance = 100 - Number(BigInt(100 * POW_RUNIC_CHANCE[runicType][tableIndex]) >> BIG_BASE); // good runic
    }

    // Slow weapons get an adjusted chance of 1 - (1-p)^2 to reflect two bites at the apple instead of one.
    if (theItem.flags & ITEM_ATTACKS_STAGGER) {
        chance = 100 - Math.floor(((100 - chance) * (100 - chance)) / 100);
    }
    // Fast weapons get an adjusted chance of 1 - sqrt(1-p) to reflect one bite at the apple instead of two.
    if (theItem.flags & ITEM_ATTACKS_QUICKLY) {
        chance = 100 * (FP_FACTOR - fp_sqrt(FP_FACTOR - Math.floor((chance << FP_BASE)/100))) >> FP_BASE;
    }

    // The lowest percent change that a weapon will ever have is its enchantment level (if greater than 0).
    // That is so that even really heavy weapons will improve at least 1% per enchantment.
    chance = clamp(chance, max(1, (enchantLevel >> FP_BASE)), 100);

    return Math.floor(chance);
}
/*
 *  Globals.c
 *  Brogue
 *
 *  Created by Brian Walker on 1/10/09.
 *  Copyright 2012. All rights reserved.
 *
 *  This file is part of Brogue.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

// #include "Rogue.h"

function ARRAY(l, fn) {
	fn = fn || (() => 0);
	const arr = new Array(l);
	for( let i = 0; i < l; ++i) {
		arr[i] = fn(i);
	}
	return arr;
}

function GRID(w, h, fn) {
	fn = fn || (() => 0);
	const grid = new Array(w);
	for( let i = 0; i < w; ++i ) {
		const row = new Array(h);
		for( let j = 0; j < h; ++j) {
			row[j] = fn(j, i);
		}
		grid[i] = row;
	}
	return grid;
}


function ERROR(message) {
	throw new Error(message);
}


const tmap = GRID(DCOLS, DROWS, tcell); // tcell [DCOLS][DROWS];						// grids with info about the map
const pmap = GRID(DCOLS, DROWS, pcell); // pcell [DCOLS][DROWS];
var scentMap = null; // short **
const displayBuffer = GRID(COLS, ROWS, cellDisplayBuffer); // cellDisplayBuffer [COLS][ROWS];	// used to optimize plotCharWithColor
const terrainRandomValues = GRID(DCOLS, DROWS, () => []); // short [DCOLS][DROWS][8];
var safetyMap = null; // short **								// used to help monsters flee
var allySafetyMap = null;  // short **							// used to help allies flee
var chokeMap = null;  // short **								// used to assess the importance of the map's various chokepoints
const nbDirs = [[0,-1], [0,1], [-1,0], [1,0], [-1,-1], [-1,1], [1,-1], [1,1]];
const cDirs = [[0, 1], [1, 1], [1, 0], [1, -1], [0, -1], [-1, -1], [-1, 0], [-1, 1]];
var numberOfWaypoints = 0;
var levels = null;	// levelData *
var player = null; // creature();
const rogue = playerCharacter();
var monsters = null;	// creature *
var dormantMonsters = null;	// creature *
var graveyard = null;	// creature *
var purgatory = null;	// creature *
var floorItems = null;	// item *
var packItems = null;	// item *
var monsterItemsHopper = null;	// item *

const displayedMessage = ARRAY(MESSAGE_LINES, () => STRING() ); // char[MESSAGE_LINES][COLS*2];
const messageConfirmed = ARRAY(MESSAGE_LINES, () => false); // boolean[MESSAGE_LINES];
const combatText = STRING(); // char [COLS * 2];
var messageArchivePosition = 0;
const messageArchive = ARRAY(MESSAGE_ARCHIVE_LINES, () => STRING() ); // char [MESSAGE_ARCHIVE_LINES][COLS*2];

const currentFilePath = STRING(); // char[BROGUE_FILENAME_MAX];

const displayDetail = GRID(DCOLS, DROWS, () => 0 );  // char [DCOLS][DROWS];		// used to make certain per-cell data accessible to external code (e.g. terminal adaptations)

// #ifdef AUDIT_RNG
// FILE *RNGLogFile;
// #endif

const inputRecordBuffer = ARRAY(INPUT_RECORD_BUFFER + 100, () => 0); // unsigned char[INPUT_RECORD_BUFFER + 100];
var locationInRecordingBuffer = 0;
var randomNumbersGenerated = 0;
var positionInPlaybackFile = 0;
var lengthOfPlaybackFile = 0;
var recordingLocation = 0;
var maxLevelChanges = 0;
const annotationPathname = STRING(); // char [BROGUE_FILENAME_MAX];	// pathname of annotation file
var previousGameSeed = 0;

// #pragma mark Colors

//									Red		Green	Blue	RedRand	GreenRand	BlueRand	Rand	Dances?
// basic colors

const white =					color(100,	100,	100,	0,		0,			0,			0,		false);
const gray =					 	color(50,	50,		50,		0,		0,			0,			0,		false);
const darkGray =				color(30,	30,		30,		0,		0,			0,			0,		false);
const veryDarkGray =		color(15,	15,		15,		0,		0,			0,			0,		false);
const black =					color(0,		0,		0,		0,		0,			0,			0,		false);
const yellow =				 	color(100,	100,	0,		0,		0,			0,			0,		false);
const darkYellow =			color(50,	50,		0,		0,		0,			0,			0,		false);
const teal =					 	color(30,	100,	100,	0,		0,			0,			0,		false);
const purple =				 	color(100,	0,		100,	0,		0,			0,			0,		false);
const darkPurple =			color(50,	0,		50,		0,		0,			0,			0,		false);
const brown =					color(60,	40,		0,		0,		0,			0,			0,		false);
const green =					color(0,		100,	0,		0,		0,			0,			0,		false);
const darkGreen =			color(0,		50,		0,		0,		0,			0,			0,		false);
const orange =				 	color(100,	50,		0,		0,		0,			0,			0,		false);
const darkOrange =			color(50,	25,		0,		0,		0,			0,			0,		false);
const blue =					 	color(0,		0,		100,	0,		0,			0,			0,		false);
const darkBlue =				color(0,		0,		50,		0,		0,			0,			0,		false);
const darkTurquoise =  color(0,		40,		65,		0,		0,			0,			0,		false);
const lightBlue =			color(40,	40,		100,	0,		0,			0,			0,		false);
const pink =					 	color(100,	60,		66,		0,		0,			0,			0,		false);
const red =					 	color(100,	0,		0,		0,		0,			0,			0,		false);
const darkRed =				color(50,	0,		0,		0,		0,			0,			0,		false);
const tanColor =				color(80,	67,		15,		0,		0,			0,			0,		false);

// bolt colors
const rainbow =								color(-70,	-70,	-70,	170,	170,		170,		0,		true);
const descentBoltColor =     	color(-40,   -40,    -40,    0,      0,          80,         80,     true);
const discordColor =						color(25,	0,		25,		66,		0,			0,			0,		true);
const poisonColor =						color(0,		0,		0,		10,		50,			10,			0,		true);
const beckonColor =						color(10,	10,		10,		5,		5,			5,			50,		true);
const invulnerabilityColor =		color(25,	0,		25,		0,		0,			66,			0,		true);
const dominationColor =				color(0,		0,		100,	80,		25,			0,			0,		true);
const empowermentColor =				color(30,    100,	40,     25,		80,			25,			0,		true);
const fireBoltColor =					color(500,	150,	0,		45,		30,			0,			0,		true);
const yendorLightColor =     	color(50,    -100,    30,     0,      0,          0,          0,      true);
const dragonFireColor =				color(500,	150,	0,      45,		30,			45,			0,		true);
const flamedancerCoronaColor =	color(500,	150,	100,	45,		30,			0,			0,		true);
//const shieldingColor =				color(100,	50,		0,		0,		50,			100,		0,		true);
const shieldingColor =					color(150,	75,		0,		0,		50,			175,		0,		true);

	// tile colors
const undiscoveredColor =		color(0,		0,		0,		0,		0,			0,			0,		false);
const wallForeColor =				color(7,		7,		7,		3,		3,			3,			0,		false);

const wallBackColor =  			color();	// dynami;
const wallBackColorStart =		color(45,	40,		40,		15,		0,			5,			20,		false);
const wallBackColorEnd =			color(40,	30,		35,		0,		20,			30,			20,		false);

const mudWallForeColor =     color(55,	45,		0,		5,		5,			5,			1,		false);
//const mudWallForeColor =      color(40,	34,		7,		0,		3,			0,			3,		false);
const mudWallBackColor =     color(20,	12,		3,		8,		4,			3,			0,		false);

const graniteBackColor =			color(10,	10,		10,		0,		0,			0,			0,		false);
const floorForeColor =				color(30,	30,		30,		0,		0,			0,			35,		false);

const floorBackColor =				color();	// dynami;
const floorBackColorStart =	color(2,		2,		10,		2,		2,			0,			0,		false);
const floorBackColorEnd =		color(5,		5,		5,		2,		2,			0,			0,		false);

const stairsBackColor =			color(15,	15,		5,		0,		0,			0,			0,		false);
const firstStairsBackColor =	color(10,	10,		25,		0,		0,			0,			0,		false);

const refuseBackColor =					color(6,		5,		3,		2,		2,			0,			0,		false);
const rubbleBackColor =					color(7,		7,		8,		2,		2,			1,			0,		false);
const bloodflowerForeColor =  		color(30,    5,      40,     5,      1,          3,          0,      false);
const bloodflowerPodForeColor = 	color(50,  5,      25,     5,      1,          3,          0,      false);
const bloodflowerBackColor =  		color(15,    3,      10,     3,      1,          3,          0,      false);
const bedrollBackColor =      		color(10,	8,		5,		1,		1,			0,			0,		false);

const obsidianBackColor =			color(6,		0,		8,		2,		0,			3,			0,		false);
const carpetForeColor =				color(23,	30,		38,		0,		0,			0,			0,		false);
const carpetBackColor =				color(15,	8,		5,		0,		0,			0,			0,		false);
const marbleForeColor =				color(30,	23,		38,		0,		0,			0,			0,		false);
const marbleBackColor =				color(6,     5,		13,		1,		0,			1,			0,		false);
const doorForeColor =					color(70,	35,		15,		0,		0,			0,			0,		false);
const doorBackColor =					color(30,	10,		5,		0,		0,			0,			0,		false);
//const ironDoorForeColor =		color(40,	40,		40,		0,		0,			0,			0,		false);
const ironDoorForeColor =			color(500,	500,	500,	0,		0,			0,			0,		false);
const ironDoorBackColor =			color(15,	15,		30,		0,		0,			0,			0,		false);
const bridgeFrontColor =				color(33,	12,		12,		12,		7,			2,			0,		false);
const bridgeBackColor =				color(12,	3,		2,		3,		2,			1,			0,		false);
const statueBackColor =				color(20,	20,		20,		0,		0,			0,			0,		false);
const glyphColor =         		color(20,    5,      5,      50,     0,          0,          0,      true);
const glyphLightColor =    		color(150,   0,      0,      150,    0,          0,          0,      true);
const sacredGlyphColor =   		color(5,     20,     5,      0,      50,         0,          0,      true);
const sacredGlyphLightColor = 	color(45,    150,	60,     25,		80,			25,			0,		true);

const deepWaterForeColor =					color(5,		8,		20,		0,		4,			15,			10,		true);
const deepWaterBackColor =					color();	// dynami;
const deepWaterBackColorStart = 		color(5,	10,		31,		5,		5,			5,			6,		true);
const deepWaterBackColorEnd =			color(5,		8,		20,		2,		3,			5,			5,		true);
const shallowWaterForeColor =			color(28,	28,		60,		0,		0,			10,			10,		true);
const shallowWaterBackColor =			color(); // dynami;
const shallowWaterBackColorStart =	color(20,20,		60,		0,		0,			10,			10,		true);
const shallowWaterBackColorEnd =		color(12,	15,		40,		0,		0,			5,			5,		true);

const mudForeColor =							color(18,	14,		5,		5,		5,			0,			0,		false);
const mudBackColor =							color(23,	17,		7,		5,		5,			0,			0,		false);
const chasmForeColor =						color(7,		7,		15,		4,		4,			8,			0,		false);
const chasmEdgeBackColor =				color(); // dynami;
const chasmEdgeBackColorStart =	color(5,	5,		25,		2,		2,			2,			0,		false);
const chasmEdgeBackColorEnd =		color(8,		8,		20,		2,		2,			2,			0,		false);
const fireForeColor =						color(70,	20,		0,		15,		10,			0,			0,		true);
const lavaForeColor =						color(20,	20,		20,		100,	10,			0,			0,		true);
const brimstoneForeColor =				color(100,	50,		10,		0,		50,			40,			0,		true);
const brimstoneBackColor =				color(18,	12,		9,		0,		0,			5,			0,		false);

const lavaBackColor =			color(70,	20,		0,		15,		10,			0,			0,		true);
const acidBackColor =			color(15,	80,		25,		5,		15,			10,			0,		true);

const lightningColor =				color(100,	150,	500,	50,		50,			0,			50,		true);
const fungusLightColor =			color(2,		11,		11,		4,		3,			3,			0,		true);
const lavaLightColor =				color(47,	13,		0,		10,		7,			0,			0,		true);
const deepWaterLightColor =	color(10,	30,		100,	0,		30,			100,		0,		true);

const grassColor =					color(15,	40,		15,		15,		50,			15,			10,		false);
const deadGrassColor =			color(20,	13,		0,		20,		10,			5,			10,		false);
const fungusColor =				color(15,	50,		50,		0,		25,			0,			30,		true);
const grayFungusColor =		color(30,	30,		30,		5,		5,			5,			10,		false);
const foliageColor =				color(25,	100,	25,		15,		0,			15,			0,		false);
const deadFoliageColor =		color(20,	13,		0,		30,		15,			0,			20,		false);
const lichenColor =				color(50,	5,		25,		10,		0,			5,			0,		true);
const hayColor =						color(70,	55,		5,		0,		20,			20,			0,		false);
const ashForeColor =				color(20,	20,		20,		0,		0,			0,			20,		false);
const bonesForeColor =			color(80,	80,		30,		5,		5,			35,			5,		false);
const ectoplasmColor =			color(45,	20,		55,		25,		0,			25,			5,		false);
const forceFieldColor =		color(0,		25,		25,		0,		25,			25,			0,		true);
const wallCrystalColor =		color(40,	40,		60,		20,		20,			40,			0,		true);
const altarForeColor =			color(5,		7,		9,		0,		0,			0,			0,		false);
const altarBackColor =			color(35,	18,		18,		0,		0,			0,			0,		false);
const greenAltarBackColor =  color(18,	25,		18,		0,		0,			0,			0,		false);
const goldAltarBackColor =   color(25,	24,		12,		0,		0,			0,			0,		false);
const pedestalBackColor =		color(10,	5,		20,		0,		0,			0,			0,		false);

	// monster colors
const goblinColor =					color(40,	30,		20,		0,		0,			0,			0,		false);
const jackalColor =					color(60,	42,		27,		0,		0,			0,			0,		false);
const ogreColor =						color(60,	25,		25,		0,		0,			0,			0,		false);
const eelColor =							color(30,	12,		12,		0,		0,			0,			0,		false);
const goblinConjurerColor =	color(67,	10,		100,	0,		0,			0,			0,		false);
const spectralBladeColor =		color(15,	15,		60,		0,		0,			70,			50,		true);
const spectralImageColor =		color(13,	0,		0,		25,		0,			0,			0,		true);
const toadColor =						color(40,	65,		30,		0,		0,			0,			0,		false);
const trollColor =						color(40,	60,		15,		0,		0,			0,			0,		false);
const centipedeColor =				color(75,	25,		85,		0,		0,			0,			0,		false);
const dragonColor =					color(20,	80,		15,		0,		0,			0,			0,		false);
const krakenColor =					color(100,	55,		55,		0,		0,			0,			0,		false);
const salamanderColor =			color(40,	10,		0,		8,		5,			0,			0,		true);
const pixieColor =						color(60,	60,		60,		40,		40,			40,			0,		true);
const darPriestessColor =		color(0,		50,		50,		0,		0,			0,			0,		false);
const darMageColor =					color(50,	50,		0,		0,		0,			0,			0,		false);
const wraithColor =					color(66,	66,		25,		0,		0,			0,			0,		false);
const pinkJellyColor =				color(100,	40,		40,		5,		5,			5,			20,		true);
const wormColor =						color(80,	60,		40,		0,		0,			0,			0,		false);
const sentinelColor =				color(3,		3,		30,		0,		0,			10,			0,		true);
const goblinMysticColor =		color(10,	67,		100,	0,		0,			0,			0,		false);
const ifritColor =						color(50,	10,		100,	75,		0,			20,			0,		true);
const phoenixColor =					color(100,	0,		0,		0,		100,		0,			0,		true);

	// light colors
const minersLightColor =				color();
const minersLightStartColor =	color(180,	180,	180,	0,		0,			0,			0,		false);
const minersLightEndColor =		color(90,	90,		120,	0,		0,			0,			0,		false);
const torchColor =							color(150,	75,		30,		0,		30,			20,			0,		true);
const torchLightColor =				color(75,	38,		15,		0,		15,			7,			0,		true);
//const hauntedTorchColor =		color(75,	30,		150,	30,		20,			0,			0,		true);
const hauntedTorchColor =     	color(75,	20,		40,     30,		10,			0,			0,		true);
//const hauntedTorchLightColor = color(19,     7,		37,		8,		4,			0,			0,		true);
const hauntedTorchLightColor =	color(67,    10,		10,		20,		4,			0,			0,		true);
const ifritLightColor =				color(0,		10,		150,	100,	0,			100,		0,		true);
// const unicornLightColor = color(-50,	-50,	-50,	200,	200,		200,		0,		true);
const unicornLightColor =			color(-50,	-50,	-50,	250,	250,		250,		0,		true);
const wispLightColor =					color(75,	100,	250,	33,		10,			0,			0,		true);
const summonedImageLightColor =	color(200,	0,		75,		0,		0,			0,			0,		true);
const spectralBladeLightColor =	color(40,	0,		230,	0,		0,			0,			0,		true);
const ectoplasmLightColor =		color(23,	10,		28,		13,		0,			13,			3,		false);
const explosionColor =					color(10,	8,		2,		0,		2,			2,			0,		true);
const explosiveAuraColor =			color(2000,	0,      -1000,  200,    200,		0,          0,		true);
const sacrificeTargetColor =  	color(100,	-100,   -300,   0,      100,		100,        0,		true); 	// 1.7.5
const dartFlashColor =					color(500,	500,	500,	0,		2,			2,			0,		true);
const lichLightColor =					color(-50,	80,		30,		0,		0,			20,			0,		true);
const forceFieldLightColor =		color(10,	10,		10,		0,		50,			50,			0,		true);
const crystalWallLightColor =	color(10,	10,		10,		0,		0,			50,			0,		true);
const sunLightColor =					color(100,	100,	75,		0,		0,			0,			0,		false);
const fungusForestLightColor =		color(30,	40,		60,		0,		0,			0,			40,		true);
const fungusTrampledLightColor =	color(10,	10,		10,		0,		50,			50,			0,		true);
const redFlashColor =					color(100,	10,		10,		0,		0,			0,			0,		false);
const darknessPatchColor =			color(-10,	-10,	-10,	0,		0,			0,			0,		false);
const darknessCloudColor =			color(-20,	-20,	-20,	0,		0,			0,			0,		false);
const magicMapFlashColor =			color(60,	20,		60,		0,		0,			0,			0,		false);
const sentinelLightColor =			color(20,	20,		120,	10,		10,			60,			0,		true);
const telepathyColor =					color(30,	30,		130,	0,		0,			0,			0,		false);
const confusionLightColor =		color(10,	10,		10,		10,		10,			10,			0,		true);
const portalActivateLightColor =		color(300,	400,	500,	0,		0,			0,			0,		true);
const descentLightColor =     	color(20,    20,     70,     0,      0,          0,          0,      false);
const algaeBlueLightColor =   	color(20,    15,     50,     0,      0,          0,          0,      false);
const algaeGreenLightColor =  	color(15,    50,     20,     0,      0,          0,          0,      false);

	// flare colors
const scrollProtectionColor =		color(375,	750,	0,		0,		0,			0,          0,		true);
const scrollEnchantmentColor =		color(250,	225,	300,	0,		0,			450,        0,		true);
const potionStrengthColor =   		color(1000,  0,      400,	600,	0,			0,          0,		true);
const empowermentFlashColor = 		color(500,   1000,   600,	0,      500,		0,          0,		true);
const genericFlashColor =     		color(800,   800,    800,    0,      0,          0,          0,      false);
const summoningFlashColor =   		color(0,     0,      0,      600,    0,          1200,       0,      true);
const fireFlashColor =						color(750,	225,	0,		100,	50,			0,			0,		true);
const explosionFlareColor =   		color(10000, 6000,   1000,   0,      0,          0,          0,      false);
const quietusFlashColor =     		color(0,     -1000,  -200,   0,      0,          0,          0,      true);
const slayingFlashColor =     		color(-1000, -200,   0,      0,      0,          0,          0,      true);

	// color multipliers
const colorDim25 =								color(25,	25,		25,		25,		25,			25,			25,		false);
const colorMultiplier100 =				color(100,	100,	100,	100,	100,		100,		100,	false);
const memoryColor =							color(25,	25,		50,		20,		20,			20,			0,		false);
const memoryOverlay =						color(25,	25,		50,		0,		0,			0,			0,		false);
const magicMapColor =						color(60,	20,		60,		60,		20,			60,			0,		false);
const clairvoyanceColor =				color(50,	90,		50,		50,		90,			50,			66,		false);
const telepathyMultiplier =			color(30,	30,		130,	30,		30,			130,		66,		false);
const omniscienceColor =					color(140,	100,	60,		140,	100,		60,			90,		false);
const basicLightColor =					color(180,	180,	180,	180,	180,		180,		180,	false);

	// blood colors
const humanBloodColor =		color(60,	20,		10,		15,		0,			0,			15,		false);
const insectBloodColor =		color(10,	60,		20,		0,		15,			0,			15,		false);
const vomitColor =					color(60,	50,		5,		0,		15,			15,			0,		false);
const urineColor =					color(70,	70,		40,		0,		0,			0,			10,		false);
const methaneColor =				color(45,	60,		15,		0,		0,			0,			0,		false);

	// gas colors
const poisonGasColor =				color(75,	25,		85,		0,		0,			0,			0,		false);
const confusionGasColor =		color(60,	60,		60,		40,		40,			40,			0,		true);

	// interface colors
const itemColor =							color(100,	95,		-30,	0,		0,			0,			0,		false);
const blueBar =								color(15,	10,		50,		0,		0,			0,			0,		false);
const redBar =									color(45,	10,		15,		0,		0,			0,			0,		false);
const hiliteColor =						color(100,	100,	0,		0,		0,			0,			0,		false);
const interfaceBoxColor =			color(7,		6,		15,		0,		0,			0,			0,		false);
const interfaceButtonColor =		color(18,	15,		38,		0,		0,			0,			0,		false);
const buttonHoverColor =				color(100,	70,		40,		0,		0,			0,			0,		false);
const titleButtonColor =				color(23,	15,		30,		0,		0,			0,			0,		false);

const playerInvisibleColor =  	color(20,    20,     30,     0,      0,          80,         0,      true);
const playerInLightColor =			color(100,	90,     30,		0,		0,			0,			0,		false);
const playerInShadowColor =		color(60,	60,		100,	0,		0,			0,			0,		false);
const playerInDarknessColor =	color(30,	30,		65,		0,		0,			0,			0,		false);

const inLightMultiplierColor =			color(150,   150,    75,     150,    150,        75,         100,    true);
const inDarknessMultiplierColor =	color(66,  66,     120,    66,     66,         120,        66,     true);

const goodMessageColor =					color(60,	50,		100,	0,		0,			0,			0,		false);
const badMessageColor =					color(100,	50,		60,		0,		0,			0,			0,		false);
const advancementMessageColor =	color(50,	100,	60,		0,		0,			0,			0,		false);
const itemMessageColor =					color(100,	100,	50,		0,		0,			0,			0,		false);
const flavorTextColor =					color(50,	40,		90,		0,		0,			0,			0,		false);
const backgroundMessageColor =		color(60,	20,		70,		0,		0,			0,			0,		false);

const superVictoryColor =     		color(150,	100,	300,	0,		0,			0,			0,		false);

const flameSourceColor = color(20, 7, 7, 60, 40, 40, 0, true);
const flameSourceColorSecondary = color(7, 2, 0, 10, 0, 0, 0, true);

const flameTitleColor = color(0, 0, 0, 9, 9, 15, 0, true); // *pale blue*;


// #pragma mark Dynamic color references

const dynamicColors = [
	// used color			shallow color				deep color
	[minersLightColor,			minersLightStartColor,			minersLightEndColor],
	[wallBackColor,					wallBackColorStart,					wallBackColorEnd],
	[deepWaterBackColor,		deepWaterBackColorStart,		deepWaterBackColorEnd],
	[shallowWaterBackColor,	shallowWaterBackColorStart,	shallowWaterBackColorEnd],
	[floorBackColor,				floorBackColorStart,				floorBackColorEnd],
	[chasmEdgeBackColor,		chasmEdgeBackColorStart,		chasmEdgeBackColorEnd],
];

const NUMBER_DYNAMIC_COLORS = dynamicColors.length;

// #pragma mark Autogenerator definitions



const autoGeneratorCatalog = [
//	 terrain					layer	DF							Machine		reqDungeon  reqLiquid   >Depth	<Depth          freq	minIncp	minSlope	maxNumber
    // Ordinary features of the dungeon
	[0,							0,		DF_GRANITE_COLUMN,			0,			FLOOR,		NOTHING,    1,		DEEPEST_LEVEL,	60,		100,	0,			4],
	[0,							0,		DF_CRYSTAL_WALL,				0,			WALL,     NOTHING,    14,		DEEPEST_LEVEL,	15,		-325,	25,			5],
	[0,							0,		DF_LUMINESCENT_FUNGUS,	0,			FLOOR,		NOTHING,    7,		DEEPEST_LEVEL,	15,		-300,	70,			14],
	[0,							0,		DF_GRASS,								0,			FLOOR,		NOTHING,    0,		10,             0,		1000,	-80,        10],
	[0,							0,		DF_DEAD_GRASS,					0,			FLOOR,		NOTHING,    4,		9,              0,		-200,	80,         10],
	[0,							0,		DF_DEAD_GRASS,					0,			FLOOR,		NOTHING,    9,		14,             0,		1200,	-80,        10],
	[0,							0,		DF_BONES,								0,			FLOOR,		NOTHING,    12,		DEEPEST_LEVEL-1,30,		0,		0,			4],
	[0,							0,		DF_RUBBLE,							0,			FLOOR,		NOTHING,    0,		DEEPEST_LEVEL-1,30,		0,		0,			4],
	[0,							0,		DF_FOLIAGE,							0,			FLOOR,		NOTHING,    0,		8,              15,		1000,	-333,       10],
	[0,							0,		DF_FUNGUS_FOREST,				0,			FLOOR,		NOTHING,    13,		DEEPEST_LEVEL,	30,		-600,	50,			12],
  [0,							0,		DF_BUILD_ALGAE_WELL,		0,			FLOOR,    DEEP_WATER, 10,		DEEPEST_LEVEL,	50,		0,      0,			2],
	[STATUE_INERT,				DUNGEON,						0,	0,			WALL,     NOTHING,    6,		DEEPEST_LEVEL-1,5,		-100,	35,			3],
	[STATUE_INERT,				DUNGEON,						0,	0,			FLOOR,		NOTHING,    10,		DEEPEST_LEVEL-1,50,		0,		0,			3],
	[TORCH_WALL,					DUNGEON,						0,	0,			WALL,     NOTHING,    6,		DEEPEST_LEVEL-1,5,		-200,	70,			12],

    // Pre-revealed traps
	[GAS_TRAP_POISON,           DUNGEON, 0, 0,		FLOOR,		NOTHING,    2,		4,              20,		0,      0,			1],
  [NET_TRAP,                  DUNGEON, 0, 0,		FLOOR,		NOTHING,    2,		5,              20,		0,      0,			1],
	[0, 0, 0, 				 MT_PARALYSIS_TRAP_AREA,		FLOOR,		NOTHING,    2,		6,              20,		0,      0,			1],
  [ALARM_TRAP,                DUNGEON, 0, 0,		FLOOR,		NOTHING,    4,		7,              20,		0,      0,			1],
	[GAS_TRAP_CONFUSION,        DUNGEON, 0, 0,		FLOOR,		NOTHING,    2,		10,             20,		0,      0,			1],
	[FLAMETHROWER,              DUNGEON, 0, 0,		FLOOR,		NOTHING,    4,		12,             20,		0,      0,			1],
  [FLOOD_TRAP,                DUNGEON, 0, 0,		FLOOR,		NOTHING,    10,		14,             20,		0,      0,			1],

    // Hidden traps
	[GAS_TRAP_POISON_HIDDEN,		DUNGEON,0,							0,	FLOOR,		NOTHING,    5,		DEEPEST_LEVEL-1,20,		100,	0,			3],
  [NET_TRAP_HIDDEN,						DUNGEON,0,							0,	FLOOR,		NOTHING,    6,		DEEPEST_LEVEL-1,20,		100,	0,			3],
	[0,   0,      0,				MT_PARALYSIS_TRAP_HIDDEN_AREA, 	FLOOR,		NOTHING,    7,		DEEPEST_LEVEL-1,20,		100,	0,			3],
  [ALARM_TRAP_HIDDEN,					DUNGEON,0,							0,	FLOOR,		NOTHING,    8,		DEEPEST_LEVEL-1,20,		100,	0,			2],
	[TRAP_DOOR_HIDDEN,					DUNGEON,0,							0,	FLOOR,		NOTHING,    9,		DEEPEST_LEVEL-1,20,		100,	0,			2],
	[GAS_TRAP_CONFUSION_HIDDEN,	DUNGEON,0,							0,	FLOOR,		NOTHING,    11,		DEEPEST_LEVEL-1,20,		100,	0,			3],
	[FLAMETHROWER_HIDDEN,				DUNGEON,0,							0,	FLOOR,		NOTHING,    13,		DEEPEST_LEVEL-1,20,		100,	0,			3],
  [FLOOD_TRAP_HIDDEN,					DUNGEON,0,							0,	FLOOR,		NOTHING,    15,		DEEPEST_LEVEL-1,20,		100,	0,			3],

	[0,							0,		0,								MT_SWAMP_AREA,	FLOOR,		NOTHING,    1,		DEEPEST_LEVEL-1,30,		0,		0,			2],
	[0,							0,			DF_SUNLIGHT,				0,					FLOOR,		NOTHING,    0,		5,              15,		500,	-150,       10],
	[0,							0,			DF_DARKNESS,				0,					FLOOR,		NOTHING,    1,		15,             15,		500,	-50,        10],
	[STEAM_VENT,				DUNGEON, 0,							0,					FLOOR,		NOTHING,    16,		DEEPEST_LEVEL-1,30,		100,	0,			3],
  [CRYSTAL_WALL,      DUNGEON, 0,             0,          WALL,     NOTHING,    DEEPEST_LEVEL,DEEPEST_LEVEL,100,0,      0,          600],

  // Dewars
  [DEWAR_CAUSTIC_GAS,         DUNGEON,	DF_CARPET_AREA, 0, FLOOR,      NOTHING,    8,      DEEPEST_LEVEL-1,2,      0,      0,          2],
  [DEWAR_CONFUSION_GAS,       DUNGEON,	DF_CARPET_AREA, 0, FLOOR,      NOTHING,    8,      DEEPEST_LEVEL-1,2,      0,      0,          2],
  [DEWAR_PARALYSIS_GAS,       DUNGEON,	DF_CARPET_AREA, 0, FLOOR,      NOTHING,    8,      DEEPEST_LEVEL-1,2,      0,      0,          2],
  [DEWAR_METHANE_GAS,         DUNGEON,	DF_CARPET_AREA, 0, FLOOR,      NOTHING,    8,      DEEPEST_LEVEL-1,2,      0,      0,          2],

  // Flavor machines
  [0,	0,		DF_LUMINESCENT_FUNGUS, 0,				FLOOR,		NOTHING,    DEEPEST_LEVEL,DEEPEST_LEVEL,100,0,      0,			200],
  [0, 0,    0,    MT_BLOODFLOWER_AREA,  		FLOOR,    NOTHING,    1,      30,             25,     140,    -10,        3],
  [0,	0,		0,		MT_SHRINE_AREA,						FLOOR,		NOTHING,    5,		AMULET_LEVEL,   7,		0,		0,          1],
	[0,	0,		0,		MT_IDYLL_AREA,						FLOOR,		NOTHING,    1,		5,              15,		0,		0,          1],
	[0,	0,		0,		MT_REMNANT_AREA,					FLOOR,		NOTHING,    10,		DEEPEST_LEVEL,	15,		0,		0,			2],
	[0,	0,		0,		MT_DISMAL_AREA,						FLOOR,		NOTHING,    7,		DEEPEST_LEVEL,	12,		0,		0,			5],
	[0,	0,		0,		MT_BRIDGE_TURRET_AREA,		FLOOR,		NOTHING,    5,		DEEPEST_LEVEL-1,6,		0,		0,			2],
	[0,	0,		0,		MT_LAKE_PATH_TURRET_AREA,	FLOOR,		NOTHING,    5,		DEEPEST_LEVEL-1,6,		0,		0,			2],
	[0,	0,		0,		MT_TRICK_STATUE_AREA,			FLOOR,		NOTHING,    6,		DEEPEST_LEVEL-1,15,		0,		0,			3],
	[0,	0,		0,		MT_SENTINEL_AREA,					FLOOR,		NOTHING,    12,		DEEPEST_LEVEL-1,10,		0,		0,			2],
	[0,	0,		0,		MT_WORM_AREA,							FLOOR,		NOTHING,    12,		DEEPEST_LEVEL-1,12,		0,		0,			3],
].map( (v) => autoGenerator(...v) );

const NUMBER_AUTOGENERATORS = autoGeneratorCatalog.length;


//#pragma mark Terrain definitions

const tileCatalog = [

	// promoteChance is in hundredths of a percent per turn

	//	char		fore color				back color		priority	ignit	fireType	discovType	promoteType		promoteChance	glowLight		flags																								description			flavorText

	// dungeon layer (this layer must have all of fore color, back color and char)
	[	' ',		black,					black,					100,0,	DF_PLAIN_FIRE,	0,			0,				0,				NO_LIGHT,		0, 0,																								"a chilly void",		""],
	[WALL_CHAR,		wallBackColor,			graniteBackColor,		0,	0,	DF_PLAIN_FIRE,	0,			0,				0,				NO_LIGHT,		(T_OBSTRUCTS_EVERYTHING), (TM_STAND_IN_TILE),														"a rough granite wall",	"The granite is split open with splinters of rock jutting out at odd angles."],
	[FLOOR_CHAR,	floorForeColor,		floorBackColor,		95,	0,	DF_PLAIN_FIRE,	0,			0,				0,				NO_LIGHT,		0, 0,                                                                                               "the ground",			""],
	[FLOOR_CHAR,	floorForeColor,		floorBackColor,		95,	0,	DF_PLAIN_FIRE,	0,			0,				0,				NO_LIGHT,		0, 0,                                                                                               "the ground",			""],
	[FLOOR_CHAR,	carpetForeColor,		carpetBackColor,		85,	0,	DF_EMBERS,		0,			0,				0,				NO_LIGHT,		(T_IS_FLAMMABLE), (TM_VANISHES_UPON_PROMOTION),                                                     "the carpet",			"Ornate carpeting fills this room, a relic of ages past."],
	[FLOOR_CHAR,	marbleForeColor,       marbleBackColor,       85,	0,	DF_EMBERS,		0,			0,				0,				NO_LIGHT,		0, 0,                                                                                               "the marble ground",    "Light from the nearby crystals catches the grain of the lavish marble floor."],
	[WALL_CHAR,		wallForeColor,			wallBackColor,			0,	0,	DF_PLAIN_FIRE,	0,			0,				0,				NO_LIGHT,		(T_OBSTRUCTS_EVERYTHING), (TM_STAND_IN_TILE),														"a stone wall",			"The rough stone wall is firm and unyielding."],
	[DOOR_CHAR,		doorForeColor,			doorBackColor,			25,	50,	DF_EMBERS,		0,			DF_OPEN_DOOR,	0,				NO_LIGHT,		(T_OBSTRUCTS_VISION | T_OBSTRUCTS_GAS | T_IS_FLAMMABLE), (TM_STAND_IN_TILE | TM_VANISHES_UPON_PROMOTION | TM_PROMOTES_ON_STEP | TM_VISUALLY_DISTINCT), "a wooden door",	"you pass through the doorway."],
	[OPEN_DOOR_CHAR,doorForeColor,			doorBackColor,			25,	50,	DF_EMBERS,		0,			DF_CLOSED_DOOR,	10000,			NO_LIGHT,		(T_IS_FLAMMABLE), (TM_STAND_IN_TILE | TM_VANISHES_UPON_PROMOTION | TM_VISUALLY_DISTINCT),           "an open door",			"you pass through the doorway."],
	[WALL_CHAR,		wallForeColor,			wallBackColor,			0,	50,	DF_EMBERS,		DF_SHOW_DOOR,0,				0,				NO_LIGHT,		(T_OBSTRUCTS_EVERYTHING | T_IS_FLAMMABLE), (TM_STAND_IN_TILE | TM_VANISHES_UPON_PROMOTION | TM_IS_SECRET),	"a stone wall",		"The rough stone wall is firm and unyielding."],
	[DOOR_CHAR,		ironDoorForeColor,		ironDoorBackColor,		15,	50,	DF_EMBERS,		0,			DF_OPEN_IRON_DOOR_INERT,0,		NO_LIGHT,		(T_OBSTRUCTS_EVERYTHING), (TM_STAND_IN_TILE | TM_VANISHES_UPON_PROMOTION | TM_PROMOTES_WITH_KEY | TM_LIST_IN_SIDEBAR | TM_VISUALLY_DISTINCT | TM_BRIGHT_MEMORY | TM_INTERRUPT_EXPLORATION_WHEN_SEEN | TM_INVERT_WHEN_HIGHLIGHTED),	"a locked iron door",	"you search your pack but do not have a matching key."],
	[OPEN_DOOR_CHAR,white,                 ironDoorBackColor,		90,	50,	DF_EMBERS,		0,			0,				0,				NO_LIGHT,		(T_OBSTRUCTS_SURFACE_EFFECTS), (TM_STAND_IN_TILE | TM_VISUALLY_DISTINCT),                           "an open iron door",	"you pass through the doorway."],
	[DESCEND_CHAR,	itemColor,				stairsBackColor,		30,	0,	DF_PLAIN_FIRE,	0,			DF_REPEL_CREATURES, 0,			NO_LIGHT,		(T_OBSTRUCTS_ITEMS | T_OBSTRUCTS_SURFACE_EFFECTS), (TM_PROMOTES_ON_STEP | TM_STAND_IN_TILE | TM_LIST_IN_SIDEBAR | TM_VISUALLY_DISTINCT | TM_BRIGHT_MEMORY | TM_INTERRUPT_EXPLORATION_WHEN_SEEN | TM_INVERT_WHEN_HIGHLIGHTED), "a downward staircase",	"stairs spiral downward into the depths."],
	[ASCEND_CHAR,	itemColor,				stairsBackColor,		30,	0,	DF_PLAIN_FIRE,	0,			DF_REPEL_CREATURES, 0,			NO_LIGHT,		(T_OBSTRUCTS_ITEMS | T_OBSTRUCTS_SURFACE_EFFECTS), (TM_PROMOTES_ON_STEP | TM_STAND_IN_TILE | TM_LIST_IN_SIDEBAR | TM_VISUALLY_DISTINCT | TM_BRIGHT_MEMORY | TM_INTERRUPT_EXPLORATION_WHEN_SEEN | TM_INVERT_WHEN_HIGHLIGHTED), "an upward staircase",	"stairs spiral upward."],
	[OMEGA_CHAR,	lightBlue,				firstStairsBackColor,	30,	0,	DF_PLAIN_FIRE,	0,			DF_REPEL_CREATURES, 0,			NO_LIGHT,		(T_OBSTRUCTS_ITEMS | T_OBSTRUCTS_SURFACE_EFFECTS), (TM_PROMOTES_ON_STEP | TM_STAND_IN_TILE | TM_LIST_IN_SIDEBAR | TM_VISUALLY_DISTINCT | TM_BRIGHT_MEMORY | TM_INTERRUPT_EXPLORATION_WHEN_SEEN | TM_INVERT_WHEN_HIGHLIGHTED), "the dungeon exit",		"the gilded doors leading out of the dungeon are sealed by an invisible force."],
    [OMEGA_CHAR,	wallCrystalColor,		firstStairsBackColor,	30,	0,	DF_PLAIN_FIRE,	0,			DF_REPEL_CREATURES, 0,			INCENDIARY_DART_LIGHT,		(T_OBSTRUCTS_ITEMS | T_OBSTRUCTS_SURFACE_EFFECTS), (TM_PROMOTES_ON_STEP | TM_STAND_IN_TILE | TM_LIST_IN_SIDEBAR | TM_VISUALLY_DISTINCT | TM_BRIGHT_MEMORY | TM_INTERRUPT_EXPLORATION_WHEN_SEEN | TM_INVERT_WHEN_HIGHLIGHTED), "a crystal portal",		"dancing lights play across the plane of this sparkling crystal portal."],
	[WALL_CHAR,		torchColor,			wallBackColor,			0,	0,	DF_PLAIN_FIRE,	0,			0,				0,				TORCH_LIGHT,	(T_OBSTRUCTS_EVERYTHING), (TM_STAND_IN_TILE),														"a wall-mounted torch",	"The torch is anchored firmly to the wall and sputters quietly in the gloom."],
	[WALL_CHAR,		wallCrystalColor,		wallCrystalColor,		0,	0,	DF_PLAIN_FIRE,	0,			0,				0,				CRYSTAL_WALL_LIGHT,(T_OBSTRUCTS_PASSABILITY | T_OBSTRUCTS_ITEMS | T_OBSTRUCTS_GAS | T_OBSTRUCTS_SURFACE_EFFECTS | T_OBSTRUCTS_DIAGONAL_MOVEMENT), (TM_STAND_IN_TILE | TM_REFLECTS_BOLTS),"a crystal formation", "You feel the crystal's glossy surface and admire the dancing lights beneath."],
	[WALL_CHAR,		gray,					floorBackColor,		10,	0,	DF_PLAIN_FIRE,	0,			DF_OPEN_PORTCULLIS,	0,			NO_LIGHT,		(T_OBSTRUCTS_PASSABILITY | T_OBSTRUCTS_ITEMS), (TM_STAND_IN_TILE | TM_VANISHES_UPON_PROMOTION | TM_IS_WIRED | TM_LIST_IN_SIDEBAR | TM_VISUALLY_DISTINCT | TM_CONNECTS_LEVEL), "a heavy portcullis",	"The iron bars rattle but will not budge; they are firmly locked in place."],
	[FLOOR_CHAR,	floorForeColor,		floorBackColor,		95,	0,	DF_PLAIN_FIRE,	0,			DF_ACTIVATE_PORTCULLIS,0,		NO_LIGHT,		(0), (TM_VANISHES_UPON_PROMOTION | TM_IS_WIRED),                                                    "the ground",			""],
	[WALL_CHAR,		doorForeColor,			floorBackColor,		10,	100,DF_WOODEN_BARRICADE_BURN,0,	0,				0,				NO_LIGHT,		(T_OBSTRUCTS_PASSABILITY | T_OBSTRUCTS_ITEMS | T_IS_FLAMMABLE), (TM_STAND_IN_TILE | TM_VANISHES_UPON_PROMOTION | TM_VISUALLY_DISTINCT | TM_CONNECTS_LEVEL),"a dry wooden barricade","The wooden barricade is firmly set but has dried over the years. Might it burn?"],
	[WALL_CHAR,		torchLightColor,		wallBackColor,			0,	0,	DF_PLAIN_FIRE,	0,			DF_PILOT_LIGHT,	0,				TORCH_LIGHT,	(T_OBSTRUCTS_EVERYTHING), (TM_STAND_IN_TILE | TM_VANISHES_UPON_PROMOTION | TM_IS_WIRED),			"a wall-mounted torch",	"The torch is anchored firmly to the wall, and sputters quietly in the gloom."],
	[FIRE_CHAR,		fireForeColor,			wallBackColor,			0,	0,	DF_PLAIN_FIRE,	0,			0,				0,				TORCH_LIGHT,	(T_OBSTRUCTS_EVERYTHING | T_IS_FIRE), (TM_STAND_IN_TILE | TM_LIST_IN_SIDEBAR),						"a fallen torch",		"The torch lies at the foot of the wall, spouting gouts of flame haphazardly."],
    [WALL_CHAR,		torchColor,			wallBackColor,			0,	0,	DF_PLAIN_FIRE,	0,			DF_HAUNTED_TORCH_TRANSITION,0,	TORCH_LIGHT,	(T_OBSTRUCTS_EVERYTHING), (TM_STAND_IN_TILE | TM_VANISHES_UPON_PROMOTION | TM_IS_WIRED),			"a wall-mounted torch",	"The torch is anchored firmly to the wall and sputters quietly in the gloom."],
    [WALL_CHAR,		torchColor,			wallBackColor,			0,	0,	DF_PLAIN_FIRE,	0,			DF_HAUNTED_TORCH,2000,			TORCH_LIGHT,	(T_OBSTRUCTS_EVERYTHING), (TM_STAND_IN_TILE | TM_VANISHES_UPON_PROMOTION),                          "a wall-mounted torch",	"The torch is anchored firmly to the wall and sputters quietly in the gloom."],
    [WALL_CHAR,		hauntedTorchColor,		wallBackColor,			0,	0,	DF_PLAIN_FIRE,	0,			0,				0,				HAUNTED_TORCH_LIGHT,(T_OBSTRUCTS_EVERYTHING), (TM_STAND_IN_TILE),                                                   "a sputtering torch",	"A dim purple flame sputters and spits atop this wall-mounted torch."],
	[WALL_CHAR,		wallForeColor,			wallBackColor,			0,	0,	DF_PLAIN_FIRE,	DF_REVEAL_LEVER,0,			0,				NO_LIGHT,		(T_OBSTRUCTS_EVERYTHING), (TM_STAND_IN_TILE | TM_VANISHES_UPON_PROMOTION | TM_IS_SECRET),			"a stone wall",			"The rough stone wall is firm and unyielding."],
    [LEVER_CHAR,	wallForeColor,			wallBackColor,			0,	0,	DF_PLAIN_FIRE,	0,			DF_PULL_LEVER,  0,				NO_LIGHT,		(T_OBSTRUCTS_EVERYTHING), (TM_STAND_IN_TILE | TM_VANISHES_UPON_PROMOTION | TM_IS_WIRED | TM_PROMOTES_ON_PLAYER_ENTRY | TM_LIST_IN_SIDEBAR | TM_VISUALLY_DISTINCT | TM_INVERT_WHEN_HIGHLIGHTED),"a lever", "The lever moves."],
    [LEVER_PULLED_CHAR,wallForeColor,		wallBackColor,			0,	0,	DF_PLAIN_FIRE,	0,			0,				0,				NO_LIGHT,		(T_OBSTRUCTS_EVERYTHING), (TM_STAND_IN_TILE),                                                       "an inactive lever",    "The lever won't budge."],
    [WALL_CHAR,		wallForeColor,         wallBackColor,			0,	0,	DF_PLAIN_FIRE,	0,          DF_CREATE_LEVER,0,				NO_LIGHT,		(T_OBSTRUCTS_EVERYTHING), (TM_STAND_IN_TILE | TM_IS_WIRED),											"a stone wall",			"The rough stone wall is firm and unyielding."],
    [STATUE_CHAR,	wallBackColor,			statueBackColor,		0,	0,	DF_PLAIN_FIRE,	0,			0,				0,				NO_LIGHT,		(T_OBSTRUCTS_PASSABILITY | T_OBSTRUCTS_ITEMS | T_OBSTRUCTS_GAS | T_OBSTRUCTS_SURFACE_EFFECTS), (TM_STAND_IN_TILE),	"a marble statue",	"The cold marble statue has weathered the years with grace."],
	[STATUE_CHAR,	wallBackColor,			statueBackColor,		0,	0,	DF_PLAIN_FIRE,	0,			DF_CRACKING_STATUE,0,			NO_LIGHT,		(T_OBSTRUCTS_PASSABILITY | T_OBSTRUCTS_ITEMS | T_OBSTRUCTS_GAS | T_OBSTRUCTS_SURFACE_EFFECTS), (TM_STAND_IN_TILE | TM_VANISHES_UPON_PROMOTION | TM_IS_WIRED),"a marble statue",	"The cold marble statue has weathered the years with grace."],
	[STATUE_CHAR,	wallBackColor,			statueBackColor,		0,	0,	DF_PLAIN_FIRE,	0,			DF_STATUE_SHATTER,3500,			NO_LIGHT,		(T_OBSTRUCTS_PASSABILITY | T_OBSTRUCTS_ITEMS | T_OBSTRUCTS_GAS | T_OBSTRUCTS_SURFACE_EFFECTS), (TM_STAND_IN_TILE | TM_VANISHES_UPON_PROMOTION | TM_LIST_IN_SIDEBAR),"a cracking statue",	"Deep cracks ramble down the side of the statue even as you watch."],
    [STATUE_CHAR,	wallBackColor,			statueBackColor,		0,	0,	DF_PLAIN_FIRE,	0,			DF_STATUE_SHATTER,0,			NO_LIGHT,		(T_OBSTRUCTS_PASSABILITY | T_OBSTRUCTS_ITEMS | T_OBSTRUCTS_GAS | T_OBSTRUCTS_SURFACE_EFFECTS), (TM_STAND_IN_TILE | TM_VANISHES_UPON_PROMOTION | TM_IS_WIRED),"a marble statue",	"The cold marble statue has weathered the years with grace."],
	[OMEGA_CHAR,	wallBackColor,			floorBackColor,		17,	0,	DF_PLAIN_FIRE,	0,			DF_PORTAL_ACTIVATE,0,			NO_LIGHT,		(T_OBSTRUCTS_ITEMS), (TM_STAND_IN_TILE | TM_IS_WIRED | TM_LIST_IN_SIDEBAR | TM_VISUALLY_DISTINCT),  "a stone archway",		"This ancient moss-covered stone archway radiates a strange, alien energy."],
	[WALL_CHAR,		wallForeColor,			wallBackColor,			0,	0,	DF_PLAIN_FIRE,	0,			DF_TURRET_EMERGE,0,				NO_LIGHT,		(T_OBSTRUCTS_EVERYTHING), (TM_STAND_IN_TILE | TM_VANISHES_UPON_PROMOTION | TM_IS_WIRED),			"a stone wall",			"The rough stone wall is firm and unyielding."],
	[WALL_CHAR,		wallForeColor,			wallBackColor,			0,	0,	DF_PLAIN_FIRE,	0,			DF_WALL_SHATTER,0,				NO_LIGHT,		(T_OBSTRUCTS_EVERYTHING), (TM_STAND_IN_TILE | TM_VANISHES_UPON_PROMOTION | TM_IS_WIRED),			"a stone wall",			"The rough stone wall is firm and unyielding."],
	[FLOOR_CHAR,	floorForeColor,		floorBackColor,		95,	0,	DF_PLAIN_FIRE,	0,			DF_DARKENING_FLOOR,	0,			NO_LIGHT,		(0), (TM_VANISHES_UPON_PROMOTION | TM_IS_WIRED),                                                    "the ground",			""],
	[FLOOR_CHAR,	floorForeColor,		floorBackColor,		95,	0,	DF_PLAIN_FIRE,	0,			DF_DARK_FLOOR,	1500,			NO_LIGHT,		(0), (TM_VANISHES_UPON_PROMOTION),                                                                  "the ground",			""],
	[FLOOR_CHAR,	floorForeColor,		floorBackColor,		95,	0,	DF_PLAIN_FIRE,	0,			0,				0,				DARKNESS_CLOUD_LIGHT, 0, 0,                                                                                         "the ground",			""],
	[FLOOR_CHAR,	floorForeColor,		floorBackColor,		95,	0,	DF_PLAIN_FIRE,	0,			0,				0,				NO_LIGHT,		(0), (TM_VANISHES_UPON_PROMOTION | TM_IS_WIRED | TM_PROMOTES_ON_PLAYER_ENTRY),                      "the ground",			""],
	[ALTAR_CHAR,	altarForeColor,		altarBackColor,		17, 0,	0,				0,			0,				0,				CANDLE_LIGHT,	(T_OBSTRUCTS_SURFACE_EFFECTS), (TM_LIST_IN_SIDEBAR | TM_VISUALLY_DISTINCT),							"a candle-lit altar",	"a gilded altar is adorned with candles that flicker in the breeze."],
	[GEM_CHAR,		altarForeColor,		altarBackColor,		17, 0,	0,				0,			0,				0,				CANDLE_LIGHT,	(T_OBSTRUCTS_SURFACE_EFFECTS), (TM_PROMOTES_WITH_KEY | TM_IS_WIRED | TM_LIST_IN_SIDEBAR),           "a candle-lit altar",	"ornate gilding spirals around a spherical depression in the top of the altar."],
	[ALTAR_CHAR,	altarForeColor,		altarBackColor,		17, 0,	0,				0,			DF_ITEM_CAGE_CLOSE,	0,			CANDLE_LIGHT,	(T_OBSTRUCTS_SURFACE_EFFECTS), (TM_VANISHES_UPON_PROMOTION | TM_IS_WIRED | TM_PROMOTES_WITHOUT_KEY | TM_LIST_IN_SIDEBAR | TM_VISUALLY_DISTINCT),"a candle-lit altar",	"a cage, open on the bottom, hangs over this altar on a retractable chain."],
	[WALL_CHAR,		altarBackColor,		veryDarkGray,			17, 0,	0,				0,			DF_ITEM_CAGE_OPEN,	0,			CANDLE_LIGHT,	(T_OBSTRUCTS_PASSABILITY | T_OBSTRUCTS_SURFACE_EFFECTS), (TM_STAND_IN_TILE | TM_VANISHES_UPON_PROMOTION | TM_PROMOTES_WITH_KEY | TM_IS_WIRED | TM_LIST_IN_SIDEBAR | TM_VISUALLY_DISTINCT),"an iron cage","the missing item must be replaced before you can access the remaining items."],
	[ALTAR_CHAR,	altarForeColor,		altarBackColor,		17, 0,	0,				0,			DF_ALTAR_INERT,	0,				CANDLE_LIGHT,	(T_OBSTRUCTS_SURFACE_EFFECTS), (TM_VANISHES_UPON_PROMOTION | TM_IS_WIRED | TM_PROMOTES_ON_ITEM_PICKUP | TM_LIST_IN_SIDEBAR | TM_VISUALLY_DISTINCT),	"a candle-lit altar",	"a weathered stone altar is adorned with candles that flicker in the breeze."],
	[ALTAR_CHAR,	altarForeColor,		altarBackColor,		17, 0,	0,				0,			DF_ALTAR_RETRACT,0,				CANDLE_LIGHT,	(T_OBSTRUCTS_SURFACE_EFFECTS), (TM_VANISHES_UPON_PROMOTION | TM_IS_WIRED | TM_PROMOTES_ON_ITEM_PICKUP | TM_LIST_IN_SIDEBAR | TM_VISUALLY_DISTINCT),	"a candle-lit altar",	"a weathered stone altar is adorned with candles that flicker in the breeze."],
	[WALL_CHAR,		altarBackColor,		veryDarkGray,			17, 0,	0,				0,			DF_CAGE_DISAPPEARS,	0,			CANDLE_LIGHT,	(T_OBSTRUCTS_PASSABILITY | T_OBSTRUCTS_SURFACE_EFFECTS), (TM_STAND_IN_TILE | TM_VANISHES_UPON_PROMOTION | TM_IS_WIRED | TM_LIST_IN_SIDEBAR | TM_VISUALLY_DISTINCT),"an iron cage","the cage won't budge. Perhaps there is a way to raise it nearby..."],
	[ALTAR_CHAR,	altarForeColor,		pedestalBackColor,		17, 0,	0,				0,			0,				0,				CANDLE_LIGHT,	(T_OBSTRUCTS_SURFACE_EFFECTS), 0,																	"a stone pedestal",		"elaborate carvings wind around this ancient pedestal."],
	[ALTAR_CHAR,	floorBackColor,		veryDarkGray,			17, 0,	0,				0,			0,				0,				NO_LIGHT,		(0), (TM_STAND_IN_TILE),																			"an open cage",			"the interior of the cage is filthy and reeks of decay."],
	[WALL_CHAR,		gray,					darkGray,				17, 0,	0,				0,			DF_MONSTER_CAGE_OPENS,	0,		NO_LIGHT,		(T_OBSTRUCTS_PASSABILITY | T_OBSTRUCTS_SURFACE_EFFECTS | T_OBSTRUCTS_GAS), (TM_STAND_IN_TILE | TM_VANISHES_UPON_PROMOTION | TM_PROMOTES_WITH_KEY | TM_LIST_IN_SIDEBAR | TM_INTERRUPT_EXPLORATION_WHEN_SEEN),"a locked iron cage","the bars of the cage are firmly set and will not budge."],
	[ALTAR_CHAR,	bridgeFrontColor,		bridgeBackColor,		17,	20,	DF_COFFIN_BURNS,0,			DF_COFFIN_BURSTS,0,				NO_LIGHT,		(T_IS_FLAMMABLE), (TM_IS_WIRED | TM_VANISHES_UPON_PROMOTION | TM_LIST_IN_SIDEBAR),                  "a sealed coffin",		"a coffin made from thick wooden planks rests in a bed of moss."],
	[ALTAR_CHAR,	black,					bridgeBackColor,		17,	20,	DF_PLAIN_FIRE,	0,			0,				0,				NO_LIGHT,		(T_IS_FLAMMABLE), (TM_STAND_IN_TILE | TM_VANISHES_UPON_PROMOTION | TM_LIST_IN_SIDEBAR),				"an empty coffin",		"an open wooden coffin rests in a bed of moss."],

	// traps (part of dungeon layer):
	[FLOOR_CHAR,	floorForeColor,		floorBackColor,		95,	0,	DF_POISON_GAS_CLOUD, DF_SHOW_POISON_GAS_TRAP, 0, 0,			NO_LIGHT,		(T_IS_DF_TRAP), (TM_IS_SECRET),                                                                     "the ground",			""],
	[TRAP_CHAR,		poisonGasColor,		0,                      30,	0,	DF_POISON_GAS_CLOUD, 0,		0,				0,				NO_LIGHT,		(T_IS_DF_TRAP), (TM_LIST_IN_SIDEBAR | TM_VISUALLY_DISTINCT),                                        "a caustic gas trap",	"there is a hidden pressure plate in the floor above a reserve of caustic gas."],
	[FLOOR_CHAR,	floorForeColor,		floorBackColor,		95,	0,	DF_POISON_GAS_CLOUD, DF_SHOW_TRAPDOOR,0,	0,				NO_LIGHT,		(T_AUTO_DESCENT), (TM_IS_SECRET),                                                                   "the ground",			"you plunge through a hidden trap door!"],
	[CHASM_CHAR,	chasmForeColor,		black,					30,	0,	DF_POISON_GAS_CLOUD,0,      0,				0,				NO_LIGHT,		(T_AUTO_DESCENT), 0,                                                                                "a hole",				"you plunge through a hole in the ground!"],
	[FLOOR_CHAR,	floorForeColor,		floorBackColor,		95,	0,	0,              DF_SHOW_PARALYSIS_GAS_TRAP, 0, 0,           NO_LIGHT,		(T_IS_DF_TRAP), (TM_IS_SECRET | TM_IS_WIRED),                                                       "the ground",			""],
	[TRAP_CHAR,		pink,					0,              		30,	0,	0,              0,          0,				0,				NO_LIGHT,		(T_IS_DF_TRAP), (TM_IS_WIRED | TM_LIST_IN_SIDEBAR | TM_VISUALLY_DISTINCT),                          "a paralysis trigger",	"there is a hidden pressure plate in the floor."],
    [FLOOR_CHAR,	floorForeColor,		floorBackColor,		95,	0,	DF_PLAIN_FIRE,	DF_DISCOVER_PARALYSIS_VENT, DF_PARALYSIS_VENT_SPEW,0,NO_LIGHT,	(0), (TM_VANISHES_UPON_PROMOTION | TM_IS_SECRET | TM_IS_WIRED),                                 "the ground",			""],
	[VENT_CHAR,		pink,                  0,              		30,	0,	DF_PLAIN_FIRE,	0,			DF_PARALYSIS_VENT_SPEW,0,		NO_LIGHT,		(0), (TM_IS_WIRED | TM_LIST_IN_SIDEBAR | TM_VISUALLY_DISTINCT),                                     "an inactive gas vent",	"A dormant gas vent is connected to a reserve of paralytic gas."],
	[FLOOR_CHAR,	floorForeColor,		floorBackColor,		95,	0,	DF_CONFUSION_GAS_TRAP_CLOUD,DF_SHOW_CONFUSION_GAS_TRAP, 0,0,NO_LIGHT,		(T_IS_DF_TRAP), (TM_IS_SECRET),                                                                     "the ground",			""],
	[TRAP_CHAR,		confusionGasColor,		0,              		30,	0,	DF_CONFUSION_GAS_TRAP_CLOUD,0,	0,			0,				NO_LIGHT,		(T_IS_DF_TRAP), (TM_LIST_IN_SIDEBAR | TM_VISUALLY_DISTINCT),                                        "a confusion trap",		"A hidden pressure plate accompanies a reserve of psychotropic gas."],
	[FLOOR_CHAR,	floorForeColor,		floorBackColor,		95,	0,	DF_FLAMETHROWER,	DF_SHOW_FLAMETHROWER_TRAP, 0,	0,		NO_LIGHT,		(T_IS_DF_TRAP), (TM_IS_SECRET),                                                                     "the ground",			""],
	[TRAP_CHAR,		red,                   0,              		30,	0,	DF_FLAMETHROWER,	0,		0,				0,				NO_LIGHT,		(T_IS_DF_TRAP), (TM_LIST_IN_SIDEBAR | TM_VISUALLY_DISTINCT),										"a fire trap",			"A hidden pressure plate is connected to a crude flamethrower mechanism."],
	[FLOOR_CHAR,	floorForeColor,		floorBackColor,		95,	0,	DF_FLOOD,		DF_SHOW_FLOOD_TRAP, 0,		0,				NO_LIGHT,		(T_IS_DF_TRAP), (TM_IS_SECRET),                                                                     "the ground",			""],
	[TRAP_CHAR,		blue,                  0,              		58,	0,	DF_FLOOD,		0,			0,				0,				NO_LIGHT,		(T_IS_DF_TRAP), (TM_LIST_IN_SIDEBAR | TM_VISUALLY_DISTINCT),										"a flood trap",			"A hidden pressure plate is connected to floodgates in the walls and ceiling."],
    [FLOOR_CHAR,	floorForeColor,		floorBackColor,		95,	0,	DF_NET,         DF_SHOW_NET_TRAP, 0,        0,              NO_LIGHT,		(T_IS_DF_TRAP), (TM_IS_SECRET),                                                                     "the ground",			""],
	[TRAP_CHAR,		tanColor,              0,                      30,	0,	DF_NET,         0,          0,				0,				NO_LIGHT,		(T_IS_DF_TRAP), (TM_LIST_IN_SIDEBAR | TM_VISUALLY_DISTINCT),                                        "a net trap",           "you see netting subtly concealed in the ceiling over a hidden pressure plate."],
    [FLOOR_CHAR,	floorForeColor,		floorBackColor,		95,	0,	DF_AGGRAVATE_TRAP, DF_SHOW_ALARM_TRAP, 0,   0,              NO_LIGHT,		(T_IS_DF_TRAP), (TM_IS_SECRET),                                                                     "the ground",			""],
	[TRAP_CHAR,		gray,                  0,                      30,	0,	DF_AGGRAVATE_TRAP, 0,       0,				0,				NO_LIGHT,		(T_IS_DF_TRAP), (TM_LIST_IN_SIDEBAR | TM_VISUALLY_DISTINCT),                                        "an alarm trap",        "a hidden pressure plate is connected to a loud alarm mechanism."],
	[FLOOR_CHAR,	floorForeColor,		floorBackColor,		95,	0,	DF_PLAIN_FIRE,	DF_SHOW_POISON_GAS_VENT, DF_POISON_GAS_VENT_OPEN, 0, NO_LIGHT, (0), (TM_VANISHES_UPON_PROMOTION | TM_IS_SECRET | TM_IS_WIRED),                                  "the ground",			""],
	[VENT_CHAR,		floorForeColor,		0,              		30,	0,	DF_PLAIN_FIRE,	0,			DF_POISON_GAS_VENT_OPEN,0,		NO_LIGHT,		(0), (TM_VANISHES_UPON_PROMOTION | TM_IS_WIRED | TM_LIST_IN_SIDEBAR | TM_VISUALLY_DISTINCT),		"an inactive gas vent",	"An inactive gas vent is hidden in a crevice in the ground."],
	[VENT_CHAR,		floorForeColor,		0,              		30,	0,	DF_PLAIN_FIRE,	0,			DF_VENT_SPEW_POISON_GAS,10000,	NO_LIGHT,		0, (TM_LIST_IN_SIDEBAR | TM_VISUALLY_DISTINCT),														"a gas vent",			"Clouds of caustic gas are wafting out of a hidden vent in the floor."],
	[FLOOR_CHAR,	floorForeColor,		floorBackColor,		95,	0,	DF_PLAIN_FIRE,	DF_SHOW_METHANE_VENT, DF_METHANE_VENT_OPEN,0,NO_LIGHT,		(0), (TM_VANISHES_UPON_PROMOTION | TM_IS_SECRET | TM_IS_WIRED),                                     "the ground",			""],
	[VENT_CHAR,		floorForeColor,		0,              		30,	0,	DF_PLAIN_FIRE,	0,			DF_METHANE_VENT_OPEN,0,			NO_LIGHT,		(0), (TM_VANISHES_UPON_PROMOTION | TM_IS_WIRED | TM_LIST_IN_SIDEBAR | TM_VISUALLY_DISTINCT),		"an inactive gas vent",	"An inactive gas vent is hidden in a crevice in the ground."],
	[VENT_CHAR,		floorForeColor,		0,              		30,	15,	DF_EMBERS,		0,			DF_VENT_SPEW_METHANE,5000,		NO_LIGHT,		(T_IS_FLAMMABLE), (TM_LIST_IN_SIDEBAR | TM_VISUALLY_DISTINCT),										"a gas vent",			"Clouds of explosive gas are wafting out of a hidden vent in the floor."],
	[VENT_CHAR,		gray,					0,              		15,	15,	DF_EMBERS,		0,			DF_STEAM_PUFF,	250,			NO_LIGHT,		T_OBSTRUCTS_ITEMS, (TM_LIST_IN_SIDEBAR | TM_VISUALLY_DISTINCT),										"a steam vent",			"A natural crevice in the floor periodically vents scalding gouts of steam."],
	[TRAP_CHAR,		white,					chasmEdgeBackColor,	15,	0,	0,				0,			DF_MACHINE_PRESSURE_PLATE_USED,0,NO_LIGHT,      (T_IS_DF_TRAP), (TM_VANISHES_UPON_PROMOTION | TM_PROMOTES_ON_STEP | TM_IS_WIRED | TM_LIST_IN_SIDEBAR | TM_VISUALLY_DISTINCT),"a pressure plate",		"There is an exposed pressure plate here. A thrown item might trigger it."],
    [TRAP_CHAR,		darkGray,				chasmEdgeBackColor,	15,	0,	0,				0,			0,				0,				NO_LIGHT,		0, (TM_LIST_IN_SIDEBAR),                                                                            "an inactive pressure plate", "This pressure plate has already been depressed."],
    [CHASM_CHAR,	glyphColor,            0,                      42,	0,	0,              0,          DF_INACTIVE_GLYPH,0,			GLYPH_LIGHT_DIM,(0), (TM_VANISHES_UPON_PROMOTION | TM_IS_WIRED | TM_PROMOTES_ON_PLAYER_ENTRY | TM_VISUALLY_DISTINCT),"a magical glyph",      "A strange glyph, engraved into the floor, flickers with magical light."],
    [CHASM_CHAR,	glyphColor,            0,                      42,	0,	0,              0,          DF_ACTIVE_GLYPH,10000,			GLYPH_LIGHT_BRIGHT,(0), (TM_VANISHES_UPON_PROMOTION | TM_VISUALLY_DISTINCT),                                        "a glowing glyph",      "A strange glyph, engraved into the floor, radiates magical light."],
    [DEWAR_CHAR,    poisonGasColor,        darkGray,              10, 20, DF_DEWAR_CAUSTIC,0,         DF_DEWAR_CAUSTIC,0,             NO_LIGHT,       (T_OBSTRUCTS_PASSABILITY | T_OBSTRUCTS_SURFACE_EFFECTS | T_OBSTRUCTS_GAS | T_IS_FLAMMABLE), (TM_VANISHES_UPON_PROMOTION | TM_VISUALLY_DISTINCT | TM_LIST_IN_SIDEBAR | TM_PROMOTES_ON_PLAYER_ENTRY | TM_INVERT_WHEN_HIGHLIGHTED),"a glass dewar of caustic gas", ""],
    [DEWAR_CHAR,    confusionGasColor,     darkGray,              10, 20, DF_DEWAR_CONFUSION,0,       DF_DEWAR_CONFUSION,0,           NO_LIGHT,       (T_OBSTRUCTS_PASSABILITY | T_OBSTRUCTS_SURFACE_EFFECTS | T_OBSTRUCTS_GAS | T_IS_FLAMMABLE), (TM_VANISHES_UPON_PROMOTION | TM_VISUALLY_DISTINCT | TM_LIST_IN_SIDEBAR | TM_PROMOTES_ON_PLAYER_ENTRY | TM_INVERT_WHEN_HIGHLIGHTED),"a glass dewar of confusion gas", ""],
    [DEWAR_CHAR,    pink,                  darkGray,              10, 20, DF_DEWAR_PARALYSIS,0,       DF_DEWAR_PARALYSIS,0,           NO_LIGHT,       (T_OBSTRUCTS_PASSABILITY | T_OBSTRUCTS_SURFACE_EFFECTS | T_OBSTRUCTS_GAS | T_IS_FLAMMABLE), (TM_VANISHES_UPON_PROMOTION | TM_VISUALLY_DISTINCT | TM_LIST_IN_SIDEBAR | TM_PROMOTES_ON_PLAYER_ENTRY | TM_INVERT_WHEN_HIGHLIGHTED),"a glass dewar of paralytic gas", ""],
    [DEWAR_CHAR,    methaneColor,          darkGray,              10, 20, DF_DEWAR_METHANE,0,         DF_DEWAR_METHANE,0,             NO_LIGHT,       (T_OBSTRUCTS_PASSABILITY | T_OBSTRUCTS_SURFACE_EFFECTS | T_OBSTRUCTS_GAS | T_IS_FLAMMABLE), (TM_VANISHES_UPON_PROMOTION | TM_VISUALLY_DISTINCT | TM_LIST_IN_SIDEBAR | TM_PROMOTES_ON_PLAYER_ENTRY | TM_INVERT_WHEN_HIGHLIGHTED),"a glass dewar of methane gas", ""],

	// liquid layer
	[LIQUID_CHAR,	deepWaterForeColor,	deepWaterBackColor,	40,	100,DF_STEAM_ACCUMULATION,	0,	0,				0,				NO_LIGHT,		(T_IS_FLAMMABLE | T_IS_DEEP_WATER), (TM_ALLOWS_SUBMERGING | TM_STAND_IN_TILE | TM_EXTINGUISHES_FIRE),"the murky waters",    "the current tugs you in all directions."],
	[0,				shallowWaterForeColor,	shallowWaterBackColor,	55,	0,	DF_STEAM_ACCUMULATION,	0,	0,				0,				NO_LIGHT,		(0), (TM_STAND_IN_TILE | TM_EXTINGUISHES_FIRE | TM_ALLOWS_SUBMERGING),                              "shallow water",		"the water is cold and reaches your knees."],
	[MUD_CHAR,		mudForeColor,			mudBackColor,			55,	0,	DF_PLAIN_FIRE,	0,			DF_METHANE_GAS_PUFF, 100,		NO_LIGHT,		(0), (TM_STAND_IN_TILE | TM_ALLOWS_SUBMERGING),                                                     "a bog",				"you are knee-deep in thick, foul-smelling mud."],
	[CHASM_CHAR,	chasmForeColor,		black,					40,	0,	DF_PLAIN_FIRE,	0,			0,				0,				NO_LIGHT,		(T_AUTO_DESCENT), (TM_STAND_IN_TILE),																"a chasm",				"you plunge downward into the chasm!"],
	[FLOOR_CHAR,	white,					chasmEdgeBackColor,	80,	0,	DF_PLAIN_FIRE,	0,			0,				0,				NO_LIGHT,		0, 0,                                                                                               "the brink of a chasm",	"chilly winds blow upward from the stygian depths."],
	[FLOOR_CHAR,	floorForeColor,		floorBackColor,		95,	0,	DF_PLAIN_FIRE,	0,			DF_SPREADABLE_COLLAPSE,0,		NO_LIGHT,		(0), (TM_VANISHES_UPON_PROMOTION | TM_IS_WIRED),                                                    "the ground",			""],
	[FLOOR_CHAR,	white,					chasmEdgeBackColor,	45,	0,	DF_PLAIN_FIRE,	0,			DF_COLLAPSE_SPREADS,2500,		NO_LIGHT,		(0), (TM_VANISHES_UPON_PROMOTION),                                                                  "the crumbling ground",	"cracks are appearing in the ground beneath your feet!"],
	[LIQUID_CHAR,	fireForeColor,			lavaBackColor,			40,	0,	DF_OBSIDIAN,	0,			0,				0,				LAVA_LIGHT,		(T_LAVA_INSTA_DEATH), (TM_STAND_IN_TILE | TM_ALLOWS_SUBMERGING),									"lava",					"searing heat rises from the lava."],
	[LIQUID_CHAR,	fireForeColor,			lavaBackColor,			40,	0,	DF_OBSIDIAN,	0,			DF_RETRACTING_LAVA,	0,			LAVA_LIGHT,		(T_LAVA_INSTA_DEATH), (TM_STAND_IN_TILE | TM_VANISHES_UPON_PROMOTION | TM_IS_WIRED | TM_ALLOWS_SUBMERGING),"lava","searing heat rises from the lava."],
	[LIQUID_CHAR,	fireForeColor,			lavaBackColor,			40,	0,	DF_OBSIDIAN,	0,			DF_OBSIDIAN_WITH_STEAM,	-1500,	LAVA_LIGHT,		(T_LAVA_INSTA_DEATH), (TM_STAND_IN_TILE | TM_VANISHES_UPON_PROMOTION | TM_ALLOWS_SUBMERGING),		"cooling lava",         "searing heat rises from the lava."],
	[FLOOR_CHAR,	floorForeColor,		floorBackColor,		90,	0,	DF_PLAIN_FIRE,	0,			0,				0,				SUN_LIGHT,		(0), (TM_STAND_IN_TILE),																			"a patch of sunlight",	"sunlight streams through cracks in the ceiling."],
	[FLOOR_CHAR,	floorForeColor,		floorBackColor,		90,	0,	DF_PLAIN_FIRE,	0,			0,				0,				DARKNESS_PATCH_LIGHT,	(0), 0,																						"a patch of shadows",	"this area happens to be cloaked in shadows -- perhaps a safe place to hide."],
	[ASH_CHAR,		brimstoneForeColor,	brimstoneBackColor,	40, 100,DF_INERT_BRIMSTONE,	0,		DF_INERT_BRIMSTONE,	10,			NO_LIGHT,		(T_IS_FLAMMABLE | T_SPONTANEOUSLY_IGNITES), 0,                                                      "hissing brimstone",	"the jagged brimstone hisses and spits ominously as it crunches under your feet."],
	[ASH_CHAR,		brimstoneForeColor,	brimstoneBackColor,	40, 0,	DF_INERT_BRIMSTONE,	0,		DF_ACTIVE_BRIMSTONE, 800,		NO_LIGHT,		(T_SPONTANEOUSLY_IGNITES), 0,                                                                       "hissing brimstone",	"the jagged brimstone hisses and spits ominously as it crunches under your feet."],
	[FLOOR_CHAR,	darkGray,				obsidianBackColor,		50,	0,	DF_PLAIN_FIRE,	0,			0,				0,				NO_LIGHT,		0, 0,                                                                                               "the obsidian ground",	"the ground has fused into obsidian."],
	[BRIDGE_CHAR,	bridgeFrontColor,		bridgeBackColor,		45,	50,	DF_BRIDGE_FIRE,	0,			0,				0,				NO_LIGHT,		(T_IS_FLAMMABLE), (TM_VANISHES_UPON_PROMOTION),                                                     "a rickety rope bridge","the rickety rope bridge creaks underfoot."],
	[BRIDGE_CHAR,	bridgeFrontColor,		bridgeBackColor,		45,	50,	DF_BRIDGE_FALL,	0,			DF_BRIDGE_FALL, 10000,			NO_LIGHT,		(T_IS_FLAMMABLE), (TM_VANISHES_UPON_PROMOTION),                                                     "a plummeting bridge",  "the bridge is plunging into the chasm before your eyes!"],
	[BRIDGE_CHAR,	bridgeFrontColor,		bridgeBackColor,		45,	50,	DF_PLAIN_FIRE,	0,			0,				0,				NO_LIGHT,		(T_IS_FLAMMABLE), (TM_VANISHES_UPON_PROMOTION),                                                     "a rickety rope bridge","the rickety rope bridge is staked to the edge of the chasm."],
	[FLOOR_CHAR,	white,					chasmEdgeBackColor,	20,	50,	DF_BRIDGE_FIRE,	0,			0,				0,				NO_LIGHT,		0, 0,                                                                                               "a stone bridge",		"the narrow stone bridge winds precariously across the chasm."],
	[0,				shallowWaterForeColor,	shallowWaterBackColor,	60,	0,	DF_STEAM_ACCUMULATION,	0,	DF_SPREADABLE_WATER,0,			NO_LIGHT,		(0), (TM_STAND_IN_TILE | TM_VANISHES_UPON_PROMOTION | TM_IS_WIRED | TM_EXTINGUISHES_FIRE | TM_ALLOWS_SUBMERGING),	"shallow water",	"the water is cold and reaches your knees."],
	[0,				shallowWaterForeColor,	shallowWaterBackColor,	60,	0,	DF_STEAM_ACCUMULATION,	0,	DF_WATER_SPREADS,2500,			NO_LIGHT,		(0), (TM_STAND_IN_TILE | TM_VANISHES_UPON_PROMOTION | TM_EXTINGUISHES_FIRE | TM_ALLOWS_SUBMERGING),	"shallow water",		"the water is cold and reaches your knees."],
	[MUD_CHAR,		mudForeColor,			mudBackColor,			55,	0,	DF_PLAIN_FIRE,	0,			DF_MUD_ACTIVATE,0,				NO_LIGHT,		(0), (TM_STAND_IN_TILE | TM_VANISHES_UPON_PROMOTION | TM_IS_WIRED | TM_ALLOWS_SUBMERGING),			"a bog",				"you are knee-deep in thick, foul-smelling mud."],

	[BONES_CHAR,	white,                 lightBlue,             35, 100,DF_DEEP_WATER_THAW, 0,      DF_DEEP_WATER_MELTING, -100,    NO_LIGHT,       (T_IS_FLAMMABLE), (TM_VANISHES_UPON_PROMOTION),                                                     "ice",                  "a sheet of ice extends into the water, ripples frozen into its glossy surface."],
	[BONES_CHAR,	black,                 lightBlue,             35, 100,DF_DEEP_WATER_THAW, 0,      DF_DEEP_WATER_THAW, 10000,      NO_LIGHT,       (T_IS_FLAMMABLE), (TM_VANISHES_UPON_PROMOTION),                                                     "melting ice",          "cracks extend across the surface of the ice as it melts before your eyes."],
	[BONES_CHAR,	white,                 lightBlue,             35, 100,DF_SHALLOW_WATER_THAW, 0,   DF_SHALLOW_WATER_MELTING, -100, NO_LIGHT,       (T_IS_FLAMMABLE), (TM_VANISHES_UPON_PROMOTION),                                                     "ice",                  "a sheet of ice extends into the water, ripples frozen into its glossy surface."],
	[BONES_CHAR,	black,                 lightBlue,             35, 100,DF_DEEP_WATER_THAW, 0,      DF_SHALLOW_WATER_THAW, 10000,   NO_LIGHT,       (T_IS_FLAMMABLE), (TM_VANISHES_UPON_PROMOTION),                                                     "melting ice",          "cracks extend across the surface of the ice as it melts before your eyes."],

	// surface layer
	[CHASM_CHAR,	chasmForeColor,		black,					9,	0,	DF_PLAIN_FIRE,	0,			DF_HOLE_DRAIN,	-1000,			NO_LIGHT,		(T_AUTO_DESCENT), (TM_STAND_IN_TILE | TM_VANISHES_UPON_PROMOTION),                                  "a hole",				"you plunge downward into the hole!"],
    [CHASM_CHAR,	chasmForeColor,		black,					9,	0,	DF_PLAIN_FIRE,	0,			DF_HOLE_DRAIN,	-1000,			DESCENT_LIGHT,	(T_AUTO_DESCENT), (TM_STAND_IN_TILE | TM_VANISHES_UPON_PROMOTION),                                  "a hole",				"you plunge downward into the hole!"],
	[FLOOR_CHAR,	white,					chasmEdgeBackColor,	50,	0,	DF_PLAIN_FIRE,	0,			0,				-500,			NO_LIGHT,		(0), (TM_VANISHES_UPON_PROMOTION),																	"translucent ground",	"chilly gusts of air blow upward through the translucent floor."],
	[LIQUID_CHAR,	deepWaterForeColor,	deepWaterBackColor,	41,	100,DF_STEAM_ACCUMULATION,	0,	DF_FLOOD_DRAIN,	-200,			NO_LIGHT,		(T_IS_FLAMMABLE | T_IS_DEEP_WATER), (TM_STAND_IN_TILE | TM_VANISHES_UPON_PROMOTION | TM_EXTINGUISHES_FIRE | TM_ALLOWS_SUBMERGING), "sloshing water", "roiling water floods the room."],
	[0,				shallowWaterForeColor,	shallowWaterBackColor,	50,	0,	DF_STEAM_ACCUMULATION,	0,	DF_PUDDLE,		-100,			NO_LIGHT,		(0), (TM_STAND_IN_TILE | TM_VANISHES_UPON_PROMOTION | TM_EXTINGUISHES_FIRE | TM_ALLOWS_SUBMERGING),	"shallow water",		"knee-deep water drains slowly into holes in the floor."],
	[GRASS_CHAR,	grassColor,			0,						60,	15,	DF_PLAIN_FIRE,	0,			0,				0,				NO_LIGHT,		(T_IS_FLAMMABLE), (TM_STAND_IN_TILE | TM_VANISHES_UPON_PROMOTION),                                  "grass-like fungus",	"grass-like fungus crunches underfoot."],
	[GRASS_CHAR,	deadGrassColor,		0,						60,	40,	DF_PLAIN_FIRE,	0,			0,				0,				NO_LIGHT,		(T_IS_FLAMMABLE), (TM_STAND_IN_TILE | TM_VANISHES_UPON_PROMOTION),                                  "withered fungus",		"dead fungus covers the ground."],
	[GRASS_CHAR,	grayFungusColor,		0,						51,	10,	DF_PLAIN_FIRE,	0,			0,				0,				NO_LIGHT,		(T_IS_FLAMMABLE), (TM_STAND_IN_TILE | TM_VANISHES_UPON_PROMOTION),                                  "withered fungus",		"groping tendrils of pale fungus rise from the muck."],
	[GRASS_CHAR,	fungusColor,			0,						60,	10,	DF_PLAIN_FIRE,	0,			0,				0,				FUNGUS_LIGHT,	(T_IS_FLAMMABLE), (TM_STAND_IN_TILE | TM_VANISHES_UPON_PROMOTION),                                  "luminescent fungus",	"luminescent fungus casts a pale, eerie glow."],
	[GRASS_CHAR,	lichenColor,			0,						60,	50,	DF_PLAIN_FIRE,	0,			DF_LICHEN_GROW,	10000,			NO_LIGHT,		(T_CAUSES_POISON | T_IS_FLAMMABLE), (TM_STAND_IN_TILE | TM_VANISHES_UPON_PROMOTION),                "deadly lichen",		"venomous barbs cover the quivering tendrils of this fast-growing lichen."],
	[GRASS_CHAR,	hayColor,				refuseBackColor,		57,	50,	DF_STENCH_BURN,	0,			0,				0,				NO_LIGHT,		(T_IS_FLAMMABLE), (TM_STAND_IN_TILE | TM_VANISHES_UPON_PROMOTION),                                  "filthy hay",			"a pile of hay, matted with filth, has been arranged here as a makeshift bed."],
	[FLOOR_CHAR,	humanBloodColor,		0,						80,	0,	DF_PLAIN_FIRE,	0,			0,				0,				NO_LIGHT,		(0), (TM_STAND_IN_TILE),                                                                            "a pool of blood",		"the floor is splattered with blood."],
	[FLOOR_CHAR,	insectBloodColor,		0,						80,	0,	DF_PLAIN_FIRE,	0,			0,				0,				NO_LIGHT,		(0), (TM_STAND_IN_TILE),                                                                            "a pool of green blood", "the floor is splattered with green blood."],
	[FLOOR_CHAR,	poisonGasColor,		0,						80,	0,	DF_PLAIN_FIRE,	0,			0,				0,				NO_LIGHT,		(0), (TM_STAND_IN_TILE),                                                                            "a pool of purple blood", "the floor is splattered with purple blood."],
	[FLOOR_CHAR,	acidBackColor,			0,						80,	0,	DF_PLAIN_FIRE,	0,			0,				0,				NO_LIGHT,		0, 0,                                                                                               "a puddle of acid", "the floor is splattered with acid."],
	[FLOOR_CHAR,	vomitColor,			0,						80,	0,	DF_PLAIN_FIRE,	0,			0,				0,				NO_LIGHT,		(0), (TM_STAND_IN_TILE),                                                                            "a puddle of vomit",	"the floor is caked with vomit."],
	[FLOOR_CHAR,	urineColor,			0,						80,	0,	DF_PLAIN_FIRE,	0,			0,				100,			NO_LIGHT,		(0), (TM_STAND_IN_TILE | TM_VANISHES_UPON_PROMOTION),                                               "a puddle of urine",	"a puddle of urine covers the ground."],
	[FLOOR_CHAR,	white,					0,						80,	0,	DF_PLAIN_FIRE,	0,			0,				0,				UNICORN_POOP_LIGHT,(0), (TM_STAND_IN_TILE),                                                                         "unicorn poop",			"a pile of lavender-scented unicorn poop sparkles with rainbow light."],
	[FLOOR_CHAR,	wormColor,				0,						80,	0,	DF_PLAIN_FIRE,	0,			0,				0,				NO_LIGHT,		(0), (TM_STAND_IN_TILE),                                                                            "a pool of worm entrails", "worm viscera cover the ground."],
	[ASH_CHAR,		ashForeColor,			0,						80,	0,	DF_PLAIN_FIRE,	0,			0,				0,				NO_LIGHT,		(0), (TM_STAND_IN_TILE),                                                                            "a pile of ashes",		"charcoal and ash crunch underfoot."],
	[ASH_CHAR,		ashForeColor,			0,						87,	0,	DF_PLAIN_FIRE,	0,			0,				0,				NO_LIGHT,		(0), (TM_STAND_IN_TILE),                                                                            "burned carpet",		"the carpet has been scorched by an ancient fire."],
	[FLOOR_CHAR,	shallowWaterBackColor,	0,						80,	20,	0,				0,			0,				100,			NO_LIGHT,		(T_IS_FLAMMABLE), (TM_STAND_IN_TILE | TM_VANISHES_UPON_PROMOTION),                                  "a puddle of water",	"a puddle of water covers the ground."],
	[BONES_CHAR,	bonesForeColor,		0,						70,	0,	DF_PLAIN_FIRE,	0,			0,				0,				NO_LIGHT,		(0), (TM_STAND_IN_TILE),                                                                            "a pile of bones",		"unidentifiable bones, yellowed with age, litter the ground."],
	[BONES_CHAR,	gray,					0,						70,	0,	DF_PLAIN_FIRE,	0,			0,				0,				NO_LIGHT,		(0), (TM_STAND_IN_TILE),                                                                            "a pile of rubble",		"rocky rubble covers the ground."],
	[BONES_CHAR,	mudBackColor,			refuseBackColor,		50,	20,	DF_PLAIN_FIRE,	0,			0,				0,				NO_LIGHT,		(0), (TM_STAND_IN_TILE),                                                                            "a pile of filthy effects","primitive tools, carvings and trinkets are strewn about the area."],
    [BONES_CHAR,    white,                 0,                      70, 0,  DF_PLAIN_FIRE,  0,          0,              0,              NO_LIGHT,       (0), (TM_STAND_IN_TILE),                                                                            "shattered glass",      "jagged chunks of glass from the broken dewar litter the ground."],
	[FLOOR_CHAR,	ectoplasmColor,		0,						70,	0,	DF_PLAIN_FIRE,	0,			0,				0,				ECTOPLASM_LIGHT,(0), (TM_STAND_IN_TILE),                                                                            "ectoplasmic residue",	"a thick, glowing substance has congealed on the ground."],
	[ASH_CHAR,		fireForeColor,			0,						70,	0,	DF_PLAIN_FIRE,	0,			DF_ASH,			300,			EMBER_LIGHT,	(0), (TM_STAND_IN_TILE | TM_VANISHES_UPON_PROMOTION),                                               "sputtering embers",	"sputtering embers cover the ground."],
	[WEB_CHAR,		white,					0,						19,	100,DF_PLAIN_FIRE,	0,			0,				0,				NO_LIGHT,		(T_ENTANGLES | T_IS_FLAMMABLE), (TM_STAND_IN_TILE | TM_VANISHES_UPON_PROMOTION | TM_VISUALLY_DISTINCT),"a spiderweb",       "thick, sticky spiderwebs fill the area."],
    [WEB_CHAR,		brown,                 0,						19,	40, DF_PLAIN_FIRE,	0,			0,				0,				NO_LIGHT,		(T_ENTANGLES | T_IS_FLAMMABLE), (TM_STAND_IN_TILE | TM_VANISHES_UPON_PROMOTION | TM_VISUALLY_DISTINCT),"a net",             "a dense tangle of netting fills the area."],
	[FOLIAGE_CHAR,	foliageColor,			0,						45,	15,	DF_PLAIN_FIRE,	0,			DF_TRAMPLED_FOLIAGE, 0,			NO_LIGHT,		(T_OBSTRUCTS_VISION | T_IS_FLAMMABLE), (TM_STAND_IN_TILE | TM_VANISHES_UPON_PROMOTION | TM_PROMOTES_ON_STEP), "dense foliage",   "dense foliage fills the area, thriving on what sunlight trickles in."],
	[FOLIAGE_CHAR,	deadFoliageColor,		0,						45,	80,	DF_PLAIN_FIRE,	0,			DF_SMALL_DEAD_GRASS, 0,			NO_LIGHT,		(T_OBSTRUCTS_VISION | T_IS_FLAMMABLE), (TM_STAND_IN_TILE | TM_VANISHES_UPON_PROMOTION | TM_PROMOTES_ON_STEP), "dead foliage",    "the decaying husk of a fungal growth fills the area."],
	[TRAMPLED_FOLIAGE_CHAR,foliageColor,	0,						60,	15,	DF_PLAIN_FIRE,	0,			DF_FOLIAGE_REGROW, 100,			NO_LIGHT,		(T_IS_FLAMMABLE), (TM_VANISHES_UPON_PROMOTION),                                                     "trampled foliage",		"dense foliage fills the area, thriving on what sunlight trickles in."],
	[FOLIAGE_CHAR,	fungusForestLightColor,0,						45,	15,	DF_PLAIN_FIRE,	0,			DF_TRAMPLED_FUNGUS_FOREST, 0,	FUNGUS_FOREST_LIGHT,(T_OBSTRUCTS_VISION | T_IS_FLAMMABLE), (TM_STAND_IN_TILE | TM_VANISHES_UPON_PROMOTION | TM_PROMOTES_ON_STEP),"a luminescent fungal forest", "luminescent fungal growth fills the area, groping upward from the rich soil."],
	[TRAMPLED_FOLIAGE_CHAR,fungusForestLightColor,0,				60,	15,	DF_PLAIN_FIRE,	0,			DF_FUNGUS_FOREST_REGROW, 100,	FUNGUS_LIGHT,	(T_IS_FLAMMABLE), (TM_VANISHES_UPON_PROMOTION),                                                     "trampled fungal foliage", "luminescent fungal growth fills the area, groping upward from the rich soil."],
	[WALL_CHAR,		forceFieldColor,		forceFieldColor,		0,	0,	0,				0,			DF_FORCEFIELD_MELT, -200,		FORCEFIELD_LIGHT, (T_OBSTRUCTS_PASSABILITY | T_OBSTRUCTS_GAS | T_OBSTRUCTS_DIAGONAL_MOVEMENT), (TM_STAND_IN_TILE | TM_VANISHES_UPON_PROMOTION | TM_PROMOTES_ON_STEP),		"a green crystal",		"The translucent green crystal is melting away in front of your eyes."],
	[WALL_CHAR,		black,                 forceFieldColor,		0,	0,	0,				0,			0,				-10000,			FORCEFIELD_LIGHT, (T_OBSTRUCTS_PASSABILITY | T_OBSTRUCTS_GAS | T_OBSTRUCTS_DIAGONAL_MOVEMENT), (TM_STAND_IN_TILE | TM_VANISHES_UPON_PROMOTION),		"a dissolving crystal",		"The translucent green crystal is melting away in front of your eyes."],
    [CHASM_CHAR,    sacredGlyphColor,      0,                      57, 0,  0,              0,          0,              0,              SACRED_GLYPH_LIGHT, (T_SACRED), 0,                                                                                  "a sacred glyph",       "a sacred glyph adorns the floor, glowing with a powerful warding enchantment."],
	[CHAIN_TOP_LEFT,gray,					0,						20,	0,	0,				0,			0,				0,				NO_LIGHT,		0, 0,																								"an iron manacle",		"a thick iron manacle is anchored to the ceiling."],
	[CHAIN_BOTTOM_RIGHT, gray,				0,						20,	0,	0,				0,			0,				0,				NO_LIGHT,		0, 0,																								"an iron manacle",		"a thick iron manacle is anchored to the floor."],
	[CHAIN_TOP_RIGHT, gray,				0,						20,	0,	0,				0,			0,				0,				NO_LIGHT,		0, 0,																								"an iron manacle",		"a thick iron manacle is anchored to the ceiling."],
	[CHAIN_BOTTOM_LEFT, gray,				0,						20,	0,	0,				0,			0,				0,				NO_LIGHT,		0, 0,																								"an iron manacle",		"a thick iron manacle is anchored to the floor."],
	[CHAIN_TOP,		gray,					0,						20,	0,	0,				0,			0,				0,				NO_LIGHT,		0, 0,																								"an iron manacle",		"a thick iron manacle is anchored to the wall."],
	[CHAIN_BOTTOM,	gray,					0,						20,	0,	0,				0,			0,				0,				NO_LIGHT,		0, 0,																								"an iron manacle",		"a thick iron manacle is anchored to the wall."],
	[CHAIN_LEFT,	gray,					0,						20,	0,	0,				0,			0,				0,				NO_LIGHT,		0, 0,																								"an iron manacle",		"a thick iron manacle is anchored to the wall."],
	[CHAIN_RIGHT,	gray,					0,						20,	0,	0,				0,			0,				0,				NO_LIGHT,		0, 0,																								"an iron manacle",		"a thick iron manacle is anchored to the wall."],
	[0,				0,						0,						1,	0,	0,				0,			0,				10000,			PORTAL_ACTIVATE_LIGHT,(0), (TM_STAND_IN_TILE | TM_VANISHES_UPON_PROMOTION),											"blinding light",		"blinding light streams out of the archway."],
    [0,				0,						0,						100,0,	0,				0,			0,				10000,			GLYPH_LIGHT_BRIGHT,(0), (TM_STAND_IN_TILE | TM_VANISHES_UPON_PROMOTION),                                            "a red glow",           "a red glow fills the area."],

	// fire tiles
	[FIRE_CHAR,		fireForeColor,			0,						10,	0,	0,				0,			DF_EMBERS,		500,			FIRE_LIGHT,		(T_IS_FIRE), (TM_STAND_IN_TILE | TM_VANISHES_UPON_PROMOTION | TM_VISUALLY_DISTINCT),				"billowing flames",		"flames billow upward."],
	[FIRE_CHAR,		fireForeColor,			0,						10,	0,	0,				0,			0,				2500,			BRIMSTONE_FIRE_LIGHT,(T_IS_FIRE), (TM_STAND_IN_TILE | TM_VANISHES_UPON_PROMOTION | TM_VISUALLY_DISTINCT),           "sulfurous flames",		"sulfurous flames leap from the unstable bed of brimstone."],
	[FIRE_CHAR,		fireForeColor,			0,						10,	0,	0,				0,			DF_OBSIDIAN,	5000,			FIRE_LIGHT,		(T_IS_FIRE), (TM_STAND_IN_TILE | TM_VANISHES_UPON_PROMOTION | TM_VISUALLY_DISTINCT),				"clouds of infernal flame", "billowing infernal flames eat at the floor."],
	[FIRE_CHAR,		fireForeColor,			0,						10,	0,	0,              0,			0,              8000,			FIRE_LIGHT,		(T_IS_FIRE), (TM_STAND_IN_TILE | TM_VANISHES_UPON_PROMOTION | TM_VISUALLY_DISTINCT),				"a cloud of burning gas", "burning gas fills the air with flame."],
	[FIRE_CHAR,		yellow,				0,						10,	0,	0,				0,			0,              10000,			EXPLOSION_LIGHT,(T_IS_FIRE | T_CAUSES_EXPLOSIVE_DAMAGE), (TM_STAND_IN_TILE | TM_VANISHES_UPON_PROMOTION | TM_VISUALLY_DISTINCT), "a violent explosion",	"the force of the explosion slams into you."],
	[FIRE_CHAR,		white,					0,						10,	0,	0,				0,			0,				10000,			INCENDIARY_DART_LIGHT ,(T_IS_FIRE), (TM_STAND_IN_TILE | TM_VANISHES_UPON_PROMOTION | TM_VISUALLY_DISTINCT),			"a flash of fire",		"flames burst out of the incendiary dart."],
    [FIRE_CHAR,		white,                 0,						10,	0,	0,				0,			DF_EMBERS,		3000,			FIRE_LIGHT,		(T_IS_FIRE), (TM_STAND_IN_TILE | TM_VANISHES_UPON_PROMOTION | TM_VISUALLY_DISTINCT),				"crackling flames",		"crackling flames rise from the blackened item."],
    [FIRE_CHAR,		white,                 0,						10,	0,	0,				0,			DF_EMBERS,		3000,			FIRE_LIGHT,		(T_IS_FIRE), (TM_STAND_IN_TILE | TM_VANISHES_UPON_PROMOTION | TM_VISUALLY_DISTINCT),				"greasy flames",		"greasy flames rise from the corpse."],

	// gas layer
	[	' ',		0,						poisonGasColor,		35,	100,DF_GAS_FIRE,	0,			0,				0,				NO_LIGHT,		(T_IS_FLAMMABLE | T_CAUSES_DAMAGE), (TM_STAND_IN_TILE | TM_GAS_DISSIPATES),							"a cloud of caustic gas", "you can feel the purple gas eating at your flesh."],
	[	' ',		0,						confusionGasColor,		35,	100,DF_GAS_FIRE,	0,			0,				0,				CONFUSION_GAS_LIGHT,(T_IS_FLAMMABLE | T_CAUSES_CONFUSION), (TM_STAND_IN_TILE | TM_GAS_DISSIPATES_QUICKLY),			"a cloud of confusion gas", "the rainbow-colored gas tickles your brain."],
	[	' ',		0,						vomitColor,			35,	100,DF_GAS_FIRE,	0,			0,				0,				NO_LIGHT,		(T_IS_FLAMMABLE | T_CAUSES_NAUSEA), (TM_STAND_IN_TILE | TM_GAS_DISSIPATES_QUICKLY),					"a cloud of putrescence", "the stench of rotting flesh is overpowering."],
    [	' ',		0,						vomitColor,			35,	0,  DF_GAS_FIRE,	0,			0,				0,				NO_LIGHT,		(T_CAUSES_NAUSEA), (TM_STAND_IN_TILE | TM_GAS_DISSIPATES_QUICKLY),                                  "a cloud of putrid smoke", "you retch violently at the smell of the greasy smoke."],
	[	' ',		0,						pink,					35,	100,DF_GAS_FIRE,	0,			0,				0,				NO_LIGHT,		(T_IS_FLAMMABLE | T_CAUSES_PARALYSIS), (TM_STAND_IN_TILE | TM_GAS_DISSIPATES_QUICKLY),				"a cloud of paralytic gas", "the pale gas causes your muscles to stiffen."],
	[	' ',		0,						methaneColor,			35,	100,DF_GAS_FIRE,    0,          DF_EXPLOSION_FIRE, 0,			NO_LIGHT,		(T_IS_FLAMMABLE), (TM_STAND_IN_TILE | TM_EXPLOSIVE_PROMOTE),                                        "a cloud of explosive gas",	"the smell of explosive swamp gas fills the air."],
	[	' ',		0,						white,					35,	0,	DF_GAS_FIRE,	0,			0,				0,				NO_LIGHT,		(T_CAUSES_DAMAGE), (TM_STAND_IN_TILE | TM_GAS_DISSIPATES_QUICKLY),									"a cloud of scalding steam", "scalding steam fills the air!"],
	[	' ',		0,						0,						35,	0,	DF_GAS_FIRE,	0,			0,				0,				DARKNESS_CLOUD_LIGHT,	(0), (TM_STAND_IN_TILE),                                                                    "a cloud of supernatural darkness", "everything is obscured by an aura of supernatural darkness."],
	[	' ',		0,						darkRed,				35,	0,	DF_GAS_FIRE,	0,			0,				0,				NO_LIGHT,		(T_CAUSES_HEALING), (TM_STAND_IN_TILE | TM_GAS_DISSIPATES_QUICKLY),                                 "a cloud of healing spores", "bloodwort spores, renowned for their healing properties, fill the air."],

  // bloodwort pods
  [FOLIAGE_CHAR,  bloodflowerForeColor,  bloodflowerBackColor,  10, 20, DF_PLAIN_FIRE,  0,          DF_BLOODFLOWER_PODS_GROW, 100,  NO_LIGHT,       (T_OBSTRUCTS_PASSABILITY | T_OBSTRUCTS_ITEMS | T_IS_FLAMMABLE), (TM_LIST_IN_SIDEBAR | TM_VISUALLY_DISTINCT), "a bloodwort stalk", "this spindly plant grows seed pods famous for their healing properties."],
  [GOLD_CHAR,     bloodflowerPodForeColor, 0,                    11, 20, DF_BLOODFLOWER_POD_BURST,0, DF_BLOODFLOWER_POD_BURST, 0,    NO_LIGHT,       (T_OBSTRUCTS_PASSABILITY | T_OBSTRUCTS_ITEMS | T_IS_FLAMMABLE), (TM_STAND_IN_TILE | TM_VANISHES_UPON_PROMOTION | TM_PROMOTES_ON_PLAYER_ENTRY | TM_VISUALLY_DISTINCT | TM_INVERT_WHEN_HIGHLIGHTED), "a bloodwort pod", "the bloodwort seed pod bursts, releasing a cloud of healing spores."],

  // shrine accoutrements
  [BRIDGE_CHAR,	black,                 bedrollBackColor,      57,	50,	DF_PLAIN_FIRE,	0,			0,				0,				NO_LIGHT,		(T_IS_FLAMMABLE), (TM_VANISHES_UPON_PROMOTION),                                                     "an abandoned bedroll", "a bedroll lies in the corner, disintegrating with age."],

  // algae
  [FLOOR_CHAR,	floorForeColor,		floorBackColor,		95,	0,	DF_PLAIN_FIRE,	0,			DF_ALGAE_1,		100,			NO_LIGHT,		0, 0,                                                                                               "the ground",			""],
  [LIQUID_CHAR,	deepWaterForeColor,    deepWaterBackColor,	40,	100,DF_STEAM_ACCUMULATION,	0,	DF_ALGAE_1,     500,			LUMINESCENT_ALGAE_BLUE_LIGHT,(T_IS_FLAMMABLE | T_IS_DEEP_WATER), (TM_STAND_IN_TILE | TM_EXTINGUISHES_FIRE | TM_ALLOWS_SUBMERGING),	"luminescent waters",	"blooming algae fills the waters with a swirling luminescence."],
  [LIQUID_CHAR,	deepWaterForeColor,    deepWaterBackColor,	39,	100,DF_STEAM_ACCUMULATION,	0,	DF_ALGAE_REVERT,300,			LUMINESCENT_ALGAE_GREEN_LIGHT,(T_IS_FLAMMABLE | T_IS_DEEP_WATER), (TM_STAND_IN_TILE | TM_EXTINGUISHES_FIRE | TM_ALLOWS_SUBMERGING),	"luminescent waters",	"blooming algae fills the waters with a swirling luminescence."],

  // ancient spirit terrain
	[VINE_CHAR,		lichenColor,           0,						19,	100,DF_PLAIN_FIRE,	0,			DF_ANCIENT_SPIRIT_GRASS,1000,	NO_LIGHT,		(T_ENTANGLES | T_CAUSES_DAMAGE | T_IS_FLAMMABLE), (TM_STAND_IN_TILE | TM_VANISHES_UPON_PROMOTION | TM_VISUALLY_DISTINCT | TM_PROMOTES_ON_PLAYER_ENTRY),"thorned vines",       "thorned vines make a rustling noise as they quiver restlessly."],
  [GRASS_CHAR,	grassColor,			0,						60,	15,	DF_PLAIN_FIRE,	0,			0,				0,				NO_LIGHT,		(T_IS_FLAMMABLE), (TM_STAND_IN_TILE),                                                               "a tuft of grass",      "tufts of lush grass have improbably pushed upward through the stone ground."],

  // Yendor amulet floor tile
	[FLOOR_CHAR,	floorForeColor,		floorBackColor,		95,	0,	DF_PLAIN_FIRE,	0,			0,              0,				NO_LIGHT,       0, (TM_VANISHES_UPON_PROMOTION | TM_IS_WIRED | TM_PROMOTES_ON_ITEM_PICKUP),                         "the ground",           ""],

  // commutation device
	[ALTAR_CHAR,	altarForeColor,		greenAltarBackColor,   17, 0,	0,				0,			DF_ALTAR_COMMUTE,0,             NO_LIGHT,       (T_OBSTRUCTS_SURFACE_EFFECTS), (TM_VANISHES_UPON_PROMOTION | TM_IS_WIRED | TM_SWAP_ENCHANTS_ACTIVATION | TM_LIST_IN_SIDEBAR | TM_VISUALLY_DISTINCT),	"a commutation altar",	"crude diagrams on this altar and its twin invite you to place items upon them."],
  [ALTAR_CHAR,	black,                 greenAltarBackColor,   17, 0,	0,				0,			0,				0,				NO_LIGHT,       (T_OBSTRUCTS_SURFACE_EFFECTS), (TM_LIST_IN_SIDEBAR | TM_VISUALLY_DISTINCT),							"a scorched altar",     "scorch marks cover the surface of the altar, but it is cold to the touch."],
  ['+',           veryDarkGray,          0,                      45, 0,  DF_PLAIN_FIRE,  0,          DF_INERT_PIPE,  0,              CONFUSION_GAS_LIGHT, (0), (TM_IS_WIRED | TM_VANISHES_UPON_PROMOTION),                                               "glowing glass pipes",  "glass pipes are set into the floor and emit a soft glow of shifting color."],
  ['+',           black,                 0,                      45, 0,  DF_PLAIN_FIRE,  0,          0,              0,              NO_LIGHT,       (0), (0),                                                                                           "charred glass pipes",  "the inside of the glass pipes are charred."],

  // resurrection altar
	[ALTAR_CHAR,	altarForeColor,		goldAltarBackColor,    17, 0,	0,				0,			DF_ALTAR_RESURRECT,0,           CANDLE_LIGHT,   (T_OBSTRUCTS_SURFACE_EFFECTS), (TM_IS_WIRED | TM_LIST_IN_SIDEBAR | TM_VISUALLY_DISTINCT),           "a resurrection altar",	"the souls of the dead surround you. A deceased ally might be called back."],
  [ALTAR_CHAR,	black,                 goldAltarBackColor,    16, 0,	0,				0,			0,				0,				NO_LIGHT,       (T_OBSTRUCTS_SURFACE_EFFECTS), (TM_LIST_IN_SIDEBAR | TM_VISUALLY_DISTINCT),							"a scorched altar",     "scorch marks cover the surface of the altar, but it is cold to the touch."],
  [0,             0,                      0,                      95,	0,	0,              0,			0,				0,				NO_LIGHT,		(0), (TM_IS_WIRED | TM_PROMOTES_ON_PLAYER_ENTRY),                                                   "the ground",			""],

	// sacrifice altar
	[ALTAR_CHAR,	altarForeColor,		altarBackColor,   17, 0,	0,				0,			DF_SACRIFICE_ALTAR,0,           CANDLE_LIGHT,   (T_OBSTRUCTS_SURFACE_EFFECTS), (TM_VANISHES_UPON_PROMOTION | TM_IS_WIRED | TM_LIST_IN_SIDEBAR | TM_VISUALLY_DISTINCT), "a sacrifice altar",	"demonological symbols decorate this altar."],
	[ALTAR_CHAR,	altarForeColor,		altarBackColor,   17, 0,	0,				0,			DF_SACRIFICE_COMPLETE,0,        CANDLE_LIGHT,   (T_OBSTRUCTS_SURFACE_EFFECTS), (TM_VANISHES_UPON_PROMOTION | TM_IS_WIRED | TM_LIST_IN_SIDEBAR | TM_VISUALLY_DISTINCT | TM_PROMOTES_ON_SACRIFICE_ENTRY), "a sacrifice altar",	"demonological symbols decorate this altar."],
	[LIQUID_CHAR,	fireForeColor,		lavaBackColor,		40,	0,	DF_OBSIDIAN,	0,			0,				0,				LAVA_LIGHT,		(T_LAVA_INSTA_DEATH), (TM_ALLOWS_SUBMERGING | TM_LIST_IN_SIDEBAR),                                  "sacrificial pit",      "the smell of burnt flesh lingers over this pit of lava."],
	[WALL_CHAR,		altarBackColor,		veryDarkGray,			17, 0,	0,				0,			DF_SACRIFICE_CAGE_ACTIVE,	0,	CANDLE_LIGHT,	(T_OBSTRUCTS_PASSABILITY | T_OBSTRUCTS_SURFACE_EFFECTS), (TM_STAND_IN_TILE | TM_VANISHES_UPON_PROMOTION | TM_IS_WIRED | TM_LIST_IN_SIDEBAR | TM_VISUALLY_DISTINCT),"an iron cage","the cage won't budge. Perhaps there is a way to raise it nearby..."],
  [STATUE_CHAR,	wallBackColor,		statueBackColor,	 0,	0,	DF_PLAIN_FIRE,	0,			0,				0,				DEMONIC_STATUE_LIGHT,	(T_OBSTRUCTS_PASSABILITY | T_OBSTRUCTS_ITEMS | T_OBSTRUCTS_GAS | T_OBSTRUCTS_SURFACE_EFFECTS), (TM_STAND_IN_TILE),	"a demonic statue",	"An obsidian statue of a leering demon looms over the room."],

  // doorway statues
  [STATUE_CHAR,	wallBackColor,			statueBackColor,		0,	0,	DF_PLAIN_FIRE,	0,			0,				0,				NO_LIGHT,		(T_OBSTRUCTS_PASSABILITY | T_OBSTRUCTS_ITEMS | T_OBSTRUCTS_GAS | T_OBSTRUCTS_SURFACE_EFFECTS), (TM_STAND_IN_TILE | TM_CONNECTS_LEVEL),	"a marble statue",	"The cold marble statue has weathered the years with grace."],
	[STATUE_CHAR,	wallBackColor,			statueBackColor,		0,	0,	DF_PLAIN_FIRE,	0,			DF_CRACKING_STATUE,0,			NO_LIGHT,		(T_OBSTRUCTS_PASSABILITY | T_OBSTRUCTS_ITEMS | T_OBSTRUCTS_GAS | T_OBSTRUCTS_SURFACE_EFFECTS), (TM_STAND_IN_TILE | TM_VANISHES_UPON_PROMOTION | TM_IS_WIRED | TM_CONNECTS_LEVEL),"a marble statue",	"The cold marble statue has weathered the years with grace."],

  // extensible stone bridge
	[CHASM_CHAR,	chasmForeColor,		black,					40,	0,	DF_PLAIN_FIRE,	0,			0,              0,              NO_LIGHT,		(T_AUTO_DESCENT), (TM_STAND_IN_TILE),                                                               "a chasm",				"you plunge downward into the chasm!"],
	[FLOOR_CHAR,	white,					chasmEdgeBackColor,	40,	0,	DF_PLAIN_FIRE,	0,			DF_BRIDGE_ACTIVATE,6000,        NO_LIGHT,		(0), (TM_VANISHES_UPON_PROMOTION),                                                                  "a stone bridge",		"the narrow stone bridge is extending across the chasm."],
	[FLOOR_CHAR,	white,					chasmEdgeBackColor,	80,	0,	DF_PLAIN_FIRE,	0,			DF_BRIDGE_ACTIVATE_ANNOUNCE,0,	NO_LIGHT,		(0), (TM_IS_WIRED),                                                                                 "the brink of a chasm",	"chilly winds blow upward from the stygian depths."],

  // rat trap
  [WALL_CHAR,		wallForeColor,			wallBackColor,			0,	0,	DF_PLAIN_FIRE,	0,			DF_WALL_CRACK,  0,              NO_LIGHT,		(T_OBSTRUCTS_EVERYTHING), (TM_STAND_IN_TILE | TM_VANISHES_UPON_PROMOTION | TM_IS_WIRED),			"a stone wall",			"The rough stone wall is firm and unyielding."],
  [WALL_CHAR,		wallForeColor,			wallBackColor,			0,	0,	DF_PLAIN_FIRE,	0,			DF_WALL_SHATTER,500,			NO_LIGHT,		(T_OBSTRUCTS_EVERYTHING), (TM_STAND_IN_TILE | TM_VANISHES_UPON_PROMOTION | TM_LIST_IN_SIDEBAR),     "a cracking wall",		"Cracks are running ominously across the base of this rough stone wall."],

  // electric crystals
	[ELECTRIC_CRYSTAL_CHAR, wallCrystalColor, graniteBackColor,   0,  0,  DF_PLAIN_FIRE,  0,          DF_ELECTRIC_CRYSTAL_ON, 0,      NO_LIGHT,       (T_OBSTRUCTS_PASSABILITY | T_OBSTRUCTS_ITEMS | T_OBSTRUCTS_GAS | T_OBSTRUCTS_SURFACE_EFFECTS), (TM_STAND_IN_TILE | TM_PROMOTES_ON_ELECTRICITY | TM_IS_CIRCUIT_BREAKER | TM_IS_WIRED | TM_LIST_IN_SIDEBAR), "a darkened crystal globe", "A slight electric shock startles you when you touch the inert crystal globe."],
  [ELECTRIC_CRYSTAL_CHAR, white,         wallCrystalColor,      0,  0,  DF_PLAIN_FIRE,  0,          0,              0,              CRYSTAL_WALL_LIGHT,(T_OBSTRUCTS_PASSABILITY | T_OBSTRUCTS_ITEMS | T_OBSTRUCTS_GAS | T_OBSTRUCTS_SURFACE_EFFECTS), (TM_STAND_IN_TILE | TM_LIST_IN_SIDEBAR), "a shining crystal globe", "Crackling light streams out of the crystal globe."],
  [LEVER_CHAR,	wallForeColor,			wallBackColor,			0,	0,	DF_PLAIN_FIRE,	0,			DF_TURRET_LEVER,0,              NO_LIGHT,		(T_OBSTRUCTS_EVERYTHING), (TM_STAND_IN_TILE | TM_VANISHES_UPON_PROMOTION | TM_PROMOTES_ON_PLAYER_ENTRY | TM_LIST_IN_SIDEBAR | TM_VISUALLY_DISTINCT | TM_INVERT_WHEN_HIGHLIGHTED),"a lever", "The lever moves."],

  // worm tunnels
	[0,				0,						0,						100,0,	0,				0,			DF_WORM_TUNNEL_MARKER_ACTIVE,0, NO_LIGHT,       (0), (TM_VANISHES_UPON_PROMOTION | TM_IS_WIRED),                                                    "",                     ""],
	[0,				0,						0,						100,0,	0,				0,			DF_GRANITE_CRUMBLES,-2000,		NO_LIGHT,		(0), (TM_VANISHES_UPON_PROMOTION),                                                                  "a rough granite wall",	"The granite is split open with splinters of rock jutting out at odd angles."],
	[WALL_CHAR,		wallForeColor,			wallBackColor,			0,	0,	DF_PLAIN_FIRE,	0,			DF_WALL_SHATTER,0,				NO_LIGHT,		(T_OBSTRUCTS_EVERYTHING), (TM_STAND_IN_TILE | TM_VANISHES_UPON_PROMOTION | TM_IS_WIRED | TM_CONNECTS_LEVEL),"a stone wall", "The rough stone wall is firm and unyielding."],

    // zombie crypt
	[FIRE_CHAR,		fireForeColor,			statueBackColor,       0,	0,	DF_PLAIN_FIRE,	0,			0,				0,				BURNING_CREATURE_LIGHT,	(T_OBSTRUCTS_PASSABILITY | T_OBSTRUCTS_ITEMS | T_IS_FIRE), (TM_STAND_IN_TILE | TM_LIST_IN_SIDEBAR),"a ceremonial brazier",		"The ancient brazier smolders with a deep crimson flame."],

    // goblin warren
    [FLOOR_CHAR,    mudBackColor,          refuseBackColor,       85,	0,	DF_STENCH_SMOLDER,0,		0,				0,				NO_LIGHT,		(T_IS_FLAMMABLE), (TM_VANISHES_UPON_PROMOTION),                                                     "the mud floor",		"Rotting animal matter has been ground into the mud floor; the stench is awful."],
    [WALL_CHAR,		mudWallForeColor,		mudWallBackColor,		0,	0,	DF_PLAIN_FIRE,	0,			0,				0,				NO_LIGHT,		(T_OBSTRUCTS_EVERYTHING), (TM_STAND_IN_TILE),														"a mud-covered wall",	"A malodorous layer of clay and fecal matter coats the wall."],
    [OMEGA_CHAR,	mudWallForeColor,      refuseBackColor,		25,	50,	DF_EMBERS,		0,			0,              0,				NO_LIGHT,		(T_OBSTRUCTS_VISION | T_OBSTRUCTS_GAS | T_IS_FLAMMABLE), (TM_STAND_IN_TILE | TM_VISUALLY_DISTINCT), "hanging animal skins",	"you push through the animal skins that hang across the threshold."],
].map( (v) => floorTileType(...v) );


//#pragma mark Dungeon Feature definitions

// Features in the gas layer use the startprob as volume, ignore probdecr, and spawn in only a single point.
// Intercepts and slopes are in units of 0.01.
const dungeonFeatureCatalog = [
	// tileType					layer		start	decr	fl	txt  flare   fCol fRad	propTerrain	subseqDF
	[0], // nothing
	[GRANITE,					DUNGEON,	80,		70,		DFF_CLEAR_OTHER_TERRAIN],
	[CRYSTAL_WALL,				DUNGEON,	200,	50,		DFF_CLEAR_OTHER_TERRAIN],
	[LUMINESCENT_FUNGUS,		SURFACE,	60,		8,		DFF_BLOCKED_BY_OTHER_LAYERS],
	[GRASS,						SURFACE,	75,		5,		DFF_BLOCKED_BY_OTHER_LAYERS],
	[DEAD_GRASS,				SURFACE,	75,		5,		DFF_BLOCKED_BY_OTHER_LAYERS,	"", 0,	0,	0,		0,			DF_DEAD_FOLIAGE],
	[BONES,						SURFACE,	75,		23,		0],
	[RUBBLE,					SURFACE,	45,		23,		0],
	[FOLIAGE,					SURFACE,	100,	33,		(DFF_BLOCKED_BY_OTHER_LAYERS)],
	[FUNGUS_FOREST,				SURFACE,	100,	45,		(DFF_BLOCKED_BY_OTHER_LAYERS)],
	[DEAD_FOLIAGE,				SURFACE,	50,		30,		(DFF_BLOCKED_BY_OTHER_LAYERS)],

	// misc. liquids
	[SUNLIGHT_POOL,				LIQUID,		65,		6,		0],
	[DARKNESS_PATCH,			LIQUID,		65,		11,		0],

	// Dungeon features spawned during gameplay:

	// revealed secrets
	[DOOR,						DUNGEON,	0,		0,		0, "", GENERIC_FLASH_LIGHT],
	[GAS_TRAP_POISON,			DUNGEON,	0,		0,		0, "", GENERIC_FLASH_LIGHT],
	[GAS_TRAP_PARALYSIS,		DUNGEON,	0,		0,		0, "", GENERIC_FLASH_LIGHT],
	[CHASM_EDGE,				LIQUID,		100,	100,	0, "", GENERIC_FLASH_LIGHT],
	[TRAP_DOOR,					LIQUID,		0,		0,		DFF_CLEAR_OTHER_TERRAIN, "", GENERIC_FLASH_LIGHT, 0, 0, 0, DF_SHOW_TRAPDOOR_HALO],
	[GAS_TRAP_CONFUSION,		DUNGEON,	0,		0,		0, "", GENERIC_FLASH_LIGHT],
	[FLAMETHROWER,				DUNGEON,	0,		0,		0, "", GENERIC_FLASH_LIGHT],
	[FLOOD_TRAP,				DUNGEON,	0,		0,		0, "", GENERIC_FLASH_LIGHT],
	[NET_TRAP,                  DUNGEON,	0,		0,		0, "", GENERIC_FLASH_LIGHT],
	[ALARM_TRAP,                DUNGEON,	0,		0,		0, "", GENERIC_FLASH_LIGHT],

	// bloods
	// Start probability is actually a percentage for bloods.
	// Base probability is 15 + (damage * 2/3), and then take the given percentage of that.
	// If it's a gas, we multiply the base by an additional 100.
	// Thus to get a starting gas volume of a poison potion (1000), with a hit for 10 damage, use a starting probability of 48.
	[RED_BLOOD,					SURFACE,	100,	25,		0],
	[GREEN_BLOOD,				SURFACE,	100,	25,		0],
	[PURPLE_BLOOD,				SURFACE,	100,	25,		0],
	[WORM_BLOOD,				SURFACE,	100,	25,		0],
	[ACID_SPLATTER,				SURFACE,	200,	25,		0],
	[ASH,						SURFACE,	50,		25,		0],
	[EMBERS,					SURFACE,	125,	25,		0],
	[ECTOPLASM,					SURFACE,	110,	25,		0],
	[RUBBLE,					SURFACE,	33,		25,		0],
	[ROT_GAS,					GAS,		12,		0,		0],

	// monster effects
	[VOMIT,						SURFACE,	30,		10,		0],
	[POISON_GAS,				GAS,		2000,	0,		0],
    [GAS_EXPLOSION,				SURFACE,	350,	100,	0,	"", EXPLOSION_FLARE_LIGHT],
	[RED_BLOOD,					SURFACE,	150,	30,		0],
	[FLAMEDANCER_FIRE,			SURFACE,	200,	75,		0],

    // mutation effects
    [GAS_EXPLOSION,				SURFACE,	350,	100,	0,	"The corpse detonates with terrifying force!", EXPLOSION_FLARE_LIGHT],
	[LICHEN,					SURFACE,	70,		60,		0,  "Poisonous spores burst from the corpse!"],

	// misc
	[NOTHING,					GAS,		0,		0,		DFF_EVACUATE_CREATURES_FIRST],
	[ROT_GAS,					GAS,		15,		0,		0],
	[STEAM,						GAS,		325,	0,		0],
	[STEAM,						GAS,		15,		0,		0],
	[METHANE_GAS,				GAS,		2,		0,		0],
	[EMBERS,					SURFACE,	0,		0,		0],
	[URINE,						SURFACE,	65,		25,		0],
	[UNICORN_POOP,				SURFACE,	65,		40,		0],
	[PUDDLE,					SURFACE,	13,		25,		0],
	[ASH,						SURFACE,	0,		0,		0],
	[ECTOPLASM,					SURFACE,	0,		0,		0],
	[FORCEFIELD,				SURFACE,	100,	50,		0],
    [FORCEFIELD_MELT,           SURFACE,    0,      0,      0],
    [SACRED_GLYPH,              LIQUID,     100,    100,    0,  "", EMPOWERMENT_LIGHT],
	[LICHEN,					SURFACE,	2,		100,	(DFF_BLOCKED_BY_OTHER_LAYERS)], // Lichen won't spread through lava.
	[RUBBLE,					SURFACE,	45,		23,		(DFF_ACTIVATE_DORMANT_MONSTER)],
	[RUBBLE,					SURFACE,	0,		0,		(DFF_ACTIVATE_DORMANT_MONSTER)],

    [SPIDERWEB,                 SURFACE,    15,     12,     0],
    [SPIDERWEB,                 SURFACE,    100,    39,     0],

    [ANCIENT_SPIRIT_VINES,      SURFACE,    75,     70,     0],
    [ANCIENT_SPIRIT_GRASS,      SURFACE,    50,     47,     0],

	// foliage
	[TRAMPLED_FOLIAGE,			SURFACE,	0,		0,		0],
	[DEAD_GRASS,				SURFACE,	75,		75,		0],
	[FOLIAGE,					SURFACE,	0,		0,		(DFF_BLOCKED_BY_OTHER_LAYERS)],
	[TRAMPLED_FUNGUS_FOREST,	SURFACE,	0,		0,		0],
	[FUNGUS_FOREST,				SURFACE,	0,		0,		(DFF_BLOCKED_BY_OTHER_LAYERS)],

	// brimstone
	[ACTIVE_BRIMSTONE,			LIQUID,		0,		0,		0],
	[INERT_BRIMSTONE,			LIQUID,		0,		0,		0,	"", 0,	0,	0,		0,			DF_BRIMSTONE_FIRE],

    // bloodwort
    [BLOODFLOWER_POD,           SURFACE,    60,     60,     DFF_EVACUATE_CREATURES_FIRST],
    [BLOODFLOWER_POD,           SURFACE,    10,     10,     DFF_EVACUATE_CREATURES_FIRST],
	[HEALING_CLOUD,				GAS,		350,	0,		0],

    // dewars
    [POISON_GAS,                GAS,        20000,  0,      0, "the dewar shatters and pressurized caustic gas explodes outward!", 0, poisonGasColor, 4, 0, DF_DEWAR_GLASS],
    [CONFUSION_GAS,             GAS,        20000,  0,      0, "the dewar shatters and pressurized confusion gas explodes outward!", 0, confusionGasColor, 4, 0, DF_DEWAR_GLASS],
    [PARALYSIS_GAS,             GAS,        20000,  0,      0, "the dewar shatters and pressurized paralytic gas explodes outward!", 0, pink, 4, 0, DF_DEWAR_GLASS],
    [METHANE_GAS,               GAS,        20000,  0,      0, "the dewar shatters and pressurized methane gas explodes outward!", 0, methaneColor, 4, 0, DF_DEWAR_GLASS],
    [BROKEN_GLASS,              SURFACE,    100,    70,     0],
    [CARPET,                    DUNGEON,    120,    20,     0],

    // algae
    [DEEP_WATER_ALGAE_WELL,     DUNGEON,    0,      0,      DFF_SUPERPRIORITY],
    [DEEP_WATER_ALGAE_1,		LIQUID,		50,		100,	0,  "", 0,  0,   0,     DEEP_WATER, DF_ALGAE_2],
    [DEEP_WATER_ALGAE_2,        LIQUID,     0,      0,      0],
    [DEEP_WATER,                LIQUID,     0,      0,      DFF_SUPERPRIORITY],

	// doors, item cages, altars, glyphs, guardians -- reusable machine components
	[OPEN_DOOR,					DUNGEON,	0,		0,		0],
	[DOOR,						DUNGEON,	0,		0,		0],
	[OPEN_IRON_DOOR_INERT,		DUNGEON,	0,		0,		0,  "", GENERIC_FLASH_LIGHT],
	[ALTAR_CAGE_OPEN,			DUNGEON,	0,		0,		0,	"the cages lift off of the altars as you approach.", GENERIC_FLASH_LIGHT],
	[ALTAR_CAGE_CLOSED,			DUNGEON,	0,		0,		(DFF_EVACUATE_CREATURES_FIRST), "the cages lower to cover the altars.", GENERIC_FLASH_LIGHT],
	[ALTAR_INERT,				DUNGEON,	0,		0,		0],
	[FLOOR_FLOODABLE,			DUNGEON,	0,		0,		0,	"the altar retracts into the ground with a grinding sound.", GENERIC_FLASH_LIGHT],
	[PORTAL_LIGHT,				SURFACE,	0,		0,		(DFF_EVACUATE_CREATURES_FIRST | DFF_ACTIVATE_DORMANT_MONSTER), "the archway flashes, and you catch a glimpse of another world!"],
    [MACHINE_GLYPH_INACTIVE,    DUNGEON,    0,      0,      0],
    [MACHINE_GLYPH,             DUNGEON,    0,      0,      0],
    [GUARDIAN_GLOW,             SURFACE,    0,      0,      0,  ""],
    [GUARDIAN_GLOW,             SURFACE,    0,      0,      0,  "the glyph beneath you glows, and the guardians take a step!"],
    [GUARDIAN_GLOW,             SURFACE,    0,      0,      0,  "the mirrored totem flashes, reflecting the red glow of the glyph beneath you."],
    [MACHINE_GLYPH,             DUNGEON,    200,    95,     DFF_BLOCKED_BY_OTHER_LAYERS],
    [WALL_LEVER,                DUNGEON,    0,      0,      0,  "you notice a lever hidden behind a loose stone in the wall.", GENERIC_FLASH_LIGHT],
    [WALL_LEVER_PULLED,         DUNGEON,    0,      0,      0],
    [WALL_LEVER_HIDDEN,         DUNGEON,    0,      0,      0],

    [BRIDGE_FALLING,            LIQUID,     200,    100,    0, "", 0, 0, 0, BRIDGE],
    [CHASM,                     LIQUID,     0,      0,      0, "", GENERIC_FLASH_LIGHT, 0, 0, 0, DF_BRIDGE_FALL_PREP],

	// fire
	[PLAIN_FIRE,				SURFACE,	0,		0,		0],
	[GAS_FIRE,					SURFACE,	0,		0,		0],
	[GAS_EXPLOSION,				SURFACE,	60,		17,		0],
	[DART_EXPLOSION,			SURFACE,	0,		0,		0],
	[BRIMSTONE_FIRE,			SURFACE,	0,		0,		0],
	[0,                         0,          0,		0,		0,	"the rope bridge snaps from the heat and plunges into the chasm!", FALLEN_TORCH_FLASH_LIGHT,	0,	0,		0,		DF_BRIDGE_FALL],
	[PLAIN_FIRE,				SURFACE,	100,	37,		0],
	[EMBERS,					SURFACE,	0,		0,		0],
	[EMBERS,					SURFACE,	100,	94,		0],
	[OBSIDIAN,					SURFACE,	0,		0,		0],
    [ITEM_FIRE,                 SURFACE,    0,      0,      0,  "", FALLEN_TORCH_FLASH_LIGHT],
    [CREATURE_FIRE,             SURFACE,    0,      0,      0,  "", FALLEN_TORCH_FLASH_LIGHT],

	[FLOOD_WATER_SHALLOW,		SURFACE,	225,	37,		0,	"", 0,	0,	0,		0,			DF_FLOOD_2],
	[FLOOD_WATER_DEEP,			SURFACE,	175,	37,		0,	"the area is flooded as water rises through imperceptible holes in the ground."],
	[FLOOD_WATER_SHALLOW,		SURFACE,	10,		25,		0],
	[HOLE,						SURFACE,	200,	100,	0],
	[HOLE_EDGE,					SURFACE,	0,		0,		0],

	// ice effects
	[ICE_DEEP,                  LIQUID,     150,	50,		DFF_EVACUATE_CREATURES_FIRST,	"", 0,	0,	0,		DEEP_WATER,			DF_ALGAE_1_FREEZE],
	[ICE_DEEP,                  LIQUID,     150,	50,		DFF_EVACUATE_CREATURES_FIRST,	"", 0,	0,	0,		DEEP_WATER_ALGAE_1,	DF_ALGAE_2_FREEZE],
	[ICE_DEEP,                  LIQUID,     150,	50,		DFF_EVACUATE_CREATURES_FIRST,	"", 0,	0,	0,		DEEP_WATER_ALGAE_2,	DF_SHALLOW_WATER_FREEZE],
	[ICE_DEEP_MELT,             LIQUID,     0,      0,      0],
	[DEEP_WATER,                LIQUID,     0,      0,      0],
	[ICE_SHALLOW,               LIQUID,     100,	50,		DFF_EVACUATE_CREATURES_FIRST,	"", 0,	0,	0,		SHALLOW_WATER],
	[ICE_SHALLOW_MELT,          LIQUID,     0,      0,      0],
	[SHALLOW_WATER,             LIQUID,     0,      0,      0],

	// gas trap effects
	[POISON_GAS,				GAS,		1000,	0,		0,	"a cloud of caustic gas sprays upward from the floor!"],
	[CONFUSION_GAS,				GAS,		300,	0,		0,	"a sparkling cloud of confusion gas sprays upward from the floor!"],
  [NETTING,                   SURFACE,    300,    90,     0,  "a net falls from the ceiling!"],
  [0,                         0,          0,      0,      DFF_AGGRAVATES_MONSTERS, "a piercing shriek echoes through the nearby rooms!", 0, 0, DCOLS/2],
	[METHANE_GAS,				GAS,		10000,	0,		0], // debugging t]y

	// potions
	[POISON_GAS,				GAS,		1000,	0,		0,	"", 0,	poisonGasColor,4],
	[PARALYSIS_GAS,				GAS,		1000,	0,		0,	"", 0,	pink,4],
	[CONFUSION_GAS,				GAS,		1000,	0,		0,	"", 0,	confusionGasColor, 4],
	[PLAIN_FIRE,				SURFACE,	100,	37,		0,	"", EXPLOSION_FLARE_LIGHT],
	[DARKNESS_CLOUD,			GAS,		200,	0,		0],
	[HOLE_EDGE,					SURFACE,	300,	100,	0,	"", 0,	darkBlue,3,0,			DF_HOLE_2],
	[LICHEN,					SURFACE,	70,		60,		0],

// other items
  [PLAIN_FIRE,				SURFACE,	100,	45,		0,	"", 0,	yellow,3],
	[HOLE_GLOW,					SURFACE,	200,	100,	DFF_SUBSEQ_EVERYWHERE,	"", 0,	darkBlue,3,0,			DF_STAFF_HOLE_EDGE],
  [HOLE_EDGE,					SURFACE,	100,	100,	0],

	// machine components

  // commutation altars
  [COMMUTATION_ALTAR_INERT,   DUNGEON,    0,      0,      0,  "the items on the two altars flash with a brilliant light!", SCROLL_ENCHANTMENT_LIGHT],
  [PIPE_GLOWING,              SURFACE,    90,     60,     0],
  [PIPE_INERT,                SURFACE,    0,      0,      0,  "", SCROLL_ENCHANTMENT_LIGHT],

  // resurrection altars
  [RESURRECTION_ALTAR_INERT,  DUNGEON,    0,      0,      DFF_RESURRECT_ALLY, "An old friend emerges from a bloom of sacred light!", EMPOWERMENT_LIGHT],
  [MACHINE_TRIGGER_FLOOR_REPEATING, LIQUID, 300,  100,    DFF_SUPERPRIORITY],

	// sacrifice altars
	[SACRIFICE_ALTAR,           DUNGEON,    0,      0,      0,  "a demonic presence whispers its demand: \"bring to me the marked sacrifice!\""],
	[SACRIFICE_LAVA,            DUNGEON,    0,      0,      0,  "demonic cackling echoes through the room as the altar plunges downward!"],
	[ALTAR_CAGE_RETRACTABLE,    DUNGEON,    0,      0,      0],

	// coffin bursts open to reveal vampire:
	[COFFIN_OPEN,				DUNGEON,	0,		0,		DFF_ACTIVATE_DORMANT_MONSTER,	"the coffin opens and a dark figure rises!", 0, darkGray, 3],
	[PLAIN_FIRE,				SURFACE,	0,		0,		DFF_ACTIVATE_DORMANT_MONSTER,	"as flames begin to lick the coffin, its tenant bursts forth!", 0, 0, 0, 0, DF_EMBERS_PATCH],
	[MACHINE_TRIGGER_FLOOR,		DUNGEON,	200,	100,	0],

	// throwing tutorial:
	[ALTAR_INERT,				DUNGEON,	0,		0,		0,	"the cage lifts off of the altar.", GENERIC_FLASH_LIGHT],
	[TRAP_DOOR,					LIQUID,		225,	100,	(DFF_CLEAR_OTHER_TERRAIN | DFF_SUBSEQ_EVERYWHERE), "", 0, 0, 0, 0, DF_SHOW_TRAPDOOR_HALO],
	[LAVA,						LIQUID,		225,	100,	(DFF_CLEAR_OTHER_TERRAIN)],
  [MACHINE_PRESSURE_PLATE_USED,DUNGEON,   0,      0,      0],

  // rat trap:
  [RAT_TRAP_WALL_CRACKING,    DUNGEON,    0,      0,      0,  "a scratching sound emanates from the nearby walls!", 0, 0, 0, 0, DF_RUBBLE],

	// wooden barricade at entrance:
	[PLAIN_FIRE,				SURFACE,	0,		0,		0,	"flames quickly consume the wooden barricade."],

	// wooden barricade around altar:
	[WOODEN_BARRICADE,          DUNGEON,	220,	100,	(DFF_TREAT_AS_BLOCKING | DFF_SUBSEQ_EVERYWHERE), "", 0, 0, 0, 0, DF_SMALL_DEAD_GRASS],

	// shallow water flood machine:
	[MACHINE_FLOOD_WATER_SPREADING,	LIQUID,	0,		0,		0,	"you hear a heavy click, and the nearby water begins flooding the area!"],
	[SHALLOW_WATER,				LIQUID,		0,		0,		0],
	[MACHINE_FLOOD_WATER_SPREADING,LIQUID,	100,	100,	0,	"", 0,	0,	0,		FLOOR_FLOODABLE,			DF_SHALLOW_WATER],
	[MACHINE_FLOOD_WATER_DORMANT,LIQUID,	250,	100,	(DFF_TREAT_AS_BLOCKING), "", 0, 0, 0, 0,            DF_SPREADABLE_DEEP_WATER_POOL],
	[DEEP_WATER,				LIQUID,		90,		100,	(DFF_CLEAR_OTHER_TERRAIN | DFF_PERMIT_BLOCKING)],

	// unstable floor machine:
	[MACHINE_COLLAPSE_EDGE_SPREADING,LIQUID,0,		0,		0,	"you hear a deep rumbling noise as the floor begins to collapse!"],
	[CHASM,						LIQUID,		0,		0,		DFF_CLEAR_OTHER_TERRAIN, "", 0, 0, 0, 0, DF_SHOW_TRAPDOOR_HALO],
	[MACHINE_COLLAPSE_EDGE_SPREADING,LIQUID,100,	100,	0,	"", 0,	0,	0,	FLOOR_FLOODABLE,	DF_COLLAPSE],
	[MACHINE_COLLAPSE_EDGE_DORMANT,LIQUID,	0,		0,		0],

	// levitation bridge machine:
    [CHASM_WITH_HIDDEN_BRIDGE_ACTIVE,LIQUID,100,    100,    0,  "", 0, 0,  0,  CHASM_WITH_HIDDEN_BRIDGE,  DF_BRIDGE_APPEARS],
    [CHASM_WITH_HIDDEN_BRIDGE_ACTIVE,LIQUID,100,    100,    0,  "a stone bridge extends from the floor with a grinding sound.", 0, 0,  0,  CHASM_WITH_HIDDEN_BRIDGE,  DF_BRIDGE_APPEARS],
	[STONE_BRIDGE,				LIQUID,		0,		0,		0],
	[MACHINE_CHASM_EDGE,        LIQUID,     100,	100,	0],

	// retracting lava pool:
    [LAVA_RETRACTABLE,          LIQUID,     100,    100,    0,  "", 0, 0,  0,  LAVA],
	[LAVA_RETRACTING,			LIQUID,		0,		0,		0,	"hissing fills the air as the lava begins to cool."],
	[OBSIDIAN,					SURFACE,	0,		0,		0,	"", 0,	0,	0,		0,			DF_STEAM_ACCUMULATION],

	// hidden poison vent machine:
	[MACHINE_POISON_GAS_VENT_DORMANT,DUNGEON,0,		0,		0,	"you notice an inactive gas vent hidden in a crevice of the floor.", GENERIC_FLASH_LIGHT],
	[MACHINE_POISON_GAS_VENT,	DUNGEON,	0,		0,		0,	"deadly purple gas starts wafting out of hidden vents in the floor!"],
	[PORTCULLIS_CLOSED,			DUNGEON,	0,		0,		DFF_EVACUATE_CREATURES_FIRST,	"with a heavy mechanical sound, an iron portcullis falls from the ceiling!", GENERIC_FLASH_LIGHT],
	[PORTCULLIS_DORMANT,		DUNGEON,	0,		0,		0,  "the portcullis slowly rises from the ground into a slot in the ceiling.", GENERIC_FLASH_LIGHT],
	[POISON_GAS,				GAS,		25,		0,		0],

	// hidden methane vent machine:
	[MACHINE_METHANE_VENT_DORMANT,DUNGEON,0,		0,		0,	"you notice an inactive gas vent hidden in a crevice of the floor.", GENERIC_FLASH_LIGHT],
	[MACHINE_METHANE_VENT,		DUNGEON,	0,		0,		0,	"explosive methane gas starts wafting out of hidden vents in the floor!", 0, 0, 0, 0, DF_VENT_SPEW_METHANE],
	[METHANE_GAS,				GAS,		60,		0,		0],
	[PILOT_LIGHT,				DUNGEON,	0,		0,		0,	"a torch falls from its mount and lies sputtering on the floor.", FALLEN_TORCH_FLASH_LIGHT],

    // paralysis trap:
	[MACHINE_PARALYSIS_VENT,    DUNGEON,    0,		0,		0,	"you notice an inactive gas vent hidden in a crevice of the floor.", GENERIC_FLASH_LIGHT],
	[PARALYSIS_GAS,				GAS,		350,	0,		0,	"paralytic gas sprays upward from hidden vents in the floor!", 0, 0, 0, 0, DF_REVEAL_PARALYSIS_VENT_SILENTLY],
	[MACHINE_PARALYSIS_VENT,    DUNGEON,    0,		0,		0],

  // thematic dungeon:
  [RED_BLOOD,					SURFACE,	75,     25,		0],

	// statuary:
	[STATUE_CRACKING,			DUNGEON,	0,		0,		0,	"cracks begin snaking across the marble surface of the statue!", 0, 0, 0, 0, DF_RUBBLE],
	[RUBBLE,					SURFACE,	120,	100,	DFF_ACTIVATE_DORMANT_MONSTER,	"the statue shatters!", 0, darkGray, 3, 0, DF_RUBBLE],

	// hidden turrets:
	[WALL,                      DUNGEON,	0,		0,		DFF_ACTIVATE_DORMANT_MONSTER,	"you hear a click, and the stones in the wall shift to reveal turrets!", 0, 0, 0, 0, DF_RUBBLE],

  // worm tunnels:
  [WORM_TUNNEL_MARKER_DORMANT,LIQUID,     5,      5,      0,  "", 0,  0,  GRANITE],
  [WORM_TUNNEL_MARKER_ACTIVE, LIQUID,     0,      0,      0],
  [FLOOR,                     DUNGEON,    0,      0,      (DFF_SUPERPRIORITY | DFF_ACTIVATE_DORMANT_MONSTER),  "", 0, 0,  0,  0,  DF_TUNNELIZE],
	[FLOOR,                     DUNGEON,    0,      0,      0,  "the nearby wall cracks and collapses in a cloud of dust!", 0, darkGray,  5,  0,  DF_TUNNELIZE],

	// haunted room:
	[DARK_FLOOR_DARKENING,		DUNGEON,	0,		0,		0,	"the light in the room flickers and you feel a chill in the air."],
	[DARK_FLOOR,				DUNGEON,	0,		0,		DFF_ACTIVATE_DORMANT_MONSTER,	"", 0, 0, 0, 0, DF_ECTOPLASM_DROPLET],
  [HAUNTED_TORCH_TRANSITIONING,DUNGEON,   0,      0,      0],
  [HAUNTED_TORCH,             DUNGEON,    0,      0,      0],

	// mud pit:
	[MACHINE_MUD_DORMANT,		LIQUID,		100,	100,	0],
	[MUD,						LIQUID,		0,		0,		DFF_ACTIVATE_DORMANT_MONSTER,	"across the bog, bubbles rise ominously from the mud."],

  // electric crystals:
  [ELECTRIC_CRYSTAL_ON,       DUNGEON,    0,      0,      0, "the crystal absorbs the electricity and begins to glow.", CHARGE_FLASH_LIGHT],
	[WALL,                      DUNGEON,	0,		0,		DFF_ACTIVATE_DORMANT_MONSTER,	"the wall above the lever shifts to reveal a spark turret!"],

	// idyll:
	[SHALLOW_WATER,				LIQUID,		150,	100,	(DFF_PERMIT_BLOCKING)],
	[DEEP_WATER,				LIQUID,		90,		100,	(DFF_TREAT_AS_BLOCKING | DFF_CLEAR_OTHER_TERRAIN | DFF_SUBSEQ_EVERYWHERE), "", 0, 0, 0, 0, DF_SHALLOW_WATER_POOL],

	// swamp:
	[SHALLOW_WATER,				LIQUID,		30,		100,	0],
	[GRAY_FUNGUS,				SURFACE,	80,		50,		0,	"", 0, 0, 0, 0, DF_SWAMP_MUD],
	[MUD,						LIQUID,		75,		5,		0,	"", 0, 0, 0, 0, DF_SWAMP_WATER],

	// camp:
	[HAY,						SURFACE,	90,		87,		0],
	[JUNK,						SURFACE,	20,		20,		0],

	// remnants:
	[CARPET,					DUNGEON,	110,	20,		DFF_SUBSEQ_EVERYWHERE,	"", 0, 0, 0, 0, DF_REMNANT_ASH],
	[BURNED_CARPET,				SURFACE,	120,	100,	0],

	// chasm catwalk:
	[CHASM,						LIQUID,		0,		0,		DFF_CLEAR_OTHER_TERRAIN, "", 0, 0, 0, 0, DF_SHOW_TRAPDOOR_HALO],
	[STONE_BRIDGE,				LIQUID,		0,		0,		DFF_CLEAR_OTHER_TERRAIN],

	// lake catwalk:
	[DEEP_WATER,				LIQUID,		0,		0,		DFF_CLEAR_OTHER_TERRAIN, "", 0, 0, 0, 0, DF_LAKE_HALO],
	[SHALLOW_WATER,				LIQUID,		160,	100,	0],

	// worms pop out of walls:
	[RUBBLE,					SURFACE,	120,	100,	DFF_ACTIVATE_DORMANT_MONSTER,	"the nearby wall explodes in a shower of stone fragments!", 0, darkGray, 3, 0, DF_RUBBLE],

	// monster cages open:
	[MONSTER_CAGE_OPEN,			DUNGEON,	0,		0,		0],

  // goblin warren:
  [STENCH_SMOKE_GAS,          GAS,		50,		0,		0, "", 0, 0, 0, 0, DF_PLAIN_FIRE],
  [STENCH_SMOKE_GAS,          GAS,		50,		0,		0, "", 0, 0, 0, 0, DF_EMBERS],
].map( (v) => dungeonFeature(...v) );

// #pragma mark Dungeon Profiles

const dungeonProfileCatalog = [
    // Room frequencies:
    //      0. Cross room
    //      1. Small symmetrical cross room
    //      2. Small room
    //      3. Circular room
    //      4. Chunky room
    //      5. Cave
    //      6. Cavern (the kind that fills a level)
    //      7. Entrance room (the big upside-down T room at the start of depth 1)

    // Room frequencies
    // 0    1   2   3   4   5   6   7   Corridor chance
    [[2,    1,  1,  1,  7,  1,  0,  0], 10],    // Basic dungeon generation (further adjusted by depth)
    [[10,   0,  0,  3,  7,  10, 10, 0], 0],     // First room for basic dungeon generation (further adjusted by depth)

    [[0,    0,  1,  0,  0,  0,  0,  0], 0],     // Goblin warrens
    [[0,    5,  0,  1,  0,  0,  0,  0], 0],     // Sentinel sanctuaries
].map( (v) => dungeonProfile(...v) );

// #pragma mark Lights

// radius is in units of 0.01
const lightCatalog = [
	//color					radius range			fade%	passThroughCreatures
	[0],																// NO_LIGHT
	[minersLightColor,		[0, 0, 1],				35,		true],		// miners light
	[fireBoltColor,		[300, 400, 1],			0,		false],		// burning creature light
	[wispLightColor,		[400, 800, 1],			0,		false],		// will-o'-the-wisp light
	[fireBoltColor,		[300, 400, 1],			0,		false],		// salamander glow
	[pink,					[600, 600, 1],			0,		true],		// imp light
	[pixieColor,			[400, 600, 1],			50,		false],		// pixie light
	[lichLightColor,		[1500, 1500, 1],		0,		false],		// lich light
	[flamedancerCoronaColor,[1000, 2000, 1],		0,		false],		// flamedancer light
	[sentinelLightColor,	[300, 500, 1],			0,		false],		// sentinel light
	[unicornLightColor,	[300, 400, 1],			0,		false],		// unicorn light
	[ifritLightColor,		[300, 600, 1],			0,		false],		// ifrit light
	[fireBoltColor,		[400, 600, 1],			0,		false],		// phoenix light
	[fireBoltColor,		[150, 300, 1],			0,		false],		// phoenix egg light
	[yendorLightColor,		[1500, 1500, 1],        0,		false],		// Yendorian light
	[spectralBladeLightColor,[350, 350, 1],		0,		false],		// spectral blades
	[summonedImageLightColor,[350, 350, 1],		0,		false],		// weapon images
	[lightningColor,		[250, 250, 1],			35,		false],		// lightning turret light
  [explosiveAuraColor,   [150, 200, 1],          0,      true],      // explosive bloat light
	[lightningColor,		[300, 300, 1],			0,		false],		// bolt glow
	[telepathyColor,		[200, 200, 1],			0,		true],		// telepathy light
	[sacrificeTargetColor, [250, 250, 1],          0,      true],      // sacrifice doom light

  // flares:
	[scrollProtectionColor,[600, 600, 1],			0,		true],		// scroll of protection flare
  [scrollEnchantmentColor,[600, 600, 1],			0,		true],		// scroll of enchantment flare
  [potionStrengthColor,  [600, 600, 1],			0,		true],		// potion of strength flare
  [empowermentFlashColor,[600, 600, 1],			0,		true],		// empowerment flare
  [genericFlashColor,    [300, 300, 1],			0,		true],		// generic flash flare
	[fireFlashColor,		[800, 800, 1],			0,		false],		// fallen torch flare
  [summoningFlashColor,  [600, 600, 1],			0,		true],		// summoning flare
  [explosionFlareColor,  [5000, 5000, 1],        0,      true],      // explosion (explosive bloat or incineration potion)
	[quietusFlashColor,	[300, 300, 1],			0,		true],		// quietus activation flare
	[slayingFlashColor,	[300, 300, 1],			0,		true],		// slaying activation flare
  [lightningColor,       [800, 800, 1],          0,      false],     // electric crystal activates

	// glowing terrain:
	[torchLightColor,		[1000, 1000, 1],		50,		false],		// torch
	[lavaLightColor,		[300, 300, 1],			50,		false],		// lava
	[sunLightColor,		[200, 200, 1],			25,		true],		// sunlight
	[darknessPatchColor,	[400, 400, 1],			0,		true],		// darkness patch
	[fungusLightColor,		[300, 300, 1],			50,		false],		// luminescent fungus
	[fungusForestLightColor,[500, 500, 1],			0,		false],		// luminescent forest
	[algaeBlueLightColor,	[300, 300, 1],			0,		false],		// luminescent algae blue
	[algaeGreenLightColor,	[300, 300, 1],			0,		false],		// luminescent algae green
	[ectoplasmColor,		[200, 200, 1],			50,		false],		// ectoplasm
	[unicornLightColor,	[200, 200, 1],			0,		false],		// unicorn poop light
	[lavaLightColor,		[200, 200, 1],			50,		false],		// embers
	[lavaLightColor,		[500, 1000, 1],			0,		false],		// fire
	[lavaLightColor,		[200, 300, 1],			0,		false],		// brimstone fire
	[explosionColor,		[DCOLS*100,DCOLS*100,1],100,	false],		// explosions
	[dartFlashColor,		[15*100,15*100,1],		0,		false],		// incendiary darts
	[portalActivateLightColor,	[DCOLS*100,DCOLS*100,1],0,	false],		// portal activation
	[confusionLightColor,	[300, 300, 1],			100,	false],		// confusion gas
	[darknessCloudColor,	[500, 500, 1],			0,		true],		// darkness cloud
	[forceFieldLightColor,	[200, 200, 1],			50,		false],		// forcefield
	[crystalWallLightColor,[300, 500, 1],			50,		false],		// crystal wall
	[torchLightColor,		[200, 400, 1],			0,		false],		// candle light
  [hauntedTorchColor,	[400, 600, 1],          0,		false],		// haunted torch
  [glyphLightColor,      [100, 100, 1],          0,      false],     // glyph dim light
  [glyphLightColor,      [300, 300, 1],          0,      false],     // glyph bright light
  [sacredGlyphColor,     [300, 300, 1],          0,      false],     // sacred glyph light
  [descentLightColor,    [600, 600, 1],          0,      false],     // magical pit light
	[sacrificeTargetColor, [800, 1200, 1],          0,      true],      // demonic statue light

].map( (v) => lightSource(...v) );

// #pragma mark Blueprints

const blueprintCatalog = [
	[], // nothing
	//BLUEPRINTS:
	//depths			roomSize	freq	featureCt   dungeonProfileType  flags	(features on subsequent lines)

		//FEATURES:
		//DF		terrain		layer		instanceCtRange	minInsts	itemCat		itemKind	monsterKind		reqSpace		hordeFl		itemFlags	featureFlags

	// -- REWARD ROOMS --

	// Mixed item library -- can check one item out at a time
	[[1, 12],           [30, 50],	30,		6,			0,                  (BP_ROOM | BP_PURGE_INTERIOR | BP_SURROUND_WITH_WALLS | BP_OPEN_INTERIOR | BP_IMPREGNABLE | BP_REWARD),	[
		[0,			CARPET,		DUNGEON,		[0,0],		0,			0,			-1,			0,				0,				0,			0,			(MF_EVERYWHERE)],
		[0,			0,          0,              [1,1],		1,			0,          0,        0,				2,					0,			0,          (MF_BUILD_AT_ORIGIN | MF_PERMIT_BLOCKING | MF_BUILD_VESTIBULE)],
		[0,			ALTAR_CAGE_OPEN,DUNGEON,	[1,1],		1,			(WEAPON|ARMOR|WAND|STAFF|RING|CHARM),-1,0,2,	0,			(ITEM_IS_KEY | ITEM_KIND_AUTO_ID | ITEM_PLAYER_AVOIDS),	(MF_GENERATE_ITEM | MF_NO_THROWING_WEAPONS | MF_TREAT_AS_BLOCKING | MF_IMPREGNABLE)],
    [0,			ALTAR_CAGE_OPEN,DUNGEON,	[3,3],		3,			(WEAPON|ARMOR|WAND),-1,	0,				2,					0,			(ITEM_IS_KEY | ITEM_KIND_AUTO_ID | ITEM_PLAYER_AVOIDS),	(MF_GENERATE_ITEM | MF_NO_THROWING_WEAPONS | MF_TREAT_AS_BLOCKING | MF_IMPREGNABLE)],
		[0,			ALTAR_CAGE_OPEN,DUNGEON,	[2,3],		2,			(STAFF|RING|CHARM),-1,	0,				2,					0,			(ITEM_IS_KEY | ITEM_KIND_AUTO_ID | ITEM_MAX_CHARGES_KNOWN | ITEM_PLAYER_AVOIDS),	(MF_GENERATE_ITEM | MF_NO_THROWING_WEAPONS | MF_TREAT_AS_BLOCKING | MF_IMPREGNABLE)],
    [0,			STATUE_INERT,DUNGEON,		[2,3],		0,			0,			-1,			0,				2,				0,          0,          (MF_TREAT_AS_BLOCKING | MF_BUILD_IN_WALLS | MF_IMPREGNABLE)]]],
	// Single item category library -- can check one item out at a time
	[[1, 12],           [30, 50],	15,		5,			0,                  (BP_ROOM | BP_PURGE_INTERIOR | BP_SURROUND_WITH_WALLS | BP_OPEN_INTERIOR | BP_IMPREGNABLE | BP_REWARD),	[
		[0,			CARPET,		DUNGEON,		[0,0],		0,			0,			-1,			0,				0,				0,			0,			(MF_EVERYWHERE)],
		[0,			0,          0,              [1,1],		1,			0,          0,          0,				2,				0,			0,          (MF_BUILD_AT_ORIGIN | MF_PERMIT_BLOCKING | MF_BUILD_VESTIBULE)],
		[0,			ALTAR_CAGE_OPEN,DUNGEON,	[3,4],		3,			(RING),		-1,			0,				2,				0,			(ITEM_IS_KEY | ITEM_KIND_AUTO_ID | ITEM_MAX_CHARGES_KNOWN | ITEM_PLAYER_AVOIDS),	(MF_GENERATE_ITEM | MF_TREAT_AS_BLOCKING | MF_ALTERNATIVE | MF_IMPREGNABLE)],
		[0,			ALTAR_CAGE_OPEN,DUNGEON,	[4,5],		4,			(STAFF),	-1,			0,				2,				0,			(ITEM_IS_KEY | ITEM_KIND_AUTO_ID | ITEM_MAX_CHARGES_KNOWN | ITEM_PLAYER_AVOIDS),	(MF_GENERATE_ITEM | MF_TREAT_AS_BLOCKING | MF_ALTERNATIVE | MF_IMPREGNABLE)],
    [0,			STATUE_INERT,DUNGEON,		[2,3],		0,			0,			-1,			0,				2,				0,          0,          (MF_TREAT_AS_BLOCKING | MF_BUILD_IN_WALLS | MF_IMPREGNABLE)]]],
	// Treasure room -- apothecary or archive (potions or scrolls)
	[[8, AMULET_LEVEL],	[20, 40],	20,		6,			0,                  (BP_ROOM | BP_PURGE_INTERIOR | BP_SURROUND_WITH_WALLS | BP_OPEN_INTERIOR | BP_IMPREGNABLE | BP_REWARD),	[
		[0,			CARPET,		DUNGEON,		[0,0],		0,			0,			-1,			0,				0,				0,			0,			(MF_EVERYWHERE)],
		[0,			0,			0,				[5,7],		2,			(POTION),	-1,			0,				2,				0,			0,			(MF_GENERATE_ITEM | MF_ALTERNATIVE | MF_TREAT_AS_BLOCKING)],
		[0,			0,			0,				[4,6],		2,			(SCROLL),	-1,			0,				2,				0,			0,			(MF_GENERATE_ITEM | MF_ALTERNATIVE | MF_TREAT_AS_BLOCKING)],
		[0,			FUNGUS_FOREST,SURFACE,		[3,4],		0,			0,			-1,			0,				2,				0,			0,			0],
		[0,			0,          0,              [1,1],		1,			0,          0,          0,				2,				0,			0,          (MF_BUILD_AT_ORIGIN | MF_PERMIT_BLOCKING | MF_BUILD_VESTIBULE)],
  	[0,			STATUE_INERT,DUNGEON,		[2,3],		0,			0,			-1,			0,				2,				0,          0,          (MF_TREAT_AS_BLOCKING | MF_BUILD_IN_WALLS | MF_IMPREGNABLE)]]],
	// Guaranteed good permanent item on a glowing pedestal (runic weapon/armor or 2 staffs)
	[[5, 16],           [10, 30],	30,		6,			0,                  (BP_ROOM | BP_PURGE_INTERIOR | BP_SURROUND_WITH_WALLS | BP_OPEN_INTERIOR | BP_IMPREGNABLE | BP_REWARD),	[
		[0,			CARPET,		DUNGEON,		[0,0],		0,			0,			-1,			0,				0,				0,			0,			(MF_EVERYWHERE)],
    [0,			STATUE_INERT,DUNGEON,		[2,3],		0,			0,			-1,			0,				2,				0,          0,          (MF_TREAT_AS_BLOCKING | MF_BUILD_IN_WALLS | MF_IMPREGNABLE)],
		[0,			PEDESTAL,	DUNGEON,		[1,1],		1,			(WEAPON),	-1,			0,				2,				0,			ITEM_IDENTIFIED,(MF_GENERATE_ITEM | MF_ALTERNATIVE | MF_REQUIRE_GOOD_RUNIC | MF_NO_THROWING_WEAPONS | MF_TREAT_AS_BLOCKING)],
		[0,			PEDESTAL,	DUNGEON,		[1,1],		1,			(ARMOR),	-1,			0,				2,				0,			ITEM_IDENTIFIED,(MF_GENERATE_ITEM | MF_ALTERNATIVE | MF_REQUIRE_GOOD_RUNIC | MF_TREAT_AS_BLOCKING)],
		[0,			PEDESTAL,	DUNGEON,		[2,2],		2,			(STAFF),	-1,			0,				2,				0,			(ITEM_KIND_AUTO_ID | ITEM_MAX_CHARGES_KNOWN),	(MF_GENERATE_ITEM | MF_ALTERNATIVE | MF_TREAT_AS_BLOCKING)],
    [0,			0,          0,              [1,1],		1,			0,          0,          0,				2,				0,			0,          (MF_BUILD_AT_ORIGIN | MF_PERMIT_BLOCKING | MF_BUILD_VESTIBULE)]]],
	// Guaranteed good consumable item on glowing pedestals (scrolls of enchanting, potion of life)
	[[10, AMULET_LEVEL],[10, 30],	30,		5,			0,                  (BP_ROOM | BP_PURGE_INTERIOR | BP_SURROUND_WITH_WALLS | BP_OPEN_INTERIOR | BP_IMPREGNABLE | BP_REWARD),	[
		[0,			CARPET,		DUNGEON,		[0,0],		0,			0,			-1,			0,				0,				0,			0,			(MF_EVERYWHERE)],
    [0,			STATUE_INERT,DUNGEON,		[1,3],		0,			0,			-1,			0,				2,				0,          0,          (MF_TREAT_AS_BLOCKING | MF_BUILD_IN_WALLS | MF_IMPREGNABLE)],
		[0,			PEDESTAL,	DUNGEON,		[1,1],		1,			(SCROLL),	SCROLL_ENCHANTING, 0,       2,				0,			(ITEM_KIND_AUTO_ID),	(MF_GENERATE_ITEM | MF_ALTERNATIVE | MF_TREAT_AS_BLOCKING)],
    [0,			PEDESTAL,	DUNGEON,		[1,1],		1,			(POTION),	POTION_LIFE,0,              2,				0,			(ITEM_KIND_AUTO_ID),	(MF_GENERATE_ITEM | MF_ALTERNATIVE | MF_TREAT_AS_BLOCKING)],
		[0,			0,          0,              [1,1],		1,			0,          0,          0,				2,				0,			0,          (MF_BUILD_AT_ORIGIN | MF_PERMIT_BLOCKING | MF_BUILD_VESTIBULE)]]],
    // Commutation altars
	[[13, AMULET_LEVEL],[10, 30],	50,		4,			0,                  (BP_ROOM | BP_PURGE_INTERIOR | BP_SURROUND_WITH_WALLS | BP_OPEN_INTERIOR | BP_IMPREGNABLE | BP_REWARD),	[
		[0,			CARPET,		DUNGEON,		[0,0],		0,			0,			-1,			0,				0,				0,			0,			(MF_EVERYWHERE)],
    [0,			STATUE_INERT,DUNGEON,		[1,3],		0,			0,			-1,			0,				2,				0,          0,          (MF_TREAT_AS_BLOCKING | MF_BUILD_IN_WALLS | MF_IMPREGNABLE)],
		[DF_MAGIC_PIPING,COMMUTATION_ALTAR,DUNGEON,[2,2],	2,			0,          -1,         0,              2,				0,			0,          (MF_TREAT_AS_BLOCKING)],
		[0,			0,          0,              [1,1],		1,			0,          0,          0,				2,				0,			0,          (MF_BUILD_AT_ORIGIN | MF_PERMIT_BLOCKING | MF_BUILD_VESTIBULE)]]],
    // Resurrection altar
	[[13, AMULET_LEVEL],[10, 30],	15,		4,			0,                  (BP_ROOM | BP_PURGE_INTERIOR | BP_SURROUND_WITH_WALLS | BP_OPEN_INTERIOR | BP_IMPREGNABLE | BP_REWARD),	[
		[0,			CARPET,		DUNGEON,		[0,0],		0,			0,			-1,			0,				0,				0,			0,			(MF_EVERYWHERE)],
    [0,			STATUE_INERT,DUNGEON,		[1,3],		0,			0,			-1,			0,				2,				0,          0,          (MF_TREAT_AS_BLOCKING | MF_BUILD_IN_WALLS | MF_IMPREGNABLE)],
		[DF_MACHINE_FLOOR_TRIGGER_REPEATING, RESURRECTION_ALTAR,DUNGEON, [1,1], 1, 0, -1,       0,              2,				0,			0,          (MF_TREAT_AS_BLOCKING)],
		[0,			0,          0,              [1,1],		1,			0,          0,          0,				2,				0,			0,          (MF_BUILD_AT_ORIGIN | MF_PERMIT_BLOCKING | MF_BUILD_VESTIBULE)]]],
    // Outsourced item -- same item possibilities as in the good permanent item reward room (plus charms), but directly adopted by 1-2 key machines.
  [[5, 17],           [0, 0],     20,		4,			0,                  (BP_REWARD | BP_NO_INTERIOR_FLAG),	[
		[0,			0,			0,				[1,1],		1,			(WEAPON),	-1,			0,				0,				0,			ITEM_IDENTIFIED,(MF_GENERATE_ITEM | MF_ALTERNATIVE | MF_REQUIRE_GOOD_RUNIC | MF_NO_THROWING_WEAPONS | MF_OUTSOURCE_ITEM_TO_MACHINE | MF_BUILD_ANYWHERE_ON_LEVEL)],
		[0,			0,			0,				[1,1],		1,			(ARMOR),	-1,			0,				0,				0,			ITEM_IDENTIFIED,(MF_GENERATE_ITEM | MF_ALTERNATIVE | MF_REQUIRE_GOOD_RUNIC | MF_OUTSOURCE_ITEM_TO_MACHINE | MF_BUILD_ANYWHERE_ON_LEVEL)],
		[0,			0,			0,				[2,2],		2,			(STAFF),	-1,			0,				0,				0,			ITEM_KIND_AUTO_ID, (MF_GENERATE_ITEM | MF_ALTERNATIVE | MF_OUTSOURCE_ITEM_TO_MACHINE | MF_BUILD_ANYWHERE_ON_LEVEL)],
    [0,			0,			0,				[1,2],		1,			(CHARM),	-1,			0,				0,				0,			ITEM_KIND_AUTO_ID, (MF_GENERATE_ITEM | MF_ALTERNATIVE | MF_OUTSOURCE_ITEM_TO_MACHINE | MF_BUILD_ANYWHERE_ON_LEVEL)]]],
	// Dungeon -- two allies chained up for the taking
	[[5, AMULET_LEVEL],	[30, 80],	4,		5,			0,                  (BP_ROOM | BP_REWARD),	[
		[0,			VOMIT,		SURFACE,		[2,2],		2,			0,			-1,			0,				2,				(HORDE_MACHINE_CAPTIVE | HORDE_LEADER_CAPTIVE), 0, (MF_GENERATE_HORDE | MF_TREAT_AS_BLOCKING)],
		[DF_AMBIENT_BLOOD,MANACLE_T,SURFACE,	[1,2],		1,			0,			-1,			0,				1,				0,			0,			0],
		[DF_AMBIENT_BLOOD,MANACLE_L,SURFACE,	[1,2],		1,			0,			-1,			0,				1,				0,			0,			0],
		[DF_BONES,	0,			0,				[2,3],		1,			0,			-1,			0,				1,				0,			0,			0],
		[DF_VOMIT,	0,			0,				[2,3],		1,			0,			-1,			0,				1,				0,			0,			0],
		[0,			0,          0,              [1,1],		1,			0,          0,          0,				2,				0,			0,          (MF_BUILD_AT_ORIGIN | MF_PERMIT_BLOCKING | MF_BUILD_VESTIBULE)]]],
	// Kennel -- allies locked in cages in an open room; choose one or two to unlock and take with you.
	[[5, AMULET_LEVEL],	[30, 80],	4,		4,			0,                  (BP_ROOM | BP_REWARD),	[
		[0,			MONSTER_CAGE_CLOSED,DUNGEON,[3,5],		3,			0,			-1,			0,				2,				(HORDE_MACHINE_KENNEL | HORDE_LEADER_CAPTIVE), 0, (MF_GENERATE_HORDE | MF_TREAT_AS_BLOCKING | MF_IMPREGNABLE)],
		[0,			0,			0,				[1,2],		1,			KEY,		KEY_CAGE,	0,				1,				0,			(ITEM_IS_KEY | ITEM_PLAYER_AVOIDS),(MF_PERMIT_BLOCKING | MF_GENERATE_ITEM | MF_OUTSOURCE_ITEM_TO_MACHINE | MF_SKELETON_KEY | MF_KEY_DISPOSABLE)],
    [DF_AMBIENT_BLOOD, 0,	0,				[3,5],		3,			0,			-1,			0,				1,				0,			0,			0],
    [DF_BONES,	0,			0,				[3,5],		3,			0,			-1,			0,				1,				0,			0,			0],
    [0,			TORCH_WALL,	DUNGEON,		[2,3],		2,			0,			0,			0,				1,				0,			0,			(MF_BUILD_IN_WALLS)]]],
	// Vampire lair -- allies locked in cages and chained in a hidden room with a vampire in a coffin; vampire has one cage key.
	[[10, AMULET_LEVEL],[50, 80],	3,		4,			0,                  (BP_ROOM | BP_REWARD | BP_SURROUND_WITH_WALLS | BP_PURGE_INTERIOR),	[
		[DF_AMBIENT_BLOOD,0,	0,				[1,2],		1,			0,			-1,			0,				2,				(HORDE_MACHINE_CAPTIVE | HORDE_LEADER_CAPTIVE), 0, (MF_GENERATE_HORDE | MF_TREAT_AS_BLOCKING | MF_NOT_IN_HALLWAY)],
		[DF_AMBIENT_BLOOD,MONSTER_CAGE_CLOSED,DUNGEON,[2,4],2,			0,			-1,			0,				2,				(HORDE_VAMPIRE_FODDER | HORDE_LEADER_CAPTIVE), 0, (MF_GENERATE_HORDE | MF_TREAT_AS_BLOCKING | MF_IMPREGNABLE | MF_NOT_IN_HALLWAY)],
		[DF_TRIGGER_AREA,COFFIN_CLOSED,0,		[1,1],		1,			KEY,		KEY_CAGE,	MK_VAMPIRE,		1,				0,			(ITEM_IS_KEY | ITEM_PLAYER_AVOIDS),(MF_GENERATE_ITEM | MF_SKELETON_KEY | MF_MONSTER_TAKE_ITEM | MF_MONSTERS_DORMANT | MF_FAR_FROM_ORIGIN | MF_KEY_DISPOSABLE)],
		[DF_AMBIENT_BLOOD,SECRET_DOOR,DUNGEON,	[1,1],		1,			0,			0,			0,				1,				0,			0,			(MF_PERMIT_BLOCKING | MF_BUILD_AT_ORIGIN)]]],
	// Legendary ally -- approach the altar with the crystal key to activate a portal and summon a legendary ally.
	[[8, AMULET_LEVEL], [30, 50],	10,		2,			0,                  (BP_ROOM | BP_REWARD),	[
		[DF_LUMINESCENT_FUNGUS,	ALTAR_KEYHOLE, DUNGEON,	[1,1], 1,		KEY,		KEY_PORTAL,	0,				2,				0,			(ITEM_IS_KEY | ITEM_PLAYER_AVOIDS),(MF_GENERATE_ITEM | MF_NOT_IN_HALLWAY | MF_NEAR_ORIGIN | MF_OUTSOURCE_ITEM_TO_MACHINE | MF_KEY_DISPOSABLE)],
		[DF_LUMINESCENT_FUNGUS,	PORTAL,	DUNGEON,[1,1],		1,			0,			-1,			0,				2,				HORDE_MACHINE_LEGENDARY_ALLY,0,	(MF_GENERATE_HORDE | MF_MONSTERS_DORMANT | MF_FAR_FROM_ORIGIN)]]],
    // Goblin warren
	[[5, 15],           [100, 200],	15,     9,			DP_GOBLIN_WARREN,   (BP_ROOM | BP_REWARD | BP_MAXIMIZE_INTERIOR | BP_REDESIGN_INTERIOR),	[
		[0,			MUD_FLOOR,	DUNGEON,		[0,0],		0,			0,			-1,			0,				0,				0,			0,			(MF_EVERYWHERE)],
    [0,         MUD_DOORWAY,DUNGEON,        [1,1],      1,          0,          -1,         0,              1,              0,          0,          (MF_BUILD_AT_ORIGIN)],
    [0,         MUD_WALL,   DUNGEON,        [1,1],      100,        0,			-1,			0,				1,				0,			0,			(MF_BUILD_IN_WALLS | MF_EVERYWHERE)],
    [0,			PEDESTAL,	DUNGEON,		[1,1],		1,			(SCROLL),	SCROLL_ENCHANTING, MK_GOBLIN_CHIEFTAN, 2,   0,			(ITEM_KIND_AUTO_ID),	(MF_GENERATE_ITEM | MF_MONSTER_SLEEPING | MF_ALTERNATIVE | MF_TREAT_AS_BLOCKING | MF_NOT_IN_HALLWAY | MF_FAR_FROM_ORIGIN)],
    [0,			PEDESTAL,	DUNGEON,		[1,1],		1,			(POTION),	POTION_LIFE, MK_GOBLIN_CHIEFTAN, 2,         0,			(ITEM_KIND_AUTO_ID),	(MF_GENERATE_ITEM | MF_MONSTER_SLEEPING | MF_ALTERNATIVE | MF_TREAT_AS_BLOCKING | MF_NOT_IN_HALLWAY | MF_FAR_FROM_ORIGIN)],
    [0,         0,          0,              [5, 8],     5,          0,          -1,         0,              2,              HORDE_MACHINE_GOBLIN_WARREN,    0,  (MF_GENERATE_HORDE | MF_NOT_IN_HALLWAY | MF_MONSTER_SLEEPING)],
    [0,			0,			0,				[2,3],		2,			(WEAPON|ARMOR),	-1,		0,				1,				0,			0,			(MF_GENERATE_ITEM | MF_TREAT_AS_BLOCKING | MF_NOT_IN_HALLWAY)],
    [DF_HAY,	0,			0,				[10, 15],	1,			0,			-1,			0,				1,				0,			0,			(MF_NOT_IN_HALLWAY)],
		[DF_JUNK,	0,			0,				[7, 12],	1,			0,			-1,			0,				1,				0,			0,			(MF_NOT_IN_HALLWAY)]]],
    // Sentinel sanctuary
	[[10, 23],           [100, 200], 15,  10,			DP_SENTINEL_SANCTUARY, (BP_ROOM | BP_REWARD | BP_MAXIMIZE_INTERIOR | BP_REDESIGN_INTERIOR),	[
		[0,			MARBLE_FLOOR,DUNGEON,		[0,0],		0,			0,			-1,			0,				0,				0,			0,			(MF_EVERYWHERE)],
    [0,         CRYSTAL_WALL,DUNGEON,       [0,0],      0,          0,			-1,			0,				0,				0,			0,			(MF_BUILD_IN_WALLS | MF_EVERYWHERE)],
    [0,         PEDESTAL, DUNGEON, [1,1],	1,			(SCROLL),	SCROLL_ENCHANTING,0,	2,              0,              (ITEM_KIND_AUTO_ID),	(MF_GENERATE_ITEM | MF_ALTERNATIVE | MF_TREAT_AS_BLOCKING | MF_NOT_IN_HALLWAY | MF_FAR_FROM_ORIGIN)],
    [0,         PEDESTAL, DUNGEON, [1,1],	1,			(POTION),	POTION_LIFE,0,          2,              0,              (ITEM_KIND_AUTO_ID),	(MF_GENERATE_ITEM | MF_ALTERNATIVE | MF_TREAT_AS_BLOCKING | MF_NOT_IN_HALLWAY | MF_FAR_FROM_ORIGIN)],
    [0,         MACHINE_GLYPH,DUNGEON,      [30, 35],	20,			0,			-1,			0,				1,				0,			0,			(MF_PERMIT_BLOCKING)],
    [0,         STATUE_INERT,DUNGEON,       [3, 5],     3,          0,          -1,         MK_SENTINEL,    2,              0,          0,          (MF_TREAT_AS_BLOCKING | MF_NOT_IN_HALLWAY)],
    [0,         STATUE_INERT,DUNGEON,       [10, 15],   8,          0,          -1,         MK_SENTINEL,    2,              0,          0,          MF_BUILD_IN_WALLS],
    [0,         0,          0,              [4, 6],     4,          0,          -1,         MK_GUARDIAN,    1,              0,          0,          MF_TREAT_AS_BLOCKING],
    [0,         0,          0,              [0, 2],     0,          0,          -1,         MK_WINGED_GUARDIAN, 1,          0,          0,          MF_TREAT_AS_BLOCKING],
    [0,			0,			0,				[2,3],		2,			(SCROLL | POTION), -1,	0,				1,				0,			0,			(MF_GENERATE_ITEM | MF_TREAT_AS_BLOCKING | MF_NOT_IN_HALLWAY)]]],

    // -- AMULET HOLDER --
    // Statuary -- key on an altar, area full of statues; take key to cause statues to burst and reveal monsters
	[[10, AMULET_LEVEL],[35, 40],	0,		4,			0,                  (BP_PURGE_INTERIOR | BP_OPEN_INTERIOR),	[
		[DF_LUMINESCENT_FUNGUS,	AMULET_SWITCH, DUNGEON, [1,1], 1,		AMULET,		-1,			0,				2,				0,			0,			(MF_GENERATE_ITEM | MF_NEAR_ORIGIN | MF_TREAT_AS_BLOCKING | MF_NOT_IN_HALLWAY)],
    [0,			FUNGUS_FOREST,SURFACE,		[2,3],		0,			0,			-1,			0,				2,				0,			0,			MF_NOT_IN_HALLWAY],
		[0,			STATUE_INSTACRACK,DUNGEON,	[1,1],		1,			0,			-1,			MK_WARDEN_OF_YENDOR,1,          0,          0,          (MF_TREAT_AS_BLOCKING | MF_NOT_IN_HALLWAY | MF_MONSTERS_DORMANT | MF_FAR_FROM_ORIGIN | MF_IN_PASSABLE_VIEW_OF_ORIGIN | MF_IMPREGNABLE)],
    [0,			TORCH_WALL,	DUNGEON,		[3,4],		0,			0,			0,			0,				1,				0,			0,			(MF_BUILD_IN_WALLS)]]],

  // -- VESTIBULES --

  // Plain locked door, key guarded by an adoptive room
	[[1, AMULET_LEVEL],	[1, 1],     150,		1,		0,                  (BP_VESTIBULE),	[
		[0,			LOCKED_DOOR, DUNGEON,		[1,1],		1,			KEY,		KEY_DOOR,	0,				1,				0,			(ITEM_IS_KEY | ITEM_PLAYER_AVOIDS), (MF_BUILD_AT_ORIGIN | MF_PERMIT_BLOCKING | MF_GENERATE_ITEM | MF_OUTSOURCE_ITEM_TO_MACHINE | MF_KEY_DISPOSABLE | MF_IMPREGNABLE)]]],
  // Plain secret door
  [[2, AMULET_LEVEL],	[1, 1],     1,		1,			0,                  (BP_VESTIBULE),	[
		[0,			SECRET_DOOR, DUNGEON,		[1,1],		1,			0,          0,          0,				1,				0,			0,          (MF_BUILD_AT_ORIGIN | MF_PERMIT_BLOCKING)]]],
  // Lever and either an exploding wall or a portcullis
  [[4, AMULET_LEVEL],	[1, 1],     8,		3,			0,                  (BP_VESTIBULE),	[
		[0,         WORM_TUNNEL_OUTER_WALL,DUNGEON,[1,1],	1,			0,			-1,			0,				1,				0,			0,			(MF_BUILD_AT_ORIGIN | MF_PERMIT_BLOCKING | MF_IMPREGNABLE | MF_ALTERNATIVE)],
    [0,			PORTCULLIS_CLOSED,DUNGEON,  [1,1],      1,			0,			0,			0,				3,				0,			0,			(MF_BUILD_AT_ORIGIN | MF_PERMIT_BLOCKING | MF_IMPREGNABLE | MF_ALTERNATIVE)],
    [0,			WALL_LEVER_HIDDEN,DUNGEON,  [1,1],      1,			0,			-1,			0,				1,				0,			0,			(MF_BUILD_IN_WALLS | MF_IN_PASSABLE_VIEW_OF_ORIGIN | MF_BUILD_ANYWHERE_ON_LEVEL)]]],
  // Flammable barricade in the doorway -- burn the wooden barricade to enter
	[[1, 6],			[1, 1],     10,		3,			0,                  (BP_VESTIBULE), [
		[0,			WOODEN_BARRICADE,DUNGEON,   [1,1],		1,			0,			0,			0,				1,				0,			0,			(MF_PERMIT_BLOCKING | MF_BUILD_AT_ORIGIN)],
		[0,			0,			0,				[1,1],		1,			WEAPON,		INCENDIARY_DART, 0,			1,				0,			0,			(MF_GENERATE_ITEM | MF_BUILD_ANYWHERE_ON_LEVEL | MF_NOT_IN_HALLWAY | MF_ALTERNATIVE)],
		[0,			0,			0,				[1,1],		1,			POTION,		POTION_INCINERATION, 0,		1,				0,			0,			(MF_GENERATE_ITEM | MF_BUILD_ANYWHERE_ON_LEVEL | MF_NOT_IN_HALLWAY | MF_ALTERNATIVE)]]],
  // Statue in the doorway -- use a scroll of shattering to enter
	[[1, AMULET_LEVEL],	[1, 1],     6,		2,			0,                  (BP_VESTIBULE), [
		[0,			STATUE_INERT_DOORWAY,DUNGEON,       [1,1],1,		0,			0,			0,				1,				0,			0,			(MF_PERMIT_BLOCKING | MF_BUILD_AT_ORIGIN)],
		[0,			0,			0,				[1,1],		1,			SCROLL,		SCROLL_SHATTERING, 0,       1,				0,			0,			(MF_GENERATE_ITEM | MF_BUILD_ANYWHERE_ON_LEVEL | MF_NOT_IN_HALLWAY)]]],
  // Statue in the doorway -- bursts to reveal monster
	[[5, AMULET_LEVEL],	[2, 2],     6,		2,			0,                  (BP_VESTIBULE), [
		[0,			STATUE_DORMANT_DOORWAY,DUNGEON,		[1, 1],	1,		0,			-1,			0,				1,				HORDE_MACHINE_STATUE,0,	(MF_PERMIT_BLOCKING | MF_GENERATE_HORDE | MF_MONSTERS_DORMANT | MF_BUILD_AT_ORIGIN | MF_ALTERNATIVE)],
		[0,			MACHINE_TRIGGER_FLOOR,DUNGEON,[0,0],	1,			0,			-1,			0,				0,				0,			0,			(MF_EVERYWHERE)]]],
  // Throwing tutorial -- toss an item onto the pressure plate to retract the portcullis
	[[1, 4],			[70, 70],	8,      3,          0,                  (BP_VESTIBULE), [
    [DF_MEDIUM_HOLE, MACHINE_PRESSURE_PLATE, LIQUID, [1,1], 1,		0,			0,			0,				1,				0,			0,			(MF_TREAT_AS_BLOCKING | MF_NOT_IN_HALLWAY)],
		[0,			PORTCULLIS_CLOSED,DUNGEON,  [1,1],      1,			0,			0,			0,				3,				0,			0,			(MF_IMPREGNABLE | MF_PERMIT_BLOCKING | MF_BUILD_AT_ORIGIN | MF_ALTERNATIVE)],
    [0,         WORM_TUNNEL_OUTER_WALL,DUNGEON,[1,1],	1,			0,			-1,			0,				1,				0,			0,			(MF_BUILD_AT_ORIGIN | MF_PERMIT_BLOCKING | MF_IMPREGNABLE | MF_ALTERNATIVE)]]],
  // Pit traps -- area outside entrance is full of pit traps
	[[1, AMULET_LEVEL],	[30, 60],	8,		3,			0,                  (BP_VESTIBULE | BP_OPEN_INTERIOR | BP_NO_INTERIOR_FLAG),	[
		[0,			DOOR,       DUNGEON,        [1,1],      1,			0,			0,			0,				1,				0,			0,			(MF_PERMIT_BLOCKING | MF_BUILD_AT_ORIGIN | MF_ALTERNATIVE)],
    [0,			SECRET_DOOR,DUNGEON,        [1,1],      1,			0,			0,			0,				1,				0,			0,			(MF_IMPREGNABLE | MF_PERMIT_BLOCKING | MF_BUILD_AT_ORIGIN | MF_ALTERNATIVE)],
		[0,			TRAP_DOOR_HIDDEN,DUNGEON,	[60, 60],	1,			0,			-1,			0,				1,				0,			0,			(MF_TREAT_AS_BLOCKING | MF_REPEAT_UNTIL_NO_PROGRESS)]]],
  // Beckoning obstacle -- a mirrored totem guards the door, and glyph are around the doorway.
	[[5, AMULET_LEVEL], [15, 30],	8,		3,			0,                  (BP_VESTIBULE | BP_PURGE_INTERIOR | BP_OPEN_INTERIOR), [
		[0,         DOOR,       DUNGEON,        [1,1],		1,			0,			-1,			0,				1,				0,			0,			(MF_PERMIT_BLOCKING | MF_BUILD_AT_ORIGIN)],
		[0,         MACHINE_GLYPH,DUNGEON,      [1,1],		0,			0,			-1,			0,				1,				0,			0,			(MF_NEAR_ORIGIN | MF_EVERYWHERE)],
		[0,         0,          0,              [1,1],		1,			0,			-1,			MK_MIRRORED_TOTEM,3,			0,			0,			(MF_TREAT_AS_BLOCKING | MF_NOT_IN_HALLWAY | MF_IN_VIEW_OF_ORIGIN | MF_BUILD_ANYWHERE_ON_LEVEL)],
		[0,         MACHINE_GLYPH,DUNGEON,      [3,5],      2,          0,          -1,         0,              2,              0,          0,          (MF_TREAT_AS_BLOCKING)]]],
  // Guardian obstacle -- a guardian is in the door on a glyph, with other glyphs scattered around.
	[[6, AMULET_LEVEL], [25, 25],	8,		4,          0,                  (BP_VESTIBULE | BP_OPEN_INTERIOR),	[
		[0,			DOOR,       DUNGEON,        [1,1],		1,			0,			0,			MK_GUARDIAN,	2,				0,			0,			(MF_BUILD_AT_ORIGIN | MF_PERMIT_BLOCKING | MF_ALTERNATIVE)],
		[0,			DOOR,       DUNGEON,        [1,1],		1,			0,			0,			MK_WINGED_GUARDIAN,2,           0,			0,			(MF_BUILD_AT_ORIGIN | MF_PERMIT_BLOCKING | MF_ALTERNATIVE)],
    [0,         MACHINE_GLYPH,DUNGEON,      [10,10],    3,          0,          -1,         0,              1,              0,          0,          (MF_PERMIT_BLOCKING| MF_NEAR_ORIGIN)],
    [0,         MACHINE_GLYPH,DUNGEON,      [1,1],      0,          0,          -1,         0,              2,              0,          0,          (MF_EVERYWHERE | MF_PERMIT_BLOCKING | MF_NOT_IN_HALLWAY)]]],

	// -- KEY HOLDERS --

	// Nested item library -- can check one item out at a time, and one is a disposable key to another reward room
	[[1, AMULET_LEVEL],	[30, 50],	35,		7,			0,                  (BP_ROOM | BP_PURGE_INTERIOR | BP_SURROUND_WITH_WALLS | BP_OPEN_INTERIOR | BP_ADOPT_ITEM | BP_IMPREGNABLE),	[
		[0,			CARPET,		DUNGEON,		[0,0],		0,			0,			-1,			0,				0,				0,			0,			(MF_EVERYWHERE)],
    [0,			WALL,       DUNGEON,		[0,0],      0,			0,			-1,			0,				0,				0,          0,          (MF_TREAT_AS_BLOCKING | MF_BUILD_IN_WALLS | MF_IMPREGNABLE | MF_EVERYWHERE)],
		[0,			0,          0,              [1,1],		1,			0,          0,          0,				2,				0,			0,          (MF_BUILD_AT_ORIGIN | MF_PERMIT_BLOCKING | MF_BUILD_VESTIBULE)],
		[0,			ALTAR_CAGE_OPEN,DUNGEON,	[1,2],		1,			(WEAPON|ARMOR|WAND),-1,	0,				2,				0,			(ITEM_IS_KEY | ITEM_KIND_AUTO_ID | ITEM_PLAYER_AVOIDS),	(MF_GENERATE_ITEM | MF_NO_THROWING_WEAPONS | MF_TREAT_AS_BLOCKING | MF_IMPREGNABLE)],
		[0,			ALTAR_CAGE_OPEN,DUNGEON,	[1,2],		1,			(STAFF|RING|CHARM),-1,	0,				2,				0,			(ITEM_IS_KEY | ITEM_KIND_AUTO_ID | ITEM_MAX_CHARGES_KNOWN | ITEM_PLAYER_AVOIDS),	(MF_GENERATE_ITEM | MF_NO_THROWING_WEAPONS | MF_TREAT_AS_BLOCKING | MF_IMPREGNABLE)],
		[0,			ALTAR_CAGE_OPEN,DUNGEON,	[1,1],		1,			0,			-1,			0,				2,				0,			(ITEM_IS_KEY | ITEM_PLAYER_AVOIDS | ITEM_MAX_CHARGES_KNOWN),	(MF_ADOPT_ITEM | MF_TREAT_AS_BLOCKING | MF_IMPREGNABLE)],
    [0,			STATUE_INERT,DUNGEON,		[1,3],		0,			0,			-1,			0,				2,				0,          0,          (MF_TREAT_AS_BLOCKING | MF_BUILD_IN_WALLS | MF_IMPREGNABLE)]]],
	// Secret room -- key on an altar in a secret room
	[[1, AMULET_LEVEL],	[15, 100],	1,		2,			0,                  (BP_ROOM | BP_ADOPT_ITEM), [
		[0,			ALTAR_INERT,DUNGEON,		[1,1],		1,			0,			-1,			0,				1,				0,			ITEM_PLAYER_AVOIDS,	(MF_ADOPT_ITEM | MF_TREAT_AS_BLOCKING | MF_NOT_IN_HALLWAY)],
		[0,			SECRET_DOOR,DUNGEON,		[1,1],		1,			0,			0,			0,				1,				0,			0,			(MF_PERMIT_BLOCKING | MF_BUILD_AT_ORIGIN)]]],
	// Throwing tutorial -- toss an item onto the pressure plate to retract the cage and reveal the key
	[[1, 4],			[70, 80],	8,		2,			0,                  (BP_ADOPT_ITEM), [
		[0,			ALTAR_CAGE_RETRACTABLE,DUNGEON,[1,1],	1,			0,			-1,			0,				3,				0,			0,			(MF_ADOPT_ITEM | MF_IMPREGNABLE | MF_NOT_IN_HALLWAY)],
		[DF_MEDIUM_HOLE, MACHINE_PRESSURE_PLATE, LIQUID, [1,1], 1,		0,			0,			0,				1,				0,			0,			(MF_TREAT_AS_BLOCKING | MF_NOT_IN_HALLWAY)]]],
  // Rat trap -- getting the key triggers paralysis vents nearby and also causes rats to burst out of the walls
	[[1,8],             [30, 70],	7,		3,          0,                  (BP_ADOPT_ITEM | BP_ROOM),	[
		[0,			ALTAR_SWITCH,DUNGEON,		[1,1],		1,			0,			-1,			0,				1,				0,			0,			(MF_ADOPT_ITEM | MF_FAR_FROM_ORIGIN | MF_TREAT_AS_BLOCKING | MF_NOT_IN_HALLWAY)],
    [0,			MACHINE_PARALYSIS_VENT_HIDDEN,DUNGEON,[1,1],1,		0,			-1,			0,				2,				0,			0,			(MF_FAR_FROM_ORIGIN | MF_NOT_IN_HALLWAY)],
    [0,			RAT_TRAP_WALL_DORMANT,DUNGEON,[10,20],	5,			0,			-1,			MK_RAT,         1,				0,			0,			(MF_MONSTERS_DORMANT | MF_BUILD_IN_WALLS | MF_NOT_ON_LEVEL_PERIMETER)]]],
	// Fun with fire -- trigger the fire trap and coax the fire over to the wooden barricade surrounding the altar and key
  [[3, 10],			[80, 100],	10,		6,			0,                  (BP_ROOM | BP_ADOPT_ITEM | BP_PURGE_INTERIOR | BP_SURROUND_WITH_WALLS | BP_OPEN_INTERIOR), [
		[DF_SURROUND_WOODEN_BARRICADE,ALTAR_INERT,DUNGEON,[1,1],1,		0,			-1,			0,				3,				0,			0,			(MF_ADOPT_ITEM | MF_FAR_FROM_ORIGIN | MF_TREAT_AS_BLOCKING)],
		[0,			GRASS,		SURFACE,		[0,0],		0,			0,			-1,			0,				0,				0,			0,			(MF_EVERYWHERE | MF_ALTERNATIVE)],
		[DF_SWAMP,	0,			0,				[4,4],		2,			0,			-1,			0,				2,				0,			0,			(MF_ALTERNATIVE | MF_FAR_FROM_ORIGIN)],
		[0,			FLAMETHROWER_HIDDEN,DUNGEON,[1,1],		1,			0,			0,			0,				1,				0,			0,			(MF_TREAT_AS_BLOCKING | MF_NEAR_ORIGIN)],
		[0,			GAS_TRAP_POISON_HIDDEN,DUNGEON,[3, 3],	1,			0,			-1,			0,				5,				0,			0,			(MF_TREAT_AS_BLOCKING | MF_ALTERNATIVE)],
		[0,			0,			0,				[2,2],		1,			POTION,		POTION_LICHEN, 0,           3,				0,			0,			(MF_GENERATE_ITEM | MF_BUILD_ANYWHERE_ON_LEVEL | MF_NOT_IN_HALLWAY | MF_ALTERNATIVE)]]],
	// Flood room -- key on an altar in a room with pools of eel-infested waters; take key to flood room with shallow water
	[[3, AMULET_LEVEL],	[80, 180],	10,		4,			0,                  (BP_ROOM | BP_SURROUND_WITH_WALLS | BP_PURGE_LIQUIDS | BP_PURGE_PATHING_BLOCKERS | BP_ADOPT_ITEM),	[
		[0,			FLOOR_FLOODABLE,LIQUID,		[0,0],		0,			0,			-1,			0,				0,				0,			0,			(MF_EVERYWHERE)],
		[0,			ALTAR_SWITCH,DUNGEON,		[1,1],		1,			0,			-1,			0,				5,				0,			0,			(MF_ADOPT_ITEM | MF_FAR_FROM_ORIGIN | MF_TREAT_AS_BLOCKING | MF_NOT_IN_HALLWAY)],
		[DF_SPREADABLE_WATER_POOL,0,0,          [2, 4],		1,			0,			-1,			0,				5,				HORDE_MACHINE_WATER_MONSTER,0,MF_GENERATE_HORDE],
    [DF_GRASS,	FOLIAGE,	SURFACE,		[3, 4],		3,			0,			-1,			0,				1,				0,			0,			0]]],
  // Fire trap room -- key on an altar, pools of water, fire traps all over the place.
	[[4, AMULET_LEVEL],	[80, 180],	6,		5,			0,                  (BP_ROOM | BP_SURROUND_WITH_WALLS | BP_PURGE_LIQUIDS | BP_PURGE_PATHING_BLOCKERS | BP_ADOPT_ITEM),	[
		[0,			ALTAR_INERT,DUNGEON,		[1,1],		1,			0,			-1,			0,				1,				0,			0,			(MF_ADOPT_ITEM | MF_FAR_FROM_ORIGIN | MF_TREAT_AS_BLOCKING | MF_NOT_IN_HALLWAY)],
    [0,         0,          0,              [1, 1],     1,          0,          -1,         0,              4,              0,          0,          MF_BUILD_AT_ORIGIN],
    [0,         FLAMETHROWER_HIDDEN,DUNGEON,[40, 60],   20,         0,          -1,         0,              1,              0,          0,          (MF_TREAT_AS_BLOCKING)],
		[DF_DEEP_WATER_POOL,0,  0,              [4, 4],		1,			0,			-1,			0,				4,				HORDE_MACHINE_WATER_MONSTER,0,MF_GENERATE_HORDE],
    [DF_GRASS,	FOLIAGE,	SURFACE,		[3, 4],		3,			0,			-1,			0,				1,				0,			0,			0]]],
  // Thief area -- empty altar, monster with item, permanently fleeing.
  [[3, AMULET_LEVEL],	[15, 20],	10,		2,			0,                  (BP_ADOPT_ITEM),	[
		[DF_LUMINESCENT_FUNGUS,	ALTAR_INERT,DUNGEON,[1,1],	1,			0,			-1,			0,				2,				HORDE_MACHINE_THIEF,0,			(MF_ADOPT_ITEM | MF_BUILD_AT_ORIGIN | MF_TREAT_AS_BLOCKING | MF_NOT_IN_HALLWAY | MF_GENERATE_HORDE | MF_MONSTER_TAKE_ITEM | MF_MONSTER_FLEEING)],
    [0,         STATUE_INERT,0,             [3, 5],     2,          0,          -1,         0,              2,              0,          0,          (MF_FAR_FROM_ORIGIN | MF_TREAT_AS_BLOCKING | MF_NOT_IN_HALLWAY)]]],
	// Collapsing floor area -- key on an altar in an area; take key to cause the floor of the area to collapse
	[[1, AMULET_LEVEL],	[45, 65],	13,		3,			0,                  (BP_ADOPT_ITEM | BP_TREAT_AS_BLOCKING),	[
		[0,			FLOOR_FLOODABLE,DUNGEON,	[0,0],		0,			0,			-1,			0,				0,				0,			0,			(MF_EVERYWHERE)],
		[0,			ALTAR_SWITCH_RETRACTING,DUNGEON,[1,1],	1,			0,			-1,			0,				3,				0,			0,			(MF_ADOPT_ITEM | MF_NEAR_ORIGIN | MF_TREAT_AS_BLOCKING | MF_NOT_IN_HALLWAY)],
		[DF_ADD_MACHINE_COLLAPSE_EDGE_DORMANT,0,0,[3, 3],	2,			0,			-1,			0,				3,				0,			0,			(MF_FAR_FROM_ORIGIN | MF_NOT_IN_HALLWAY)]]],
	// Pit traps -- key on an altar, room full of pit traps
	[[1, AMULET_LEVEL],	[30, 100],	10,		3,			0,                  (BP_ROOM | BP_ADOPT_ITEM),	[
		[0,			ALTAR_INERT,DUNGEON,		[1,1],		1,			0,			-1,			0,				2,				0,			0,			(MF_ADOPT_ITEM | MF_FAR_FROM_ORIGIN | MF_TREAT_AS_BLOCKING)],
		[0,			TRAP_DOOR_HIDDEN,DUNGEON,	[30, 40],	1,			0,			-1,			0,				1,				0,			0,			(MF_TREAT_AS_BLOCKING | MF_REPEAT_UNTIL_NO_PROGRESS)],
		[0,			SECRET_DOOR,DUNGEON,		[1,1],		1,			0,			0,			0,				1,				0,			0,			(MF_PERMIT_BLOCKING | MF_BUILD_AT_ORIGIN)]]],
	// Levitation challenge -- key on an altar, room filled with pit, levitation or lever elsewhere on level, bridge appears when you grab the key/lever.
	[[1, 13],			[75, 120],	10,		9,			0,                  (BP_ROOM | BP_ADOPT_ITEM | BP_PURGE_INTERIOR | BP_OPEN_INTERIOR | BP_SURROUND_WITH_WALLS),	[
		[0,			ALTAR_SWITCH,DUNGEON,		[1,1],		1,			0,			-1,			0,				3,				0,			0,			(MF_ADOPT_ITEM | MF_FAR_FROM_ORIGIN | MF_TREAT_AS_BLOCKING)],
		[0,			TORCH_WALL,	DUNGEON,		[1,4],		0,			0,			0,			0,				1,				0,			0,			(MF_BUILD_IN_WALLS)],
		[0,			0,			0,				[1,1],		1,			0,			0,			0,				3,				0,			0,			MF_BUILD_AT_ORIGIN],
		[DF_ADD_DORMANT_CHASM_HALO,	CHASM,LIQUID,[120, 120],1,			0,			-1,			0,				1,				0,			0,			(MF_TREAT_AS_BLOCKING | MF_REPEAT_UNTIL_NO_PROGRESS)],
		[DF_ADD_DORMANT_CHASM_HALO,	CHASM_WITH_HIDDEN_BRIDGE,LIQUID,[1,1],1,0,		0,			0,				1,				0,			0,			(MF_PERMIT_BLOCKING | MF_EVERYWHERE)],
		[0,			0,			0,				[1,1],		1,			POTION,		POTION_LEVITATION, 0,       1,				0,			0,			(MF_GENERATE_ITEM | MF_BUILD_ANYWHERE_ON_LEVEL | MF_NOT_IN_HALLWAY | MF_ALTERNATIVE)],
    [0,			WALL_LEVER_HIDDEN,DUNGEON,  [1,1],      1,			0,			-1,			0,				1,				0,			0,			(MF_BUILD_IN_WALLS | MF_IN_PASSABLE_VIEW_OF_ORIGIN | MF_BUILD_ANYWHERE_ON_LEVEL | MF_ALTERNATIVE)]]],
	// Web climbing -- key on an altar, room filled with pit, spider at altar to shoot webs, bridge appears when you grab the key
	[[7, AMULET_LEVEL],	[55, 90],	10,		7,			0,                  (BP_ROOM | BP_ADOPT_ITEM | BP_PURGE_INTERIOR | BP_OPEN_INTERIOR | BP_SURROUND_WITH_WALLS),	[
		[0,			ALTAR_SWITCH,DUNGEON,		[1,1],		1,			0,			-1,			MK_SPIDER,		3,				0,			0,			(MF_ADOPT_ITEM | MF_FAR_FROM_ORIGIN | MF_TREAT_AS_BLOCKING | MF_IN_VIEW_OF_ORIGIN)],
		[0,			TORCH_WALL,	DUNGEON,		[1,4],		0,			0,			0,			0,				1,				0,			0,			(MF_BUILD_IN_WALLS)],
		[0,			0,			0,				[1,1],		1,			0,			0,			0,				3,				0,			0,			MF_BUILD_AT_ORIGIN],
		[DF_ADD_DORMANT_CHASM_HALO,	CHASM,LIQUID,	[120, 120],	1,		0,			-1,			0,				1,				0,			0,			(MF_TREAT_AS_BLOCKING | MF_REPEAT_UNTIL_NO_PROGRESS)],
		[DF_ADD_DORMANT_CHASM_HALO,	CHASM_WITH_HIDDEN_BRIDGE,LIQUID,[1,1],1,0,		0,			0,				1,				0,			0,			(MF_PERMIT_BLOCKING | MF_EVERYWHERE)]]],
	// Lava moat room -- key on an altar, room filled with lava, levitation/fire immunity/lever elsewhere on level, lava retracts when you grab the key/lever
	[[3, 13],			[75, 120],	7,		7,			0,                  (BP_ROOM | BP_ADOPT_ITEM | BP_PURGE_INTERIOR | BP_SURROUND_WITH_WALLS | BP_OPEN_INTERIOR),	[
		[0,			ALTAR_SWITCH,DUNGEON,		[1,1],		1,			0,			-1,			0,				2,				0,			0,			(MF_ADOPT_ITEM | MF_FAR_FROM_ORIGIN | MF_TREAT_AS_BLOCKING)],
		[0,			0,			0,				[1,1],		1,			0,			0,			0,				2,				0,			0,			(MF_BUILD_AT_ORIGIN)],
    [0,			LAVA,       LIQUID,         [60,60],	1,			0,			0,			0,				1,				0,			0,			(MF_TREAT_AS_BLOCKING | MF_REPEAT_UNTIL_NO_PROGRESS)],
		[DF_LAVA_RETRACTABLE, LAVA_RETRACTABLE, LIQUID,             [1,1],		1,			0,			0,			0,				1,				0,			0,			(MF_PERMIT_BLOCKING | MF_EVERYWHERE)],
		[0,			0,			0,				[1,1],		1,			POTION,		POTION_LEVITATION, 0,       1,				0,			0,			(MF_GENERATE_ITEM | MF_BUILD_ANYWHERE_ON_LEVEL | MF_NOT_IN_HALLWAY | MF_ALTERNATIVE)],
		[0,			0,			0,				[1,1],		1,			POTION,		POTION_FIRE_IMMUNITY, 0,	1,				0,			0,			(MF_GENERATE_ITEM | MF_BUILD_ANYWHERE_ON_LEVEL | MF_NOT_IN_HALLWAY | MF_ALTERNATIVE)],
    [0,			WALL_LEVER_HIDDEN,DUNGEON,  [1,1],      1,			0,			-1,			0,				1,				0,			0,			(MF_BUILD_IN_WALLS | MF_IN_PASSABLE_VIEW_OF_ORIGIN | MF_BUILD_ANYWHERE_ON_LEVEL | MF_ALTERNATIVE)]]],
	// Lava moat area -- key on an altar, surrounded with lava, levitation/fire immunity elsewhere on level, lava retracts when you grab the key
	[[3, 13],			[40, 60],	3,		5,			0,                  (BP_ADOPT_ITEM | BP_PURGE_INTERIOR | BP_OPEN_INTERIOR | BP_TREAT_AS_BLOCKING),	[
		[0,			ALTAR_SWITCH,DUNGEON,		[1,1],		1,			0,			-1,			0,				2,				0,			0,			(MF_ADOPT_ITEM | MF_BUILD_AT_ORIGIN | MF_TREAT_AS_BLOCKING)],
    [0,			LAVA,       LIQUID,         [60,60],	1,			0,			0,			0,				1,				0,			0,			(MF_TREAT_AS_BLOCKING | MF_REPEAT_UNTIL_NO_PROGRESS)],
		[DF_LAVA_RETRACTABLE, LAVA_RETRACTABLE, LIQUID,             [1,1],		1,			0,			0,			0,				1,				0,			0,			(MF_PERMIT_BLOCKING | MF_EVERYWHERE)],
		[0,			0,			0,				[1,1],		1,			POTION,		POTION_LEVITATION, 0,       1,				0,			0,			(MF_GENERATE_ITEM | MF_BUILD_ANYWHERE_ON_LEVEL | MF_NOT_IN_HALLWAY | MF_ALTERNATIVE)],
		[0,			0,			0,				[1,1],		1,			POTION,		POTION_FIRE_IMMUNITY, 0,    1,				0,			0,			(MF_GENERATE_ITEM | MF_BUILD_ANYWHERE_ON_LEVEL | MF_NOT_IN_HALLWAY | MF_ALTERNATIVE)]]],
	// Poison gas -- key on an altar; take key to cause a caustic gas vent to appear and the door to be blocked; there is a hidden trapdoor or an escape item somewhere inside
	[[4, AMULET_LEVEL],	[35, 60],	7,		7,			0,                  (BP_ROOM | BP_PURGE_INTERIOR | BP_SURROUND_WITH_WALLS | BP_ADOPT_ITEM),	[
		[0,			ALTAR_SWITCH,DUNGEON,		[1,1],		1,			0,			-1,			0,				2,				0,			0,			(MF_ADOPT_ITEM | MF_TREAT_AS_BLOCKING)],
		[0,			MACHINE_POISON_GAS_VENT_HIDDEN,DUNGEON,[1,2], 1,	0,			-1,			0,				2,				0,			0,			0],
		[0,			TRAP_DOOR_HIDDEN,DUNGEON,	[1,1],		1,			0,			-1,			0,				2,				0,			0,			MF_ALTERNATIVE],
		[0,			0,			0,				[1,1],		1,			SCROLL,		SCROLL_TELEPORT, 0,			2,				0,			0,			(MF_GENERATE_ITEM | MF_NOT_IN_HALLWAY | MF_ALTERNATIVE)],
		[0,			0,			0,				[1,1],		1,			POTION,		POTION_DESCENT, 0,          2,				0,			0,			(MF_GENERATE_ITEM | MF_NOT_IN_HALLWAY | MF_ALTERNATIVE)],
    [0,			WALL_LEVER_HIDDEN_DORMANT,DUNGEON,[1,1],1,			0,			-1,			0,				1,				0,			0,			(MF_BUILD_IN_WALLS)],
    [0,			PORTCULLIS_DORMANT,DUNGEON,[1,1],       1,          0,			0,			0,				1,				0,			0,			(MF_BUILD_AT_ORIGIN | MF_PERMIT_BLOCKING)]]],
	// Explosive situation -- key on an altar; take key to cause a methane gas vent to appear and a pilot light to ignite
	[[7, AMULET_LEVEL],	[80, 90],	10,		5,			0,                  (BP_ROOM | BP_PURGE_LIQUIDS | BP_SURROUND_WITH_WALLS | BP_ADOPT_ITEM),	[
		[0,			DOOR,       DUNGEON,		[1,1],		1,			0,			0,			0,				1,				0,			0,			(MF_BUILD_AT_ORIGIN)],
    [0,			FLOOR,		DUNGEON,		[0,0],		0,			0,			-1,			0,				0,				0,			0,			(MF_EVERYWHERE)],
    [0,			ALTAR_SWITCH,DUNGEON,		[1,1],		1,			0,			-1,			0,				1,				0,			0,			(MF_ADOPT_ITEM | MF_TREAT_AS_BLOCKING | MF_FAR_FROM_ORIGIN)],
		[0,			MACHINE_METHANE_VENT_HIDDEN,DUNGEON,[1,1], 1,		0,			-1,			0,				1,				0,			0,			MF_NEAR_ORIGIN],
		[0,			PILOT_LIGHT_DORMANT,DUNGEON,[1,1],		1,			0,			-1,			0,				1,				0,			0,			(MF_FAR_FROM_ORIGIN | MF_BUILD_IN_WALLS)]]],
	// Burning grass -- key on an altar; take key to cause pilot light to ignite grass in room
	[[1, 7],			[40, 110],	10,		6,			0,                  (BP_ROOM | BP_PURGE_INTERIOR | BP_SURROUND_WITH_WALLS | BP_ADOPT_ITEM | BP_OPEN_INTERIOR),	[
		[DF_SMALL_DEAD_GRASS,ALTAR_SWITCH_RETRACTING,DUNGEON,[1,1],1,	0,			-1,			0,				1,				0,			0,			(MF_ADOPT_ITEM | MF_TREAT_AS_BLOCKING | MF_FAR_FROM_ORIGIN)],
		[DF_DEAD_FOLIAGE,0,		SURFACE,		[2,3],		0,			0,			-1,			0,				1,				0,			0,			0],
		[0,			FOLIAGE,	SURFACE,		[1,4],		0,			0,			-1,			0,				1,				0,			0,			0],
		[0,			GRASS,		SURFACE,		[10,25],	0,			0,			-1,			0,				1,				0,			0,			0],
		[0,			DEAD_GRASS,	SURFACE,		[0,0],		0,			0,			-1,			0,				0,				0,			0,			(MF_EVERYWHERE)],
		[0,			PILOT_LIGHT_DORMANT,DUNGEON,[1,1],		1,			0,			-1,			0,				1,				0,			0,			MF_NEAR_ORIGIN | MF_BUILD_IN_WALLS]]],
	// Statuary -- key on an altar, area full of statues; take key to cause statues to burst and reveal monsters
	[[10, AMULET_LEVEL],[35, 90],	10,		2,			0,                  (BP_ADOPT_ITEM | BP_NO_INTERIOR_FLAG),	[
		[0,			ALTAR_SWITCH,DUNGEON,		[1,1],		1,			0,			-1,			0,				2,				0,			0,			(MF_ADOPT_ITEM | MF_NEAR_ORIGIN | MF_TREAT_AS_BLOCKING | MF_NOT_IN_HALLWAY)],
		[0,			STATUE_DORMANT,DUNGEON,		[3,5],		3,			0,			-1,			0,				2,				HORDE_MACHINE_STATUE,0,	(MF_TREAT_AS_BLOCKING | MF_NOT_IN_HALLWAY | MF_GENERATE_HORDE | MF_MONSTERS_DORMANT | MF_FAR_FROM_ORIGIN)]]],
  // Guardian water puzzle -- key held by a guardian, flood trap in the room, glyphs scattered. Lure the guardian into the water to have him drop the key.
	[[4, AMULET_LEVEL], [35, 70],	8,		4,			0,                  (BP_ROOM | BP_PURGE_INTERIOR | BP_SURROUND_WITH_WALLS | BP_ADOPT_ITEM),	[
  	[0,         0,          0,              [1,1],      1,          0,          -1,         0,              2,              0,          0,          (MF_BUILD_AT_ORIGIN)],
		[0,			0,          0,              [1,1],		1,			0,			-1,			MK_GUARDIAN,	2,				0,			0,			(MF_ADOPT_ITEM | MF_FAR_FROM_ORIGIN | MF_TREAT_AS_BLOCKING | MF_NOT_IN_HALLWAY | MF_MONSTER_TAKE_ITEM)],
		[0,			FLOOD_TRAP,DUNGEON,         [1,1],		1,			0,			-1,			0,				2,				0,          0,          (MF_TREAT_AS_BLOCKING | MF_NOT_IN_HALLWAY)],
    [0,         MACHINE_GLYPH,DUNGEON,      [1,1],      4,          0,          -1,         0,              2,              0,          0,          (MF_EVERYWHERE | MF_NOT_IN_HALLWAY)]]],
  // Guardian gauntlet -- key in a room full of guardians, glyphs scattered and unavoidable.
	[[6, AMULET_LEVEL], [50, 95],	10,		6,			0,                  (BP_ROOM | BP_ADOPT_ITEM),	[
    [DF_GLYPH_CIRCLE,ALTAR_INERT,DUNGEON,	[1,1],		1,			0,			-1,			0,				1,				0,			0,			(MF_ADOPT_ITEM | MF_TREAT_AS_BLOCKING | MF_NOT_IN_HALLWAY | MF_FAR_FROM_ORIGIN)],
		[0,			DOOR,       DUNGEON,        [1,1],		1,			0,			0,			0,				3,				0,			0,			(MF_PERMIT_BLOCKING | MF_BUILD_AT_ORIGIN)],
		[0,			0,          0,              [3,6],		3,			0,			-1,			MK_GUARDIAN,	2,				0,			0,			(MF_NEAR_ORIGIN | MF_TREAT_AS_BLOCKING | MF_NOT_IN_HALLWAY | MF_ALTERNATIVE)],
		[0,			0,          0,              [1,2],		1,			0,			-1,			MK_WINGED_GUARDIAN,2,           0,			0,			(MF_NEAR_ORIGIN | MF_TREAT_AS_BLOCKING | MF_NOT_IN_HALLWAY | MF_ALTERNATIVE)],
    [0,         MACHINE_GLYPH,DUNGEON,      [10,15],   10,          0,          -1,         0,              1,              0,          0,          (MF_PERMIT_BLOCKING | MF_NOT_IN_HALLWAY)],
    [0,         MACHINE_GLYPH,DUNGEON,      [1,1],      0,          0,          -1,         0,              2,              0,          0,          (MF_EVERYWHERE | MF_PERMIT_BLOCKING | MF_NOT_IN_HALLWAY)]]],
  // Guardian corridor -- key in a small room, with a connecting corridor full of glyphs, one guardian blocking the corridor.
  [[4, AMULET_LEVEL], [85, 100],   5,     7,          0,                  (BP_ROOM | BP_ADOPT_ITEM | BP_PURGE_INTERIOR | BP_OPEN_INTERIOR | BP_SURROUND_WITH_WALLS),        [
    [DF_GLYPH_CIRCLE,ALTAR_INERT,DUNGEON,   [1,1],      1,          0,          -1,         MK_GUARDIAN,    3,              0,          0,          (MF_ADOPT_ITEM | MF_FAR_FROM_ORIGIN  | MF_ALTERNATIVE)],
    [DF_GLYPH_CIRCLE,ALTAR_INERT,DUNGEON,   [1,1],      1,          0,          -1,         MK_WINGED_GUARDIAN,3,           0,          0,          (MF_ADOPT_ITEM | MF_FAR_FROM_ORIGIN  | MF_ALTERNATIVE)],
    [0,         MACHINE_GLYPH,DUNGEON,      [3,5],      2,          0,          0,          0,              2,              0,          0,          MF_NEAR_ORIGIN | MF_NOT_IN_HALLWAY],
    [0,         0,          0,              [1,1],      1,          0,          0,          0,              3,              0,          0,          MF_BUILD_AT_ORIGIN],
    [0,         WALL,DUNGEON,               [80,80],    1,          0,          -1,         0,              1,              0,          0,          (MF_TREAT_AS_BLOCKING | MF_REPEAT_UNTIL_NO_PROGRESS)],
    [0,         MACHINE_GLYPH,DUNGEON,      [1,1],      1,          0,          0,          0,              1,              0,          0,          (MF_PERMIT_BLOCKING | MF_EVERYWHERE)],
    [0,			MACHINE_GLYPH,DUNGEON,      [1,1],      1,			0,			-1,			0,				1,				0,			0,			(MF_IN_PASSABLE_VIEW_OF_ORIGIN | MF_NOT_IN_HALLWAY | MF_BUILD_ANYWHERE_ON_LEVEL)]]],
	// Sacrifice altar -- lure the chosen monster from elsewhere on the level onto the altar to release the key.
  [[4, AMULET_LEVEL], [20, 60],   12,     6,          0,                  (BP_ROOM | BP_ADOPT_ITEM | BP_PURGE_INTERIOR | BP_OPEN_INTERIOR | BP_SURROUND_WITH_WALLS),        [
    [DF_BONES,  0,          0,              [3,4],      2,          0,          -1,         0,              1,              0,          0,          0],
    [0,         0,          0,              [1,1],      0,          0,			-1,			0,				2,				0,			0,			(MF_BUILD_IN_WALLS | MF_EVERYWHERE)],
    [DF_TRIGGER_AREA,SACRIFICE_ALTAR_DORMANT,DUNGEON,[1,1],1,       0,          -1,         0,              2,              0,          0,          (MF_FAR_FROM_ORIGIN | MF_NOT_IN_HALLWAY)],
    [0,         SACRIFICE_CAGE_DORMANT,DUNGEON,[1,1],   1,          0,          -1,         0,              2,              0,          0,          (MF_ADOPT_ITEM | MF_NOT_IN_HALLWAY | MF_IMPREGNABLE)],
    [0,         DEMONIC_STATUE,DUNGEON,     [1,1],      1,          0,          -1,         0,              2,              0,          0,          (MF_FAR_FROM_ORIGIN | MF_NOT_IN_HALLWAY | MF_IMPREGNABLE)],
 		[0,         STATUE_INSTACRACK,DUNGEON,  [1,1],      1,			0,			-1,			0,				2,				(HORDE_SACRIFICE_TARGET), 0, (MF_BUILD_ANYWHERE_ON_LEVEL | MF_GENERATE_HORDE | MF_MONSTERS_DORMANT | MF_TREAT_AS_BLOCKING | MF_IMPREGNABLE | MF_NOT_IN_HALLWAY)]]],

  // Summoning circle -- key in a room with an eldritch totem, glyphs unavoidable. // DISABLED. (Not fun enough.)
	[[12, AMULET_LEVEL], [50, 100],	0,		2,			0,                  (BP_ROOM | BP_OPEN_INTERIOR | BP_ADOPT_ITEM),	[
    [DF_GLYPH_CIRCLE,ALTAR_INERT,DUNGEON,	[1,1],		1,			0,			-1,			0,				3,				0,			0,			(MF_ADOPT_ITEM | MF_TREAT_AS_BLOCKING | MF_NOT_IN_HALLWAY | MF_FAR_FROM_ORIGIN)],
		[DF_GLYPH_CIRCLE,0,     0,              [1,1],		1,			0,			-1,			MK_ELDRITCH_TOTEM,3,			0,			0,			(MF_FAR_FROM_ORIGIN | MF_TREAT_AS_BLOCKING | MF_NOT_IN_HALLWAY)]]],
    // Beckoning obstacle -- key surrounded by glyphs in a room with a mirrored totem.
	[[5, AMULET_LEVEL], [60, 100],	10,		4,			0,                  (BP_ROOM | BP_PURGE_INTERIOR | BP_SURROUND_WITH_WALLS | BP_OPEN_INTERIOR | BP_ADOPT_ITEM), [
    [DF_GLYPH_CIRCLE,ALTAR_INERT,DUNGEON,	[1,1],		1,			0,			-1,			0,				3,				0,			0,			(MF_ADOPT_ITEM | MF_TREAT_AS_BLOCKING | MF_NOT_IN_HALLWAY | MF_FAR_FROM_ORIGIN | MF_IN_VIEW_OF_ORIGIN)],
		[0,         0,          0,              [1,1],		1,			0,			-1,			MK_MIRRORED_TOTEM,3,			0,			0,			(MF_NEAR_ORIGIN | MF_TREAT_AS_BLOCKING | MF_NOT_IN_HALLWAY | MF_IN_VIEW_OF_ORIGIN)],
    [0,         0,          0,              [1,1],      1,          0,          -1,         0,              2,              0,          0,          (MF_BUILD_AT_ORIGIN)],
    [0,         MACHINE_GLYPH,DUNGEON,      [3,5],      2,          0,          -1,         0,              2,              0,          0,          (MF_TREAT_AS_BLOCKING)]]],
    // Worms in the walls -- key on altar; take key to cause underworms to burst out of the walls
	[[12,AMULET_LEVEL],	[7, 7],		7,		2,			0,                  (BP_ADOPT_ITEM),	[
		[0,			ALTAR_SWITCH,DUNGEON,		[1,1],		1,			0,			-1,			0,				2,				0,			0,			(MF_ADOPT_ITEM | MF_NEAR_ORIGIN | MF_TREAT_AS_BLOCKING | MF_NOT_IN_HALLWAY)],
		[0,			WALL_MONSTER_DORMANT,DUNGEON,[5,8],		5,			0,			-1,			MK_UNDERWORM,	1,				0,			0,			(MF_MONSTERS_DORMANT | MF_BUILD_IN_WALLS | MF_NOT_ON_LEVEL_PERIMETER)]]],
	// Mud pit -- key on an altar, room full of mud, take key to cause bog monsters to spawn in the mud
	[[12, AMULET_LEVEL],[40, 90],	10,		3,			0,                  (BP_ROOM | BP_ADOPT_ITEM | BP_SURROUND_WITH_WALLS | BP_PURGE_LIQUIDS),	[
		[DF_SWAMP,		0,		0,				[5,5],		0,			0,			-1,			0,				1,				0,			0,			0],
		[DF_SWAMP,	ALTAR_SWITCH,DUNGEON,		[1,1],		1,			0,			-1,			0,				2,				0,			0,			(MF_ADOPT_ITEM | MF_FAR_FROM_ORIGIN | MF_TREAT_AS_BLOCKING)],
		[DF_MUD_DORMANT,0,		0,				[3,4],		3,			0,			-1,			0,				1,				HORDE_MACHINE_MUD,0,	(MF_GENERATE_HORDE | MF_MONSTERS_DORMANT)]]],
    // Electric crystals -- key caged on an altar, darkened crystal globes around the room, lightning the globes to release the key.
	[[6, AMULET_LEVEL],[40, 60],	10,		4,			0,                  (BP_ROOM | BP_ADOPT_ITEM | BP_SURROUND_WITH_WALLS | BP_OPEN_INTERIOR | BP_PURGE_INTERIOR),	[
		[0,			CARPET,		DUNGEON,		[0,0],		0,			0,			-1,			0,				0,				0,			0,			(MF_EVERYWHERE)],
		[0,         ELECTRIC_CRYSTAL_OFF,DUNGEON,[3,4],		3,			0,			-1,			0,				3,				0,			0,			(MF_NOT_IN_HALLWAY | MF_IMPREGNABLE)],
    [0,			ALTAR_CAGE_RETRACTABLE,DUNGEON,[1,1],	1,			0,			-1,			0,				3,				0,			0,			(MF_ADOPT_ITEM | MF_IMPREGNABLE | MF_NOT_IN_HALLWAY | MF_FAR_FROM_ORIGIN)],
    [0,         TURRET_LEVER, DUNGEON,      [7,9],      4,			0,			-1,			MK_SPARK_TURRET,3,				0,          0,          (MF_BUILD_IN_WALLS | MF_MONSTERS_DORMANT)]]],
    // Zombie crypt -- key on an altar; coffins scattered around; brazier in the room; take key to cause zombies to burst out of all of the coffins
	[[12, AMULET_LEVEL],[60, 90],	10,		8,			0,                  (BP_ROOM | BP_ADOPT_ITEM | BP_SURROUND_WITH_WALLS | BP_PURGE_INTERIOR),	[
		[0,         DOOR,       DUNGEON,        [1,1],		1,			0,			-1,			0,				1,				0,			0,			(MF_BUILD_AT_ORIGIN)],
    [DF_BONES,  0,          0,              [3,4],      2,          0,          -1,         0,              1,              0,          0,          0],
    [DF_ASH,    0,          0,              [3,4],      2,          0,          -1,         0,              1,              0,          0,          0],
    [DF_AMBIENT_BLOOD,0,    0,              [1,2],		1,			0,			-1,			0,				1,				0,			0,			0],
		[DF_AMBIENT_BLOOD,0,    0,              [1,2],		1,			0,			-1,			0,				1,				0,			0,			0],
    [0,         ALTAR_SWITCH,DUNGEON,		[1,1],		1,			0,			-1,			0,				2,				0,			0,			(MF_ADOPT_ITEM | MF_FAR_FROM_ORIGIN | MF_TREAT_AS_BLOCKING)],
    [0,         BRAZIER,    DUNGEON,        [1,1],      1,          0,          -1,         0,              2,              0,          0,          (MF_NEAR_ORIGIN | MF_TREAT_AS_BLOCKING)],
    [0,         COFFIN_CLOSED, DUNGEON,		[6,8],		1,			0,          0,          MK_ZOMBIE,		2,				0,			0,          (MF_TREAT_AS_BLOCKING | MF_NOT_IN_HALLWAY | MF_MONSTERS_DORMANT)]]],
	// Haunted house -- key on an altar; take key to cause the room to darken, ectoplasm to cover everything and phantoms to appear
	[[16, AMULET_LEVEL],[45, 150],	10,		4,			0,                  (BP_ROOM | BP_ADOPT_ITEM | BP_PURGE_INTERIOR | BP_SURROUND_WITH_WALLS),	[
		[0,			ALTAR_SWITCH,DUNGEON,		[1,1],		1,			0,			-1,			0,				2,				0,			0,			(MF_ADOPT_ITEM | MF_FAR_FROM_ORIGIN | MF_TREAT_AS_BLOCKING)],
		[0,			DARK_FLOOR_DORMANT,DUNGEON,	[0,0],		0,			0,			-1,			0,				0,				0,			0,			(MF_EVERYWHERE)],
		[0,			DARK_FLOOR_DORMANT,DUNGEON,	[4,5],		4,			0,			-1,			MK_PHANTOM,		1,				0,			0,			(MF_MONSTERS_DORMANT)],
    [0,         HAUNTED_TORCH_DORMANT,DUNGEON,[5,10],   3,          0,          -1,         0,              2,              0,          0,          (MF_BUILD_IN_WALLS)]]],
    // Worm tunnels -- hidden lever causes tunnels to open up revealing worm areas and a key
  [[8, AMULET_LEVEL],[80, 175],	10,		6,			0,                  (BP_ROOM | BP_ADOPT_ITEM | BP_PURGE_INTERIOR | BP_MAXIMIZE_INTERIOR | BP_SURROUND_WITH_WALLS),	[
		[0,			ALTAR_INERT,DUNGEON,		[1,1],		1,			0,			-1,			0,				2,				0,			0,			(MF_ADOPT_ITEM | MF_FAR_FROM_ORIGIN | MF_TREAT_AS_BLOCKING)],
		[0,			0,          0,              [3,6],		3,			0,			-1,			MK_UNDERWORM,	1,				0,			0,			0],
		[0,			GRANITE,    DUNGEON,        [150,150],  1,			0,			-1,			0,				1,				0,			0,			(MF_TREAT_AS_BLOCKING | MF_REPEAT_UNTIL_NO_PROGRESS)],
    [DF_WORM_TUNNEL_MARKER_DORMANT,GRANITE,DUNGEON,[0,0],0,			0,			-1,			0,				0,				0,			0,			(MF_EVERYWHERE | MF_PERMIT_BLOCKING)],
    [DF_TUNNELIZE,WORM_TUNNEL_OUTER_WALL,DUNGEON,[1,1],	1,			0,			-1,			0,				1,				0,			0,			(MF_BUILD_AT_ORIGIN | MF_PERMIT_BLOCKING)],
    [0,			WALL_LEVER_HIDDEN,DUNGEON,  [1,1],      1,			0,			-1,			0,				1,				0,			0,			(MF_BUILD_IN_WALLS | MF_IN_PASSABLE_VIEW_OF_ORIGIN | MF_BUILD_ANYWHERE_ON_LEVEL)]]],
    // Gauntlet -- key on an altar; take key to cause turrets to emerge
	[[5, 24],			[35, 90],	10,		2,			0,                  (BP_ADOPT_ITEM | BP_NO_INTERIOR_FLAG),	[
		[0,			ALTAR_SWITCH,DUNGEON,		[1,1],		1,			0,			-1,			0,				2,				0,			0,			(MF_ADOPT_ITEM | MF_NEAR_ORIGIN | MF_NOT_IN_HALLWAY | MF_TREAT_AS_BLOCKING)],
		[0,			TURRET_DORMANT,DUNGEON,		[4,6],		4,			0,			-1,			0,				2,				HORDE_MACHINE_TURRET,0,	(MF_TREAT_AS_BLOCKING | MF_GENERATE_HORDE | MF_MONSTERS_DORMANT | MF_BUILD_IN_WALLS | MF_IN_VIEW_OF_ORIGIN)]]],
	// Boss -- key is held by a boss atop a pile of bones in a secret room. A few fungus patches light up the area.
	[[5, AMULET_LEVEL],	[40, 100],	18,		3,			0,                  (BP_ROOM | BP_ADOPT_ITEM | BP_SURROUND_WITH_WALLS | BP_PURGE_LIQUIDS), [
		[DF_BONES,	SECRET_DOOR,DUNGEON,		[1,1],		1,			0,			0,			0,				3,				0,			0,			(MF_PERMIT_BLOCKING | MF_BUILD_AT_ORIGIN)],
		[DF_LUMINESCENT_FUNGUS,	STATUE_INERT,DUNGEON,[7,7],	0,			0,			-1,			0,				2,				0,			0,			(MF_TREAT_AS_BLOCKING)],
		[DF_BONES,	0,			0,				[1,1],		1,			0,			-1,			0,				1,				HORDE_MACHINE_BOSS,	0,	(MF_ADOPT_ITEM | MF_FAR_FROM_ORIGIN | MF_MONSTER_TAKE_ITEM | MF_GENERATE_HORDE | MF_MONSTER_SLEEPING)]]],

	// -- FLAVOR MACHINES --

	// Bloodwort -- bloodwort stalk, some pods, and surrounding grass
	[[1,DEEPEST_LEVEL],	[5, 5],     0,          2,      0,                  (BP_TREAT_AS_BLOCKING), [
		[DF_GRASS,	BLOODFLOWER_STALK, SURFACE,	[1, 1],		1,			0,			-1,			0,				0,				0,			0,			(MF_BUILD_AT_ORIGIN | MF_NOT_IN_HALLWAY)],
		[DF_BLOODFLOWER_PODS_GROW_INITIAL,0, 0, [1, 1],     1,			0,			-1,			0,				1,				0,			0,          (MF_BUILD_AT_ORIGIN | MF_TREAT_AS_BLOCKING)]]],
	// Shrine -- safe haven constructed and abandoned by a past adventurer
	[[1,DEEPEST_LEVEL],	[15, 25],   0,          3,      0,                  (BP_ROOM | BP_PURGE_INTERIOR | BP_SURROUND_WITH_WALLS | BP_OPEN_INTERIOR), [
		[0,         SACRED_GLYPH,  DUNGEON,     [1, 1],		1,			0,			-1,			0,				3,				0,			0,			(MF_BUILD_AT_ORIGIN)],
		[0,         HAVEN_BEDROLL, SURFACE,     [1, 1],     1,			0,			-1,			0,				2,				0,			0,          (MF_FAR_FROM_ORIGIN | MF_TREAT_AS_BLOCKING | MF_NOT_IN_HALLWAY)],
    [0,         BONES,      SURFACE,        [1, 1],     1,			(POTION|SCROLL|WEAPON|ARMOR|RING),-1,0,	2,				0,			0,          (MF_GENERATE_ITEM | MF_TREAT_AS_BLOCKING | MF_NOT_IN_HALLWAY)]]],
    // Idyll -- ponds and some grass and forest
	[[1,DEEPEST_LEVEL],	[80, 120],	0,		2,			0,                  BP_NO_INTERIOR_FLAG, [
		[DF_GRASS,	FOLIAGE,	SURFACE,		[3, 4],		3,			0,			-1,			0,				1,				0,			0,			0],
		[DF_DEEP_WATER_POOL,0,	0,				[2, 3],		2,			0,			-1,			0,				5,				0,			0,			(MF_NOT_IN_HALLWAY)]]],
	// Swamp -- mud, grass and some shallow water
	[[1,DEEPEST_LEVEL],	[50, 65],	0,		2,			0,                  BP_NO_INTERIOR_FLAG, [
		[DF_SWAMP,	0,			0,				[6, 8],		3,			0,			-1,			0,				1,				0,			0,			0],
		[DF_DEEP_WATER_POOL,0,	0,				[0, 1],		0,			0,			-1,			0,				3,				0,			0,			(MF_NOT_IN_HALLWAY | MF_TREAT_AS_BLOCKING)]]],
	// Camp -- hay, junk, urine, vomit
	[[1,DEEPEST_LEVEL],	[40, 50],	0,		4,			0,                  BP_NO_INTERIOR_FLAG, [
		[DF_HAY,	0,			0,				[1, 3],		1,			0,			-1,			0,				1,				0,			0,			(MF_NOT_IN_HALLWAY | MF_IN_VIEW_OF_ORIGIN)],
		[DF_JUNK,	0,			0,				[1, 2],		1,			0,			-1,			0,				3,				0,			0,			(MF_NOT_IN_HALLWAY | MF_IN_VIEW_OF_ORIGIN)],
		[DF_URINE,	0,			0,				[3, 5],		1,			0,			-1,			0,				1,				0,			0,			MF_IN_VIEW_OF_ORIGIN],
		[DF_VOMIT,	0,			0,				[0, 2],		0,			0,			-1,			0,				1,				0,			0,			MF_IN_VIEW_OF_ORIGIN]]],
	// Remnant -- carpet surrounded by ash and with some statues
	[[1,DEEPEST_LEVEL],	[80, 120],	0,		2,			0,                  BP_NO_INTERIOR_FLAG, [
		[DF_REMNANT, 0,			0,				[6, 8],		3,			0,			-1,			0,				1,				0,			0,			0],
		[0,			STATUE_INERT,DUNGEON,       [3, 5],		2,			0,			-1,			0,				1,				0,			0,			(MF_NOT_IN_HALLWAY | MF_TREAT_AS_BLOCKING)]]],
	// Dismal -- blood, bones, charcoal, some rubble
	[[1,DEEPEST_LEVEL],	[60, 70],	0,		3,			0,                  BP_NO_INTERIOR_FLAG, [
		[DF_AMBIENT_BLOOD, 0,	0,				[5,10],		3,			0,			-1,			0,				1,				0,			0,			MF_NOT_IN_HALLWAY],
		[DF_ASH,	0,			0,				[4, 8],		2,			0,			-1,			0,				1,				0,			0,			MF_NOT_IN_HALLWAY],
		[DF_BONES,	0,			0,				[3, 5],		2,			0,			-1,			0,				1,				0,			0,			MF_NOT_IN_HALLWAY]]],
	// Chasm catwalk -- narrow bridge over a chasm, possibly under fire from a turret or two
	[[1,DEEPEST_LEVEL-1],[40, 80],	0,		4,			0,                  (BP_REQUIRE_BLOCKING | BP_OPEN_INTERIOR | BP_NO_INTERIOR_FLAG), [
		[DF_CHASM_HOLE,	0,		0,				[80, 80],	1,			0,			-1,			0,				1,				0,			0,			(MF_TREAT_AS_BLOCKING | MF_REPEAT_UNTIL_NO_PROGRESS)],
		[DF_CATWALK_BRIDGE,0,	0,				[0,0],		0,			0,			-1,			0,				0,				0,			0,			(MF_EVERYWHERE)],
		[0,			MACHINE_TRIGGER_FLOOR, DUNGEON, [0,1],	0,			0,			0,			0,				1,				0,			0,			(MF_NEAR_ORIGIN | MF_PERMIT_BLOCKING)],
		[0,			TURRET_DORMANT,DUNGEON,		[1, 2],		1,			0,			-1,			0,				2,				HORDE_MACHINE_TURRET,0,	(MF_TREAT_AS_BLOCKING | MF_GENERATE_HORDE | MF_MONSTERS_DORMANT | MF_BUILD_IN_WALLS | MF_IN_VIEW_OF_ORIGIN)]]],
	// Lake walk -- narrow bridge of shallow water through a lake, possibly under fire from a turret or two
	[[1,DEEPEST_LEVEL],	[40, 80],	0,		3,			0,                  (BP_REQUIRE_BLOCKING | BP_OPEN_INTERIOR | BP_NO_INTERIOR_FLAG), [
		[DF_LAKE_CELL,	0,		0,				[80, 80],	1,			0,			-1,			0,				1,				0,			0,			(MF_TREAT_AS_BLOCKING | MF_REPEAT_UNTIL_NO_PROGRESS)],
		[0,			MACHINE_TRIGGER_FLOOR, DUNGEON, [0,1],	0,			0,			0,			0,				1,				0,			0,			(MF_NEAR_ORIGIN | MF_PERMIT_BLOCKING)],
		[0,			TURRET_DORMANT,DUNGEON,		[1, 2],		1,			0,			-1,			0,				2,				HORDE_MACHINE_TURRET,0,	(MF_TREAT_AS_BLOCKING | MF_GENERATE_HORDE | MF_MONSTERS_DORMANT | MF_BUILD_IN_WALLS | MF_IN_VIEW_OF_ORIGIN)]]],
    // Paralysis trap -- already-revealed pressure plate with a few hidden vents nearby.
  [[1,DEEPEST_LEVEL],	[35, 40],	0,		2,			0,                  (BP_NO_INTERIOR_FLAG), [
		[0,         GAS_TRAP_PARALYSIS, DUNGEON, [1,2],     1,          0,          0,			0,				3,				0,          0,			(MF_NEAR_ORIGIN | MF_NOT_IN_HALLWAY)],
		[0,			MACHINE_PARALYSIS_VENT_HIDDEN,DUNGEON,[3, 4],2,		0,			0,			0,				3,				0,          0,          (MF_FAR_FROM_ORIGIN | MF_NOT_IN_HALLWAY)]]],
    // Paralysis trap -- hidden pressure plate with a few vents nearby.
  [[1,DEEPEST_LEVEL],	[35, 40],	0,		2,			0,                  (BP_NO_INTERIOR_FLAG), [
		[0,         GAS_TRAP_PARALYSIS_HIDDEN, DUNGEON, [1,2],1,        0,          0,			0,				3,				0,          0,			(MF_NEAR_ORIGIN | MF_NOT_IN_HALLWAY)],
		[0,			MACHINE_PARALYSIS_VENT_HIDDEN,DUNGEON,[3, 4],2,		0,			0,			0,				3,				0,          0,          (MF_FAR_FROM_ORIGIN | MF_NOT_IN_HALLWAY)]]],
	// Statue comes alive -- innocent-looking statue that bursts to reveal a monster when the player approaches
	[[1,DEEPEST_LEVEL],	[5, 5],		0,		3,			0,                  (BP_NO_INTERIOR_FLAG), [
		[0,			STATUE_DORMANT,DUNGEON,		[1, 1],		1,			0,			-1,			0,				1,				HORDE_MACHINE_STATUE,0,	(MF_GENERATE_HORDE | MF_MONSTERS_DORMANT | MF_BUILD_AT_ORIGIN | MF_ALTERNATIVE)],
		[0,			STATUE_DORMANT,DUNGEON,		[1, 1],		1,			0,			-1,			0,				1,				HORDE_MACHINE_STATUE,0,	(MF_GENERATE_HORDE | MF_MONSTERS_DORMANT | MF_BUILD_IN_WALLS | MF_ALTERNATIVE | MF_NOT_ON_LEVEL_PERIMETER)],
		[0,			MACHINE_TRIGGER_FLOOR,DUNGEON,[0,0],	2,			0,			-1,			0,				0,				0,			0,			(MF_EVERYWHERE)]]],
	// Worms in the walls -- step on trigger region to cause underworms to burst out of the walls
	[[1,DEEPEST_LEVEL],	[7, 7],		0,		2,			0,                  (BP_NO_INTERIOR_FLAG), [
		[0,			WALL_MONSTER_DORMANT,DUNGEON,[1, 3],	1,			0,			-1,			MK_UNDERWORM,	1,				0,			0,			(MF_MONSTERS_DORMANT | MF_BUILD_IN_WALLS | MF_NOT_ON_LEVEL_PERIMETER)],
		[0,			MACHINE_TRIGGER_FLOOR,DUNGEON,[0,0],	2,			0,			-1,			0,				0,				0,			0,			(MF_EVERYWHERE)]]],
	// Sentinels
	[[1,DEEPEST_LEVEL],	[40, 40],	0,		2,			0,                  (BP_NO_INTERIOR_FLAG), [
		[0,			STATUE_INERT,DUNGEON,		[3, 3],		3,			0,			-1,			MK_SENTINEL,	2,				0,			0,			(MF_NOT_IN_HALLWAY | MF_TREAT_AS_BLOCKING | MF_IN_VIEW_OF_ORIGIN)],
		[DF_ASH,	0,			0,				[2, 3],		0,			0,			-1,			0,				0,				0,			0,			0]]],
].map( (v) => blueprint(...v) );


// #pragma mark Monster definitions

// Defines all creatures, which include monsters and the player:
const monsterCatalog = [
	//	name			ch		color			HP		def		acc		damage			reg	move	attack	blood			light	DFChance DFType         bolts       behaviorF, abilityF
	[0,	"you",	PLAYER_CHAR,	playerInLightColor,30,	0,		100,	[1, 2, 1],		20,	100,	100,	DF_RED_BLOOD,	0,		0,		0,              [0],
		(MONST_MALE | MONST_FEMALE)],

	[0, "rat",			'r',	gray,			6,		0,		80,		[1, 3, 1],		20,	100,	100,	DF_RED_BLOOD,	0,		1,		DF_URINE,       [0]],
	[0, "kobold",		'k',	goblinColor,	7,		0,		80,		[1, 4, 1],		20,	100,	100,	DF_RED_BLOOD,	0,		0,		0,              [0]],
	[0,	"jackal",		'j',	jackalColor,	8,		0,		70,		[2, 4, 1],		20,	50,		100,	DF_RED_BLOOD,	0,		1,		DF_URINE,              [0]],
	[0,	"eel",			'e',	eelColor,		18,		27,		100,	[3, 7, 2],		5,	50,		100,	0,              0,		0,		0,              [0],
		(MONST_RESTRICTED_TO_LIQUID | MONST_IMMUNE_TO_WATER | MONST_SUBMERGES | MONST_FLITS | MONST_NEVER_SLEEPS)],
	[0,	"monkey",		'm',	ogreColor,		12,		17,		100,	[1, 3, 1],		20,	100,	100,	DF_RED_BLOOD,	0,		1,		DF_URINE,       [0],
		(0), (MA_HIT_STEAL_FLEE)],
	[0, "bloat",		'b',	poisonGasColor,4,		0,		100,	[0, 0, 0],		5,	100,	100,	DF_PURPLE_BLOOD,0,		0,		DF_BLOAT_DEATH, [0],
		(MONST_FLIES | MONST_FLITS), (MA_KAMIKAZE | MA_DF_ON_DEATH)],
	[0, "pit bloat",	'b',	lightBlue,     4,		0,		100,	[0, 0, 0],		5,	100,	100,	DF_PURPLE_BLOOD,0,		0,		DF_HOLE_POTION, [0],
		(MONST_FLIES | MONST_FLITS), (MA_KAMIKAZE | MA_DF_ON_DEATH)],
	[0, "goblin",		'g',	goblinColor,	15,		10,		70,		[2, 5, 1],		20,	100,	100,	DF_RED_BLOOD,	0,		0,		0,              [0],
        (0),  (MA_ATTACKS_PENETRATE | MA_AVOID_CORRIDORS)],
	[0, "goblin conjurer",'g',	goblinConjurerColor, 10,10,	70,		[2, 4, 1],		20,	100,	100,	DF_RED_BLOOD,	0,		0,		0,              [0],
		(MONST_MAINTAINS_DISTANCE | MONST_CAST_SPELLS_SLOWLY | MONST_CARRY_ITEM_25), (MA_CAST_SUMMON | MA_ATTACKS_PENETRATE | MA_AVOID_CORRIDORS)],
	[0, "goblin mystic",'g',	goblinMysticColor, 10,	10,		70,		[2, 4, 1],		20,	100,	100,	DF_RED_BLOOD,	0,		0,		0,              [BOLT_SHIELDING],
		(MONST_MAINTAINS_DISTANCE | MONST_CARRY_ITEM_25), (MA_AVOID_CORRIDORS)],
	[0, "goblin totem",	TOTEM_CHAR,	orange,	30,		0,		0,		[0, 0, 0],		0,	100,	300,	DF_RUBBLE_BLOOD,IMP_LIGHT,0,	0,              [BOLT_HASTE, BOLT_SPARK],
		(MONST_IMMUNE_TO_WEBS | MONST_NEVER_SLEEPS | MONST_IMMOBILE | MONST_INANIMATE | MONST_WILL_NOT_USE_STAIRS), (0)],
	[0, "pink jelly",	'J',	pinkJellyColor,50,		0,		85,     [1, 3, 1],		0,	100,	100,	DF_PURPLE_BLOOD,0,		0,		0,              [0],
		(MONST_NEVER_SLEEPS), (MA_CLONE_SELF_ON_DEFEND)],
	[0, "toad",			't',	toadColor,		18,		0,		90,		[1, 4, 1],		10,	100,	100,	DF_GREEN_BLOOD,	0,		0,		0,              [0],
		(0), (MA_HIT_HALLUCINATE)],
	[0, "vampire bat",	'v',	gray,			18,		25,		100,	[2, 6, 1],		20,	50,		100,	DF_RED_BLOOD,	0,		0,		0,              [0],
		(MONST_FLIES | MONST_FLITS), (MA_TRANSFERENCE)],
	[0, "arrow turret", TURRET_CHAR,black,		30,		0,		90,		[2, 6, 1],		0,	100,	250,	0,              0,		0,		0,              [BOLT_DISTANCE_ATTACK],
		(MONST_TURRET), (0)],
	[0, "acid mound",	'a',	acidBackColor,	15,		10,		70,		[1, 3, 1],		5,	100,	100,	DF_ACID_BLOOD,	0,		0,		0,              [0],
		(MONST_DEFEND_DEGRADE_WEAPON), (MA_HIT_DEGRADE_ARMOR)],
	[0, "centipede",	'c',	centipedeColor,20,		20,		80,		[4, 12, 1],		20,	100,	100,	DF_GREEN_BLOOD,	0,		0,		0,              [0],
		(0), (MA_CAUSES_WEAKNESS)],
	[0,	"ogre",			'O',	ogreColor,		55,		60,		125,	[9, 13, 2],		20,	100,	200,	DF_RED_BLOOD,	0,		0,		0,              [0],
		(MONST_MALE | MONST_FEMALE), (MA_AVOID_CORRIDORS | MA_ATTACKS_STAGGER)],
	[0,	"bog monster",	'B',	krakenColor,	55,		60,		5000,	[3, 4, 1],		3,	200,	100,	0,              0,		0,		0,              [0],
		(MONST_RESTRICTED_TO_LIQUID | MONST_SUBMERGES | MONST_FLITS | MONST_FLEES_NEAR_DEATH), (MA_SEIZES)],
	[0, "ogre totem",	TOTEM_CHAR,	green,		70,		0,		0,		[0, 0, 0],		0,	100,	400,	DF_RUBBLE_BLOOD,LICH_LIGHT,0,	0,              [BOLT_HEALING, BOLT_SLOW_2],
		(MONST_IMMUNE_TO_WEBS | MONST_NEVER_SLEEPS | MONST_IMMOBILE | MONST_INANIMATE | MONST_WILL_NOT_USE_STAIRS), (0)],
	[0, "spider",		's',	white,			20,		70,		90,		[3, 4, 2],		20,	100,	200,	DF_GREEN_BLOOD,	0,		0,		0,              [BOLT_SPIDERWEB],
		(MONST_IMMUNE_TO_WEBS | MONST_CAST_SPELLS_SLOWLY | MONST_ALWAYS_USE_ABILITY), (MA_POISONS)],
	[0, "spark turret", TURRET_CHAR, lightningColor,80,0,		100,	[0, 0, 0],		0,	100,	150,	0,              SPARK_TURRET_LIGHT,	0,	0,      [BOLT_SPARK],
		(MONST_TURRET), (0)],
	[0,	"wisp",			'w',	wispLightColor,10,		90,     100,	[0,	0, 0],		5,	100,	100,	DF_ASH_BLOOD,	WISP_LIGHT,	0,	0,              [0],
		(MONST_IMMUNE_TO_FIRE | MONST_FLIES | MONST_FLITS | MONST_NEVER_SLEEPS | MONST_FIERY | MONST_DIES_IF_NEGATED), (MA_HIT_BURN)],
	[0, "wraith",		'W',	wraithColor,	50,		60,		120,	[6, 13, 2],		5,	50,		100,	DF_GREEN_BLOOD,	0,		0,		0,              [0],
		(MONST_FLEES_NEAR_DEATH)],
	[0, "zombie",		'Z',	vomitColor,	80,		0,		120,	[7, 12, 1],		0,	100,	100,	DF_ROT_GAS_BLOOD,0,		100,	DF_ROT_GAS_PUFF, [0]],
	[0, "troll",		'T',	trollColor,	65,		70,		125,	[10, 15, 3],	1,	100,	100,	DF_RED_BLOOD,	0,		0,		0,              [0],
		(MONST_MALE | MONST_FEMALE)],
	[0,	"ogre shaman",	'O',	green,			45,		40,		100,	[5, 9, 1],		20,	100,	200,	DF_RED_BLOOD,	0,		0,		0,              [BOLT_HASTE, BOLT_SPARK],
		(MONST_MAINTAINS_DISTANCE | MONST_CAST_SPELLS_SLOWLY | MONST_MALE | MONST_FEMALE), (MA_CAST_SUMMON | MA_AVOID_CORRIDORS)],
	[0, "naga",			'N',	trollColor,	75,		70,     150,	[7, 11, 4],		10,	100,	100,	DF_GREEN_BLOOD,	0,		100,	DF_PUDDLE,      [0],
		(MONST_IMMUNE_TO_WATER | MONST_SUBMERGES | MONST_NEVER_SLEEPS | MONST_FEMALE), (MA_ATTACKS_ALL_ADJACENT)],
	[0, "salamander",	'S',	salamanderColor,60,	70,     150,	[5, 11, 3],		10,	100,	100,	DF_ASH_BLOOD,	SALAMANDER_LIGHT, 100, DF_SALAMANDER_FLAME, [0],
		(MONST_IMMUNE_TO_FIRE | MONST_SUBMERGES | MONST_NEVER_SLEEPS | MONST_FIERY | MONST_MALE), (MA_ATTACKS_EXTEND)],
	[0, "explosive bloat",'b',	orange,		10,		0,		100,	[0, 0, 0],		5,	100,	100,	DF_RED_BLOOD,	EXPLOSIVE_BLOAT_LIGHT,0, DF_BLOAT_EXPLOSION, [0],
		(MONST_FLIES | MONST_FLITS), (MA_KAMIKAZE | MA_DF_ON_DEATH)],
	[0, "dar blademaster",'d',	purple,		35,		70,     160,	[5, 9, 2],		20,	100,	100,	DF_RED_BLOOD,	0,		0,		0,              [BOLT_BLINKING],
		(MONST_CARRY_ITEM_25 | MONST_MALE | MONST_FEMALE), (MA_AVOID_CORRIDORS)],
	[0, "dar priestess", 'd',	darPriestessColor,20,	60,		100,	[2, 5, 1],		20,	100,	100,	DF_RED_BLOOD,   0,		0,		0,              [BOLT_NEGATION, BOLT_HEALING, BOLT_HASTE, BOLT_SPARK],
		(MONST_MAINTAINS_DISTANCE | MONST_CARRY_ITEM_25 | MONST_FEMALE), (MA_AVOID_CORRIDORS)],
	[0, "dar battlemage",'d',	darMageColor,	20,		60,		100,	[1, 3, 1],		20,	100,	100,	DF_RED_BLOOD,	0,		0,		0,              [BOLT_FIRE, BOLT_SLOW_2, BOLT_DISCORD],
		(MONST_MAINTAINS_DISTANCE | MONST_CARRY_ITEM_25 | MONST_MALE | MONST_FEMALE), (MA_AVOID_CORRIDORS)],
	[0, "acidic jelly",	'J',	acidBackColor,	60,		0,		115,	[2, 6, 1],		0,	100,	100,	DF_ACID_BLOOD,	0,		0,		0,              [0],
		(MONST_DEFEND_DEGRADE_WEAPON), (MA_HIT_DEGRADE_ARMOR | MA_CLONE_SELF_ON_DEFEND)],
	[0,	"centaur",		'C',	tanColor,		35,		50,		175,	[4, 8, 2],		20,	50,		100,	DF_RED_BLOOD,	0,		0,		0,              [BOLT_DISTANCE_ATTACK],
		(MONST_MAINTAINS_DISTANCE | MONST_MALE), (0)],
	[0, "underworm",	'U',	wormColor,		80,		40,		160,	[18, 22, 2],	3,	150,	200,	DF_WORM_BLOOD,	0,		0,		0,              [0],
        (MONST_NEVER_SLEEPS)],
	[0, "sentinel",		STATUE_CHAR, sentinelColor, 50,0,		0,		[0, 0, 0],		0,	100,	175,	DF_RUBBLE_BLOOD,SENTINEL_LIGHT,0,0,             [BOLT_HEALING, BOLT_SPARK],
		(MONST_TURRET | MONST_CAST_SPELLS_SLOWLY | MONST_DIES_IF_NEGATED), (0)],
	// [0, "acid turret", TURRET_CHAR,	acidBackColor,35,	0,		250,	[1, 2, 1],      0,	100,	250,	0,              0,		0,		0,              [BOLT_ACID_TURRET_ATTACK],
	// 	(MONST_TURRET), (MA_HIT_DEGRADE_ARMOR)],
  [0, "dart turret", TURRET_CHAR,	centipedeColor,20,	0,		140,	[1, 2, 1],      0,	100,	250,	0,              0,		0,		0,              [BOLT_POISON_DART],
		(MONST_TURRET), (MA_CAUSES_WEAKNESS)],
	[0,	"kraken",		'K',	krakenColor,	120,	0,		150,	[15, 20, 3],	1,	50,		100,	0,              0,		0,		0,              [0],
		(MONST_RESTRICTED_TO_LIQUID | MONST_IMMUNE_TO_WATER | MONST_SUBMERGES | MONST_FLITS | MONST_NEVER_SLEEPS | MONST_FLEES_NEAR_DEATH), (MA_SEIZES)],
	[0,	"lich",			'L',	white,			35,		80,     175,	[2, 6, 1],		0,	100,	100,	DF_ASH_BLOOD,	LICH_LIGHT,	0,	0,              [BOLT_FIRE],
		(MONST_MAINTAINS_DISTANCE | MONST_CARRY_ITEM_25 | MONST_NO_POLYMORPH), (MA_CAST_SUMMON)],
	[0, "phylactery",	GEM_CHAR,lichLightColor,30,	0,		0,		[0, 0, 0],		0,	100,	150,	DF_RUBBLE_BLOOD,LICH_LIGHT,	0,	0,              [0],
		(MONST_IMMUNE_TO_WEBS | MONST_NEVER_SLEEPS | MONST_IMMOBILE | MONST_INANIMATE | MONST_ALWAYS_HUNTING | MONST_WILL_NOT_USE_STAIRS | MONST_DIES_IF_NEGATED), (MA_CAST_SUMMON | MA_ENTER_SUMMONS)],
	[0, "pixie",		'p',	pixieColor,	10,		90,     100,	[1, 3, 1],		20,	50,		100,	DF_GREEN_BLOOD,	PIXIE_LIGHT, 0,	0,              [BOLT_NEGATION, BOLT_SLOW_2, BOLT_DISCORD, BOLT_SPARK],
		(MONST_MAINTAINS_DISTANCE | MONST_FLIES | MONST_FLITS | MONST_MALE | MONST_FEMALE), (0)],
	[0,	"phantom",		'P',	ectoplasmColor,35,		70,     160,	[12, 18, 4],    0,	50,		200,	DF_ECTOPLASM_BLOOD,	0,	2,		DF_ECTOPLASM_DROPLET, [0],
		(MONST_INVISIBLE | MONST_FLITS | MONST_FLIES | MONST_IMMUNE_TO_WEBS)],
	[0, "flame turret", TURRET_CHAR, lavaForeColor,40,	0,		150,	[1, 2, 1],		0,	100,	250,	0,              LAVA_LIGHT,	0,	0,              [BOLT_FIRE],
		(MONST_TURRET), (0)],
	[0, "imp",			'i',	pink,			35,		90,     225,	[4, 9, 2],		10,	100,	100,	DF_GREEN_BLOOD,	IMP_LIGHT,	0,	0,              [BOLT_BLINKING],
		(0), (MA_HIT_STEAL_FLEE)],
	[0,	"fury",			'f',	darkRed,		19,		90,     200,	[6, 11, 4],		20,	50,		100,	DF_RED_BLOOD,	0,		0,		0,              [0],
		(MONST_NEVER_SLEEPS | MONST_FLIES)],
	[0, "revenant",		'R',	ectoplasmColor,30,		0,		200,	[15, 20, 5],	0,	100,	100,	DF_ECTOPLASM_BLOOD,	0,	0,		0,              [0],
		(MONST_IMMUNE_TO_WEAPONS)],
	[0, "tentacle horror",'H',	centipedeColor,120,	95,     225,	[25, 35, 3],	1,	100,	100,	DF_PURPLE_BLOOD,0,		0,		0,              [0]],
	[0, "golem",		'G',	gray,			400,	70,     225,	[4, 8, 1],		0,	100,	100,	DF_RUBBLE_BLOOD,0,		0,		0,              [0],
		(MONST_REFLECT_4 | MONST_DIES_IF_NEGATED)],
	[0, "dragon",		'D',	dragonColor,	150,	90,     250,	[25, 50, 4],	20,	50,		200,	DF_GREEN_BLOOD,	0,		0,		0,              [BOLT_DRAGONFIRE],
		(MONST_IMMUNE_TO_FIRE | MONST_CARRY_ITEM_100), (MA_ATTACKS_ALL_ADJACENT)],

	// bosses
	[0, "goblin warlord",'g',	blue,			30,		17,		100,	[3, 6, 1],		20,	100,	100,	DF_RED_BLOOD,	0,		0,		0,              [0],
		(MONST_MAINTAINS_DISTANCE | MONST_CARRY_ITEM_25), (MA_CAST_SUMMON | MA_ATTACKS_PENETRATE | MA_AVOID_CORRIDORS)],
	[0,	"black jelly",	'J',	black,			120,	0,		130,	[3, 8, 1],		0,	100,	100,	DF_PURPLE_BLOOD,0,		0,		0,              [0],
		(0), (MA_CLONE_SELF_ON_DEFEND)],
	[0, "vampire",		'V',	white,			75,		60,     120,	[4, 15, 2],		6,	50,		100,	DF_RED_BLOOD,	0,		0,		DF_BLOOD_EXPLOSION, [BOLT_BLINKING, BOLT_DISCORD],
		(MONST_FLEES_NEAR_DEATH | MONST_MALE), (MA_TRANSFERENCE | MA_DF_ON_DEATH | MA_CAST_SUMMON | MA_ENTER_SUMMONS)],
	[0, "flamedancer",	'F',	white,			65,		80,     120,	[3, 8, 2],		0,	100,	100,	DF_EMBER_BLOOD,	FLAMEDANCER_LIGHT,100,DF_FLAMEDANCER_CORONA, [BOLT_FIRE],
		(MONST_MAINTAINS_DISTANCE | MONST_IMMUNE_TO_FIRE | MONST_FIERY), (MA_HIT_BURN)],

	// special effect monsters
	[0, "spectral blade",WEAPON_CHAR, spectralBladeColor,1, 0,	150,	[1, 1, 1],		0,	50,		100,	0,              SPECTRAL_BLADE_LIGHT,0,0,       [0],
		(MONST_INANIMATE | MONST_NEVER_SLEEPS | MONST_FLIES | MONST_WILL_NOT_USE_STAIRS | MONST_DIES_IF_NEGATED | MONST_IMMUNE_TO_WEBS | MONST_NOT_LISTED_IN_SIDEBAR)],
	[0, "spectral sword",WEAPON_CHAR, spectralImageColor, 1,0,	150,	[1, 1, 1],		0,	50,		100,	0,              SPECTRAL_IMAGE_LIGHT,0,0,       [0],
		(MONST_INANIMATE | MONST_NEVER_SLEEPS | MONST_FLIES | MONST_WILL_NOT_USE_STAIRS | MONST_DIES_IF_NEGATED | MONST_IMMUNE_TO_WEBS)],
  [0, "stone guardian",STATUE_CHAR, white,   1000,   0,		200,	[12, 17, 2],	0,	100,	100,	DF_RUBBLE,      0,      100,      DF_GUARDIAN_STEP, [0],
		(MONST_INANIMATE | MONST_NEVER_SLEEPS | MONST_ALWAYS_HUNTING | MONST_IMMUNE_TO_FIRE | MONST_IMMUNE_TO_WEAPONS | MONST_WILL_NOT_USE_STAIRS | MONST_DIES_IF_NEGATED | MONST_REFLECT_4 | MONST_ALWAYS_USE_ABILITY | MONST_GETS_TURN_ON_ACTIVATION)],
  [0, "winged guardian",STATUE_CHAR, blue,   1000,   0,		200,	[12, 17, 2],	0,	100,	100,	DF_RUBBLE,      0,      100,      DF_SILENT_GLYPH_GLOW, [BOLT_BLINKING],
		(MONST_INANIMATE | MONST_NEVER_SLEEPS | MONST_ALWAYS_HUNTING | MONST_IMMUNE_TO_FIRE | MONST_IMMUNE_TO_WEAPONS | MONST_WILL_NOT_USE_STAIRS | MONST_DIES_IF_NEGATED | MONST_REFLECT_4 | MONST_GETS_TURN_ON_ACTIVATION | MONST_ALWAYS_USE_ABILITY), (0)],
  [0, "guardian spirit",STATUE_CHAR, spectralImageColor,1000,0,200,	[5, 12, 2],     0,	100,	100,	0,              SPECTRAL_IMAGE_LIGHT,100,0,     [0],
		(MONST_INANIMATE | MONST_NEVER_SLEEPS | MONST_IMMUNE_TO_FIRE | MONST_IMMUNE_TO_WEAPONS | MONST_DIES_IF_NEGATED | MONST_REFLECT_4 | MONST_ALWAYS_USE_ABILITY)],
  [0, "Warden of Yendor",'Y', yendorLightColor,1000,   0,	300,	[12, 17, 2],	0,	200,	200,	DF_RUBBLE,      YENDOR_LIGHT, 100, 0,           [0],
		(MONST_NEVER_SLEEPS | MONST_ALWAYS_HUNTING | MONST_INVULNERABLE | MONST_NO_POLYMORPH)],
  [0, "eldritch totem",TOTEM_CHAR, glyphColor,80,    0,		0,		[0, 0, 0],		0,	100,	100,	DF_RUBBLE_BLOOD,0,      0,      0,              [0],
		(MONST_IMMUNE_TO_WEBS | MONST_NEVER_SLEEPS | MONST_IMMOBILE | MONST_INANIMATE | MONST_ALWAYS_HUNTING | MONST_WILL_NOT_USE_STAIRS | MONST_GETS_TURN_ON_ACTIVATION | MONST_ALWAYS_USE_ABILITY), (MA_CAST_SUMMON)],
  [0, "mirrored totem",TOTEM_CHAR, beckonColor,80,	0,		0,		[0, 0, 0],		0,	100,	100,	DF_RUBBLE_BLOOD,0,      100,	DF_MIRROR_TOTEM_STEP, [BOLT_BECKONING],
		(MONST_IMMUNE_TO_WEBS | MONST_NEVER_SLEEPS | MONST_IMMOBILE | MONST_INANIMATE | MONST_ALWAYS_HUNTING | MONST_WILL_NOT_USE_STAIRS | MONST_GETS_TURN_ON_ACTIVATION | MONST_ALWAYS_USE_ABILITY | MONST_REFLECT_4 | MONST_IMMUNE_TO_WEAPONS | MONST_IMMUNE_TO_FIRE), (0)],

	// legendary allies
	[0,	"unicorn",		UNICORN_CHAR, white,   40,		60,		175,	[2, 10, 2],		20,	50,		100,	DF_RED_BLOOD,	UNICORN_LIGHT,1,DF_UNICORN_POOP, [BOLT_HEALING, BOLT_SHIELDING],
		(MONST_MAINTAINS_DISTANCE | MONST_MALE | MONST_FEMALE), (0)],
	[0,	"ifrit",		'I',	ifritColor,	40,		75,     175,	[5, 13, 2],		1,	50,		100,	DF_ASH_BLOOD,	IFRIT_LIGHT,0,	0,              [BOLT_DISCORD],
		(MONST_IMMUNE_TO_FIRE | MONST_FLIES | MONST_MALE), (0)],
	[0,	"phoenix",		'P',	phoenixColor,	30,		70,     175,	[4, 10, 2],		0,	50,		100,	DF_ASH_BLOOD,	PHOENIX_LIGHT,0,0,              [0],
		(MONST_IMMUNE_TO_FIRE| MONST_FLIES | MONST_NO_POLYMORPH)],
	[0, "phoenix egg",	GEM_CHAR,phoenixColor,	50,	0,		0,		[0, 0, 0],		0,	100,	150,	DF_ASH_BLOOD,	PHOENIX_EGG_LIGHT,	0,	0,      [0],
		(MONST_IMMUNE_TO_FIRE| MONST_IMMUNE_TO_WEBS | MONST_NEVER_SLEEPS | MONST_IMMOBILE | MONST_INANIMATE | MONST_WILL_NOT_USE_STAIRS | MONST_NO_POLYMORPH | MONST_ALWAYS_HUNTING | MONST_IMMUNE_TO_WEAPONS), (MA_CAST_SUMMON | MA_ENTER_SUMMONS)],
  [0,	"mangrove dryad",'M',	tanColor,      70,		60,     175,	[2, 8, 2],		6,	100,	100,	DF_ASH_BLOOD,	0,      0,      0,              [BOLT_ANCIENT_SPIRIT_VINES],
		(MONST_IMMUNE_TO_WEBS | MONST_ALWAYS_USE_ABILITY | MONST_MAINTAINS_DISTANCE | MONST_NO_POLYMORPH | MONST_MALE | MONST_FEMALE), (0)],
].map( (v) => creatureType(...v) );


// #pragma mark Monster words

const monsterText = [
	["A naked adventurer in an unforgiving place, bereft of equipment and confused about the circumstances.",
		"studying", "Studying",
		["hit"]],
	["The rat is a scavenger of the shallows, perpetually in search of decaying animal matter.",
		"gnawing at", "Eating",
		["scratches", "bites"]],
	["The kobold is a lizardlike humanoid of the upper dungeon.",
		"poking at", "Examining",
		["clubs", "bashes"]],
	["The jackal prowls the caverns for intruders to rend with $HISHER powerful jaws.",
		"tearing at", "Eating",
		["claws", "bites", "mauls"]],
	["The eel slips silently through the subterranean lake, waiting for unsuspecting prey to set foot in $HISHER dark waters.",
		"eating", "Eating",
		["shocks", "bites"]],
	["Mischievous trickster that $HESHE is, the monkey lives to steal shiny trinkets from passing adventurers.",
		"examining", "Examining",
		["tweaks", "bites", "punches"]],
	["A bladder of deadly gas buoys the bloat through the air, $HISHER thin veinous membrane ready to rupture at the slightest stress.",
		"gazing at", "Gazing",
		["bumps"],
		"bursts, leaving behind an expanding cloud of caustic gas!"],
	["This rare subspecies of bloat is filled with a peculiar vapor that, if released, will cause the floor to vanish out from underneath $HIMHER.",
		"gazing at", "Gazing",
		["bumps"],
		"bursts, causing the floor underneath $HIMHER to disappear!"],
	["A filthy little primate, the tribalistic goblin often travels in packs and carries a makeshift stone spear.",
		"chanting over", "Chanting",
		["cuts", "stabs", "skewers"]],
	["This goblin is covered with glowing sigils that pulse with power. $HESHE can call into existence phantom blades to attack $HISHER foes.",
		"performing a ritual on", "Performing ritual",
		["thumps", "whacks", "wallops"],
		null,
		"gestures ominously!"],
	["This goblin carries no weapon, and $HISHER eyes sparkle with golden light. $HESHE can invoke a powerful shielding magic to protect $HISHER escorts from harm.",
		"performing a ritual on", "Performing ritual",
		["slaps", "punches", "kicks"]],
	["Goblins have created this makeshift totem and imbued $HIMHER with a shamanistic power.",
		"gazing at", "Gazing",
		["hits"]],
	["This mass of caustic pink goo slips across the ground in search of a warm meal.",
		"absorbing", "Feeding",
		["smears", "slimes", "drenches"]],
	["The enormous, warty toad secretes a powerful hallucinogenic slime to befuddle the senses of any creatures that come in contact with $HIMHER.",
		"eating", "Eating",
		["slimes", "slams"]],
	["Often hunting in packs, leathery wings and keen senses guide the vampire bat unerringly to $HISHER prey.",
		"draining", "Feeding",
		["nips", "bites"]],
	["A mechanical contraption embedded in the wall, the spring-loaded arrow turret will fire volley after volley of arrows at intruders.",
		"gazing at", "Gazing",
		["shoots"]],
	["The acid mound squelches softly across the ground, leaving a trail of hissing goo in $HISHER path.",
		"liquefying", "Feeding",
		["slimes", "douses", "drenches"]],
	["This monstrous centipede's incisors are imbued with a horrible venom that will slowly kill $HISHER prey.",
		"eating", "Eating",
		["pricks", "stings"]],
	["This lumbering creature carries an enormous club that $HESHE can swing with incredible force.",
		"examining", "Studying",
		["cudgels", "clubs", "batters"]],
	["The horrifying bog monster dwells beneath the surface of mud-filled swamps. When $HISHER prey ventures into the mud, the bog monster will ensnare the unsuspecting victim in $HISHER pale tentacles and squeeze its life away.",
		"draining", "Feeding",
		["squeezes", "strangles", "crushes"]],
	["Ancient ogres versed in the eldritch arts have assembled this totem and imbued $HIMHER with occult power.",
		"gazing at", "Gazing",
		["hits"]],
	["The spider's red eyes pierce the darkness in search of enemies to ensnare with $HISHER projectile webs and dissolve with deadly poison.",
		"draining", "Feeding",
		["bites", "stings"]],
	["This contraption hums with electrical charge that $HISHER embedded crystals and magical sigils can direct at intruders in deadly arcs.",
		"gazing at", "Gazing",
		["shocks"]],
	["An ethereal blue flame dances through the air, flickering and pulsing in time to an otherworldly rhythm.",
		"consuming", "Feeding",
		["scorches", "burns"]],
	["The wraith's hollow eye sockets stare hungrily at the world from $HISHER emaciated frame, and $HISHER long, bloodstained nails grope ceaselessly at the air for a fresh victim.",
		"devouring", "Feeding",
		["clutches", "claws", "bites"]],
	["The zombie is the accursed product of a long-forgotten ritual. Perpetually decaying flesh hangs from $HISHER bones in shreds and releases a flammable stench that will induce violent nausea with one whiff.",
		"rending", "Eating",
		["hits", "bites"]],
	["An enormous, disfigured creature covered in phlegm and warts, the troll regenerates very quickly and attacks with astonishing strength. Many adventures have ended at $HISHER misshapen hands.",
		"eating", "Eating",
		["cudgels", "clubs", "bludgeons", "pummels", "batters"]],
	["This ogre is bent with age, but what $HESHE has lost in physical strength, $HESHE has more than gained in occult power.",
		"performing a ritual on", "Performing ritual",
		["cudgels", "clubs"],
		null,
		"chants in a harsh, guttural tongue!"],
	["The serpentine naga live beneath the subterranean waters and emerge to attack unsuspecting adventurers.",
		"studying", "Studying",
		["claws", "bites", "tail-whips"]],
	["A serpent wreathed in flames and carrying a burning lash, salamanders dwell in lakes of fire and emerge when they sense a nearby victim, leaving behind a trail of glowing embers.",
		"studying", "Studying",
		["whips", "lashes"]],
	["This rare subspecies of bloat is little more than a thin membrane surrounding a bladder of highly explosive gases. The slightest stress will cause $HIMHER to rupture in spectacular and deadly fashion.",
		"gazing at", "Gazing",
		["bumps"],
		"detonates with terrifying force!"],
	["An elf of the deep, the dar blademaster leaps toward $HISHER enemies with frightening speed to engage in deadly swordplay.",
		"studying", "Studying",
		["grazes", "cuts", "slices", "slashes", "stabs"]],
	["The dar priestess carries a host of religious relics that jangle as $HESHE walks.",
		"praying over", "Praying",
		["cuts", "slices"]],
	["The dar battlemage's eyes glow like embers and $HISHER hands radiate an occult heat.",
		"transmuting", "Transmuting",
		["cuts"]],
	["A jelly subsisting on a diet of acid mounds will eventually express the characteristics of $HISHER prey, corroding any unprotected weapons or armor that come in contact with $HIMHER.",
		"transmuting", "Transmuting",
		["burns"]],
	["Half man and half horse, the centaur is an expert with the bow and arrow -- hunter and steed fused into a single creature.",
		"studying", "Studying",
		["shoots"]],
	["A strange and horrifying creature of the earth's deepest places, larger than an ogre but capable of squeezing through tiny openings. When hungry, the underworm will burrow behind the walls of a cavern and lurk dormant and motionless -- often for months -- until $HESHE can feel the telltale vibrations of nearby prey.",
		"consuming", "Consuming",
		["slams", "bites", "tail-whips"]],
	["An ancient statue of an unrecognizable humanoid figure, the sentinel holds aloft a crystal that gleams with ancient warding magic. Sentinels are always found in groups, and each will attempt to repair any damage done to the others.",
		"focusing on", "Focusing",
		["hits"]],
	// ["A green-flecked nozzle is embedded in the wall, ready to spew a stream of corrosive acid at intruders.",
	// 	"gazing at", "Gazing",
	// 	["douses", "drenches"]],
	["This spring-loaded contraption fires darts that are imbued with a strength-sapping poison.",
		"gazing at", "Gazing",
		["pricks"]],
	["This tentacled nightmare will emerge from the subterranean waters to ensnare and devour any creature foolish enough to set foot into $HISHER lake.",
		"devouring", "Feeding",
		["slaps", "smites", "batters"]],
	["The desiccated form of an ancient sorcerer, animated by dark arts and lust for power, commands the obedience of the infernal planes. $HISHER essence is anchored to reality by a phylactery that is always in $HISHER possession, and the lich cannot die unless $HISHER phylactery is destroyed.",
		"enchanting", "Enchanting",
		["touches"],
		null,
		"rasps a terrifying incantation!"],
	["This gem was the fulcrum of a dark rite, performed centuries ago, that bound the soul of an ancient and terrible sorcerer. Hurry and destroy the gem, before the lich can gather its power and regenerate its corporeal form!",
		"enchanting", "Enchanting",
		["touches"],
		null,
		"swirls with dark sorcery as the lich regenerates its form!"],
	["A tiny humanoid sparkles in the gloom, the hum of $HISHER beating wings punctuated by intermittent peals of high-pitched laughter. What $HESHE lacks in physical endurance, $HESHE makes up for with $HISHER wealth of mischievous magical abilities.",
		"sprinkling dust on", "Dusting",
		["pokes"]],
	["A silhouette of mournful rage against an empty backdrop, the phantom slips through the dungeon invisibly in clear air, leaving behind glowing droplets of ectoplasm and the cries of $HISHER unsuspecting victims.",
		"permeating", "Permeating",
		["hits"]],
	["This infernal contraption spits blasts of flame at intruders.",
		"incinerating", "Incinerating",
		["pricks"]],
	["This trickster demon moves with astonishing speed and delights in stealing from $HISHER enemies and blinking away.",
		"dissecting", "Dissecting",
		["slices", "cuts"]],
	["A creature of inchoate rage made flesh, the fury's moist wings beat loudly in the darkness.",
		"flagellating", "Flagellating",
		["drubs", "fustigates", "castigates"]],
	["This unholy specter stalks the deep places of the earth without fear, impervious to conventional attacks.",
		"desecrating", "Desecrating",
		["hits"]],
	["This seething, towering nightmare of fleshy tentacles slinks through the bowels of the world. The tentacle horror's incredible strength and regeneration make $HIMHER one of the most fearsome creatures of the dungeon.",
		"sucking on", "Consuming",
		["slaps", "batters", "crushes"]],
	["A statue animated by an ancient and tireless magic, the golem does not regenerate and attacks with only moderate strength, but $HISHER stone form can withstand incredible damage before collapsing into rubble.",
		"cradling", "Cradling",
		["backhands", "punches", "kicks"]],
	["An ancient serpent of the world's deepest places, the dragon's immense form belies its lightning-quick speed and testifies to $HISHER breathtaking strength. An undying furnace of white-hot flames burns within $HISHER scaly hide, and few could withstand a single moment under $HISHER infernal lash.",
		"consuming", "Consuming",
		["claws", "tail-whips", "bites"]],

	["Taller, stronger and smarter than other goblins, the warlord commands the loyalty of $HISHER kind and can summon them into battle.",
		"chanting over", "Chanting",
		["slashes", "cuts", "stabs", "skewers"],
		null,
		"lets loose a deafening war cry!"],
	["This blob of jet-black goo is as rare as $HESHE is deadly. Few creatures of the dungeon can withstand $HISHER caustic assault. Beware.",
		"absorbing", "Feeding",
		["smears", "slimes", "drenches"]],
	["This vampire lives a solitary life deep underground, consuming any warm-blooded creature unfortunate to venture near $HISHER lair.",
		"draining", "Drinking",
		["grazes", "bites", "buries $HISHER fangs in"],
		null,
		"spreads his cloak and bursts into a cloud of bats!"],
	["An elemental creature from another plane of existence, the infernal flamedancer burns with such intensity that $HESHE is painful to behold.",
		"immolating", "Consuming",
		["singes", "burns", "immolates"]],

	["Eldritch forces have coalesced to form this flickering, ethereal weapon.",
		"gazing at", "Gazing",
		["nicks"]],
	["Eldritch energies bound up in your equipment have leapt forth to project this spectral image.",
		"gazing at", "Gazing",
		["hits"]],
	["Guarding the room is a weathered stone statue of a knight carrying a battleaxe, connected to the glowing glyphs on the floor by invisible strands of enchantment.",
		"gazing at", "Gazing",
		["strikes"]],
	["A statue of a sword-wielding angel surveys the room, connected to the glowing glyphs on the floor by invisible strands of enchantment.",
		"gazing at", "Gazing",
		["strikes"]],
	["A spectral outline of a knight carrying a battleaxe casts an ethereal light on $HISHER surroundings.",
		"gazing at", "Gazing",
		["strikes"]],
    ["An immortal presence stalks through the dungeon, implacably hunting that which was taken... and the one who took it.",
		"gazing at", "Gazing",
		["strikes"]],
	["This totem sits at the center of a summoning circle that radiates a strange energy.",
		"gazing at", "Gazing",
		["strikes"],
        null,
        "crackles with energy as you touch the glyph!"],
	["A prism of shoulder-high mirrored surfaces gleams in the darkness.",
		"gazing at", "Gazing",
		["strikes"]],

	["The unicorn's flowing mane and tail shine with rainbow light, $HISHER horn glows with healing and protective magic, and $HISHER eyes implore you to always chase your dreams. Unicorns are rumored to be attracted to virgins -- is there a hint of accusation in $HISHER gaze?",
		"consecrating", "Consecrating",
		["pokes", "stabs", "gores"]],
	["A whirling desert storm given human shape, the ifrit's twin scimitars flicker in the darkness and $HISHER eyes burn with otherworldly zeal.",
		"absorbing", "Absorbing",
		["cuts", "slashes", "lacerates"]],
	["This legendary bird shines with a brilliant light, and $HISHER wings crackle and pop like embers as they beat the air. When $HESHE dies, legend has it that an egg will form and a newborn phoenix will rise from its ashes.",
		"cremating", "Cremating",
		["pecks", "scratches", "claws"]],
	["Cradled in a nest of cooling ashes, the translucent membrane of the phoenix egg reveals a yolk that glows brighter by the second.",
		"cremating", "Cremating",
		["touches"],
		null,
		"bursts as a newborn phoenix rises from the ashes!"],
	["This mangrove dryad is as old as the earth, and $HISHER gnarled figure houses an ancient power. When angered, $HESHE can call upon the forces of nature to bind $HISHER foes and tear them to shreds.",
		"absorbing", "Absorbing",
		["whips", "lashes", "thrashes", "lacerates"]],
].map( (v) => monsterWords(...v) );


// #pragma mark Mutation definitions

const mutationCatalog = [
    //Title         textColor       healthFactor    moveSpdMult attackSpdMult   defMult damMult DF% DFtype  light   monstFlags  abilityFlags    forbiddenFlags      forbiddenAbilities
    ["explosive",   orange,        50,             100,        100,            50,     100,    0,  DF_MUTATION_EXPLOSION, EXPLOSIVE_BLOAT_LIGHT, 0, MA_DF_ON_DEATH, MONST_SUBMERGES, 0,
        "A rare mutation will cause $HIMHER to explode violently when $HESHE dies."],
    ["infested",    lichenColor,   50,             100,        100,            50,     100,    0,  DF_MUTATION_LICHEN, 0, 0,   MA_DF_ON_DEATH, 0,               0,
        "$HESHE has been infested by deadly lichen spores; poisonous fungus will spread from $HISHER corpse when $HESHE dies."],
    ["agile",       lightBlue,     100,            50,         100,            150,    100,    -1, 0,      0,      MONST_FLEES_NEAR_DEATH, 0, MONST_FLEES_NEAR_DEATH, 0,
        "A rare mutation greatly enhances $HISHER mobility."],
    ["juggernaut",  brown,         300,            200,        200,            75,     200,    -1, 0,      0,      0,          MA_ATTACKS_STAGGER, MONST_MAINTAINS_DISTANCE, 0,
        "A rare mutation has hardened $HISHER flesh, increasing $HISHER health and power but compromising $HISHER speed."],
    ["grappling",   tanColor,      150,            100,        100,            50,     100,    -1, 0,      0,      0,          MA_SEIZES,      MONST_MAINTAINS_DISTANCE, MA_SEIZES,
        "A rare mutation has caused suckered tentacles to sprout from $HISHER frame, increasing $HISHER health and allowing $HIMHER to grapple with $HISHER prey."],
    ["vampiric",    red,           100,            100,        100,            100,    100,    -1, 0,      0,      0,          MA_TRANSFERENCE, MONST_MAINTAINS_DISTANCE, MA_TRANSFERENCE,
        "A rare mutation allows $HIMHER to heal $HIMSELFHERSELF with every attack."],
    ["toxic",       green,         100,            100,        200,            100,    20,     -1, 0,      0,      0,          (MA_CAUSES_WEAKNESS | MA_POISONS), MONST_MAINTAINS_DISTANCE, (MA_CAUSES_WEAKNESS | MA_POISONS),
        "A rare mutation causes $HIMHER to poison $HISHER victims and sap their strength with every attack."],
    ["reflective",  darkTurquoise, 100,            100,        100,            100,    100,    -1, 0,      0,      MONST_REFLECT_4, 0,         (MONST_REFLECT_4 | MONST_ALWAYS_USE_ABILITY), 0,
        "A rare mutation has coated $HISHER flesh with reflective scales."],
].map( (v) => mutation(...v) );

// #pragma mark Horde definitions

const hordeCatalog = [
	// leader		#members	member list								member numbers					minL	maxL	freq	spawnsIn		machine			flags
	[MK_RAT,						0,		null,									null,									1,		5,		150],
	[MK_KOBOLD,					0,		null,									null,									1,		6,		150],
	[MK_JACKAL,					0,		null,									null,									1,		3,		100],
	[MK_JACKAL,					1,		[MK_JACKAL],					[[1, 3, 1]],					3,		7,		50],
	[MK_EEL,						0,		null,									null,									2,		17,		100,		DEEP_WATER],
	[MK_MONKEY,					0,		null,									null,									2,		9,		50],
	[MK_BLOAT,					0,		null,									null,									2,		13,		30],
	[MK_PIT_BLOAT,			0,		null,									null,									2,		13,		10],
	[MK_BLOAT,					1,		[MK_BLOAT],						[[0, 2, 1]],					14,		26,		30],
	[MK_PIT_BLOAT,			1,		[MK_PIT_BLOAT],				[[0, 2, 1]],					14,		26,		10],
	[MK_EXPLOSIVE_BLOAT,0,		null,									null,									10,		26,		10],
	[MK_GOBLIN,					0,		null,									null,									3,		10,		100],
	[MK_GOBLIN_CONJURER,0,		null,									null,									3,		10,		60],
	[MK_TOAD,						0,		null,									null,									4,		11,		100],
	[MK_PINK_JELLY,			0,		null,									null,									4,		13,		100],
	[MK_GOBLIN_TOTEM,		1,		[MK_GOBLIN],					[[2,4,1]],						5,		13,		100,		0,				MT_CAMP_AREA,	HORDE_NO_PERIODIC_SPAWN],
	[MK_ARROW_TURRET,		0,		null,									null,									5,		13,		100,		WALL,	0,                      HORDE_NO_PERIODIC_SPAWN],
	[MK_MONKEY,					1,		[MK_MONKEY],					[[2,4,1]],						5,		13,		20],
  [MK_VAMPIRE_BAT,		0,		null,                 null,                 6,		13,		30],
  [MK_VAMPIRE_BAT,		1,		[MK_VAMPIRE_BAT],			[[1,2,1]],						6,		13,		70,      0,              0,              HORDE_NEVER_OOD],
	[MK_ACID_MOUND,			0,		null,									null,									6,		13,		100],
	[MK_GOBLIN,					3,		[MK_GOBLIN, MK_GOBLIN_MYSTIC, MK_JACKAL],[[2, 3, 1], [1,2,1], [1,2,1]],	6,		12,		40],
	[MK_GOBLIN_CONJURER,2,		[MK_GOBLIN_CONJURER, MK_GOBLIN_MYSTIC],	[[0,1,1], [1,1,1]],				7,		15,		40],
	[MK_CENTIPEDE,			0,		null,									null,									7,		14,		100],
	[MK_BOG_MONSTER,		0,		null,									null,									7,		14,		80,		MUD,            0,              HORDE_NEVER_OOD],
	[MK_OGRE,						0,		null,									null,									7,		13,		100],
	[MK_EEL,						1,		[MK_EEL],							[[2, 4, 1]],					8,		22,		70,		DEEP_WATER],
	[MK_ACID_MOUND,			1,		[MK_ACID_MOUND],			[[2, 4, 1]],					9,		13,		30],
	[MK_SPIDER,					0,		null,									null,									9,		16,		100],
	[MK_DAR_BLADEMASTER,1,		[MK_DAR_BLADEMASTER],	[[0, 1, 1]],					10,		14,		100],
	[MK_WILL_O_THE_WISP,0,		null,									null,									10,		17,		100],
	[MK_WRAITH,					0,		null,									null,									10,		17,		100],
	[MK_GOBLIN_TOTEM,		4,		[MK_GOBLIN_TOTEM, MK_GOBLIN_CONJURER, MK_GOBLIN_MYSTIC, MK_GOBLIN], [[1,2,1],[1,2,1],[1,2,1],[3,5,1]],	10,17,80,	0,MT_CAMP_AREA,	HORDE_NO_PERIODIC_SPAWN],
	[MK_SPARK_TURRET,		0,		null,									null,									11,		18,		100,		WALL,	0,                      HORDE_NO_PERIODIC_SPAWN],
	[MK_ZOMBIE,					0,		null,									null,									11,		18,		100],
	[MK_TROLL,					0,		null,									null,									12,		19,		100],
	[MK_OGRE_TOTEM,			1,		[MK_OGRE],						[[2,4,1]],						12,		19,		60,		0,			0,					HORDE_NO_PERIODIC_SPAWN],
	[MK_BOG_MONSTER,		1,		[MK_BOG_MONSTER],			[[2,4,1]],						12,		26,		100,		MUD],
	[MK_NAGA,						0,		null,									null,									13,		20,		100,		DEEP_WATER],
	[MK_SALAMANDER,			0,		null,									null,									13,		20,		100,		LAVA],
	[MK_OGRE_SHAMAN,		1,		[MK_OGRE],						[[1, 3, 1]],					14,		20,		100],
	[MK_CENTAUR,				1,		[MK_CENTAUR],					[[1, 1, 1]],					14,		21,		100],
	[MK_ACID_JELLY,			0,		null,									null,									14,		21,		100],
	// [MK_ACID_TURRET,		0,		null,									null,									15,		22,		100,		WALL,	0,                      HORDE_NO_PERIODIC_SPAWN],
  [MK_DART_TURRET,		0,		null,									null,									15,		22,		100,		WALL,	0,                      HORDE_NO_PERIODIC_SPAWN],
	[MK_PIXIE,					0,		null,									null,									14,		21,		80],
	[MK_FLAME_TURRET,		0,		null,									null,									14,		24,		100,		WALL,	0,                      HORDE_NO_PERIODIC_SPAWN],
	[MK_DAR_BLADEMASTER,2,		[MK_DAR_BLADEMASTER, MK_DAR_PRIESTESS],	[[0, 1, 1], [0, 1, 1]],			15,		17,		100],
  [MK_PINK_JELLY,     2,		[MK_PINK_JELLY, MK_DAR_PRIESTESS],      [[0, 1, 1], [1, 2, 1]],			17,		23,		70],
	[MK_KRAKEN,					0,		null,									null,									15,		30,		100,		DEEP_WATER],
	[MK_PHANTOM,				0,		null,									null,									16,		23,		100],
	[MK_WRAITH,					1,		[MK_WRAITH],					[[1, 4, 1]],					16,		23,		80],
	[MK_IMP,						0,		null,									null,									17,		24,		100],
	[MK_DAR_BLADEMASTER,3,		[MK_DAR_BLADEMASTER, MK_DAR_PRIESTESS, MK_DAR_BATTLEMAGE],[[1,2,1],[1,1,1],[1,1,1]], 18,25,100],
	[MK_FURY,						1,		[MK_FURY],						[[2, 4, 1]],					18,		26,		80],
	[MK_REVENANT,				0,		null,									null,									19,		27,		100],
	[MK_GOLEM,					0,		null,									null,									21,		30,		100],
	[MK_TENTACLE_HORROR,0,		null,									null,									22,		DEEPEST_LEVEL-1,		100],
	[MK_PHYLACTERY,			0,		null,									null,									22,		DEEPEST_LEVEL-1,		100],
	[MK_DRAGON,					0,		null,									null,									24,		DEEPEST_LEVEL-1,		70],
	[MK_DRAGON,					1,		[MK_DRAGON],					[[1,1,1]],						27,		DEEPEST_LEVEL-1,		30],
	[MK_GOLEM,					3,		[MK_GOLEM, MK_DAR_PRIESTESS, MK_DAR_BATTLEMAGE], [[1, 2, 1], [0,1,1],[0,1,1]],27,DEEPEST_LEVEL-1,	80],
	[MK_GOLEM,					1,		[MK_GOLEM],						[[5, 10, 2]],					30,		DEEPEST_LEVEL-1,    20],
  [MK_KRAKEN,					1,		[MK_KRAKEN],					[[5, 10, 2]],					30,		DEEPEST_LEVEL-1,    100,		DEEP_WATER],
	[MK_TENTACLE_HORROR,2,		[MK_TENTACLE_HORROR, MK_REVENANT],		[[1, 3, 1], [2, 4, 1]],			32,		DEEPEST_LEVEL-1,    20],
	[MK_DRAGON,					1,		[MK_DRAGON],					[[3, 5, 1]],					34,		DEEPEST_LEVEL-1,    20],

	// summons
	[MK_GOBLIN_CONJURER,1,		[MK_SPECTRAL_BLADE],	[[3, 5, 1]],					0,		0,		100,		0,			0,					HORDE_IS_SUMMONED | HORDE_DIES_ON_LEADER_DEATH],
	[MK_OGRE_SHAMAN,		1,		[MK_OGRE],						[[1, 1, 1]],					0,		0,		100,		0,			0,					HORDE_IS_SUMMONED],
	[MK_VAMPIRE,				1,		[MK_VAMPIRE_BAT],			[[3, 3, 1]],					0,		0,		100,		0,			0,					HORDE_IS_SUMMONED],
	[MK_LICH,						1,		[MK_PHANTOM],					[[2, 3, 1]],					0,		0,		100,		0,			0,					HORDE_IS_SUMMONED],
	[MK_LICH,						1,		[MK_FURY],						[[2, 3, 1]],					0,		0,		100,		0,			0,					HORDE_IS_SUMMONED],
	[MK_PHYLACTERY,			1,		[MK_LICH],						[[1,1,1]],						0,		0,		100,		0,			0,					HORDE_IS_SUMMONED],
	[MK_GOBLIN_CHIEFTAN,2,		[MK_GOBLIN_CONJURER, MK_GOBLIN],		[[1,1,1], [3,4,1]],				0,		0,		100,		0,			0,					HORDE_IS_SUMMONED | HORDE_SUMMONED_AT_DISTANCE],
	[MK_PHOENIX_EGG,		1,		[MK_PHOENIX],					[[1,1,1]],						0,		0,		100,		0,			0,					HORDE_IS_SUMMONED],
  [MK_ELDRITCH_TOTEM, 1,		[MK_SPECTRAL_BLADE],	[[4, 7, 1]],					0,		0,		100,		0,			0,					HORDE_IS_SUMMONED | HORDE_DIES_ON_LEADER_DEATH],
  [MK_ELDRITCH_TOTEM, 1,		[MK_FURY],            [[2, 3, 1]],					0,		0,		100,		0,			0,					HORDE_IS_SUMMONED | HORDE_DIES_ON_LEADER_DEATH],

	// captives
	[MK_MONKEY,					1,		[MK_KOBOLD],					[[1, 2, 1]],									1,		5,		3,		0,			0,					HORDE_LEADER_CAPTIVE | HORDE_NEVER_OOD],
	[MK_GOBLIN,					1,		[MK_GOBLIN],					[[1, 2, 1]],									3,		7,		3,		0,			0,					HORDE_LEADER_CAPTIVE | HORDE_NEVER_OOD],
	[MK_OGRE,						1,		[MK_GOBLIN],					[[3, 5, 1]],									4,		10,		3,		0,			0,					HORDE_LEADER_CAPTIVE | HORDE_NEVER_OOD],
	[MK_GOBLIN_MYSTIC,	1,		[MK_KOBOLD],					[[3, 7, 1]],									5,		11,		3,		0,			0,					HORDE_LEADER_CAPTIVE | HORDE_NEVER_OOD],
	[MK_OGRE,						1,		[MK_OGRE],						[[1, 2, 1]],									8,		15,		6,		0,			0,					HORDE_LEADER_CAPTIVE | HORDE_NEVER_OOD],
	[MK_TROLL,					1,		[MK_TROLL],						[[1, 2, 1]],									14,		19,		3,		0,			0,					HORDE_LEADER_CAPTIVE | HORDE_NEVER_OOD],
	[MK_CENTAUR,				1,		[MK_TROLL],						[[1, 2, 1]],									12,		19,		3,		0,			0,					HORDE_LEADER_CAPTIVE | HORDE_NEVER_OOD],
	[MK_TROLL,					2,		[MK_OGRE, MK_OGRE_SHAMAN],[[2, 3, 1], [0, 1, 1]],		17,		19,		3,		0,			0,					HORDE_LEADER_CAPTIVE | HORDE_NEVER_OOD],
	[MK_DAR_BLADEMASTER,1,		[MK_TROLL],						[[1, 2, 1]],									12,		19,		3,		0,			0,					HORDE_LEADER_CAPTIVE | HORDE_NEVER_OOD],
	[MK_NAGA,						1,		[MK_SALAMANDER],			[[1, 2, 1]],									14,		20,		3,		0,			0,					HORDE_LEADER_CAPTIVE | HORDE_NEVER_OOD],
	[MK_SALAMANDER,			1,		[MK_NAGA],						[[1, 2, 1]],									13,		20,		3,		0,			0,					HORDE_LEADER_CAPTIVE | HORDE_NEVER_OOD],
	[MK_TROLL,					1,		[MK_SALAMANDER],			[[1, 2, 1]],									13,		19,		3,		0,			0,					HORDE_LEADER_CAPTIVE | HORDE_NEVER_OOD],
	[MK_IMP,						1,		[MK_FURY],						[[2, 4, 1]],									18,		26,		3,		0,			0,					HORDE_LEADER_CAPTIVE | HORDE_NEVER_OOD],
	[MK_PIXIE,					1,		[MK_IMP, MK_PHANTOM],	[[1, 2, 1], [1, 2, 1]],				14,		21,		3,		0,			0,					HORDE_LEADER_CAPTIVE | HORDE_NEVER_OOD],
	[MK_DAR_BLADEMASTER,1,		[MK_FURY],						[[2, 4, 1]],									18,		26,		3,		0,			0,					HORDE_LEADER_CAPTIVE | HORDE_NEVER_OOD],
	[MK_DAR_BLADEMASTER,1,		[MK_IMP],							[[2, 3, 1]],									18,		26,		3,		0,			0,					HORDE_LEADER_CAPTIVE | HORDE_NEVER_OOD],
	[MK_DAR_PRIESTESS,	1,		[MK_FURY],						[[2, 4, 1]],									18,		26,		3,		0,			0,					HORDE_LEADER_CAPTIVE | HORDE_NEVER_OOD],
	[MK_DAR_BATTLEMAGE,	1,		[MK_IMP],							[[2, 3, 1]],									18,		26,		3,		0,			0,					HORDE_LEADER_CAPTIVE | HORDE_NEVER_OOD],
	[MK_TENTACLE_HORROR,3,		[MK_DAR_BLADEMASTER, MK_DAR_PRIESTESS, MK_DAR_BATTLEMAGE],[[1,2,1],[1,1,1],[1,1,1]], 20,26,3,	0,			0,					HORDE_LEADER_CAPTIVE | HORDE_NEVER_OOD],
	[MK_GOLEM,					3,		[MK_DAR_BLADEMASTER, MK_DAR_PRIESTESS, MK_DAR_BATTLEMAGE],[[1,2,1],[1,1,1],[1,1,1]], 18,25,3,	0,			0,					HORDE_LEADER_CAPTIVE | HORDE_NEVER_OOD],

	// bosses
	[MK_GOBLIN_CHIEFTAN,2,		[MK_GOBLIN_MYSTIC, MK_GOBLIN, MK_GOBLIN_TOTEM], [[1,1,1], [2,3,1], [2,2,1]],2,	10,		50,		0,			0,					HORDE_MACHINE_BOSS],
	[MK_BLACK_JELLY,		0,		null,									null,							5,		15,		50,		0,			0,					HORDE_MACHINE_BOSS],
	[MK_VAMPIRE,				0,		null,									null,							10,		DEEPEST_LEVEL,	50,  0,		0,					HORDE_MACHINE_BOSS],
	[MK_FLAMEDANCER,		0,		null,									null,							10,		DEEPEST_LEVEL,	50,  0,		0,					HORDE_MACHINE_BOSS],

	// machine water monsters
	[MK_EEL,						0,		null,									null,							2,		7,		100,		DEEP_WATER,	0,					HORDE_MACHINE_WATER_MONSTER],
	[MK_EEL,						1,		[MK_EEL],							[[2, 4, 1]],			5,		15,		100,		DEEP_WATER,	0,					HORDE_MACHINE_WATER_MONSTER],
	[MK_KRAKEN,					0,		null,									null,							12,		DEEPEST_LEVEL,	100,	DEEP_WATER,	0,				HORDE_MACHINE_WATER_MONSTER],
	[MK_KRAKEN,					1,		[MK_EEL],							[[1, 2, 1]],			12,		DEEPEST_LEVEL,	80,	DEEP_WATER,	0,				HORDE_MACHINE_WATER_MONSTER],

	// dungeon captives -- no captors
	[MK_OGRE,						0,		null,									null,							4,		13,		100,		0,			0,					HORDE_MACHINE_CAPTIVE | HORDE_LEADER_CAPTIVE],
	[MK_NAGA,						0,		null,									null,							12,		20,		50,			0,			0,					HORDE_MACHINE_CAPTIVE | HORDE_LEADER_CAPTIVE],
	[MK_GOBLIN_MYSTIC,	0,		null,									null,							2,		8,		100,		0,			0,					HORDE_MACHINE_CAPTIVE | HORDE_LEADER_CAPTIVE],
	[MK_TROLL,					0,		null,									null,							10,		20,		50,			0,			0,					HORDE_MACHINE_CAPTIVE | HORDE_LEADER_CAPTIVE],
	[MK_DAR_BLADEMASTER,0,		null,									null,							8,		16,		100,		0,			0,					HORDE_MACHINE_CAPTIVE | HORDE_LEADER_CAPTIVE],
	[MK_DAR_PRIESTESS,	0,		null,									null,							8,		14,		100,		0,			0,					HORDE_MACHINE_CAPTIVE | HORDE_LEADER_CAPTIVE],
	[MK_WRAITH,					0,		null,									null,							11,		20,		100,		0,			0,					HORDE_MACHINE_CAPTIVE | HORDE_LEADER_CAPTIVE],
	[MK_GOLEM,					0,		null,									null,							17,		23,		100,		0,			0,					HORDE_MACHINE_CAPTIVE | HORDE_LEADER_CAPTIVE],
	[MK_TENTACLE_HORROR,0,		null,									null,							20,		AMULET_LEVEL,100,0,			0,					HORDE_MACHINE_CAPTIVE | HORDE_LEADER_CAPTIVE],
	[MK_DRAGON,					0,		null,									null,							23,		AMULET_LEVEL,100,0,			0,					HORDE_MACHINE_CAPTIVE | HORDE_LEADER_CAPTIVE],

	// machine statue monsters
	[MK_GOBLIN,					0,		null,									null,							1,		6,		100,						STATUE_DORMANT, 0,				HORDE_MACHINE_STATUE],
	[MK_OGRE,						0,		null,									null,							6,		12,		100,						STATUE_DORMANT, 0,				HORDE_MACHINE_STATUE],
	[MK_WRAITH,					0,		null,									null,							10,		17,		100,						STATUE_DORMANT, 0,				HORDE_MACHINE_STATUE],
	[MK_NAGA,						0,		null,									null,							12,		19,		100,						STATUE_DORMANT, 0,				HORDE_MACHINE_STATUE],
	[MK_TROLL,					0,		null,									null,							14,		21,		100,						STATUE_DORMANT, 0,				HORDE_MACHINE_STATUE],
	[MK_GOLEM,					0,		null,									null,							21,		30,		100,						STATUE_DORMANT, 0,				HORDE_MACHINE_STATUE],
	[MK_DRAGON,					0,		null,									null,							29,		DEEPEST_LEVEL,	100,	STATUE_DORMANT, 0,			HORDE_MACHINE_STATUE],
  [MK_TENTACLE_HORROR,0,		null,									null,							29,		DEEPEST_LEVEL,	100,	STATUE_DORMANT, 0,			HORDE_MACHINE_STATUE],

	// machine turrets
	[MK_ARROW_TURRET,		0,		null,									null,							5,		13,		100,		TURRET_DORMANT, 0,				HORDE_MACHINE_TURRET],
	[MK_SPARK_TURRET,		0,		null,									null,							11,		18,		100,		TURRET_DORMANT, 0,				HORDE_MACHINE_TURRET],
	// [MK_ACID_TURRET,		0,		null,									null,							15,		22,		100,		TURRET_DORMANT, 0,				HORDE_MACHINE_TURRET],
	[MK_DART_TURRET,		0,		null,									null,							15,		22,		100,		TURRET_DORMANT, 0,				HORDE_MACHINE_TURRET],
	[MK_FLAME_TURRET,		0,		null,									null,							17,		24,		100,		TURRET_DORMANT, 0,				HORDE_MACHINE_TURRET],

	// machine mud monsters
	[MK_BOG_MONSTER,		0,		null,									null,							12,		26,		100,		MACHINE_MUD_DORMANT, 0,			HORDE_MACHINE_MUD],
	[MK_KRAKEN,					0,		null,									null,							17,		26,		30,		MACHINE_MUD_DORMANT, 0,			HORDE_MACHINE_MUD],

	// kennel monsters
	[MK_MONKEY,					0,		null,									null,							1,		5,		100,		MONSTER_CAGE_CLOSED, 0,			HORDE_MACHINE_KENNEL | HORDE_LEADER_CAPTIVE],
	[MK_GOBLIN,					0,		null,									null,							1,		8,		100,		MONSTER_CAGE_CLOSED, 0,			HORDE_MACHINE_KENNEL | HORDE_LEADER_CAPTIVE],
	[MK_GOBLIN_CONJURER,0,		null,									null,							2,		9,		100,		MONSTER_CAGE_CLOSED, 0,			HORDE_MACHINE_KENNEL | HORDE_LEADER_CAPTIVE],
	[MK_GOBLIN_MYSTIC,	0,		null,									null,							2,		9,		100,		MONSTER_CAGE_CLOSED, 0,			HORDE_MACHINE_KENNEL | HORDE_LEADER_CAPTIVE],
	[MK_OGRE,						0,		null,									null,							7,		17,		100,		MONSTER_CAGE_CLOSED, 0,			HORDE_MACHINE_KENNEL | HORDE_LEADER_CAPTIVE],
	[MK_TROLL,					0,		null,									null,							12,		21,		100,		MONSTER_CAGE_CLOSED, 0,			HORDE_MACHINE_KENNEL | HORDE_LEADER_CAPTIVE],
	[MK_NAGA,						0,		null,									null,							13,		23,		100,		MONSTER_CAGE_CLOSED, 0,			HORDE_MACHINE_KENNEL | HORDE_LEADER_CAPTIVE],
	[MK_SALAMANDER,			0,		null,									null,							9,		20,		100,		MONSTER_CAGE_CLOSED, 0,			HORDE_MACHINE_KENNEL | HORDE_LEADER_CAPTIVE],
	[MK_IMP,						0,		null,									null,							15,		26,		100,		MONSTER_CAGE_CLOSED, 0,			HORDE_MACHINE_KENNEL | HORDE_LEADER_CAPTIVE],
	[MK_PIXIE,					0,		null,									null,							11,		21,		100,		MONSTER_CAGE_CLOSED, 0,			HORDE_MACHINE_KENNEL | HORDE_LEADER_CAPTIVE],
	[MK_DAR_BLADEMASTER,0,		null,									null,							9,		AMULET_LEVEL, 100, MONSTER_CAGE_CLOSED, 0,		HORDE_MACHINE_KENNEL | HORDE_LEADER_CAPTIVE],
	[MK_DAR_PRIESTESS,	0,		null,									null,							12,		AMULET_LEVEL, 100, MONSTER_CAGE_CLOSED, 0,		HORDE_MACHINE_KENNEL | HORDE_LEADER_CAPTIVE],
	[MK_DAR_BATTLEMAGE,	0,		null,									null,							13,		AMULET_LEVEL, 100, MONSTER_CAGE_CLOSED, 0,		HORDE_MACHINE_KENNEL | HORDE_LEADER_CAPTIVE],

	// vampire bloodbags
	[MK_MONKEY,					0,		null,									null,							1,		5,		100,				MONSTER_CAGE_CLOSED, 0,			HORDE_VAMPIRE_FODDER | HORDE_LEADER_CAPTIVE],
	[MK_GOBLIN,					0,		null,									null,							1,		8,		100,				MONSTER_CAGE_CLOSED, 0,			HORDE_VAMPIRE_FODDER | HORDE_LEADER_CAPTIVE],
	[MK_GOBLIN_CONJURER,0,		null,									null,							2,		9,		100,				MONSTER_CAGE_CLOSED, 0,			HORDE_VAMPIRE_FODDER | HORDE_LEADER_CAPTIVE],
	[MK_GOBLIN_MYSTIC,	0,		null,									null,							2,		9,		100,				MONSTER_CAGE_CLOSED, 0,			HORDE_VAMPIRE_FODDER | HORDE_LEADER_CAPTIVE],
	[MK_OGRE,						0,		null,									null,							5,		15,		100,				MONSTER_CAGE_CLOSED, 0,			HORDE_VAMPIRE_FODDER | HORDE_LEADER_CAPTIVE],
	[MK_TROLL,					0,		null,									null,							10,		19,		100,				MONSTER_CAGE_CLOSED, 0,			HORDE_VAMPIRE_FODDER | HORDE_LEADER_CAPTIVE],
	[MK_NAGA,						0,		null,									null,							9,		20,		100,				MONSTER_CAGE_CLOSED, 0,			HORDE_VAMPIRE_FODDER | HORDE_LEADER_CAPTIVE],
	[MK_IMP,						0,		null,									null,							15,		AMULET_LEVEL,100,	MONSTER_CAGE_CLOSED, 0,			HORDE_VAMPIRE_FODDER | HORDE_LEADER_CAPTIVE],
	[MK_PIXIE,					0,		null,									null,							11,		21,		100,				MONSTER_CAGE_CLOSED, 0,			HORDE_VAMPIRE_FODDER | HORDE_LEADER_CAPTIVE],
	[MK_DAR_BLADEMASTER,0,		null,									null,							9,		AMULET_LEVEL,100,	MONSTER_CAGE_CLOSED, 0,			HORDE_VAMPIRE_FODDER | HORDE_LEADER_CAPTIVE],
	[MK_DAR_PRIESTESS,	0,		null,									null,							12,		AMULET_LEVEL,100,	MONSTER_CAGE_CLOSED, 0,			HORDE_VAMPIRE_FODDER | HORDE_LEADER_CAPTIVE],
	[MK_DAR_BATTLEMAGE,	0,		null,									null,							13,		AMULET_LEVEL,100,	MONSTER_CAGE_CLOSED, 0,			HORDE_VAMPIRE_FODDER | HORDE_LEADER_CAPTIVE],

  // key thieves
  [MK_MONKEY,					0,		null,									null,							1,		14,		100,     			 0,          0,                  HORDE_MACHINE_THIEF],
  [MK_IMP,						0,		null,									null,							15,		DEEPEST_LEVEL,	100, 0,      0,                  HORDE_MACHINE_THIEF],

	// sacrifice victims
	[MK_MONKEY,					0,		null,									[[0]],							1,		5,		100,		STATUE_INSTACRACK, 0,			HORDE_SACRIFICE_TARGET],
	[MK_GOBLIN,					0,		null,									[[0]],							3,		10,		100,		STATUE_INSTACRACK, 0,			HORDE_SACRIFICE_TARGET],
	[MK_OGRE,						0,		null,									[[0]],							7,		13,		100,		STATUE_INSTACRACK, 0,			HORDE_SACRIFICE_TARGET],
	[MK_TROLL,					0,		null,									[[0]],							12,		19,		100,		STATUE_INSTACRACK, 0,			HORDE_SACRIFICE_TARGET],
	[MK_WRAITH,					0,		null,									[[0]],							10,		17,		100,		STATUE_INSTACRACK, 0,			HORDE_SACRIFICE_TARGET],
	[MK_NAGA,						0,		null,									[[0]],							13,		20,		100,		STATUE_INSTACRACK, 0,			HORDE_SACRIFICE_TARGET],
	[MK_DAR_BLADEMASTER,0,		null,									[[0]],							10,		20,		100,		STATUE_INSTACRACK, 0,			HORDE_SACRIFICE_TARGET],
	[MK_GOLEM,					0,		null,									[[0]],							22,		DEEPEST_LEVEL,100,  STATUE_INSTACRACK, 0,			HORDE_SACRIFICE_TARGET],
	[MK_REVENANT,				0,		null,									[[0]],							22,		DEEPEST_LEVEL,100,  STATUE_INSTACRACK, 0,			HORDE_SACRIFICE_TARGET],
	[MK_TENTACLE_HORROR,0,		null,									[[0]],							22,		DEEPEST_LEVEL,100,  STATUE_INSTACRACK, 0,			HORDE_SACRIFICE_TARGET],

	// legendary allies
	[MK_UNICORN,				0,		null,									null,							1,		DEEPEST_LEVEL,	100, 0,		0,					HORDE_MACHINE_LEGENDARY_ALLY | HORDE_ALLIED_WITH_PLAYER],
	[MK_IFRIT,					0,		null,									null,							1,		DEEPEST_LEVEL,	100,	0,		0,					HORDE_MACHINE_LEGENDARY_ALLY | HORDE_ALLIED_WITH_PLAYER],
	[MK_PHOENIX_EGG,		0,		null,									null,							1,		DEEPEST_LEVEL,	100,	0,		0,					HORDE_MACHINE_LEGENDARY_ALLY | HORDE_ALLIED_WITH_PLAYER],
  [MK_ANCIENT_SPIRIT,	0,		null,									null,							1,		DEEPEST_LEVEL,	100,	0,		0,					HORDE_MACHINE_LEGENDARY_ALLY | HORDE_ALLIED_WITH_PLAYER],

  // goblin warren
  [MK_GOBLIN,					0,		null,									null,							1,		10,		100,     0,              0,              HORDE_MACHINE_GOBLIN_WARREN],
	[MK_GOBLIN_CONJURER,0,		null,									null,							1,		10,		60,      0,              0,              HORDE_MACHINE_GOBLIN_WARREN],
	[MK_GOBLIN_TOTEM,		1,		[MK_GOBLIN],					[[2,4,1]],						5,		13,		100,		0,				MT_CAMP_AREA,	HORDE_MACHINE_GOBLIN_WARREN],
	[MK_GOBLIN,					3,		[MK_GOBLIN, MK_GOBLIN_MYSTIC, MK_JACKAL],[[2, 3, 1], [1,2,1], [1,2,1]],	6,		12,		40,      0,              0,              HORDE_MACHINE_GOBLIN_WARREN],
	[MK_GOBLIN_CONJURER,2,		[MK_GOBLIN_CONJURER, MK_GOBLIN_MYSTIC],	[[0,1,1], [1,1,1]],				7,		15,		40,      0,              0,              HORDE_MACHINE_GOBLIN_WARREN],
	[MK_GOBLIN_TOTEM,		4,		[MK_GOBLIN_TOTEM, MK_GOBLIN_CONJURER, MK_GOBLIN_MYSTIC, MK_GOBLIN], [[1,2,1],[1,2,1],[1,2,1],[3,5,1]],10,17,80, 0,MT_CAMP_AREA,	HORDE_MACHINE_GOBLIN_WARREN],
	[MK_GOBLIN,					1,		[MK_GOBLIN],					[[1, 2, 1]],					3,		7,		10,		0,              0,				HORDE_MACHINE_GOBLIN_WARREN | HORDE_LEADER_CAPTIVE],
].map( (v) => hordeType(...v) );

const	NUMBER_HORDES 			=				hordeCatalog.length;


// #pragma mark Monster class definitions

const monsterClassCatalog = [
    // name             frequency   maxDepth    member list
    ["abomination",     10,         -1,         [MK_BOG_MONSTER, MK_UNDERWORM, MK_KRAKEN, MK_TENTACLE_HORROR]],
    ["dar",             10,         22,         [MK_DAR_BLADEMASTER, MK_DAR_PRIESTESS, MK_DAR_BATTLEMAGE]],
    ["animal",          10,         10,         [MK_RAT, MK_MONKEY, MK_JACKAL, MK_EEL, MK_TOAD, MK_VAMPIRE_BAT, MK_CENTIPEDE, MK_SPIDER]],
    ["goblin",          10,         10,         [MK_GOBLIN, MK_GOBLIN_CONJURER, MK_GOBLIN_MYSTIC, MK_GOBLIN_TOTEM, MK_GOBLIN_CHIEFTAN, MK_SPECTRAL_BLADE]],
    ["ogre",            10,         16,         [MK_OGRE, MK_OGRE_SHAMAN, MK_OGRE_TOTEM]],
    ["dragon",          10,         -1,         [MK_DRAGON]],
    ["undead",          10,         -1,         [MK_ZOMBIE, MK_WRAITH, MK_VAMPIRE, MK_PHANTOM, MK_LICH, MK_REVENANT]],
    ["jelly",           10,         15,         [MK_PINK_JELLY, MK_BLACK_JELLY, MK_ACID_JELLY]],
    ["turret",          5,          18,         [MK_ARROW_TURRET, MK_SPARK_TURRET, MK_DART_TURRET, MK_FLAME_TURRET]],
    ["infernal",        10,         -1,         [MK_FLAMEDANCER, MK_IMP, MK_REVENANT, MK_FURY, MK_PHANTOM, MK_IFRIT]],
		["mage",            10,         -1,         [MK_GOBLIN_CONJURER, MK_GOBLIN_MYSTIC, MK_OGRE_SHAMAN, MK_DAR_BATTLEMAGE, MK_PIXIE, MK_LICH]],
    ["waterborne",      10,         17,         [MK_EEL, MK_NAGA, MK_KRAKEN]],
		["airborne",        10,         15,         [MK_VAMPIRE_BAT, MK_WILL_O_THE_WISP, MK_PIXIE, MK_PHANTOM, MK_FURY, MK_IFRIT, MK_PHOENIX]],
    ["fireborne",       10,         12,         [MK_WILL_O_THE_WISP, MK_SALAMANDER, MK_FLAMEDANCER, MK_PHOENIX]],
    ["troll",           10,         15,         [MK_TROLL]],
].map( (v) => monsterClass(...v) );

// ITEMS

// #pragma mark Item flavors

const itemTitles = []; // [NUMBER_SCROLL_KINDS][30];

const titlePhonemes = [
	"glorp",
	"snarg",
	"gana",
	"flin",
	"herba",
	"pora",
	"nuglo",
	"greep",
	"nur",
	"lofa",
	"poder",
	"nidge",
	"pus",
	"wooz",
	"flem",
	"bloto",
	"porta",
  "ermah",
  "gerd",
  "nurt",
  "flurx",
];

const itemColors = []; // [NUMBER_ITEM_COLORS][30];

const itemColorsRef = [
	"crimson",
	"scarlet",
	"orange",
	"yellow",
	"green",
	"blue",
	"indigo",
	"violet",
	"puce",
	"mauve",
	"burgundy",
	"turquoise",
	"aquamarine",
	"gray",
	"pink",
	"white",
	"lavender",
	"tan",
	"brown",
	"cyan",
	"black"
];

const itemWoods = []; // [NUMBER_ITEM_WOODS][30];

const itemWoodsRef = [
	"teak",
	"oak",
	"redwood",
	"rowan",
	"willow",
	"mahogany",
	"pinewood",
	"maple",
	"bamboo",
	"ironwood",
	"pearwood",
	"birch",
	"cherry",
	"eucalyptus",
	"walnut",
	"cedar",
	"rosewood",
	"yew",
	"sandalwood",
    "hickory",
    "hemlock",
];

const itemMetals = []; // [NUMBER_ITEM_METALS][30];

const itemMetalsRef = [
	"bronze",
	"steel",
	"brass",
	"pewter",
	"nickel",
	"copper",
	"aluminum",
	"tungsten",
	"titanium",
  "cobalt",
  "chromium",
  "silver",
];

const itemGems = []; // [NUMBER_ITEM_GEMS][30];

const itemGemsRef = [
	"diamond",
	"opal",
	"garnet",
	"ruby",
	"amethyst",
	"topaz",
	"onyx",
	"tourmaline",
	"sapphire",
	"obsidian",
	"malachite",
	"aquamarine",
	"emerald",
	"jade",
	"alexandrite",
	"agate",
	"bloodstone",
	"jasper"
];

// #pragma mark Item definitions

//typedef struct itemTable {
//	char *name;
//	char *flavor;
//	short frequency;
//	short marketValue;
//	short number;
//	randomRange range;
//} itemTable;

const keyTable = [ // [NUMBER_KEY_TYPES] = {
	["door key",			"", "", 1, 0,	0, [0,0,0], true, false, "The notches on this ancient iron key are well worn; its leather lanyard is battered by age. What door might it open?"],
	["cage key",			"", "", 1, 0,	0, [0,0,0], true, false, "The rust accreted on this iron key has been stained with flecks of blood; it must have been used recently. What cage might it open?"],
	["crystal orb",			"", "", 1, 0,	0, [0,0,0], true, false, "A faceted orb, seemingly cut from a single crystal, sparkling and perpetually warm to the touch. What manner of device might such an object activate?"],
].map( (v) => itemTable(...v) );

const foodTable = [ // [NUMBER_FOOD_KINDS] = [
	["ration of food",		"", "", 3, 25,	1800, [0,0,0], true, false, "A ration of food. Was it left by former adventurers? Is it a curious byproduct of the subterranean ecosystem?"],
	["mango",				"", "", 1, 15,	1550, [0,0,0], true, false, "An odd fruit to be found so deep beneath the surface of the earth, but only slightly less filling than a ration of food."]
].map( (v) => itemTable(...v) );

const weaponTable = [		// [NUMBER_WEAPON_KINDS] = [
	["dagger",				"", "", 10, 190,		12,	[3,	4,	1],		true, false, "A simple iron dagger with a well-worn wooden handle. Daggers will deal quintuple damage upon a successful sneak attack instead of triple damage."],
	["sword",				"", "", 10, 440,		14, [7,	9,	1],		true, false, "The razor-sharp length of steel blade shines reassuringly."],
	["broadsword",			"", "", 10, 990,		19,	[14, 22, 1],	true, false, "This towering blade inflicts heavy damage by investing its heft into every cut."],

  ["whip",				"", "", 10, 440,		14, [3,	5,	1],		true, false, "The lash from this coil of braided leather can tear bark from trees, and it will reach opponents up to five spaces away."],
  ["rapier",				"", "", 10, 440,		15, [3,	5,	1],		true, false, "This blade is thin and flexible, designed for deft and rapid maneuvers. It inflicts less damage than comparable weapons, but permits you to attack twice as quickly. If there is one space between you and an enemy and you step directly toward it, you will perform a devastating lunge attack, which deals treble damage and never misses."],
  ["flail",				"", "", 10, 440,		17, [10,13,	1],		true, false, "This spiked iron ball can be whirled at the end of its chain in synchronicity with your movement, allowing you a free attack whenever moving between two spaces that are adjacent to an enemy."],

	["mace",				"", "", 10, 660,		16, [16, 20, 1],	true, false, "The iron flanges at the head of this weapon inflict substantial damage with every weighty blow. Because of its heft, it takes an extra turn to recover when it hits."],
	["war hammer",			"", "", 10, 1100,		20, [25, 35, 1],	true, false, "Few creatures can withstand the crushing blow of this towering mass of lead and steel, but only the strongest of adventurers can effectively wield it. Because of its heft, it takes an extra turn to recover when it hits, and will push the opponent backward if there is room."],

	["spear",				"", "", 10, 330,		13, [4, 5, 1],		true, false, "A slender wooden rod tipped with sharpened iron. The reach of the spear permits you to simultaneously attack an adjacent enemy and the enemy directly behind it."],
	["war pike",			"", "", 10, 880,		18, [11, 15, 1],	true, false, "A long steel pole ending in a razor-sharp point. The reach of the pike permits you to simultaneously attack an adjacent enemy and the enemy directly behind it."],

	["axe",					"", "", 10, 550,		15, [7, 9, 1],		true, false, "The blunt iron edge on this axe glints in the darkness. The arc of its swing permits you to attack all adjacent enemies simultaneously."],
	["war axe",				"", "", 10, 990,		19, [12, 17, 1],	true, false, "The enormous steel head of this war axe puts considerable heft behind each stroke. The arc of its swing permits you to attack all adjacent enemies simultaneously."],

	["dart",				"", "",	0,	15,			10,	[2,	4,	1],		true, false, "These simple metal spikes are weighted to fly true and sting their prey with a flick of the wrist."],
	["incendiary dart",		"", "",	10, 25,			12,	[1,	2,	1],		true, false, "The barbed spike on each of these darts is designed to stick to its target while the compounds strapped to its length explode into flame."],
	["javelin",				"", "",	10, 40,			15,	[3, 11, 3],		true, false, "This length of metal is weighted to keep the spike at its tip foremost as it sails through the air."],
].map( (v) => itemTable(...v) );

const armorTable = [ 	// [NUMBER_ARMOR_KINDS] = [
	["leather armor",	"", "", 10,	250,		10,	[30,30,0],		true, false, "This lightweight armor offers basic protection."],
	["scale mail",		"", "", 10, 350,		12, [40,40,0],		true, false, "Bronze scales cover the surface of treated leather, offering greater protection than plain leather with minimal additional weight."],
	["chain mail",		"", "", 10, 500,		13, [50,50,0],		true, false, "Interlocking metal links make for a tough but flexible suit of armor."],
	["banded mail",		"", "", 10, 800,		15, [70,70,0],		true, false, "Overlapping strips of metal horizontally encircle a chain mail base, offering an additional layer of protection at the cost of greater weight."],
	["splint mail",		"", "", 10, 1000,		17, [90,90,0],		true, false, "Thick plates of metal are embedded into a chain mail base, providing the wearer with substantial protection."],
	["plate armor",		"", "", 10, 1300,		19, [110,110,0],	true, false, "Enormous plates of metal are joined together into a suit that provides unmatched protection to any adventurer strong enough to bear its staggering weight."]
].map( (v) => itemTable(...v) );

const weaponRunicNames = [		// [NUMBER_WEAPON_RUNIC_KINDS][30] = {
	"speed",
	"quietus",
	"paralysis",
	"multiplicity",
	"slowing",
	"confusion",
  "force",
	"slaying",
	"mercy",
	"plenty"
];

const armorRunicNames = [		// [NUMBER_ARMOR_ENCHANT_KINDS][30] = {
	"multiplicity",
	"mutuality",
	"absorption",
	"reprisal",
	"immunity",
	"reflection",
  "respiration",
  "dampening",
	"burden",
	"vulnerability",
  "immolation",
];


const scrollTable = [			/// ][NUMBER_SCROLL_KINDS] = [
	["enchanting",					/* itemTitles[0] */ null, 	"",		0,	550,	0,[0,0,0], false, false, "This ancient enchanting sorcery will imbue a single item with a powerful and permanent magical charge. A staff will increase in power and in number of charges; a weapon will inflict more damage and find its mark more easily; a suit of armor will deflect attacks more often; the magic of a ring will intensify; and a wand will gain expendable charges in the least amount that such a wand can be found with. Weapons and armor will also require less strength to use, and any curses on the item will be lifted."], // frequency is dynamically adjusted
	["identify",						/* itemTitles[1] */ null, 	"",		30,	300,	0,[0,0,0], false, false, "This scrying magic will permanently reveal all of the secrets of a single item."],
	["teleportation",				/* itemTitles[2] */ null, 	"",		10,	500,	0,[0,0,0], false, false, "This escape spell will instantly relocate you to a random location on the dungeon level. It can be used to escape a dangerous situation with luck. The unlucky reader might find himself in an even more dangerous place."],
	["remove curse",				/* itemTitles[3] */ null, 	"",		15,	150,	0,[0,0,0], false, false, "This redemption spell will instantly strip from the reader's weapon, armor, rings and carried items any evil enchantments that might prevent the wearer from removing them."],
	["recharging",					/* itemTitles[4] */ null, 	"",		12,	375,	0,[0,0,0], false, false, "The power bound up in this parchment will instantly recharge all of your staffs and charms."],
	["protect armor",				/* itemTitles[5] */ null, 	"",		10,	400,	0,[0,0,0], false, false, "This ceremonial shielding magic will permanently proof your armor against degradation by acid."],
	["protect weapon",			/* itemTitles[6] */ null, 	"",		10,	400,	0,[0,0,0], false, false, "This ceremonial shielding magic will permanently proof your weapon against degradation by acid."],
  ["sanctuary",       		/* itemTitles[7] */ null, 	"",  	10, 500,  0,[0,0,0], false, false, "This protection rite will imbue the area with powerful warding glyphs, when released over plain ground. Monsters will not willingly set foot on the affected area."],
	["magic mapping",				/* itemTitles[8] */ null, 	"",		12,	500,	0,[0,0,0], false, false, "This powerful scouting magic will etch a purple-hued image of crystal clarity into your memory, alerting you to the precise layout of the level and revealing all hidden secrets."],
	["negation",						/* itemTitles[9] */ null, 	"",		8,	400,	0,[0,0,0], false, false, "When this powerful anti-magic is released, all creatures (including yourself) and all items lying on the ground within your field of view will be exposed to its blast and stripped of magic. Creatures animated purely by magic will die. Potions, scrolls, items being held by other creatures and items in your inventory will not be affected."],
	["shattering",					/* itemTitles[10] */ null,	"",		8,	500,	0,[0,0,0], false, false, "This strange incantation will alter the physical structure of nearby stone, causing it to evaporate into the air over the ensuing minutes."],
  ["discord",             /* itemTitles[11] */ null, 	"",		8,	400,	0,[0,0,0], false, false, "This scroll will unleash a powerful blast of mind magic. Any creatures within line of sight will turn against their companions and attack indiscriminately for 30 turns."],
	["aggravate monsters",	/* itemTitles[12] */ null, 	"",		15,	50,		0,[0,0,0], false, false, "This scroll will unleash a piercing shriek that will awaken all monsters and alert them to the reader's location."],
	["summon monsters",			/* itemTitles[13] */ null, 	"",		10,	50,		0,[0,0,0], false, false, "This summoning incantation will call out to creatures in other planes of existence, drawing them through the fabric of reality to confront the reader."],
].map( (v) => itemTable(...v) );


const potionTable = [		// ][NUMBER_POTION_KINDS] = [
	["life",						/* itemColors[1] */ null, "",		0,	500,	0,[0,0,0], false, false, "A swirling elixir that will instantly heal you, cure you of ailments, and permanently increase your maximum health."], // frequency is dynamically adjusted
  ["strength",				/* itemColors[2] */ null, "",		0,	400,	0,[0,0,0], false, false, "This powerful medicine will course through your muscles, permanently increasing your strength by one point."], // frequency is dynamically adjusted
	["telepathy",				/* itemColors[3] */ null, "",	20,	350,	0,[0,0,0], false, false, "This mysterious liquid will attune your mind to the psychic signature of distant creatures. Its effects will not reveal inanimate objects, such as totems, turrets and traps."],
	["levitation",			/* itemColors[4] */ null, "",	15,	250,	0,[0,0,0], false, false, "This curious liquid will cause you to hover in the air, able to drift effortlessly over lava, water, chasms and traps. Flames, gases and spiderwebs fill the air, and cannot be bypassed while airborne. Creatures that dwell in water or mud will be unable to attack you while you levitate."],
	["detect magic",		/* itemColors[5] */ null, "",	20,	500,	0,[0,0,0], false, false, "This mysterious brew will sensitize your mind to the radiance of magic. Items imbued with helpful enchantments will be marked with a full sigil; items corrupted by curses or designed to bring misfortune upon the bearer will be marked with a hollow sigil. The Amulet of Yendor will be revealed by its unique aura."],
	["speed",						/* itemColors[6] */ null, "",		10,	500,	0,[0,0,0], false, false, "Quaffing the contents of this flask will enable you to move at blinding speed for several minutes."],
	["fire immunity",		/* itemColors[7] */ null, "",		15,	500,	0,[0,0,0], false, false, "This potion will render you impervious to heat and permit you to wander through fire and lava and ignore otherwise deadly bolts of flame. It will not guard against the concussive impact of an explosion, however."],
  ["invisibility",		/* itemColors[8] */ null, "",		15,	400,	0,[0,0,0], false, false, "Drinking this potion will render you temporarily invisible. Enemies more than two spaces away will be unable to track you."],
  ["caustic gas",     /* itemColors[9] */ null, "",		15,	200,	0,[0,0,0], false, false, "Uncorking or shattering this pressurized glass will cause its contents to explode into a deadly cloud of caustic purple gas. You might choose to fling this potion at distant enemies instead of uncorking it by hand."],
	["paralysis",				/* itemColors[10] */ null, "",	10, 250,	0,[0,0,0], false, false, "Upon exposure to open air, the liquid in this flask will vaporize into a numbing pink haze. Anyone who inhales the cloud will be paralyzed instantly, unable to move for some time after the cloud dissipates. This item can be thrown at distant enemies to catch them within the effect of the gas."],
	["hallucination",		/* itemColors[11] */ null, "",	10,	500,	0,[0,0,0], false, false, "This flask contains a vicious and long-lasting hallucinogen. Under its dazzling effect, you will wander through a rainbow wonderland, unable to discern the form of any creatures or items you see."],
	["confusion",				/* itemColors[12] */ null, "",	15,	450,	0,[0,0,0], false, false, "This unstable chemical will quickly vaporize into a glittering cloud upon contact with open air, causing any creature that inhales it to lose control of the direction of its movements until the effect wears off (although its ability to aim projectile attacks will not be affected). Its vertiginous intoxication can cause creatures and adventurers to careen into one another or into chasms or lava pits, so extreme care should be taken when under its effect. Its contents can be weaponized by throwing the flask at distant enemies."],
	["incineration",		/* itemColors[13] */ null, "",	15,	500,	0,[0,0,0], false, false, "This flask contains an unstable compound which will burst violently into flame upon exposure to open air. You might throw the flask at distant enemies -- or into a deep lake, to cleanse the cavern with scalding steam."],
	["darkness",				/* itemColors[14] */ null, "",	7,	150,	0,[0,0,0], false, false, "Drinking this potion will plunge you into darkness. At first, you will be completely blind to anything not illuminated by an independent light source, but over time your vision will regain its former strength. Throwing the potion will create a cloud of supernatural darkness, and enemies will have difficulty seeing or following you if you take refuge under its cover."],
	["descent",					/* itemColors[15] */ null, "",	15,	500,	0,[0,0,0], false, false, "When this flask is uncorked by hand or shattered by being thrown, the fog that seeps out will temporarily cause the ground in the vicinity to vanish."],
	["creeping death",	/* itemColors[16] */ null, "",	7,	450,	0,[0,0,0], false, false, "When the cork is popped or the flask is thrown, tiny spores will spill across the ground and begin to grow a deadly lichen. Anything that touches the lichen will be poisoned by its clinging tendrils, and the lichen will slowly grow to fill the area. Fire will purge the infestation."],
].map( (v) => itemTable(...v) );


const wandTable = [		// ][NUMBER_WAND_KINDS] = [
	["teleportation",		/* itemMetals[0] */ null, "",	3,	800,	BOLT_TELEPORT,      [3,5,1], false, false, "This wand will teleport a creature to a random place on the level. Aquatic or mud-bound creatures will be rendered helpless on dry land."],
	["slowness",				/* itemMetals[1] */ null, "",	3,	800,	BOLT_SLOW,          [2,5,1], false, false, "This wand will cause a creature to move at half its ordinary speed for 30 turns."],
	["polymorphism",		/* itemMetals[2] */ null, "",	3,	700,	BOLT_POLYMORPH,     [3,5,1], false, false, "This mischievous magic will transform a creature into another creature at random. Beware: the tamest of creatures might turn into the most fearsome. The horror of the transformation will turn an allied victim against you."],
	["negation",				/* itemMetals[3] */ null, "",	3,	550,	BOLT_NEGATION,      [4,6,1], false, false, "This powerful anti-magic will strip a creature of a host of magical traits, including flight, invisibility, acidic corrosiveness, telepathy, magical speed or slowness, hypnosis, magical fear, immunity to physical attack, fire resistance and the ability to blink. Spellcasters will lose their magical abilities and magical totems will be rendered inert. Creatures animated purely by magic will die."],
	["domination",			/* itemMetals[4] */ null, "",	1,	1000,	BOLT_DOMINATION,    [1,2,1], false, false, "This wand can forever bind an enemy to the caster's will, turning it into a steadfast ally. However, the magic works only against enemies that are near death."],
	["beckoning",				/* itemMetals[5] */ null, "",	3,	500,	BOLT_BECKONING,     [2,4,1], false, false, "The force of this wand will draw the targeted creature into direct proximity."],
	["plenty",					/* itemMetals[6] */ null, "",	2,	700,	BOLT_PLENTY,        [1,2,1], false, false, "The creature at the other end of this mischievous bit of cloning magic, friend or foe, will be beside itself -- literally!"],
	["invisibility",		/* itemMetals[7] */ null, "",	3,	100,	BOLT_INVISIBILITY,  [3,5,1], false, false, "This wand will render a creature temporarily invisible to the naked eye. Only with telepathy or in the silhouette of a thick gas will an observer discern the creature's hazy outline."],
  ["empowerment",     /* itemMetals[8] */ null, "",	1,	100,	BOLT_EMPOWERMENT,   [1,1,1], false, false, "This sacred magic will permanently improve the mind and body of any monster it hits. A wise adventurer will use it on allies, making them stronger in combat and able to learn a new talent from a fallen foe. If the bolt is reflected back at you, it will have no effect."],
].map( (v) => itemTable(...v) );


const staffTable = [		// ][NUMBER_STAFF_KINDS] = [
	["lightning",			/* itemWoods[0] */ null, "",	15,	1300,	BOLT_LIGHTNING,     [2,4,1], false, false, "This staff conjures forth deadly arcs of electricity to damage to any number of creatures in a straight line."],
	["firebolt",			/* itemWoods[1] */ null, "",	15,	1300,	BOLT_FIRE,          [2,4,1], false, false, "This staff unleashes bursts of magical fire. It will ignite flammable terrain and burn any creature that it hits. Creatures with an immunity to fire will be unaffected by the bolt."],
	["poison",				/* itemWoods[3] */ null, "",	10,	1200,	BOLT_POISON,        [2,4,1], false, false, "The vile blast of this twisted staff will imbue its target with a deadly venom. Each turn, a creature that is poisoned will suffer one point of damage per dose of poison it has received, and poisoned creatures will not regenerate lost health until the poison clears."],
	["tunneling",			/* itemWoods[4] */ null, "",	10,	1000,	BOLT_TUNNELING,     [2,4,1], false, false, "Bursts of magic from this staff will pass harmlessly through creatures but will reduce obstructions to rubble."],
	["blinking",			/* itemWoods[5] */ null, "",	11,	1200,	BOLT_BLINKING,      [2,4,1], false, false, "This staff will allow you to teleport in the chosen direction. Creatures and inanimate obstructions will block the teleportation."],
	["entrancement",	/* itemWoods[6] */ null, "",	6,	1000,	BOLT_ENTRANCEMENT,  [2,4,1], false, false, "This staff will send creatures into a temporary trance, causing them to mindlessly mirror your movements. You can use the effect to cause one creature to attack another or to step into hazardous terrain, but the spell will be broken if you attack the creature under the effect."],
	["obstruction",		/* itemWoods[7] */ null, "",	10,	1000,	BOLT_OBSTRUCTION,   [2,4,1], false, false, "This staff will conjure a mass of impenetrable green crystal, preventing anything from moving through the affected area and temporarily entombing anything that is already there. The crystal will dissolve into the air as time passes. Higher level staffs will create larger obstructions."],
	["discord",				/* itemWoods[8] */ null, "",	10,	1000,	BOLT_DISCORD,       [2,4,1], false, false, "This staff will alter the perception of a creature and cause it to lash out indiscriminately. Strangers and allies alike will turn on the victim."],
	["conjuration",		/* itemWoods[9] */ null, "",	8,	1000,	BOLT_CONJURATION,   [2,4,1], false, false, "A flick of this staff will summon a number of phantom blades to fight on your behalf."],
	["healing",				/* itemWoods[10] */ null, "",	5,	1100,	BOLT_HEALING,       [2,4,1], false, false, "This staff will heal any creature, friend or foe. Unfortunately, you cannot use this or any staff on yourself except by reflecting the bolt."],
	["haste",					/* itemWoods[11] */ null, "",	5,	900,	BOLT_HASTE,         [2,4,1], false, false, "This staff will temporarily double the speed of any creature, friend or foe. Unfortunately, you cannot use this or any staff on yourself except by reflecting the bolt."],
	["protection",		/* itemWoods[12] */ null, "",	5,	900,	BOLT_SHIELDING,     [2,4,1], false, false, "This staff will bathe a creature in a protective light that will absorb all damage until it is depleted. Unfortunately, you cannot use this or any staff on yourself except by reflecting the bolt."],
].map( (v) => itemTable(...v) );


const ringTable = [		// ][NUMBER_RING_KINDS] = [
	["clairvoyance",	/* itemGems[0] */ null, "",	1,	900,	0,[1,3,1], false, false, "This ring of eldritch scrying will permit you to see through nearby walls and doors, within a radius determined by the level of the ring. A cursed ring of clairvoyance will blind you to your immediate surroundings."],
	["stealth",				/* itemGems[1] */ null, "",	1,	800,	0,[1,3,1], false, false, "This ring of silent passage will reduce your stealth range, making enemies less likely to notice you and more likely to lose your trail. Staying motionless and lurking in the shadows will make you even harder to spot. Cursed rings of stealth will increase your stealth range, making you easier to spot and to track."],
	["regeneration",	/* itemGems[2] */ null, "",	1,	750,	0,[1,3,1], false, false, "This ring of sacred life will allow you to recover lost health at an accelerated rate. Cursed rings will decrease or even halt your natural regeneration."],
	["transference",	/* itemGems[3] */ null, "",	1,	750,	0,[1,3,1], false, false, "This ring of blood magic will heal you in proportion to the damage you inflict on others. Cursed rings will cause you to lose health when inflicting damage."],
	["light",					/* itemGems[4] */ null, "",	1,	600,	0,[1,3,1], false, false, "This ring of preternatural vision will allow you to see farther in the dimming light of the deeper dungeon levels. It will not make you more noticeable to enemies."],
	["awareness",			/* itemGems[5] */ null, "",	1,	700,	0,[1,3,1], false, false, "This ring of effortless vigilance will enable you to notice hidden secrets (traps, secret doors and hidden levers) more often and from a greater distance. Cursed rings of awareness will dull your senses, making it harder to notice secrets without actively searching for them."],
	["wisdom",				/* itemGems[6] */ null, "",	1,	700,	0,[1,3,1], false, false, "This ring of arcane power will cause your staffs to recharge at an accelerated rate. Cursed rings of wisdom will cause your staffs to recharge more slowly."],
  ["reaping",       /* itemGems[7] */ null, "",	1,	700,	0,[1,3,1], false, false, "This ring of blood magic will recharge your staffs and charms every time you hit an enemy. Cursed rings of reaping will drain your staffs and charms with every hit."],
].map( (v) => itemTable(...v) );


const charmTable = [		// ][NUMBER_CHARM_KINDS] = [
	["health",          "", "",	5,	900,	0,[1,2,1], true, false, "A handful of dried bloodwort and mandrake root has been bound together with leather cord and imbued with a powerful healing magic."],
	["protection",			"", "",	5,	800,	0,[1,2,1], true, false, "Four copper rings have been joined into a tetrahedron. The construct is oddly warm to the touch."],
	["haste",           "", "",	5,	750,	0,[1,2,1], true, false, "Various animals have been etched into the surface of this brass bangle. It emits a barely audible hum."],
	["fire immunity",		"", "",	3,	750,	0,[1,2,1], true, false, "Eldritch flames flicker within this polished crystal bauble."],
	["invisibility",		"", "",	5,	700,	0,[1,2,1], true, false, "A jade figurine depicts a strange humanoid creature. It has a face on both sides of its head, but all four eyes are closed."],
	["telepathy",				"", "",	3,	700,	0,[1,2,1], true, false, "Seven tiny glass eyes roll freely within this glass sphere. Somehow, they always come to rest facing outward."],
	["levitation",      "", "",	1,	700,	0,[1,2,1], true, false, "Sparkling dust and fragments of feather waft and swirl endlessly inside this small glass sphere."],
  ["shattering",      "", "",	1,	700,	0,[1,2,1], true, false, "This turquoise crystal, fixed to a leather lanyard, hums with an arcane energy that sets your teeth on edge."],
  ["guardian",        "", "",	5,	700,	0,[1,2,1], true, false, "When you touch this tiny granite statue, a rhythmic booming sound echoes in your head."],
//    ["fear",            "", "",	3,	700,	0,[1,2,1], true, false, "When you gaze into the murky interior of this obsidian cube, you feel as though something predatory is watching you."],
  ["teleportation",   "", "",	4,	700,	0,[1,2,1], true, false, "The surface of this nickel sphere has been etched with a perfect grid pattern. Somehow, the squares of the grid are all exactly the same size."],
  ["recharging",      "", "",	5,	700,	0,[1,2,1], true, false, "A strip of bronze has been wound around a rough wooden sphere. Each time you touch it, you feel a tiny electric shock."],
  ["negation",        "", "",	5,	700,	0,[1,2,1], true, false, "A featureless gray disc hangs from a leather lanyard. When you touch it, your hand and arm go numb."],
].map( (v) => itemTable(...v) );


// #pragma mark Bolt definitions

const boltCatalog = [		// ][NUMBER_BOLT_KINDS] = {
    [],
    //name                      bolt description                ability description                         char    foreColor       backColor           boltEffect      magnitude       pathDF      targetDF    forbiddenMonsterFlags       flags
    ["teleportation spell",     "casts a teleport spell",       "can teleport other creatures",             0,      NULL,           blue,              BE_TELEPORT,    10,             0,          0,          MONST_IMMOBILE,             (BF_TARGET_ENEMIES)],
    ["slowing spell",           "casts a slowing spell",        "can slow $HISHER enemies",                 0,      NULL,           green,             BE_SLOW,        10,             0,          0,          MONST_INANIMATE,            (BF_TARGET_ENEMIES)],
    ["polymorph spell",         "casts a polymorphism spell",   "can polymorph other creatures",            0,      NULL,           purple,            BE_POLYMORPH,   10,             0,          0,          MONST_INANIMATE,            (BF_TARGET_ENEMIES)],
    ["negation magic",          "casts a negation spell",       "can cast negation",                        0,      NULL,           pink,              BE_NEGATION,    10,             0,          0,          0,                          (BF_TARGET_ENEMIES)],
    ["domination spell",        "casts a domination spell",     "can dominate other creatures",             0,      NULL,           dominationColor,   BE_DOMINATION,  10,             0,          0,          MONST_INANIMATE,            (BF_TARGET_ENEMIES)],
    ["beckoning spell",         "casts a beckoning spell",      "can cast beckoning",                       0,      NULL,           beckonColor,       BE_BECKONING,   10,             0,          0,          MONST_IMMOBILE,             (BF_TARGET_ENEMIES)],
    ["spell of plenty",         "casts a spell of plenty",      "can duplicate other creatures",            0,      NULL,           rainbow,           BE_PLENTY,      10,             0,          0,          MONST_INANIMATE,            (BF_TARGET_ALLIES | BF_NOT_LEARNABLE)],
    ["invisibility magic",      "casts invisibility magic",     "can turn creatures invisible",             0,      NULL,           darkBlue,          BE_INVISIBILITY, 10,            0,          0,          MONST_INANIMATE,            (BF_TARGET_ALLIES)],
    ["empowerment sorcery",     "casts empowerment",            "can cast empowerment",                     0,      NULL,           empowermentColor,  BE_EMPOWERMENT, 10,             0,          0,          MONST_INANIMATE,            (BF_TARGET_ALLIES | BF_NOT_LEARNABLE)],
    ["lightning",               "casts lightning",              "can hurl lightning bolts",                 0,      NULL,           lightningColor,    BE_DAMAGE,      10,             0,          0,          0,                          (BF_PASSES_THRU_CREATURES | BF_TARGET_ENEMIES | BF_ELECTRIC)],
    ["flame",                   "casts a gout of flame",        "can hurl gouts of flame",                  0,      NULL,           fireBoltColor,     BE_DAMAGE,      4,              0,          0,          MONST_IMMUNE_TO_FIRE,       (BF_TARGET_ENEMIES | BF_FIERY)],
    ["poison ray",              "casts a poison ray",           "can cast poisonous bolts",                 0,      NULL,           poisonColor,       BE_POISON,      10,             0,          0,          MONST_INANIMATE,            (BF_TARGET_ENEMIES)],
    ["tunneling magic",         "casts tunneling",              "can tunnel",                               0,      NULL,           brown,             BE_TUNNELING,   10,             0,          0,          0,                          (BF_PASSES_THRU_CREATURES)],
    ["blink trajectory",        "blinks",                       "can blink",                                0,      NULL,           white,             BE_BLINKING,    5,              0,          0,          0,                          (BF_HALTS_BEFORE_OBSTRUCTION)],
    ["entrancement ray",        "casts entrancement",           "can cast entrancement",                    0,      NULL,           yellow,            BE_ENTRANCEMENT,10,             0,          0,          MONST_INANIMATE,            (BF_TARGET_ENEMIES)],
    ["obstruction magic",       "casts obstruction",            "can cast obstruction",                     0,      NULL,           forceFieldColor,   BE_OBSTRUCTION, 10,             0,          0,          0,                          (BF_HALTS_BEFORE_OBSTRUCTION)],
    ["spell of discord",        "casts a spell of discord",     "can cast discord",                         0,      NULL,           discordColor,      BE_DISCORD,     10,             0,          0,          MONST_INANIMATE,            (BF_TARGET_ENEMIES)],
    ["conjuration magic",       "casts a conjuration bolt",     "can cast conjuration",                     0,      NULL,           spectralBladeColor, BE_CONJURATION,10,             0,          0,          MONST_IMMUNE_TO_WEAPONS,    (BF_HALTS_BEFORE_OBSTRUCTION | BF_TARGET_ENEMIES)],
    ["healing magic",           "casts healing",                "can heal $HISHER allies",                  0,      NULL,           darkRed,           BE_HEALING,     5,              0,          0,          0,                          (BF_TARGET_ALLIES)],
    ["haste spell",             "casts a haste spell",          "can haste $HISHER allies",                 0,      NULL,           orange,            BE_HASTE,       2,              0,          0,          MONST_INANIMATE,            (BF_TARGET_ALLIES)],
    ["slowing spell",           "casts a slowing spell",        "can slow $HISHER enemies",                 0,      NULL,           green,             BE_SLOW,        2,              0,          0,          MONST_INANIMATE,            (BF_TARGET_ENEMIES)],
    ["protection magic",        "casts protection",             "can cast protection",                      0,      NULL,           shieldingColor,    BE_SHIELDING,   5,              0,          0,          MONST_INANIMATE,            (BF_TARGET_ALLIES)],
    ["spiderweb",               "launches a sticky web",        "can launch sticky webs",                   '*',    white,         NULL,               BE_NONE,        10,             DF_WEB_SMALL, DF_WEB_LARGE, (MONST_IMMOBILE | MONST_IMMUNE_TO_WEBS),   (BF_TARGET_ENEMIES | BF_NEVER_REFLECTS | BF_NOT_LEARNABLE)],
    ["spark",                   "shoots a spark",               "can throw sparks of lightning",            0,      NULL,           lightningColor,    BE_DAMAGE,      1,              0,          0,          0,                          (BF_PASSES_THRU_CREATURES | BF_TARGET_ENEMIES | BF_ELECTRIC)],
    ["dragonfire",              "breathes a gout of white-hot flame", "can breathe gouts of white-hot flame", 0,    NULL,           dragonFireColor,   BE_DAMAGE,      18,             DF_OBSIDIAN, 0,         MONST_IMMUNE_TO_FIRE,       (BF_TARGET_ENEMIES | BF_FIERY | BF_NOT_LEARNABLE)],
    ["arrow",                   "shoots an arrow",              "attacks from a distance",                  WEAPON_CHAR, gray,     NULL,               BE_ATTACK,      1,              0,          0,          MONST_IMMUNE_TO_WEAPONS,    (BF_TARGET_ENEMIES | BF_NEVER_REFLECTS | BF_NOT_LEARNABLE)],
    ["poisoned dart",           "fires a dart",                 "fires strength-sapping darts",             WEAPON_CHAR, centipedeColor, NULL,         BE_ATTACK,      1,              0,          0,          0,                          (BF_TARGET_ENEMIES | BF_NEVER_REFLECTS | BF_NOT_LEARNABLE)],
    // ["acid spray",              "sprays a stream of acid",      "sprays streams of acid",                   '*',    acidBackColor, NULL,               BE_ATTACK,      1,              0,          0,          0,                          (BF_TARGET_ENEMIES | BF_NEVER_REFLECTS | BF_NOT_LEARNABLE)],
    ["growing vines",           "releases carnivorous vines into the ground", "conjures carnivorous vines", GRASS_CHAR, tanColor,  NULL,               BE_NONE,        5,              DF_ANCIENT_SPIRIT_GRASS, DF_ANCIENT_SPIRIT_VINES, (MONST_INANIMATE | MONST_IMMUNE_TO_WEBS),   (BF_TARGET_ENEMIES | BF_NEVER_REFLECTS)],
    ["whip",                    "whips",                        "wields a whip",                            '*',    tanColor,      NULL,               BE_ATTACK,      1,              0,          0,          MONST_IMMUNE_TO_WEAPONS,    (BF_TARGET_ENEMIES | BF_NEVER_REFLECTS | BF_NOT_LEARNABLE | BF_DISPLAY_CHAR_ALONG_LENGTH)],
].map( (v) => bolt(...v) );

// #pragma mark Feat definitions

const featTable = [		// ][FEAT_COUNT] = {
    ["Pure Mage",       "Ascend without using fists or a weapon.", true],
    ["Pure Warrior",    "Ascend without using a staff, wand or charm.", true],
    ["Pacifist",        "Ascend without attacking a creature.", true],
    ["Archivist",       "Ascend without drinking a potion or reading a scroll.", true],
    ["Companion",       "Journey with an ally through 20 depths.", false],
    ["Specialist",      "Enchant an item up to or above +16.", false],
    ["Jellymancer",     "Obtain at least 90 jelly allies simultaneously.", false],
    ["Indomitable",     "Ascend without taking damage.", true],
    ["Mystic",          "Ascend without eating.", true],
    ["Dragonslayer",    "Kill a dragon with a melee attack.", false],
    ["Paladin",         "Ascend without attacking an unaware or fleeing creature.", true],
].map( (v) => feat(...v) );


// #pragma mark Miscellaneous definitions

const monsterBehaviorFlagDescriptions = [		// ][32][COLS] = {
	"is invisible",								// MONST_INVISIBLE
	"is an inanimate object",					// MONST_INANIMATE
	"cannot move",								// MONST_IMMOBILE
	null,                                         // MONST_CARRY_ITEM_100
	null,                                         // MONST_CARRY_ITEM_25
	null,                                         // MONST_ALWAYS_HUNTING
	"flees at low health",						// MONST_FLEES_NEAR_DEATH
	null,											// MONST_ATTACKABLE_THRU_WALLS
	"corrodes weapons when hit",				// MONST_DEFEND_DEGRADE_WEAPON
	"is immune to weapon damage",				// MONST_IMMUNE_TO_WEAPONS
	"flies",									// MONST_FLIES
	"moves erratically",						// MONST_FLITS
	"is immune to fire",						// MONST_IMMUNE_TO_FIRE
	null,											// MONST_CAST_SPELLS_SLOWLY
	"cannot be entangled",						// MONST_IMMUNE_TO_WEBS
	"can reflect magic spells",                 // MONST_REFLECT_4
	"never sleeps",								// MONST_NEVER_SLEEPS
	"burns unceasingly",						// MONST_FIERY
	"is invulnerable",                          // MONST_INVULNERABLE
	"is at home in water",						// MONST_IMMUNE_TO_WATER
	"cannot venture onto dry land",				// MONST_RESTRICTED_TO_LIQUID
	"submerges",								// MONST_SUBMERGES
	"keeps $HISHER distance",					// MONST_MAINTAINS_DISTANCE
	null,											// MONST_WILL_NOT_USE_STAIRS
	"is animated purely by magic",				// MONST_DIES_IF_NEGATED
	null,                                         // MONST_MALE
	null,                                         // MONST_FEMALE
  null,                                         // MONST_NOT_LISTED_IN_SIDEBAR
  "moves only when activated",                // MONST_GETS_TURN_ON_ACTIVATION
];

const monsterAbilityFlagDescriptions = [		// ][32][COLS] = {
	"can induce hallucinations",				// MA_HIT_HALLUCINATE
	"can steal items",							// MA_HIT_STEAL_FLEE
	"lights enemies on fire when $HESHE hits",  // MA_HIT_BURN
	"can possess $HISHER summoned allies",		// MA_ENTER_SUMMONS
	"corrodes armor when $HESHE hits",			// MA_HIT_DEGRADE_ARMOR
	"can summon allies",						// MA_CAST_SUMMON
	"immobilizes $HISHER prey",					// MA_SEIZES
	"injects poison when $HESHE hits",			// MA_POISONS
	null,											// MA_DF_ON_DEATH
	"divides in two when struck",				// MA_CLONE_SELF_ON_DEFEND
	"dies when $HESHE attacks",					// MA_KAMIKAZE
	"recovers health when $HESHE inflicts damage",// MA_TRANSFERENCE
  "saps strength when $HESHE inflicts damage",// MA_CAUSE_WEAKNESS

  "attacks up to two opponents in a line",    // MA_ATTACKS_PENETRATE
  "attacks all adjacent opponents at once",   // MA_ATTACKS_ALL_ADJACENT
  // "attacks enemies at a distance",            // MA_ATTACKS_EXTEND
	"pushes opponents backward when $HESHE hits", // MA_ATTACKS_STAGGER
  "avoids attacking in corridors in a group", // MA_AVOID_CORRIDORS
];


const monsterBookkeepingFlagDescriptions = [		// ][32][COLS] = {
	null,											// MB_WAS_VISIBLE
	"is telepathically bonded with you",		// MB_TELEPATHICALLY_REVEALED
	null,											// MB_PREPLACED
	null,											// MB_APPROACHING_UPSTAIRS
	null,											// MB_APPROACHING_DOWNSTAIRS
	null,											// MB_APPROACHING_PIT
	null,											// MB_LEADER
	null,											// MB_FOLLOWER
	null,											// MB_CAPTIVE
	"has been immobilized",						// MB_SEIZED
	"is currently holding $HISHER prey immobile",// MB_SEIZING
	"is submerged",								// MB_SUBMERGED
	null,											// MB_JUST_SUMMONED
	null,											// MB_WILL_FLASH
	"is anchored to reality by $HISHER summoner",// MB_BOUND_TO_LEADER
	"is marked for demonic sacrifice",          // MB_MARKED_FOR_SACRIFICE
	null, // MB_ABSORBING
	null, // MB_DOES_NOT_TRACK_LEADER
	null, // MB_IS_FALLING
	null, // MB_IS_DYING
	null, // MB_GIVEN_UP_ON_SCENT
	null, // MB_IS_DORMANT
	null, // MB_HAS_SOUL
	null, // MB_ALREADY_SEEN
];
/*
 *  Dijkstra.c
 *  Brogue
 *
 *  Copyright 2012. All rights reserved.
 *
 *  This file is part of Brogue.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

// This code was created by Joshua Day, to replace my clunkier and slower Dijkstra scanning algorithm in Movement.c.
// Thanks very much, Joshua.

// #include "Rogue.h"
// #include "IncludeGlobals.h"

function pdsLink(i) {
	return {
		distance: 0,
		cost: 0,
		index: i,
		left: null, right: null
	};
}

function pdsMap() {
	return {
		eightWays: false,
		front: pdsLink(-1),
		links: ARRAY(DCOLS * DROWS, (i) => pdsLink(i) )
	};
}


function pdsUpdate(map) {
	let dir, dirs;
	let linkIndex;
	let left = NULL, right = NULL, link = NULL;

	dirs = map.eightWays ? 8 : 4;

	head = map.front.right;
	map.front.right = NULL;

	while (head != NULL) {
		for (dir = 0; dir < dirs; dir++) {
			linkIndex = head.index + (nbDirs[dir][0] + DCOLS * nbDirs[dir][1]);
			if (linkIndex < 0 || linkIndex >= DCOLS * DROWS) continue;
			link = map.links[linkIndex];

			// verify passability
			if (link.cost < 0) continue;
			if (dir >= 4) {
				let way1, way1index, way2, way2index;
				way1index = head.index + nbDirs[dir][0];
				if (way1index < 0 || way1index >= DCOLS * DROWS) continue;

				way2index = head.index + DCOLS * nbDirs[dir][1];
				if (way2index < 0 || way2index >= DCOLS * DROWS) continue;

				way1 = map.links[way1index];
				way2 = map.links[way2index];

				if (way1.cost == PDS_OBSTRUCTION || way2.cost == PDS_OBSTRUCTION) continue;
			}

			if (head.distance + link.cost < link.distance) {
				link.distance = head.distance + link.cost;

				// reinsert the touched cell; it'll be close to the beginning of the list now, so
				// this will be very fast.  start by removing it.

				if (link.right != NULL) link.right.left = link.left;
				if (link.left != NULL) link.left.right = link.right;

				left = head;
				right = head.right;
				while (right != NULL && right.distance < link.distance) {
					left = right;
					right = right.right;
				}
				if (left != NULL) left.right = link;
				link.right = right;
				link.left = left;
				if (right != NULL) right.left = link;
			}
		}

		right = head.right;

		head.left = NULL;
		head.right = NULL;

		head = right;
	}
}

function pdsClear(map, maxDistance, eightWays) {
	let i;

	map.eightWays = eightWays;

	map.front.right = NULL;

	for (i=0; i < DCOLS*DROWS; i++) {
		map.links[i].distance = maxDistance;
		map.links[i].left = map.links[i].right = NULL;
	}
}

function pdsGetDistance(map, x, y) {
	pdsUpdate(map);
	return PDS_CELL(map, x, y).distance;
}

function pdsSetDistance(map, x, y, distance) {
	let left, right, link;

	if (x > 0 && y > 0 && x < DCOLS - 1 && y < DROWS - 1) {
		link = PDS_CELL(map, x, y);
		if (link.distance > distance) {
			link.distance = distance;

			if (link.right != NULL) link.right.left = link.left;
			if (link.left != NULL) link.left.right = link.right;

			left = map.front;
			right = map.front.right;

			while (right != NULL && right.distance < link.distance) {
				left = right;
				right = right.right;
			}

			link.right = right;
			link.left = left;
			left.right = link;
			if (right != NULL) right.left = link;
		}
	}
}

function pdsSetCosts(map, costMap) {
	let i, j;

	for (i=0; i<DCOLS; i++) {
		for (j=0; j<DROWS; j++) {
			if (i != 0 && j != 0 && i < DCOLS - 1 && j < DROWS - 1) {
				PDS_CELL(map, i, j).cost = costMap[i][j];
			} else {
				PDS_CELL(map, i, j).cost = PDS_FORBIDDEN;
			}
		}
	}
}

function pdsBatchInput(map, distanceMap, costMap, maxDistance, eightWays) {
	let i, j;
	let left, right;

	map.eightWays = eightWays;

	left = NULL;
	right = NULL;

	map.front.right = NULL;
	for (i=0; i<DCOLS; i++) {
		for (j=0; j<DROWS; j++) {
			let link = PDS_CELL(map, i, j);

			if (distanceMap != NULL) {
				link.distance = distanceMap[i][j];
			} else {
				if (costMap != NULL) {
					// totally hackish; refactor
					link.distance = maxDistance;
				}
			}

			let cost;

			if (i == 0 || j == 0 || i == DCOLS - 1 || j == DROWS - 1) {
				cost = PDS_OBSTRUCTION;
			} else if (costMap === NULL) {
				if (cellHasTerrainFlag(i, j, T_OBSTRUCTS_PASSABILITY) && cellHasTerrainFlag(i, j, T_OBSTRUCTS_DIAGONAL_MOVEMENT)) {
					cost = PDS_OBSTRUCTION;
				}
				else {
					cost = PDS_FORBIDDEN;
				}
			} else {
				cost = costMap[i][j];
			}

			link.cost = cost;

			if (cost > 0) {
				if (link.distance < maxDistance) {
					if (right == NULL || right.distance > link.distance) {
						// left and right are used to traverse the list; if many cells have similar values,
						// some time can be saved by not clearing them with each insertion.  this time,
						// sadly, we have to start from the front.

						left = map.front;
						right = map.front.right;
					}

					while (right != NULL && right.distance < link.distance) {
						left = right;
						right = right.right;
					}

					link.right = right;
					link.left = left;
					left.right = link;
					if (right != NULL) right.left = link;

					left = link;
				} else {
					link.right = NULL;
					link.left = NULL;
				}
			} else {
				link.right = NULL;
				link.left = NULL;
			}
		}
	}
}

function pdsBatchOutput(map, distanceMap) {
	let i, j;

	pdsUpdate(map);
	// transfer results to the distanceMap
	for (i=0; i<DCOLS; i++) {
		for (j=0; j<DROWS; j++) {
			distanceMap[i][j] = PDS_CELL(map, i, j).distance;
		}
	}
}

function pdsInvalidate(map, maxDistance) {
	pdsBatchInput(map, NULL, NULL, maxDistance, map.eightWays);
}

const DIJKSTRA_MAP = pdsMap();

function dijkstraScan(distanceMap, costMap, useDiagonals) {
	// static pdsMap map;

	pdsBatchInput(DIJKSTRA_MAP, distanceMap, costMap, 30000, useDiagonals);
	pdsBatchOutput(DIJKSTRA_MAP, distanceMap);
}

function calculateDistances(distanceMap,
						destinationX, destinationY,
						blockingTerrainFlags,
						traveler,
						canUseSecretDoors,
						eightWays)
{
	let monst;
  // static pdsMap map;

	let i, j;

	for (i=0; i<DCOLS; i++) {
		for (j=0; j<DROWS; j++) {
			let cost;
      monst = monsterAtLoc(i, j);
      if (monst
          && (monst.info.flags & (MONST_IMMUNE_TO_WEAPONS | MONST_INVULNERABLE))
          && (monst.info.flags & (MONST_IMMOBILE | MONST_GETS_TURN_ON_ACTIVATION)))
			{
          // Always avoid damage-immune stationary monsters.
        cost = PDS_FORBIDDEN;
      } else if (canUseSecretDoors
          && cellHasTMFlag(i, j, TM_IS_SECRET)
          && cellHasTerrainFlag(i, j, T_OBSTRUCTS_PASSABILITY)
          && !(discoveredTerrainFlagsAtLoc(i, j) & T_OBSTRUCTS_PASSABILITY))
			{
				cost = 1;
			} else if (cellHasTerrainFlag(i, j, T_OBSTRUCTS_PASSABILITY)
					   || (traveler && traveler === player && !(pmap[i][j].flags & (DISCOVERED | MAGIC_MAPPED))))
			{
				cost = cellHasTerrainFlag(i, j, T_OBSTRUCTS_DIAGONAL_MOVEMENT) ? PDS_OBSTRUCTION : PDS_FORBIDDEN;
			} else if ((traveler && monsterAvoids(traveler, i, j)) || cellHasTerrainFlag(i, j, blockingTerrainFlags)) {
				cost = PDS_FORBIDDEN;
			} else {
				cost = 1;
			}

			PDS_CELL(DIJKSTRA_MAP, i, j).cost = cost;
		}
	}

	pdsClear(DIJKSTRA_MAP, 30000, eightWays);
	pdsSetDistance(DIJKSTRA_MAP, destinationX, destinationY, 0);
	pdsBatchOutput(DIJKSTRA_MAP, distanceMap);
}

function pathingDistance(x1, y1, x2, y2, blockingTerrainFlags) {
	let retval;
	const distanceMap = allocGrid();
	calculateDistances(distanceMap, x2, y2, blockingTerrainFlags, NULL, true, true);
	retval = distanceMap[x1][y1];
	freeGrid(distanceMap);
	return retval;
}
/*
 *  Architect.c
 *  Brogue
 *
 *  Created by Brian Walker on 1/10/09.
 *  Copyright 2012. All rights reserved.
 *
 *  This file is part of Brogue.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

//#include "Rogue.h"
//#include "IncludeGlobals.h"




////////////////////////////////////////////


var topBlobMinX, topBlobMinY, blobWidth, blobHeight;

//#ifdef BROGUE_ASSERTS // otherwise handled as a macro in rogue.h
function cellHasTerrainFlag(x, y, flagMask) {
	assert(coordinatesAreInMap(x, y));
	return ((flagMask) & terrainFlags((x), (y)) ? true : false);
}
//#endif

function checkLoopiness( x,  y) {
	let inString;
	let newX, newY, dir, sdir;
	let numStrings, maxStringLength, currentStringLength;

	if (!(pmap[x][y].flags & IN_LOOP)) {
		return false;
	}

	// find an unloopy neighbor to start on
	for (sdir = 0; sdir < DIRECTION_COUNT; sdir++) {
		newX = x + cDirs[sdir][0];
		newY = y + cDirs[sdir][1];
		if (!coordinatesAreInMap(newX, newY)
			|| !(pmap[newX][newY].flags & IN_LOOP)) {
			break;
		}
	}
	if (sdir == 8) { // no unloopy neighbors
		return false; // leave cell loopy
	}

	// starting on this unloopy neighbor, work clockwise and count up (a) the number of strings
	// of loopy neighbors, and (b) the length of the longest such string.
	numStrings = maxStringLength = currentStringLength = 0;
	inString = false;
	for (dir = sdir; dir < sdir + 8; dir++) {
		newX = x + cDirs[dir % 8][0];
		newY = y + cDirs[dir % 8][1];
		if (coordinatesAreInMap(newX, newY) && (pmap[newX][newY].flags & IN_LOOP)) {
			currentStringLength++;
			if (!inString) {
				if (numStrings > 0) {
					return false; // more than one string here; leave loopy
				}
				numStrings++;
				inString = true;
			}
		} else if (inString) {
			if (currentStringLength > maxStringLength) {
				maxStringLength = currentStringLength;
			}
			currentStringLength = 0;
			inString = false;
		}
	}
	if (inString && currentStringLength > maxStringLength) {
		maxStringLength = currentStringLength;
	}
	if (numStrings == 1 && maxStringLength <= 4) {
		pmap[x][y].flags &= ~IN_LOOP;

		for (dir = 0; dir < DIRECTION_COUNT; dir++) {
			newX = x + cDirs[dir][0];
			newY = y + cDirs[dir][1];
			if (coordinatesAreInMap(newX, newY)) {
				checkLoopiness(newX, newY);
			}
		}
		return true;
	} else {
		return false;
	}
}

function auditLoop(x, y, grid) {
	let dir, newX, newY;
	if (coordinatesAreInMap(x, y)
		&& !grid[x][y]
		&& !(pmap[x][y].flags & IN_LOOP)) {

		grid[x][y] = true;
		for (dir = 0; dir < DIRECTION_COUNT; dir++) {
			newX = x + nbDirs[dir][0];
			newY = y + nbDirs[dir][1];
			if (coordinatesAreInMap(newX, newY)) {
				auditLoop(newX, newY, grid);
			}
		}
	}
}

// Assumes it is called with respect to a passable (startX, startY), and that the same is not already included in results.
// Returns 10000 if the area included an area machine.
function floodFillCount(results, passMap, startX, startY) {
	let dir, newX, newY, count;

	count = (passMap[startX][startY] == 2 ? 5000 : 1);

	if (pmap[startX][startY].flags & IS_IN_AREA_MACHINE) {
		count = 10000;
	}

	results[startX][startY] = true;

	for(dir=0; dir<4; dir++) {
		newX = startX + nbDirs[dir][0];
		newY = startY + nbDirs[dir][1];
		if (coordinatesAreInMap(newX, newY)
			&& passMap[newX][newY]
			&& !results[newX][newY]) {

			count += floodFillCount(results, passMap, newX, newY);
		}
	}
	return Math.min(count, 10000);
}

// Rotates around the cell, counting up the number of distinct strings of passable neighbors in a single revolution.
//		Zero means there are no impassable tiles adjacent.
//		One means it is adjacent to a wall.
//		Two means it is in a hallway or something similar.
//		Three means it is the center of a T-intersection or something similar.
//		Four means it is in the intersection of two hallways.
//		Five or more means there is a bug.
function passableArcCount(x, y) {
	let arcCount, dir, oldX, oldY, newX, newY;

  assert(coordinatesAreInMap(x, y));

	arcCount = 0;
	for (dir = 0; dir < DIRECTION_COUNT; dir++) {
		oldX = x + cDirs[(dir + 7) % 8][0];
		oldY = y + cDirs[(dir + 7) % 8][1];
		newX = x + cDirs[dir][0];
		newY = y + cDirs[dir][1];
		// Counts every transition from passable to impassable or vice-versa on the way around the cell:
		if ((coordinatesAreInMap(newX, newY) && cellIsPassableOrDoor(newX, newY))
			!= (coordinatesAreInMap(oldX, oldY) && cellIsPassableOrDoor(oldX, oldY)))
		{
			arcCount++;
		}
	}
	return Math.floor(arcCount / 2); // Since we added one when we entered a wall and another when we left.
}




// locates all loops and chokepoints
function analyzeMap(calculateChokeMap) {
	let i, j, i2, j2, dir, newX, newY, oldX, oldY, passableArcCount, cellCount;
	let grid = allocGrid(), passMap = allocGrid();
	let designationSurvives;

	// first find all of the loops
	rogue.staleLoopMap = false;

	for(i=0; i<DCOLS; i++) {
		for(j=0; j<DROWS; j++) {
			if (cellHasTerrainFlag(i, j, T_PATHING_BLOCKER)
				&& !cellHasTMFlag(i, j, TM_IS_SECRET)) {

				pmap[i][j].flags &= ~IN_LOOP;
				passMap[i][j] = false;
			} else {
				pmap[i][j].flags |= IN_LOOP;
				passMap[i][j] = true;
			}
		}
	}

	for(i=0; i<DCOLS; i++) {
		for(j=0; j<DROWS; j++) {
			checkLoopiness(i, j);
		}
	}

	// remove extraneous loop markings
	zeroOutGrid(grid);
	auditLoop(0, 0, grid);

	for(i=0; i<DCOLS; i++) {
		for(j=0; j<DROWS; j++) {
			if (pmap[i][j].flags & IN_LOOP) {
				designationSurvives = false;
				for (dir = 0; dir < DIRECTION_COUNT; dir++) {
					newX = i + nbDirs[dir][0];
					newY = j + nbDirs[dir][1];
					if (coordinatesAreInMap(newX, newY)
						&& !grid[newX][newY]
						&& !(pmap[newX][newY].flags & IN_LOOP)) {
						designationSurvives = true;
						break;
					}
				}
				if (!designationSurvives) {
					grid[i][j] = true;
					pmap[i][j].flags &= ~IN_LOOP;
				}
			}
		}
	}

	// done finding loops; now flag chokepoints
	for(i=1; i<DCOLS-1; i++) {
		for(j=1; j<DROWS-1; j++) {
			pmap[i][j].flags &= ~IS_CHOKEPOINT;
			if (passMap[i][j] && !(pmap[i][j].flags & IN_LOOP)) {
				passableArcCount = 0;
				for (dir = 0; dir < DIRECTION_COUNT; dir++) {
					oldX = i + cDirs[(dir + 7) % 8][0];
					oldY = j + cDirs[(dir + 7) % 8][1];
					newX = i + cDirs[dir][0];
					newY = j + cDirs[dir][1];
					if ((coordinatesAreInMap(newX, newY) && passMap[newX][newY])
						!= (coordinatesAreInMap(oldX, oldY) && passMap[oldX][oldY])) {
						if (++passableArcCount > 2) {
							if (!passMap[i-1][j] && !passMap[i+1][j] || !passMap[i][j-1] && !passMap[i][j+1]) {
								pmap[i][j].flags |= IS_CHOKEPOINT;
							}
							break;
						}
					}
				}
			}
		}
	}

	if (calculateChokeMap) {

		// Done finding chokepoints; now create a chokepoint map.

		// The chokepoint map is a number for each passable tile. If the tile is a chokepoint,
		// then the number indicates the number of tiles that would be rendered unreachable if the
		// chokepoint were blocked. If the tile is not a chokepoint, then the number indicates
		// the number of tiles that would be rendered unreachable if the nearest exit chokepoint
		// were blocked.
		// The cost of all of this is one depth-first flood-fill per open point that is adjacent to a chokepoint.

		// Start by setting the chokepoint values really high, and roping off room machines.
		for(i=0; i<DCOLS; i++) {
			for(j=0; j<DROWS; j++) {
				chokeMap[i][j] = 30000;
				if (pmap[i][j].flags & IS_IN_ROOM_MACHINE) {
					passMap[i][j] = false;
				}
			}
		}

		// Scan through and find a chokepoint next to an open point.

		for(i=0; i<DCOLS; i++) {
			for(j=0; j<DROWS; j++) {
				if (passMap[i][j] && (pmap[i][j].flags & IS_CHOKEPOINT)) {
					for (dir=0; dir<4; dir++) {
						newX = i + nbDirs[dir][0];
						newY = j + nbDirs[dir][1];
						if (coordinatesAreInMap(newX, newY)
							&& passMap[newX][newY]
							&& !(pmap[newX][newY].flags & IS_CHOKEPOINT)) {
							// OK, (newX, newY) is an open point and (i, j) is a chokepoint.
							// Pretend (i, j) is blocked by changing passMap, and run a flood-fill cell count starting on (newX, newY).
							// Keep track of the flooded region in grid[][].
							zeroOutGrid(grid);
							passMap[i][j] = false;
							cellCount = floodFillCount(grid, passMap, newX, newY);
							passMap[i][j] = true;

							// CellCount is the size of the region that would be obstructed if the chokepoint were blocked.
							// CellCounts less than 4 are not useful, so we skip those cases.

							if (cellCount >= 4) {
								// Now, on the chokemap, all of those flooded cells should take the lesser of their current value or this resultant number.
								for(i2=0; i2<DCOLS; i2++) {
									for(j2=0; j2<DROWS; j2++) {
										if (grid[i2][j2] && cellCount < chokeMap[i2][j2]) {
											chokeMap[i2][j2] = cellCount;
											pmap[i2][j2].flags &= ~IS_GATE_SITE;
										}
									}
								}

								// The chokepoint itself should also take the lesser of its current value or the flood count.
								if (cellCount < chokeMap[i][j]) {
									chokeMap[i][j] = cellCount;
									pmap[i][j].flags |= IS_GATE_SITE;
								}
							}
						}
					}
				}
			}
		}
	}
}

// Add some loops to the otherwise simply connected network of rooms.
async function addLoops(grid, minimumPathingDistance) {
    let newX, newY, oppX, oppY;
    let pathMap, costMap;
    let i, d, x, y;
		let sCoord = [];
    const dirCoords = [[1, 0], [0, 1]];

    fillSequentialList(sCoord, DCOLS*DROWS);
    shuffleList(sCoord, DCOLS*DROWS);

    if (D_INSPECT_LEVELGEN) {
        colorOverDungeon(/* Color. */darkGray);
        hiliteGrid(grid, /* Color. */white, 100);
    }

    pathMap = allocGrid();
    costMap = allocGrid();
    copyGrid(costMap, grid);
    findReplaceGrid(costMap, 0, 0, PDS_OBSTRUCTION);
    findReplaceGrid(costMap, 1, 30000, 1);

    for (i = 0; i < DCOLS*DROWS; i++) {
        x = Math.floor(sCoord[i]/DROWS);
        y = sCoord[i] % DROWS;
        if (!grid[x][y]) {
            for (d=0; d <= 1; d++) { // Try a horizontal door, and then a vertical door.
                newX = x + dirCoords[d][0];
                oppX = x - dirCoords[d][0];
                newY = y + dirCoords[d][1];
                oppY = y - dirCoords[d][1];
                if (coordinatesAreInMap(newX, newY)
                    && coordinatesAreInMap(oppX, oppY)
                    && grid[newX][newY] > 0
                    && grid[oppX][oppY] > 0) { // If the tile being inspected has floor on both sides,

                    fillGrid(pathMap, 30000);
                    pathMap[newX][newY] = 0;
                    dijkstraScan(pathMap, costMap, false);
                    if (pathMap[oppX][oppY] > minimumPathingDistance) { // and if the pathing distance between the two flanking floor tiles exceeds minimumPathingDistance,
                        grid[x][y] = 2;             // then turn the tile into a doorway.
                        costMap[x][y] = 1;          // (Cost map also needs updating.)
                        if (D_INSPECT_LEVELGEN) {
                            plotCharWithColor(DOOR_CHAR, mapToWindowX(x), mapToWindowY(y), /* Color. */black, /* Color. */green);
                        }
                        break;
                    }
                }
            }
        }
    }
    if (D_INSPECT_LEVELGEN) {
        await temporaryMessage("Added secondary connections:", true);
    }
    freeGrid(pathMap);
    freeGrid(costMap);
}

// Assumes (startX, startY) is in the machine.
// Returns true if everything went well, and false if we ran into a machine component
// that was already there, as we don't want to build a machine around it.
function addTileToMachineInteriorAndIterate(interior, startX, startY) {
	let dir, newX, newY;
	let goodSoFar = true;

	interior[startX][startY] = true;

	for (dir = 0; dir < 4 && goodSoFar; dir++) {
		newX = startX + nbDirs[dir][0];
		newY = startY + nbDirs[dir][1];
        if (coordinatesAreInMap(newX, newY)) {
            if ((pmap[newX][newY].flags & HAS_ITEM)
                || ((pmap[newX][newY].flags & IS_IN_MACHINE) && !(pmap[newX][newY].flags & IS_GATE_SITE))) {
                // Abort if there's an item in the room.
                // Items haven't been populated yet, so the only way this could happen is if another machine
                // previously placed an item here.
                // Also abort if we're touching another machine at any point other than a gate tile.
                return false;
            }
            if (!interior[newX][newY]
                && chokeMap[newX][newY] <= chokeMap[startX][startY] // don't have to worry about walls since they're all 30000
                && !(pmap[newX][newY].flags & IS_IN_MACHINE)) {
                //goodSoFar = goodSoFar && addTileToMachineInteriorAndIterate(interior, newX, newY);
                if (goodSoFar) {
                    goodSoFar = addTileToMachineInteriorAndIterate(interior, newX, newY);
                }
            }
        }
	}
	return goodSoFar;
}

function copyMap(from, to) {
	let i, j;

	for(i=0; i<DCOLS; i++) {
		for(j=0; j<DROWS; j++) {
			to[i][j].copy(from[i][j]);
		}
	}
}

function itemIsADuplicate(theItem, spawnedItems, itemCount) {
    let i;
    if (theItem.category & (STAFF | WAND | POTION | SCROLL | RING | WEAPON | ARMOR | CHARM)) {
        for (i = 0; i < itemCount; i++) {
            if (spawnedItems[i].category == theItem.category
                && spawnedItems[i].kind == theItem.kind)
						{
                return true;
            }
        }
    }
    return false;
}

function blueprintQualifies(i, requiredMachineFlags) {
	if (blueprintCatalog[i].depthRange[0] > rogue.depthLevel
		|| blueprintCatalog[i].depthRange[1] < rogue.depthLevel
				// Must have the required flags:
		|| (~(blueprintCatalog[i].flags) & requiredMachineFlags)
				// May NOT have BP_ADOPT_ITEM unless that flag is required:
		|| (blueprintCatalog[i].flags & BP_ADOPT_ITEM & ~requiredMachineFlags)
                // May NOT have BP_VESTIBULE unless that flag is required:
		|| (blueprintCatalog[i].flags & BP_VESTIBULE & ~requiredMachineFlags)) {

		return false;
	}
	return true;
}

function abortItemsAndMonsters(spawnedItems, spawnedMonsters) {
	let i, j;

	for (i=0; i<MACHINES_BUFFER_LENGTH && spawnedItems[i]; i++) {
		removeItemFromChain(spawnedItems[i], floorItems);
		removeItemFromChain(spawnedItems[i], packItems); // just in case; can't imagine why this would arise.
		for (j=0; j<MACHINES_BUFFER_LENGTH && spawnedMonsters[j]; j++) {
			// Remove the item from spawned monsters, so it doesn't get double-freed when the creature is killed below.
			if (spawnedMonsters[j].carriedItem == spawnedItems[i]) {
				spawnedMonsters[j].carriedItem = NULL;
				break;
			}
		}
		deleteItem(spawnedItems[i]);
        spawnedItems[i] = NULL;
	}
	for (i=0; i<MACHINES_BUFFER_LENGTH && spawnedMonsters[i]; i++) {
		killCreature(spawnedMonsters[i], true);
        spawnedMonsters[i] = NULL;
	}
}

function cellIsFeatureCandidate(x, y,
							   originX, originY,
							   distanceBound,
							   interior,
							   occupied,
							   viewMap,
							   distanceMap,
                 machineNumber,
							   featureFlags,
							   bpFlags) {
	let newX, newY, dir, distance;

	// No building in the hallway if it's prohibited.
	// This check comes before the origin check, so an area machine will fail altogether
	// if its origin is in a hallway and the feature that must be built there does not permit as much.
	if ((featureFlags & MF_NOT_IN_HALLWAY)
		&& passableArcCount(x, y) > 1) {
		return false;
	}

	// No building along the perimeter of the level if it's prohibited.
	if ((featureFlags & MF_NOT_ON_LEVEL_PERIMETER)
		&& (x == 0 || x == DCOLS - 1 || y == 0 || y == DROWS - 1)) {
		return false;
	}

	// The origin is a candidate if the feature is flagged to be built at the origin.
	// If it's a room, the origin (i.e. doorway) is otherwise NOT a candidate.
	if (featureFlags & MF_BUILD_AT_ORIGIN) {
		return ((x == originX && y == originY) ? true : false);
	} else if ((bpFlags & BP_ROOM) && x == originX && y == originY) {
		return false;
	}

	// No building in another feature's personal space!
	if (occupied[x][y]) {
		return false;
	}

	// Must be in the viewmap if the appropriate flag is set.
	if ((featureFlags & (MF_IN_VIEW_OF_ORIGIN | MF_IN_PASSABLE_VIEW_OF_ORIGIN))
		&& !viewMap[x][y]) {
		return false;
	}

	// Do a distance check if the feature requests it.
	if (cellHasTerrainFlag(x, y, T_OBSTRUCTS_PASSABILITY)) { // Distance is calculated for walls too.
		distance = 10000;
		for (dir = 0; dir < 4; dir++) {
			newX = x + nbDirs[dir][0];
			newY = y + nbDirs[dir][1];
			if (coordinatesAreInMap(newX, newY)
				&& !cellHasTerrainFlag(newX, newY, T_OBSTRUCTS_PASSABILITY)
				&& distance > distanceMap[newX][newY] + 1) {

				distance = distanceMap[newX][newY] + 1;
			}
		}
	} else {
		distance = distanceMap[x][y];
	}

	if (distance > distanceBound[1]		// distance exceeds max
		|| distance < distanceBound[0]) {	// distance falls short of min
		return false;
	}
	if (featureFlags & MF_BUILD_IN_WALLS) {				// If we're supposed to build in a wall...
		if (!interior[x][y]
            && (pmap[x][y].machineNumber == 0 || pmap[x][y].machineNumber == machineNumber)
			&& cellHasTerrainFlag(x, y, T_OBSTRUCTS_PASSABILITY)) { // ...and this location is a wall that's not already machined...
			for (dir=0; dir<4; dir++) {
				newX = x + nbDirs[dir][0];
				newY = y + nbDirs[dir][1];
				if (coordinatesAreInMap(newX, newY)		// ...and it's next to an interior spot or permitted elsewhere and next to passable spot...
					&& ((interior[newX][newY] && !(newX==originX && newY==originY))
						|| ((featureFlags & MF_BUILD_ANYWHERE_ON_LEVEL)
							&& !cellHasTerrainFlag(newX, newY, T_PATHING_BLOCKER)
                            && pmap[newX][newY].machineNumber == 0))) {
					return true;						// ...then we're golden!
				}
			}
		}
		return false;									// Otherwise, no can do.
    } else if (cellHasTerrainFlag(x, y, T_OBSTRUCTS_PASSABILITY)) { // Can't build in a wall unless instructed to do so.
        return false;
	} else if (featureFlags & MF_BUILD_ANYWHERE_ON_LEVEL) {
		if ((featureFlags & MF_GENERATE_ITEM)
			&& (cellHasTerrainFlag(x, y, T_OBSTRUCTS_ITEMS | T_PATHING_BLOCKER) || (pmap[x][y].flags & (IS_CHOKEPOINT | IN_LOOP | IS_IN_MACHINE)))) {
			return false;
		} else {
			return !(pmap[x][y].flags & IS_IN_MACHINE);
		}
	} else if (interior[x][y]) {
		return true;
	}
	return false;
}


function addLocationToKey(theItem, x, y, disposableHere) {
	let i;

	for (i=0; i < KEY_ID_MAXIMUM && (theItem.keyLoc[i].x || theItem.keyLoc[i].machine); i++);
	theItem.keyLoc[i].x = x;
	theItem.keyLoc[i].y = y;
	theItem.keyLoc[i].disposableHere = disposableHere;
}

function addMachineNumberToKey(theItem, machineNumber, disposableHere) {
	let i;

	for (i=0; i < KEY_ID_MAXIMUM && (theItem.keyLoc[i].x || theItem.keyLoc[i].machine); i++);
	theItem.keyLoc[i].machine = machineNumber;
	theItem.keyLoc[i].disposableHere = disposableHere;
}

function expandMachineInterior(interior, minimumInteriorNeighbors) {
    let madeChange;
    let nbcount, newX, newY, i, j, layer;
    let dir;

    do {
        madeChange = false;
        for(i=1; i<DCOLS-1; i++) {
            for(j=1; j < DROWS-1; j++) {
                if (cellHasTerrainFlag(i, j, T_PATHING_BLOCKER)
                    && pmap[i][j].machineNumber == 0) {

                    // Count up the number of interior open neighbors out of eight:
                    for (nbcount = dir = 0; dir < DIRECTION_COUNT; dir++) {
                        newX = i + nbDirs[dir][0];
                        newY = j + nbDirs[dir][1];
                        if (interior[newX][newY]
                            && !cellHasTerrainFlag(newX, newY, T_PATHING_BLOCKER)) {
                            nbcount++;
                        }
                    }
                    if (nbcount >= minimumInteriorNeighbors) {
                        // Make sure zero exterior open/machine neighbors out of eight:
                        for (nbcount = dir = 0; dir < DIRECTION_COUNT; dir++) {
                            newX = i + nbDirs[dir][0];
                            newY = j + nbDirs[dir][1];
                            if (!interior[newX][newY]
                                && (!cellHasTerrainFlag(newX, newY, T_OBSTRUCTS_PASSABILITY) || pmap[newX][newY].machineNumber != 0)) {
                                nbcount++;
                                break;
                            }
                        }
                        if (!nbcount) {
                            // Eliminate this obstruction; welcome its location into the machine.
                            madeChange = true;
                            interior[i][j] = true;
                            for (layer = 0; layer < NUMBER_TERRAIN_LAYERS; layer++) {
                                if (tileCatalog[pmap[i][j].layers[layer]].flags & T_PATHING_BLOCKER) {
                                    pmap[i][j].layers[layer] = (layer == DUNGEON ? FLOOR : NOTHING);
                                }
                            }
                            for (dir = 0; dir < DIRECTION_COUNT; dir++) {
                                newX = i + nbDirs[dir][0];
                                newY = j + nbDirs[dir][1];
                                if (pmap[newX][newY].layers[DUNGEON] == GRANITE) {
                                    pmap[newX][newY].layers[DUNGEON] = WALL;
                                }
                            }
                        }
                    }
                } else if (pmap[i][j].layers[DUNGEON] == DOOR
                           || pmap[i][j].layers[DUNGEON] == SECRET_DOOR) {
                    pmap[i][j].layers[DUNGEON] = FLOOR;
                }
            }
        }
    } while (madeChange);
}

function fillInteriorForVestibuleMachine(interior, bp, originX, originY) {
    let distanceMap, costMap, qualifyingTileCount, totalFreq;
		let sRows = [];
		let sCols = [];
		let i, j, k;
    let success = true;

    zeroOutGrid(interior);

    distanceMap = allocGrid();
    fillGrid(distanceMap, 30000);
    distanceMap[originX][originY] = 0;

    costMap = allocGrid();
    populateGenericCostMap(costMap);
    for(i=0; i<DCOLS; i++) {
        for(j=0; j<DROWS; j++) {
            if (costMap[i][j] == 1 && (pmap[i][j].flags & IS_IN_MACHINE)) { //pmap[i][j].machineNumber) {
                costMap[i][j] = PDS_FORBIDDEN;
            }
        }
    }
    costMap[originX][originY] = 1;
    dijkstraScan(distanceMap, costMap, false);
    freeGrid(costMap);

    qualifyingTileCount = 0; // Keeps track of how many interior cells we've added.
    totalFreq = rand_range(blueprintCatalog[bp].roomSize[0], blueprintCatalog[bp].roomSize[1]); // Keeps track of the goal size.

    fillSequentialList(sCols, DCOLS);
    shuffleList(sCols, DCOLS);
    fillSequentialList(sRows, DROWS);
    shuffleList(sRows, DROWS);

    for (k=0; k<1000 && qualifyingTileCount < totalFreq; k++) {
        for(i=0; i<DCOLS && qualifyingTileCount < totalFreq; i++) {
            for(j=0; j<DROWS && qualifyingTileCount < totalFreq; j++) {
                if (distanceMap[sCols[i]][sRows[j]] == k) {
                    interior[sCols[i]][sRows[j]] = true;
                    qualifyingTileCount++;

                    if (pmap[sCols[i]][sRows[j]].flags & HAS_ITEM) {
                        // Abort if we've engulfed another machine's item.
                        success = false;
                        qualifyingTileCount = totalFreq; // This is a hack to drop out of these three for-loops.
                    }
                }
            }
        }
    }

    // Now make sure the interior map satisfies the machine's qualifications.
    if ((blueprintCatalog[bp].flags & BP_TREAT_AS_BLOCKING)
        && levelIsDisconnectedWithBlockingMap(interior, false)) {
        success = false;
    } else if ((blueprintCatalog[bp].flags & BP_REQUIRE_BLOCKING)
               && levelIsDisconnectedWithBlockingMap(interior, true) < 100) {
        success = false;
    }
    freeGrid(distanceMap);
    return success;
}

async function redesignInterior( interior, originX, originY, theDungeonProfileIndex) {
    let i, j, n, newX, newY;
    let dir;
    let orphanList = [];
    let orphanCount = 0;

    let grid, pathingGrid, costGrid;
    grid = allocGrid();

    for (i=0; i<DCOLS; i++) {
        for (j=0; j<DROWS; j++) {
            if (interior[i][j]) {
                if (i == originX && j == originY) {
                    grid[i][j] = 1; // All rooms must grow from this space.
                } else {
                    grid[i][j] = 0; // Other interior squares are fair game for placing rooms.
                }
            } else if (cellIsPassableOrDoor(i, j)) {
                grid[i][j] = 1; // Treat existing level as already built (though shielded by a film of -1s).
                for (dir = 0; dir < 4; dir++) {
                    newX = i + nbDirs[dir][0];
                    newY = j + nbDirs[dir][1];
                    if (coordinatesAreInMap(newX, newY)
                        && interior[newX][newY]
                        && (newX != originX || newY != originY)) {


                        orphanList[orphanCount] = [newX, newY];
                        orphanCount++;
                        grid[i][j] = -1; // Treat the orphaned door as off limits.

                        break;
                    }
                }
            } else {
                grid[i][j] = -1; // Exterior spaces are off limits.
            }
        }
    }
    await attachRooms(grid, dungeonProfileCatalog[theDungeonProfileIndex], 40, 40);

    // Connect to preexisting rooms that were orphaned (mostly preexisting machine rooms).
    if (orphanCount > 0) {
        pathingGrid = allocGrid();
        costGrid = allocGrid();
        for (n = 0; n < orphanCount; n++) {

            if (D_INSPECT_MACHINES) {
                dumpLevelToScreen();
                copyGrid(pathingGrid, grid);
                findReplaceGrid(pathingGrid, -1, -1, 0);
                hiliteGrid(pathingGrid, /* Color. */green, 50);
                plotCharWithColor('X', mapToWindowX(orphanList[n][0]), mapToWindowY(orphanList[n][1]), /* Color. */black, /* Color. */orange);
                await temporaryMessage("Orphan detected:", true);
            }

            for (i=0; i<DCOLS; i++) {
                for (j=0; j<DROWS; j++) {
                    if (interior[i][j]) {
                        if (grid[i][j] > 0) {
                            pathingGrid[i][j] = 0;
                            costGrid[i][j] = 1;
                        } else {
                            pathingGrid[i][j] = 30000;
                            costGrid[i][j] = 1;
                        }
                    } else {
                        pathingGrid[i][j] = 30000;
                        costGrid[i][j] = PDS_OBSTRUCTION;
                    }
                }
            }
            dijkstraScan(pathingGrid, costGrid, false);

            i = orphanList[n][0];
            j = orphanList[n][1];
            while (pathingGrid[i][j] > 0) {
                for (dir = 0; dir < 4; dir++) {
                    newX = i + nbDirs[dir][0];
                    newY = j + nbDirs[dir][1];

                    if (coordinatesAreInMap(newX, newY)
                        && pathingGrid[newX][newY] < pathingGrid[i][j]) {

                        grid[i][j] = 1;
                        i = newX;
                        j = newY;
                        break;
                    }
                }
                brogueAssert(dir < 4);
                if (D_INSPECT_MACHINES) {
                    dumpLevelToScreen();
                    displayGrid(pathingGrid);
                    plotCharWithColor('X', mapToWindowX(i), mapToWindowY(j), /* Color. */black, /* Color. */orange);
                    await temporaryMessage("Orphan connecting:", true);
                }
            }
        }
        freeGrid(pathingGrid);
        freeGrid(costGrid);
    }

    await addLoops(grid, 10);
    for(i=0; i<DCOLS; i++) {
        for(j=0; j<DROWS; j++) {
            if (interior[i][j]) {
                if (grid[i][j] >= 0) {
                    pmap[i][j].layers[SURFACE] = pmap[i][j].layers[GAS] = NOTHING;
                }
                if (grid[i][j] == 0) {
                    pmap[i][j].layers[DUNGEON] = GRANITE;
                    interior[i][j] = false;
                }
                if (grid[i][j] >= 1) {
                    pmap[i][j].layers[DUNGEON] = FLOOR;
                }
            }
        }
    }
    freeGrid(grid);
}

async function prepareInteriorWithMachineFlags(interior, originX, originY, flags, dungeonProfileIndex) {
    let i, j, newX, newY;
    let layer;
    let dir;

    // If requested, clear and expand the room as far as possible until either it's convex or it bumps into surrounding rooms
	if (flags & BP_MAXIMIZE_INTERIOR) {
		expandMachineInterior(interior, 1);
	} else if (flags & BP_OPEN_INTERIOR) {
		expandMachineInterior(interior, 4);
	}

	// If requested, cleanse the interior -- no interesting terrain allowed.
	if (flags & BP_PURGE_INTERIOR) {
		for(i=0; i<DCOLS; i++) {
			for(j=0; j<DROWS; j++) {
				if (interior[i][j]) {
					for (layer=0; layer<NUMBER_TERRAIN_LAYERS; layer++) {
						pmap[i][j].layers[layer] = (layer == DUNGEON ? FLOOR : NOTHING);
					}
				}
			}
		}
	}

	// If requested, purge pathing blockers -- no traps allowed.
	if (flags & BP_PURGE_PATHING_BLOCKERS) {
		for(i=0; i<DCOLS; i++) {
			for(j=0; j<DROWS; j++) {
				if (interior[i][j]) {
					for (layer=0; layer<NUMBER_TERRAIN_LAYERS; layer++) {
						if (tileCatalog[pmap[i][j].layers[layer]].flags & T_PATHING_BLOCKER) {
							pmap[i][j].layers[layer] = (layer == DUNGEON ? FLOOR : NOTHING);
						}
					}
				}
			}
		}
	}

	// If requested, purge the liquid layer in the interior -- no liquids allowed.
	if (flags & BP_PURGE_LIQUIDS) {
		for(i=0; i<DCOLS; i++) {
			for(j=0; j<DROWS; j++) {
				if (interior[i][j]) {
					pmap[i][j].layers[LIQUID] = NOTHING;
				}
			}
		}
	}

	// Surround with walls if requested.
	if (flags & BP_SURROUND_WITH_WALLS) {
		for(i=0; i<DCOLS; i++) {
			for(j=0; j<DROWS; j++) {
				if (interior[i][j] && !(pmap[i][j].flags & IS_GATE_SITE)) {
					for (dir=0; dir< DIRECTION_COUNT; dir++) {
						newX = i + nbDirs[dir][0];
						newY = j + nbDirs[dir][1];
						if (coordinatesAreInMap(newX, newY)
							&& !interior[newX][newY]
							&& !cellHasTerrainFlag(newX, newY, T_OBSTRUCTS_PASSABILITY)
							&& !(pmap[newX][newY].flags & IS_GATE_SITE)
							&& !pmap[newX][newY].machineNumber
                            && cellHasTerrainFlag(newX, newY, T_PATHING_BLOCKER)) {
							for (layer=0; layer<NUMBER_TERRAIN_LAYERS; layer++) {
								pmap[newX][newY].layers[layer] = (layer == DUNGEON ? WALL : 0);
							}
						}
					}
				}
			}
		}
	}

    // Completely clear the interior, fill with granite, and cut entirely new rooms into it from the gate site.
    // Then zero out any portion of the interior that is still wall.
    if (flags & BP_REDESIGN_INTERIOR) {
        await redesignInterior(interior, originX, originY, dungeonProfileIndex);
    }

	// Reinforce surrounding tiles and interior tiles if requested to prevent tunneling in or through.
	if (flags & BP_IMPREGNABLE) {
		for(i=0; i<DCOLS; i++) {
			for(j=0; j<DROWS; j++) {
				if (interior[i][j]
                    && !(pmap[i][j].flags & IS_GATE_SITE)) {

                    pmap[i][j].flags |= IMPREGNABLE;
                    for (dir=0; dir< DIRECTION_COUNT; dir++) {
                        newX = i + nbDirs[dir][0];
                        newY = j + nbDirs[dir][1];
                        if (coordinatesAreInMap(newX, newY)
                            && !interior[newX][newY]
                            && !(pmap[newX][newY].flags & IS_GATE_SITE)) {

                            pmap[newX][newY].flags |= IMPREGNABLE;
                        }
					}
				}
			}
		}
	}
}

// Returns true if the machine got built; false if it was aborted.
// If empty array parentSpawnedItems or parentSpawnedMonsters is given, will pass those back for deletion if necessary.
async function buildAMachine(bp,	/* enum machines */
					  originX, originY,
					  requiredMachineFlags,
					  adoptiveItem,
					  parentSpawnedItems,
					  parentSpawnedMonsters) {

	let i, j, k, feat, randIndex, totalFreq;
	let gateCandidates = ARRAY(50, () => [0, 0]); // [50][2]
	let instance, instanceCount, qualifyingTileCount;
	let featX, featY, itemCount, monsterCount;
	let sRows = []; // [DROWS]
	let sCols = []; // [DCOLS],
	let distanceMap, distance25, distance75;
	let distances = []; // [100],
	let distanceBound = []; // [2],
	let personalSpace, failsafe, locationFailsafe;
	let machineNumber;

	const alternativeFlags = [MF_ALTERNATIVE, MF_ALTERNATIVE_2];
  let success;

	// Our boolean grids:
	//	Interior:		This is the master grid for the machine. All area inside the machine are set to true.
	//	Occupied:		This keeps track of what is within the personal space of a previously built feature in the same machine.
	//	Candidates:		This is calculated at the start of each feature, and is true where that feature is eligible for building.
	//	BlockingMap:	Used during terrain/DF placement in features that are flagged not to tolerate blocking, to see if they block.
	//	ViewMap:		Used for features with MF_IN_VIEW_OF_ORIGIN, to calculate which cells are in view of the origin.
	let interior = allocGrid();
	let occupied = allocGrid();
	let candidates = allocGrid();
	let blockingMap = allocGrid();
	let viewMap = allocGrid();

	let DFSucceeded, terrainSucceeded, generateEverywhere;
	let skipFeature = []; // [20],
	let chooseBP, chooseLocation, tryAgain;

	let levelBackup = GRID(DCOLS, DROWS, pcell); // pcell levelBackup[DCOLS][DROWS];

	let monst, nextMonst, torchBearer = NULL, leader = NULL;

	let theItem = NULL, torch = NULL;
	let spawnedItems = []; // [MACHINES_BUFFER_LENGTH] = {0},
	let spawnedItemsSub = []; // [MACHINES_BUFFER_LENGTH] = {0};
	let spawnedMonsters = []; // [MACHINES_BUFFER_LENGTH] = {0},
	let spawnedMonstersSub = []; // [MACHINES_BUFFER_LENGTH] = {0};

	let feature;

	distanceMap = NULL;

	chooseBP = (bp <= 0 ? true : false);

	chooseLocation = (originX <= 0 || originY <= 0 ? true : false);

	failsafe = 10;
	do {
    tryAgain = false;
		if (--failsafe <= 0) {
			if (distanceMap) {
				freeGrid(distanceMap);
			}
			if (D_MESSAGE_MACHINE_GENERATION) {
				if (chooseBP || chooseLocation) {
					printf("Depth %i: Failed to build a machine; gave up after 10 unsuccessful attempts to find a suitable blueprint and/or location.",
						   rogue.depthLevel);
				} else {
					printf("Depth %i: Failed to build a machine; requested blueprint and location did not work.",
						   rogue.depthLevel);
				}
			}
			return false;
		}

		if (chooseBP) { // If no blueprint is given, then pick one:

			// First, choose the blueprint. We choose from among blueprints
			// that have the required blueprint flags and that satisfy the depth requirements.
			totalFreq = 0;
			for (i=1; i<NUMBER_BLUEPRINTS; i++) {
				if (blueprintQualifies(i, requiredMachineFlags)) {
					totalFreq += blueprintCatalog[i].frequency;
				}
			}

			if (!totalFreq) { // If no suitable blueprints are in the library, fail.
				if (distanceMap) {
					freeGrid(distanceMap);
				}
				if (D_MESSAGE_MACHINE_GENERATION) printf("Depth %i: Failed to build a machine because no suitable blueprints were available.",
							 rogue.depthLevel);
				return false;
			}

			// Pick from among the suitable blueprints.
			randIndex = rand_range(1, totalFreq);
			for (i=1; i<NUMBER_BLUEPRINTS; i++) {
				if (blueprintQualifies(i, requiredMachineFlags)) {
					if (randIndex <= blueprintCatalog[i].frequency) {
						bp = i;
						break;
					} else {
						randIndex -= blueprintCatalog[i].frequency;
					}
				}
			}

			// If we don't have a blueprint yet, something went wrong.
      brogueAssert(bp>0);
		}

		// Find a location and map out the machine interior.
		if (blueprintCatalog[bp].flags & BP_ROOM) {
			// If it's a room machine, count up the gates of appropriate
			// choke size and remember where they are. The origin of the room will be the gate location.
			zeroOutGrid(interior);

			if (chooseLocation) {
        analyzeMap(true); // Make sure the chokeMap is up to date.
				totalFreq = 0;
				for(i=0; i<DCOLS; i++) {
					for(j=0; j<DROWS && totalFreq < 50; j++) {
						if ((pmap[i][j].flags & IS_GATE_SITE)
							&& !(pmap[i][j].flags & IS_IN_MACHINE)
							&& chokeMap[i][j] >= blueprintCatalog[bp].roomSize[0]
							&& chokeMap[i][j] <= blueprintCatalog[bp].roomSize[1])
						{
              //DEBUG printf("\nDepth %i: Gate site qualified with interior size of %i.", rogue.depthLevel, chokeMap[i][j]);
							gateCandidates[totalFreq][0] = i;
							gateCandidates[totalFreq][1] = j;
							totalFreq++;
						}
					}
				}

				if (totalFreq) {
					// Choose the gate.
					randIndex = rand_range(0, totalFreq - 1);
					originX = gateCandidates[randIndex][0];
					originY = gateCandidates[randIndex][1];
				} else {
					// If no suitable sites, abort.
					if (distanceMap) {
						freeGrid(distanceMap);
					}
					if (D_MESSAGE_MACHINE_GENERATION) printf("Depth %i: Failed to build a machine; there was no eligible door candidate for the chosen room machine from blueprint %i.",
								 rogue.depthLevel,
								 bp);
					return false;
				}
			}

			// Now map out the interior into interior[][].
			// Start at the gate location and do a depth-first floodfill to grab all adjoining tiles with the
			// same or lower choke value, ignoring any tiles that are already part of a machine.
			// If we get false from this, try again. If we've tried too many times already, abort.
			tryAgain = !addTileToMachineInteriorAndIterate(interior, originX, originY);
		}
		else if (blueprintCatalog[bp].flags & BP_VESTIBULE)
		{
        if (chooseLocation) {
            // Door machines must have locations passed in. We can't pick one ourselves.
            if (distanceMap) {
                freeGrid(distanceMap);
            }
            if (D_MESSAGE_MACHINE_GENERATION) printf("Depth %i: ERROR: Attempted to build a door machine from blueprint %i without a location being provided.",
                         rogue.depthLevel,
                         bp);
            return false;
        }
        if (!fillInteriorForVestibuleMachine(interior, bp, originX, originY)) {
            if (distanceMap) {
                freeGrid(distanceMap);
            }
            if (D_MESSAGE_MACHINE_GENERATION) printf("Depth %i: Failed to build a door machine from blueprint %i; not enough room.",
                         rogue.depthLevel,
                         bp);
            return false;
        }
    } else {
			// Find a location and map out the interior for a non-room machine.
			// The strategy here is simply to pick a random location on the map,
			// expand it along a pathing map by one space in all directions until the size reaches
			// the chosen size, and then make sure the resulting space qualifies.
			// If not, try again. If we've tried too many times already, abort.

			locationFailsafe = 10;
			do {
				zeroOutGrid(interior);
				tryAgain = false;

				if (chooseLocation) {
					// Pick a random origin location.
					const loc = randomMatchingLocation(FLOOR, NOTHING, -1);
					originX = loc[0];
					originY = loc[1];
				}

				if (!distanceMap) {
					distanceMap = allocGrid();
				}
				fillGrid(distanceMap, 0);
				calculateDistances(distanceMap, originX, originY, T_PATHING_BLOCKER, NULL, true, false);
				qualifyingTileCount = 0; // Keeps track of how many interior cells we've added.
				totalFreq = rand_range(blueprintCatalog[bp].roomSize[0], blueprintCatalog[bp].roomSize[1]); // Keeps track of the goal size.

        fillSequentialList(sCols, DCOLS);
				shuffleList(sCols, DCOLS);
        fillSequentialList(sRows, DROWS);
				shuffleList(sRows, DROWS);

				for (k=0; k<1000 && qualifyingTileCount < totalFreq; k++) {
					for(i=0; i<DCOLS && qualifyingTileCount < totalFreq; i++) {
						for(j=0; j<DROWS && qualifyingTileCount < totalFreq; j++) {
							if (distanceMap[sCols[i]][sRows[j]] == k) {
								interior[sCols[i]][sRows[j]] = true;
								qualifyingTileCount++;

								if (pmap[sCols[i]][sRows[j]].flags & (HAS_ITEM | HAS_MONSTER | IS_IN_MACHINE)) {
									// Abort if we've entered another machine or engulfed another machine's item or monster.
									tryAgain = true;
									qualifyingTileCount = totalFreq; // This is a hack to drop out of these three for-loops.
								}
							}
						}
					}
				}

				// Now make sure the interior map satisfies the machine's qualifications.
				if ((blueprintCatalog[bp].flags & BP_TREAT_AS_BLOCKING)
					&& levelIsDisconnectedWithBlockingMap(interior, false))
				{
					tryAgain = true;
				} else if ((blueprintCatalog[bp].flags & BP_REQUIRE_BLOCKING)
						   && levelIsDisconnectedWithBlockingMap(interior, true) < 100)
			  {
					tryAgain = true; // BP_REQUIRE_BLOCKING needs some work to make sure the disconnect is interesting.
				}
				// If locationFailsafe runs out, tryAgain will still be true, and we'll try a different machine.
				// If we're not choosing the blueprint, then don't bother with the locationFailsafe; just use the higher-level failsafe.
			} while (chooseBP && tryAgain && --locationFailsafe);
		}

		// If something went wrong, but we haven't been charged with choosing blueprint OR location,
		// then there is nothing to try again, so just fail.
		if (tryAgain && !chooseBP && !chooseLocation) {
			if (distanceMap) {
				freeGrid(distanceMap);
			}
			return false;
		}

		// Now loop if necessary.
	} while (tryAgain);

	// This is the point of no return. Back up the level so it can be restored if we have to abort this machine after this point.
	copyMap(pmap, levelBackup);

  // Perform any transformations to the interior indicated by the blueprint flags, including expanding the interior if requested.
  await prepareInteriorWithMachineFlags(interior, originX, originY, blueprintCatalog[bp].flags, blueprintCatalog[bp].dungeonProfileType);

	// If necessary, label the interior as IS_IN_AREA_MACHINE or IS_IN_ROOM_MACHINE and mark down the number.
	machineNumber = ++rogue.machineNumber; // Reserve this machine number, starting with 1.
    for(i=0; i<DCOLS; i++) {
        for(j=0; j<DROWS; j++) {
            if (interior[i][j]) {
                pmap[i][j].flags |= ((blueprintCatalog[bp].flags & BP_ROOM) ? IS_IN_ROOM_MACHINE : IS_IN_AREA_MACHINE);
                pmap[i][j].machineNumber = machineNumber;
                // also clear any secret doors, since they screw up distance mapping and aren't fun inside machines
                if (pmap[i][j].layers[DUNGEON] == SECRET_DOOR) {
                    pmap[i][j].layers[DUNGEON] = DOOR;
                }
            }
        }
    }

//	DEBUG printf("\n\nWorking on blueprint %i, with origin at (%i, %i). Here's the initial interior map:", bp, originX, originY);
//	DEBUG logBuffer(interior);

	// Calculate the distance map (so that features that want to be close to or far from the origin can be placed accordingly)
	// and figure out the 33rd and 67th percentiles for features that want to be near or far from the origin.
	if (!distanceMap) {
		distanceMap = allocGrid();
	}
	fillGrid(distanceMap, 0);
	calculateDistances(distanceMap, originX, originY, T_PATHING_BLOCKER, NULL, true, true);
	qualifyingTileCount = 0;
	for (i=0; i<100; i++) {
		distances[i] = 0;
	}
	for(i=0; i<DCOLS; i++) {
		for(j=0; j<DROWS; j++) {
			if (interior[i][j]
				&& distanceMap[i][j] < 100) {
				distances[distanceMap[i][j]]++; // create a histogram of distances -- poor man's sort function
				qualifyingTileCount++;
			}
		}
	}
	distance25 = Math.floor(qualifyingTileCount / 4);
	distance75 = Math.floor(3 * qualifyingTileCount / 4);
	for (i=0; i<100; i++) {
		if (distance25 <= distances[i]) {
			distance25 = i;
			break;
		} else {
			distance25 -= distances[i];
		}
	}
	for (i=0; i<100; i++) {
		if (distance75 <= distances[i]) {
			distance75 = i;
			break;
		} else {
			distance75 -= distances[i];
		}
	}
	//DEBUG printf("\nDistances calculated: 33rd percentile of distance is %i, and 67th is %i.", distance25, distance75);

	// Now decide which features will be skipped -- of the features marked MF_ALTERNATIVE, skip all but one, chosen randomly.
	// Then repeat and do the same with respect to MF_ALTERNATIVE_2, to provide up to two independent sets of alternative features per machine.

	for (i=0; i<blueprintCatalog[bp].featureCount; i++) {
		skipFeature[i] = false;
	}
	for (j = 0; j <= 1; j++) {
		totalFreq = 0;
		for (i=0; i<blueprintCatalog[bp].featureCount; i++) {
			if (blueprintCatalog[bp].feature[i].flags & alternativeFlags[j]) {
				skipFeature[i] = true;
				totalFreq++;
			}
		}
		if (totalFreq > 0) {
			randIndex = rand_range(1, totalFreq);
			for (i=0; i<blueprintCatalog[bp].featureCount; i++) {
				if (blueprintCatalog[bp].feature[i].flags & alternativeFlags[j]) {
					if (randIndex == 1) {
						skipFeature[i] = false; // This is the alternative that gets built. The rest do not.
						break;
					} else {
						randIndex--;
					}
				}
			}
		}
	}

	// Keep track of all monsters and items that we spawn -- if we abort, we have to go back and delete them all.
	itemCount = monsterCount = 0;

	// Zero out occupied[][], and use it to keep track of the personal space around each feature that gets placed.
	zeroOutGrid(occupied);

	// Now tick through the features and build them.
	for (feat = 0; feat < blueprintCatalog[bp].featureCount; feat++) {

		if (skipFeature[feat]) {
			continue; // Skip the alternative features that were not selected for building.
		}

		feature = blueprintCatalog[bp].feature[feat];

		// Figure out the distance bounds.
		distanceBound[0] = 0;
		distanceBound[1] = 10000;
		if (feature.flags & MF_NEAR_ORIGIN) {
			distanceBound[1] = distance25;
		}
		if (feature.flags & MF_FAR_FROM_ORIGIN) {
			distanceBound[0] = distance75;
		}

		if (feature.flags & (MF_IN_VIEW_OF_ORIGIN | MF_IN_PASSABLE_VIEW_OF_ORIGIN)) {
			zeroOutGrid(viewMap);
      if (feature.flags & MF_IN_PASSABLE_VIEW_OF_ORIGIN) {
          getFOVMask(viewMap, originX, originY, Math.max(DCOLS, DROWS) << FP_BASE, T_PATHING_BLOCKER, 0, false);
      } else {
          getFOVMask(viewMap, originX, originY, Math.max(DCOLS, DROWS) << FP_BASE, (T_OBSTRUCTS_PASSABILITY | T_OBSTRUCTS_VISION), 0, false);
      }
			viewMap[originX][originY] = true;

			if (D_INSPECT_MACHINES) {
				dumpLevelToScreen();
				hiliteCharGrid(viewMap, /* Color. */omniscienceColor, 75);
				await temporaryMessage("Showing visibility.", true);
			}
		}

		do { // If the MF_REPEAT_UNTIL_NO_PROGRESS flag is set, repeat until we fail to build the required number of instances.

			// Make a master map of candidate locations for this feature.
			qualifyingTileCount = 0;
			for(i=0; i<DCOLS; i++) {
				for(j=0; j<DROWS; j++) {
					if (cellIsFeatureCandidate(i, j,
                   originX, originY,
                   distanceBound,
                   interior, occupied, viewMap, distanceMap,
                   machineNumber, feature.flags, blueprintCatalog[bp].flags))
					{
						qualifyingTileCount++;
						candidates[i][j] = true;
					} else {
						candidates[i][j] = false;
					}
				}
			}

			if (D_INSPECT_MACHINES) {
				dumpLevelToScreen();
				hiliteCharGrid(occupied, /* Color. */red, 75);
				hiliteCharGrid(candidates, /* Color. */teal, 75);
				hiliteCharGrid(interior, /* Color. */blue, 75);
				await temporaryMessage("machine" + bp + ": Occupied (red); Candidates (teal); Interior (blue).", true);
			}

			if (feature.flags & MF_EVERYWHERE & ~MF_BUILD_AT_ORIGIN) {
				// Generate everywhere that qualifies -- instead of randomly picking tiles, keep spawning until we run out of eligible tiles.
				generateEverywhere = true;
			} else {
				// build as many instances as required
				generateEverywhere = false;
				instanceCount = rand_range(feature.instanceCountRange[0], feature.instanceCountRange[1]);
			}

			// Cache the personal space constant.
			personalSpace = feature.personalSpace;

			for (instance = 0; (generateEverywhere || instance < instanceCount) && qualifyingTileCount > 0;) {

				// Find a location for the feature.
				if (feature.flags & MF_BUILD_AT_ORIGIN) {
					// Does the feature want to be at the origin? If so, put it there. (Just an optimization.)
					featX = originX;
					featY = originY;
				} else {
					// Pick our candidate location randomly, and also strike it from
					// the candidates map so that subsequent instances of this same feature can't choose it.
					featX = -1;
					randIndex = rand_range(1, qualifyingTileCount);
					for(i=0; i<DCOLS && featX < 0; i++) {
						for(j=0; j<DROWS && featX < 0; j++) {
							if (candidates[i][j]) {
								if (randIndex == 1) {
									// This is the place!
									featX = i;
									featY = j;
									i = DCOLS;	// break out of the loops
									j = DROWS;
								} else {
									randIndex--;
								}
							}
						}
					}
				}
				// Don't waste time trying the same place again whether or not this attempt succeeds.
				candidates[featX][featY] = false;
				qualifyingTileCount--;

				DFSucceeded = terrainSucceeded = true;

				// Try to build the DF first, if any, since we don't want it to be disrupted by subsequently placed terrain.
				if (feature.featureDF) {
					DFSucceeded = await spawnDungeonFeature(featX, featY, dungeonFeatureCatalog[feature.featureDF], false, !(feature.flags & MF_PERMIT_BLOCKING));
					if (DFSucceeded && D_INSPECT_MACHINE_FEATURES) {
						dumpLevelToScreen();
						hiliteCell(featX, featY, yellow, 50, true);
						await temporaryMessage('Machine feature: ' + dungeonFeatureTypes.toString(feature.featureDF), true);
					}
				}

				// Now try to place the terrain tile, if any.
				if (DFSucceeded && feature.terrain) {
					// Must we check for blocking?
					if (!(feature.flags & MF_PERMIT_BLOCKING)
						&& ((tileCatalog[feature.terrain].flags & T_PATHING_BLOCKER) || (feature.flags & MF_TREAT_AS_BLOCKING))) {
						// Yes, check for blocking.

						zeroOutGrid(blockingMap);
						blockingMap[featX][featY] = true;
						terrainSucceeded = !levelIsDisconnectedWithBlockingMap(blockingMap, false);
					}
					if (terrainSucceeded) {
						pmap[featX][featY].layers[feature.layer] = feature.terrain;

						if (D_INSPECT_MACHINE_FEATURES) {
							dumpLevelToScreen();
							hiliteCell(featX, featY, yellow, 50, true);
							await temporaryMessage('Machine terrain: ' + tileType.toString(feature.terrain), true);
						}

					}
				}

				// OK, if placement was successful, clear some personal space around the feature so subsequent features can't be generated too close.
				// Personal space of 0 means nothing gets cleared, 1 means that only the tile itself gets cleared, and 2 means the 3x3 grid centered on it.

				if (DFSucceeded && terrainSucceeded) {
					for (i = featX - personalSpace + 1;
						 i <= featX + personalSpace - 1;
						 i++) {
						for (j = featY - personalSpace + 1;
							 j <= featY + personalSpace - 1;
							 j++) {
							if (coordinatesAreInMap(i, j)) {
								if (candidates[i][j]) {
                  brogueAssert(!occupied[i][j] || (i == originX && j == originY)); // Candidates[][] should never be true where occupied[][] is true.
									candidates[i][j] = false;
									qualifyingTileCount--;
								}
								occupied[i][j] = true;
							}
						}
					}
					instance++; // we've placed an instance
					//DEBUG printf("\nPlaced instance #%i of feature %i at (%i, %i).", instance, feat, featX, featY);
				}

				if (DFSucceeded && terrainSucceeded) { // Proceed only if the terrain stuff for this instance succeeded.

          theItem = NULL;

					// Mark the feature location as part of the machine, in case it is not already inside of it.
          pmap[featX][featY].flags |= ((blueprintCatalog[bp].flags & BP_ROOM) ? IS_IN_ROOM_MACHINE : IS_IN_AREA_MACHINE);
          pmap[featX][featY].machineNumber = machineNumber;

					// Mark the feature location as impregnable if requested.
					if (feature.flags & MF_IMPREGNABLE) {
						pmap[featX][featY].flags |= IMPREGNABLE;
					}

					// Generate an item as necessary.
					if ((feature.flags & MF_GENERATE_ITEM)
						|| (adoptiveItem && (feature.flags & MF_ADOPT_ITEM) && (blueprintCatalog[bp].flags & BP_ADOPT_ITEM))) {
						// Are we adopting an item instead of generating one?
						if (adoptiveItem && (feature.flags & MF_ADOPT_ITEM) && (blueprintCatalog[bp].flags & BP_ADOPT_ITEM)) {
							theItem = adoptiveItem;
							adoptiveItem = NULL; // can be adopted only once
						} else {
							// Have to create an item ourselves.
							theItem = generateItem(feature.itemCategory, feature.itemKind);
							failsafe = 1000;
							while ((theItem.flags & ITEM_CURSED)
								   || ((feature.flags & MF_REQUIRE_GOOD_RUNIC) && (!(theItem.flags & ITEM_RUNIC))) // runic if requested
								   || ((feature.flags & MF_NO_THROWING_WEAPONS) && theItem.category == WEAPON && theItem.quantity > 1) // no throwing weapons if prohibited
                   || itemIsADuplicate(theItem, spawnedItems, itemCount)) // don't want to duplicates of rings, staffs, etc.
							{
								deleteItem(theItem);
								theItem = generateItem(feature.itemCategory, feature.itemKind);
								if (failsafe <= 0) {
									break;
								}
								failsafe--;
							}
							spawnedItems[itemCount] = theItem; // Keep a list of generated items so that we can delete them all if construction fails.
							if (parentSpawnedItems) {
								parentSpawnedItems[itemCount] = theItem;
							}
							itemCount++;
						}
            theItem.flags |= feature.itemFlags;

						addLocationToKey(theItem, featX, featY, (feature.flags & MF_KEY_DISPOSABLE) ? true : false);
						theItem.originDepth = rogue.depthLevel;
						if (feature.flags & MF_SKELETON_KEY) {
							addMachineNumberToKey(theItem, machineNumber, (feature.flags & MF_KEY_DISPOSABLE) ? true : false);
						}
            if (!(feature.flags & MF_OUTSOURCE_ITEM_TO_MACHINE)
                && !(feature.flags & MF_MONSTER_TAKE_ITEM))
						{
							// Place the item at the feature location.
							await placeItem(theItem, featX, featY);	// Pressure plate should not click in this process.
						}
					}

	        if (feature.flags & (MF_OUTSOURCE_ITEM_TO_MACHINE | MF_BUILD_VESTIBULE)) {
	            // Put this item up for adoption, or generate a door guard machine.
	            // Try to create a sub-machine that qualifies.
	            // If we fail 10 times, abort the entire machine (including any sub-machines already built).
	            // Also, if we build a sub-machine, and it succeeds, but this (its parent machine) fails,
	            // we pass the monsters and items that it spawned back to the parent,
	            // so that if the parent fails, they can all be freed.
	            for (i=10; i > 0; i--) {
	                // First make sure our adopted item, if any, is not on the floor or in the pack already.
	                // Otherwise, a previous attempt to place it may have put it on the floor in a different
	                // machine, only to have that machine fail and be deleted, leaving the item remaining on
	                // the floor where placed.
	                if ((feature.flags & MF_OUTSOURCE_ITEM_TO_MACHINE) && theItem) {
	                    removeItemFromChain(theItem, floorItems);
	                    removeItemFromChain(theItem, packItems);
	                    theItem.nextItem = NULL;
	                    success = await buildAMachine(-1, -1, -1, BP_ADOPT_ITEM, theItem, spawnedItemsSub, spawnedMonstersSub);
	                } else if (feature.flags & MF_BUILD_VESTIBULE) {
	                    success = await buildAMachine(-1, featX, featY, BP_VESTIBULE, NULL, spawnedItemsSub, spawnedMonstersSub);
	                }

	                // Now put the item up for adoption.
	                if (success) {
	                    // Success! Now we have to add that machine's items and monsters to our own list, so they
	                    // all get deleted if this machine or its parent fails.
	                    for (j=0; j<MACHINES_BUFFER_LENGTH && spawnedItemsSub[j]; j++) {
	                        spawnedItems[itemCount] = spawnedItemsSub[j];
	                        if (parentSpawnedItems) {
	                            parentSpawnedItems[itemCount] = spawnedItemsSub[j];
	                        }
	                        itemCount++;
	                        spawnedItemsSub[j] = NULL;
	                    }
	                    for (j=0; j<MACHINES_BUFFER_LENGTH && spawnedMonstersSub[j]; j++) {
	                        spawnedMonsters[monsterCount] = spawnedMonstersSub[j];
	                        if (parentSpawnedMonsters) {
	                            parentSpawnedMonsters[monsterCount] = spawnedMonstersSub[j];
	                        }
	                        monsterCount++;
	                        spawnedMonstersSub[j] = NULL;
	                    }
	                    break;
	                }
	            }

	            if (!i) {
	                if (D_MESSAGE_MACHINE_GENERATION) printf("\nDepth %i: Failed to place blueprint %i because it requires an adoptive machine and we couldn't place one.", rogue.depthLevel, bp);
	                // failure! abort!
	                copyMap(levelBackup, pmap);
	                abortItemsAndMonsters(spawnedItems, spawnedMonsters);
	                freeGrid(distanceMap);
	                return false;
	            }
	            theItem = NULL;
	        }

					// Generate a horde as necessary.
					if ((feature.flags & MF_GENERATE_HORDE)
                        || feature.monsterID) {

						if (feature.flags & MF_GENERATE_HORDE) {
							monst = await spawnHorde(0,
											   featX,
											   featY,
											   ((HORDE_IS_SUMMONED | HORDE_LEADER_CAPTIVE) & ~(feature.hordeFlags)),
											   feature.hordeFlags);
							if (monst) {
								monst.bookkeepingFlags |= MB_JUST_SUMMONED;
							}
						}

						if (feature.monsterID) {
              monst = monsterAtLoc(featX, featY);
              if (monst) {
                  await killCreature(monst, true); // If there's already a monster here, quietly bury the body.
              }
							monst = generateMonster(feature.monsterID, true, true);
							if (monst) {
								monst.xLoc = featX;
								monst.yLoc = featY;
								pmap[monst.xLoc][monst.yLoc].flags |= HAS_MONSTER;
								monst.bookkeepingFlags |= MB_JUST_SUMMONED;
							}
						}

						if (monst) {
							if (!leader) {
								leader = monst;
							}

							// Give our item to the monster leader if appropriate.
							// Actually just remember that we have to give it to this monster; the actual
							// hand-off happens after we're sure that the machine will succeed.
							if (theItem && (feature.flags & MF_MONSTER_TAKE_ITEM)) {
								torchBearer = monst;
								torch = theItem;
							}
						}

						for (monst = monsters.nextCreature; monst; monst = nextMonst) {
							// Have to cache the next monster, as the chain can get disrupted by making a monster dormant below.
							nextMonst = monst.nextCreature;
							if (monst.bookkeepingFlags & MB_JUST_SUMMONED) {

								// All monsters spawned by a machine are tribemates.
								// Assign leader/follower roles if they are not yet assigned.
								if (!(monst.bookkeepingFlags & (MB_LEADER | MB_FOLLOWER))) {
									if (leader && leader != monst) {
										monst.leader = leader;
										monst.bookkeepingFlags &= ~MB_LEADER;
										monst.bookkeepingFlags |= MB_FOLLOWER;
										leader.bookkeepingFlags |= MB_LEADER;
									} else {
										leader = monst;
									}
								}

								monst.bookkeepingFlags &= ~MB_JUST_SUMMONED;
								spawnedMonsters[monsterCount] = monst;
								if (parentSpawnedMonsters) {
									parentSpawnedMonsters[monsterCount] = monst;
								}
								monsterCount++;
								if (feature.flags & MF_MONSTER_SLEEPING) {
									monst.creatureState = MONSTER_SLEEPING;
								}
                if (feature.flags & MF_MONSTER_FLEEING) {
                    monst.creatureState = MONSTER_FLEEING;
                    monst.creatureMode = MODE_PERM_FLEEING;
                }
								if (feature.flags & MF_MONSTERS_DORMANT) {
									toggleMonsterDormancy(monst);
									if (!(feature.flags & MF_MONSTER_SLEEPING) && monst.creatureState != MONSTER_ALLY) {
										monst.creatureState = MONSTER_TRACKING_SCENT;
									}
								}
                monst.machineHome = machineNumber; // Monster remembers the machine that spawned it.
							}
						}
					}
				}
				theItem = NULL;

				// Finished with this instance!
			}
		} while ((feature.flags & MF_REPEAT_UNTIL_NO_PROGRESS) && instance >= feature.minimumInstanceCount);

		//DEBUG printf("\nFinished feature %i. Here's the candidates map:", feat);
		//DEBUG logBuffer(candidates);

		if (instance < feature.minimumInstanceCount && !(feature.flags & MF_REPEAT_UNTIL_NO_PROGRESS)) {
			// failure! abort!

			if (D_MESSAGE_MACHINE_GENERATION) printf("Depth %i: Failed to place blueprint %i because of feature %i; needed %i instances but got only %i.",
						 rogue.depthLevel, bp, feat, feature.minimumInstanceCount, instance);

			// Restore the map to how it was before we touched it.
			copyMap(levelBackup, pmap);
			abortItemsAndMonsters(spawnedItems, spawnedMonsters);
			freeGrid(distanceMap);
			return false;
		}
	}

    // Clear out the interior flag for all non-wired cells, if requested.
	if (blueprintCatalog[bp].flags & BP_NO_INTERIOR_FLAG) {
        for(i=0; i<DCOLS; i++) {
            for(j=0; j<DROWS; j++) {
                if (pmap[i][j].machineNumber == machineNumber
                    && !cellHasTMFlag(i, j, (TM_IS_WIRED | TM_IS_CIRCUIT_BREAKER))) {

                    pmap[i][j].flags &= ~IS_IN_MACHINE;
                    pmap[i][j].machineNumber = 0;
                }
            }
        }
	}

	if (torchBearer && torch) {
		if (torchBearer.carriedItem) {
			deleteItem(torchBearer.carriedItem);
		}
		removeItemFromChain(torch, floorItems);
		torchBearer.carriedItem = torch;
	}

	freeGrid(distanceMap);
	if (D_MESSAGE_MACHINE_GENERATION) printf("Depth %i: Built a machine from blueprint %i with an origin at (%i, %i).", rogue.depthLevel, bp, originX, originY);
	return true;
}

// add machines to the dungeon.
async function addMachines() {
	let machineCount, failsafe;
  let randomMachineFactor;
	const buf = STRING();

	analyzeMap(true);

  // Add the amulet holder if it's depth 26:
  if (rogue.depthLevel == AMULET_LEVEL) {
      for (failsafe = 50; failsafe; failsafe--) {
          if (await buildAMachine(MT_AMULET_AREA, -1, -1, NULL, NULL, NULL, NULL)) {
              break;
          }
      }
  }

	// Add reward rooms, if any:
	machineCount = 0;
	while (rogue.depthLevel <= AMULET_LEVEL
		&& (rogue.rewardRoomsGenerated + machineCount) * 4 + 2 < rogue.depthLevel * MACHINES_FACTOR) {
		// try to build at least one every four levels on average
		machineCount++;
	}
  randomMachineFactor = (rogue.depthLevel < 3 && (rogue.rewardRoomsGenerated + machineCount) == 0 ? 40 : 15);
  while (rand_percent(Math.max(randomMachineFactor, Number(BigInt(15 * MACHINES_FACTOR) >> BIG_BASE))) && machineCount < 100) {
      randomMachineFactor = 15;
      machineCount++;
  }

	if (D_INSPECT_MACHINES) {
		sprintf(buf, "Adding %i machines.", machineCount);
		await temporaryMessage(buf, true);
	}

	for (failsafe = 50; machineCount && failsafe; failsafe--) {
		if (await buildAMachine(-1, -1, -1, BP_REWARD, NULL, NULL, NULL)) {
			machineCount--;
			rogue.rewardRoomsGenerated++;
		}
	}
}

// Add terrain, DFs and flavor machines. Includes traps, torches, funguses, flavor machines, etc.
// If buildAreaMachines is true, build ONLY the autogenerators that include machines.
// If false, build all EXCEPT the autogenerators that include machines.
async function runAutogenerators(buildAreaMachines) {
	let AG, count, x, y, i;
	let gen;
	let grid = allocGrid();

	// Cycle through the autoGenerators.
	for (AG=1; AG<NUMBER_AUTOGENERATORS; AG++) {

		// Shortcut:
		gen = autoGeneratorCatalog[AG];

    if (gen.machine > 0 == buildAreaMachines) {

        // Enforce depth constraints.
        if (rogue.depthLevel < gen.minDepth || rogue.depthLevel > gen.maxDepth) {
            continue;
        }

        // Decide how many of this AG to build.
        count = Math.min( Math.floor((gen.minNumberIntercept + rogue.depthLevel * gen.minNumberSlope) / 100), gen.maxNumber);
        while (rand_percent(gen.frequency) && count < gen.maxNumber) {
            count++;
        }

				if (D_INSPECT_AUTOGENERATORS) {
					await temporaryMessage(`Build ${count} autogenerators.`, true);
				}

        // Build that many instances.
        for (i = 0; i < count; i++) {

            // Find a location for DFs and terrain generations.
            //if (randomMatchingLocation(&x, &y, gen.requiredDungeonFoundationType, NOTHING, -1)) {
            //if (randomMatchingLocation(&x, &y, -1, -1, gen.requiredDungeonFoundationType)) {
						const loc = randomMatchingLocation(gen.requiredDungeonFoundationType, gen.requiredLiquidFoundationType, -1)
            if (loc) {
								x = loc[0];
								y = loc[1];

                // Spawn the DF.
                if (gen.DFType) {
                    await spawnDungeonFeature(x, y, dungeonFeatureCatalog[gen.DFType], false, true);

                    if (D_INSPECT_AUTOGENERATORS) {
                        dumpLevelToScreen();
                        hiliteCell(x, y, /* Color. */yellow, 50, true);
												printf("Autogenerator @ ", x, y);
                        await temporaryMessage("Dungeon feature added: " + dungeonFeatureTypes.toString(gen.DFType), true);
                    }
                }

                // Spawn the terrain if it's got the priority to spawn there and won't disrupt connectivity.
                if (gen.terrain
                    && tileCatalog[pmap[x][y].layers[gen.layer]].drawPriority >= tileCatalog[gen.terrain].drawPriority)
								{
                    // Check connectivity.
                    zeroOutGrid(grid);
                    grid[x][y] = true;
                    if (!(tileCatalog[gen.terrain].flags & T_PATHING_BLOCKER)
                        || !levelIsDisconnectedWithBlockingMap(grid, false))
										{
                        // Build!
                        pmap[x][y].layers[gen.layer] = gen.terrain;

                        if (D_INSPECT_AUTOGENERATORS) {
                            dumpLevelToScreen();
                            hiliteCell(x, y, /* Color. */yellow, 50, true);
                            await temporaryMessage("Terrain added.", true);
                        }
                    }
                }
            }

            // Attempt to build the machine if requested.
            // Machines will find their own locations, so it will not be at the same place as terrain and DF.
            if (gen.machine > 0) {
                await buildAMachine(gen.machine, -1, -1, 0, NULL, NULL, NULL);
            }
        }
    }
	}

	if (D_INSPECT_LEVELGEN && !D_INSPECT_AUTOGENERATORS) {
			dumpLevelToScreen();
			await temporaryMessage("Added Autogenerators", true);
	}

}

// Knock down the boundaries between similar lakes where possible.
function cleanUpLakeBoundaries() {
	let i, j, x, y, failsafe, layer;
	let reverse, madeChange;
  let subjectFlags;

	reverse = true;

  failsafe = 100;
	do {
		madeChange = false;
		reverse = !reverse;
    failsafe--;

		for (i = (reverse ? DCOLS - 2 : 1);
			 (reverse ? i > 0 : i < DCOLS - 1);
			 (reverse ? i-- : i++)) {

			for (j = (reverse ? DROWS - 2 : 1);
				 (reverse ? j > 0 : j < DROWS - 1);
				 (reverse ? j-- : j++)) {

				//assert(i >= 1 && i <= DCOLS - 2 && j >= 1 && j <= DROWS - 2);

				//if (cellHasTerrainFlag(i, j, T_OBSTRUCTS_PASSABILITY)
      if (cellHasTerrainFlag(i, j, T_LAKE_PATHING_BLOCKER | T_OBSTRUCTS_PASSABILITY)
          && !cellHasTMFlag(i, j, TM_IS_SECRET)
					&& !(pmap[i][j].flags & IMPREGNABLE)) {

          subjectFlags = terrainFlags(i, j) & (T_LAKE_PATHING_BLOCKER | T_OBSTRUCTS_PASSABILITY);

					x = y = 0;
					if ((terrainFlags(i - 1, j) & T_LAKE_PATHING_BLOCKER & ~subjectFlags)
            && !cellHasTMFlag(i - 1, j, TM_IS_SECRET)
            && !cellHasTMFlag(i + 1, j, TM_IS_SECRET)
						&& (terrainFlags(i - 1, j) & T_LAKE_PATHING_BLOCKER & ~subjectFlags) == (terrainFlags(i + 1, j) & T_LAKE_PATHING_BLOCKER & ~subjectFlags)) {
						x = i + 1;
						y = j;
					} else if ((terrainFlags(i, j - 1) & T_LAKE_PATHING_BLOCKER & ~subjectFlags)
                 && !cellHasTMFlag(i, j - 1, TM_IS_SECRET)
                 && !cellHasTMFlag(i, j + 1, TM_IS_SECRET)
							   && (terrainFlags(i, j - 1) & T_LAKE_PATHING_BLOCKER & ~subjectFlags) == (terrainFlags(i, j + 1) & T_LAKE_PATHING_BLOCKER & ~subjectFlags)) {
						x = i;
						y = j + 1;
					}
					if (x) {
						madeChange = true;
						for (layer = 0; layer < NUMBER_TERRAIN_LAYERS; layer++) {
							pmap[i][j].layers[layer] = pmap[x][y].layers[layer];
						}
                        //pmap[i][j].layers[DUNGEON] = CRYSTAL_WALL;
					}
				}
			}
		}
	} while (madeChange && failsafe > 0);
}

function removeDiagonalOpenings() {
  let i, j, k, x1, y1, x2, layer;
  let diagonalCornerRemoved;

	do {
		diagonalCornerRemoved = false;
		for (i=0; i<DCOLS-1; i++) {
			for (j=0; j<DROWS-1; j++) {
				for (k=0; k<=1; k++) {
					if (!(tileCatalog[pmap[i + k][j].layers[DUNGEON]].flags & T_OBSTRUCTS_PASSABILITY)
						&& (tileCatalog[pmap[i + (1-k)][j].layers[DUNGEON]].flags & T_OBSTRUCTS_PASSABILITY)
						&& (tileCatalog[pmap[i + (1-k)][j].layers[DUNGEON]].flags & T_OBSTRUCTS_DIAGONAL_MOVEMENT)
						&& (tileCatalog[pmap[i + k][j+1].layers[DUNGEON]].flags & T_OBSTRUCTS_PASSABILITY)
						&& (tileCatalog[pmap[i + k][j+1].layers[DUNGEON]].flags & T_OBSTRUCTS_DIAGONAL_MOVEMENT)
						&& !(tileCatalog[pmap[i + (1-k)][j+1].layers[DUNGEON]].flags & T_OBSTRUCTS_PASSABILITY)) {

						if (rand_percent(50)) {
							x1 = i + (1-k);
							x2 = i + k;
							y1 = j;
						} else {
							x1 = i + k;
							x2 = i + (1-k);
							y1 = j + 1;
						}
						if (!(pmap[x1][y1].flags & HAS_MONSTER) && pmap[x1][y1].machineNumber == 0) {
              diagonalCornerRemoved = true;
              for (layer = 0; layer < NUMBER_TERRAIN_LAYERS; layer++) {
                  pmap[x1][y1].layers[layer] = pmap[x2][y1].layers[layer];
              }
						}
					}
				}
			}
		}
	} while (diagonalCornerRemoved == true);
}

function insertRoomAt(dungeonMap, roomMap, roomToDungeonX, roomToDungeonY, xRoom, yRoom) {
    let newX, newY;
    let dir;

    brogueAssert(coordinatesAreInMap(xRoom + roomToDungeonX, yRoom + roomToDungeonY));

		// printf("insertRoomAt: ", xRoom + roomToDungeonX, yRoom + roomToDungeonY);

    dungeonMap[xRoom + roomToDungeonX][yRoom + roomToDungeonY] = 1;
    for (dir = 0; dir < 4; dir++) {
        newX = xRoom + nbDirs[dir][0];
        newY = yRoom + nbDirs[dir][1];
        if (coordinatesAreInMap(newX, newY)
            && roomMap[newX][newY]
            && coordinatesAreInMap(newX + roomToDungeonX, newY + roomToDungeonY)
            && dungeonMap[newX + roomToDungeonX][newY + roomToDungeonY] == 0) {

            insertRoomAt(dungeonMap, roomMap, roomToDungeonX, roomToDungeonY, newX, newY);
        }
    }
}

function designCavern(grid, minWidth, maxWidth, minHeight, maxHeight) {
	let destX, destY;
  let caveX, caveY, caveWidth, caveHeight;
  let fillX, fillY;
  let foundFillPoint = false;
  let blobGrid;
  blobGrid = allocGrid();

  fillGrid(grid, 0);
  const bounds = createBlobOnGrid(blobGrid, 5, minWidth, minHeight, maxWidth, maxHeight, 55, "ffffffttt", "ffffttttt");

//    colorOverDungeon(/* Color. */darkGray);
//    hiliteGrid(blobGrid, /* Color. */tanColor, 80);
//    temporaryMessage("Here's the cave:", true);

	// Position the new cave in the middle of the grid...
	destX = Math.floor((DCOLS - bounds.width) / 2);
	destY = Math.floor((DROWS - bounds.height) / 2);

  // ...pick a floodfill insertion point...
  for (fillX = 0; fillX < DCOLS && !foundFillPoint; fillX++) {
      for (fillY = 0; fillY < DROWS && !foundFillPoint; fillY++) {
          if (blobGrid[fillX][fillY]) {
              foundFillPoint = true;
          }
      }
  }
	// ...and copy it to the master grid.
  insertRoomAt(grid, blobGrid, destX - bounds.x, destY - bounds.y, fillX, fillY);
  freeGrid(blobGrid);
}


// This is a special room that appears at the entrance to the dungeon on depth 1.
function designEntranceRoom(grid) {
	let roomWidth, roomHeight, roomWidth2, roomHeight2, roomX, roomY, roomX2, roomY2;

  fillGrid(grid, 0);

  roomWidth = 8;
  roomHeight = 10;
  roomWidth2 = 20;
  roomHeight2 = 5;
  roomX = Math.floor(DCOLS/2 - roomWidth/2 - 1);
  roomY = DROWS - roomHeight - 2;
  roomX2 = Math.floor(DCOLS/2 - roomWidth2/2 - 1);
  roomY2 = DROWS - roomHeight2 - 2;

  drawRectangleOnGrid(grid, roomX, roomY, roomWidth, roomHeight, 1);
  drawRectangleOnGrid(grid, roomX2, roomY2, roomWidth2, roomHeight2, 1);
}

function designCrossRoom(grid) {
	let roomWidth, roomHeight, roomWidth2, roomHeight2, roomX, roomY, roomX2, roomY2;

  fillGrid(grid, 0);

  roomWidth = rand_range(3, 12);
  roomX = rand_range(Math.max(0, Math.floor(DCOLS/2) - (roomWidth - 1)), Math.min(DCOLS, Math.floor(DCOLS/2)));
  roomWidth2 = rand_range(4, 20);
  roomX2 = (roomX + Math.floor(roomWidth / 2) + rand_range(0, 2) + rand_range(0, 2) - 3) - Math.floor(roomWidth2 / 2);

  roomHeight = rand_range(3, 7);
  roomY = Math.floor(DROWS/2 - roomHeight);

  roomHeight2 = rand_range(2, 5);
  roomY2 = Math.floor(DROWS/2 - roomHeight2 - (rand_range(0, 2) + rand_range(0, 1)));

  drawRectangleOnGrid(grid, roomX - 5, roomY + 5, roomWidth, roomHeight, 1);
  drawRectangleOnGrid(grid, roomX2 - 5, roomY2 + 5, roomWidth2, roomHeight2, 1);
}

function designSymmetricalCrossRoom(grid) {
	let majorWidth, majorHeight, minorWidth, minorHeight;

  fillGrid(grid, 0);

  majorWidth = rand_range(4, 8);
  majorHeight = rand_range(4, 5);

  minorWidth = rand_range(3, 4);
  if (majorHeight % 2 == 0) {
      minorWidth -= 1;
  }
  minorHeight = 3;//rand_range(2, 3);
  if (majorWidth % 2 == 0) {
      minorHeight -= 1;
  }

  drawRectangleOnGrid(grid, Math.floor((DCOLS - majorWidth)/2), Math.floor((DROWS - minorHeight)/2), majorWidth, minorHeight, 1);
  drawRectangleOnGrid(grid, Math.floor((DCOLS - minorWidth)/2), Math.floor((DROWS - majorHeight)/2), minorWidth, majorHeight, 1);
}

function designSmallRoom(grid) {
  let width, height;

  fillGrid(grid, 0);
  width = rand_range(3, 6);
  height = rand_range(2, 4);
  drawRectangleOnGrid(grid, Math.floor((DCOLS - width) / 2), Math.floor((DROWS - height) / 2), width, height, 1);
}

function designCircularRoom(grid) {
	let radius;

  if (rand_percent(5)) {
      radius = rand_range(4, 10);
  } else {
      radius = rand_range(2, 4);
  }

  fillGrid(grid, 0);
  drawCircleOnGrid(grid, Math.floor(DCOLS/2), Math.floor(DROWS/2), radius, 1);

  if (radius > 6
      && rand_percent(50)) {
      drawCircleOnGrid(grid, Math.floor(DCOLS/2), Math.floor(DROWS/2), rand_range(3, radius - 3), 0);
  }
}

function designChunkyRoom(grid) {
  let i, x, y;
	let minX, maxX, minY, maxY;
  let chunkCount = rand_range(2, 8);

  fillGrid(grid, 0);
  drawCircleOnGrid(grid, Math.floor(DCOLS/2), Math.floor(DROWS/2), 2, 1);
  minX = Math.floor(DCOLS/2) - 3;
  maxX = Math.floor(DCOLS/2) + 3;
  minY = Math.floor(DROWS/2) - 3;
  maxY = Math.floor(DROWS/2) + 3;

  for (i=0; i<chunkCount;) {
      x = rand_range(minX, maxX);
      y = rand_range(minY, maxY);
      if (grid[x][y]) {
//            colorOverDungeon(/* Color. */darkGray);
//            hiliteGrid(grid, /* Color. */white, 100);

          drawCircleOnGrid(grid, x, y, 2, 1);
          i++;
          minX = Math.max(1, Math.min(x - 3, minX));
          maxX = Math.min(DCOLS - 2, Math.max(x + 3, maxX));
          minY = Math.max(1, Math.min(y - 3, minY));
          maxY = Math.min(DROWS - 2, Math.max(y + 3, maxY));

//            hiliteGrid(grid, /* Color. */green, 50);
//            temporaryMessage("Added a chunk:", true);
      }
  }
}

// If the indicated tile is a wall on the room stored in grid, and it could be the site of
// a door out of that room, then return the outbound direction that the door faces.
// Otherwise, return NO_DIRECTION.
function directionOfDoorSite(grid, x, y) {
    let dir, solutionDir;
    let newX, newY, oppX, oppY;

    if (grid[x][y]) { // Already occupied
        return NO_DIRECTION;
    }

    solutionDir = NO_DIRECTION;
    for (dir=0; dir<4; dir++) {
        newX = x + nbDirs[dir][0];
        newY = y + nbDirs[dir][1];
        oppX = x - nbDirs[dir][0];
        oppY = y - nbDirs[dir][1];
        if (coordinatesAreInMap(oppX, oppY)
            && coordinatesAreInMap(newX, newY)
            && grid[oppX][oppY] == 1) {

            // This grid cell would be a valid tile on which to place a door that, facing outward, points dir.
            if (solutionDir != NO_DIRECTION) {
                // Already claimed by another direction; no doors here!
                return NO_DIRECTION;
            }
            solutionDir = dir;
        }
    }
    return solutionDir;
}

async function chooseRandomDoorSites(roomMap, doorSitesArray) {
    let i, j, k, newX, newY;
    let dir;
    let grid;
    let doorSiteFailed;
		const dirChars = "^v<>";

    grid = allocGrid();
    copyGrid(grid, roomMap);

		if (D_INSPECT_ROOM_ADD) {
			colorOverDungeon(/* Color. */darkGray);
			hiliteGrid(grid, /* Color. */blue, 100);
			// temporaryMessage("Generating this room:", true);
		}

    for (i=0; i<DCOLS; i++) {
        for (j=0; j<DROWS; j++) {
            if (!grid[i][j]) {
                dir = directionOfDoorSite(roomMap, i, j);
                if (dir != NO_DIRECTION) {
                    // Trace a ray 10 spaces outward from the door site to make sure it doesn't intersect the room.
                    // If it does, it's not a valid door site.
                    newX = i + nbDirs[dir][0];
                    newY = j + nbDirs[dir][1];
                    doorSiteFailed = false;
                    for (k=0; k<10 && coordinatesAreInMap(newX, newY) && !doorSiteFailed; k++) {
                        if (grid[newX][newY]) {
                            doorSiteFailed = true;
                        }
                        newX += nbDirs[dir][0];
                        newY += nbDirs[dir][1];
                    }
                    if (!doorSiteFailed) {
												if (D_INSPECT_ROOM_ADD) {
		                       plotCharWithColor(dirChars[dir], mapToWindowX(i), mapToWindowY(j), /* Color. */black, /* Color. */green);
												}
                        grid[i][j] = dir + 2; // So as not to conflict with 0 or 1, which are used to indicate exterior/interior.
                    }
                }
            }
        }
    }

	if (D_INSPECT_ROOM_ADD) {
		await temporaryMessage("Door candidates:", true);
	}

  // Pick four doors, one in each direction, and store them in doorSites[dir].
  for (dir=0; dir<4; dir++) {
      const loc = randomLocationInGrid(grid, dir + 2) || [-1, -1];
			doorSitesArray[dir][0] = loc[0];
			doorSitesArray[dir][1] = loc[1];
  }

  freeGrid(grid);
}


function attachHallwayTo(grid, doorSitesArray) {
    let i, x, y, newX, newY;
		let dirs = []; // [4];
    let length;
    let dir, dir2;
    let allowObliqueHallwayExit;

    // Pick a direction.
    fillSequentialList(dirs, 4);
    shuffleList(dirs, 4);
    for (i=0; i<4; i++) {
        dir = dirs[i];
        if (doorSitesArray[dir][0] != -1
            && doorSitesArray[dir][1] != -1
            && coordinatesAreInMap(doorSitesArray[dir][0] + Math.floor(nbDirs[dir][0] * HORIZONTAL_CORRIDOR_MAX_LENGTH),
                                   doorSitesArray[dir][1] + Math.floor(nbDirs[dir][1] * VERTICAL_CORRIDOR_MAX_LENGTH)) ) {
                break; // That's our direction!
        }
    }
    if (i==4) {
        return; // No valid direction for hallways.
    }

    if (dir == UP || dir == DOWN) {
        length = rand_range(VERTICAL_CORRIDOR_MIN_LENGTH, VERTICAL_CORRIDOR_MAX_LENGTH);
    } else {
        length = rand_range(HORIZONTAL_CORRIDOR_MIN_LENGTH, HORIZONTAL_CORRIDOR_MAX_LENGTH);
    }

    x = doorSitesArray[dir][0];
    y = doorSitesArray[dir][1];
    for (i = 0; i < length; i++) {
        if (coordinatesAreInMap(x, y)) {
            grid[x][y] = true;
        }
        x += nbDirs[dir][0];
        y += nbDirs[dir][1];
    }
    x = clamp(x - nbDirs[dir][0], 0, DCOLS - 1);
    y = clamp(y - nbDirs[dir][1], 0, DROWS - 1); // Now (x, y) points at the last interior cell of the hallway.
    allowObliqueHallwayExit = rand_percent(15);
    for (dir2 = 0; dir2 < 4; dir2++) {
        newX = x + nbDirs[dir2][0];
        newY = y + nbDirs[dir2][1];

        if ((dir2 != dir && !allowObliqueHallwayExit)
            || !coordinatesAreInMap(newX, newY)
            || grid[newX][newY]) {

            doorSitesArray[dir2][0] = -1;
            doorSitesArray[dir2][1] = -1;
        } else {
            doorSitesArray[dir2][0] = newX;
            doorSitesArray[dir2][1] = newY;
        }
    }

		// printf("attachHallwayTo", length);
		// for(dir = 0; dir < 4; ++dir) {
		// 	printf(" - ", dir, doorSitesArray[dir][0], doorSitesArray[dir][1]);
		// }
}

// Put a random room shape somewhere on the binary grid,
// and optionally record the coordinates of up to four door sites in doorSites.
// If attachHallway is true, then it will bolt a perpendicular hallway onto the room at one of the four standard door sites,
// and then relocate three of the door sites to radiate from the end of the hallway. (The fourth is defunct.)
// RoomTypeFrequencies specifies the probability of each room type, in the following order:
//      0. Cross room
//      1. Small symmetrical cross room
//      2. Small room
//      3. Circular room
//      4. Chunky room
//      5. Cave
//      6. Cavern (the kind that fills a level)
//      7. Entrance room (the big upside-down T room at the start of depth 1)

async function designRandomRoom(grid, attachHallway, doorSitesArray, roomTypeFrequencies) {
    let randIndex, i, sum;
    let dir;

    sum = 0;
    for (i=0; i<ROOM_TYPE_COUNT; i++) {
        sum += roomTypeFrequencies[i];
    }
    randIndex = rand_range(0, sum - 1);
    for (i=0; i<ROOM_TYPE_COUNT; i++) {
        if (randIndex < roomTypeFrequencies[i]) {
            break; // "i" is our room type.
        } else {
            randIndex -= roomTypeFrequencies[i];
        }
    }

		// printf("designRandomRoom:", i);
    switch (i) {
        case 0:
            designCrossRoom(grid);
            break;
        case 1:
            designSymmetricalCrossRoom(grid);
            break;
        case 2:
            designSmallRoom(grid);
            break;
        case 3:
            designCircularRoom(grid);
            break;
        case 4:
            designChunkyRoom(grid);
            break;
        case 5:
            switch (rand_range(0, 2)) {
                case 0:
                    designCavern(grid, 3, 12, 4, 8); // Compact cave room.
                    break;
                case 1:
                    designCavern(grid, 3, 12, 15, DROWS-2); // Large north-south cave room.
                    break;
                case 2:
                    designCavern(grid, 20, DROWS-2, 4, 8); // Large east-west cave room.
                    break;
                default:
                    break;
            }
            break;
        case 6:
            designCavern(grid, CAVE_MIN_WIDTH, DCOLS - 2, CAVE_MIN_HEIGHT, DROWS - 2);
            break;
        case 7:
            designEntranceRoom(grid);
            break;
        default:
            break;
    }

    if (doorSitesArray) {
        await chooseRandomDoorSites(grid, doorSitesArray);
        if (attachHallway) {
            dir = rand_range(0, 3);
            for (i=0; doorSitesArray[dir][0] == -1 && i < 3; i++) {
                dir = (dir + 1) % 4; // Each room will have at least 2 valid directions for doors.
            }
            attachHallwayTo(grid, doorSitesArray);
        }
    }
}

function roomFitsAt(dungeonMap, roomMap, roomToDungeonX, roomToDungeonY) {
    let xRoom, yRoom, xDungeon, yDungeon, i, j;

    for (xRoom = 0; xRoom < DCOLS; xRoom++) {
        for (yRoom = 0; yRoom < DROWS; yRoom++) {
            if (roomMap[xRoom][yRoom]) {
                xDungeon = xRoom + roomToDungeonX;
                yDungeon = yRoom + roomToDungeonY;

                for (i = xDungeon - 1; i <= xDungeon + 1; i++) {
                    for (j = yDungeon - 1; j <= yDungeon + 1; j++) {
                        if (!coordinatesAreInMap(i, j)
                            || dungeonMap[i][j] > 0) {
                            return false;
                        }
                    }
                }
            }
        }
    }
    return true;
}

async function attachRooms(grid, dungeonProfile, attempts, maxRoomCount) {
    let roomsBuilt, roomsAttempted;
    let roomMap;
    let doorSites = ARRAY(4, () => [-1, -1] ); // short[4][2];
    let i, x, y;
		let sCoord = []; // [DCOLS*DROWS];
    let dir, oppDir;

    fillSequentialList(sCoord, DCOLS*DROWS);
    shuffleList(sCoord, DCOLS*DROWS);

		printf("attachRooms: sCoord[0]=", sCoord[0]);

    roomMap = allocGrid();
    for (roomsBuilt = roomsAttempted = 0; roomsBuilt < maxRoomCount && roomsAttempted < attempts; roomsAttempted++) {
        // Build a room in hyperspace.
        fillGrid(roomMap, 0);
        await designRandomRoom(roomMap, roomsAttempted <= attempts - 5 && rand_percent(dungeonProfile.corridorChance),
                         doorSites, dungeonProfile.roomFrequencies);

        if (D_INSPECT_ROOM_ADD) {
            colorOverDungeon(/* Color. */darkGray);
            hiliteGrid(roomMap, /* Color. */blue, 100);
            if (doorSites[0][0] != -1) plotCharWithColor('^', mapToWindowX(doorSites[0][0]), mapToWindowY(doorSites[0][1]), /* Color. */black, /* Color. */green);
            if (doorSites[1][0] != -1) plotCharWithColor('v', mapToWindowX(doorSites[1][0]), mapToWindowY(doorSites[1][1]), /* Color. */black, /* Color. */green);
            if (doorSites[2][0] != -1) plotCharWithColor('<', mapToWindowX(doorSites[2][0]), mapToWindowY(doorSites[2][1]), /* Color. */black, /* Color. */green);
            if (doorSites[3][0] != -1) plotCharWithColor('>', mapToWindowX(doorSites[3][0]), mapToWindowY(doorSites[3][1]), /* Color. */black, /* Color. */green);
            await temporaryMessage("Generating this room:", true);
        }

        // Slide hyperspace across real space, in a random but predetermined order, until the room matches up with a wall.
        for (i = 0; i < DCOLS*DROWS; i++) {
            x = Math.floor(sCoord[i] / DROWS);
            y = sCoord[i] % DROWS;

            dir = directionOfDoorSite(grid, x, y);
            oppDir = oppositeDirection(dir);

            if (dir != NO_DIRECTION
                && doorSites[oppDir][0] != -1
                && roomFitsAt(grid, roomMap, x - doorSites[oppDir][0], y - doorSites[oppDir][1])) {

								// printf("attachRoom: ", x, y, oppDir);

                // Room fits here.
                if (D_INSPECT_ROOM_ADD) {
                    colorOverDungeon(/* Color. */darkGray);
                    hiliteGrid(grid, /* Color. */white, 100);
                }
                insertRoomAt(grid, roomMap, x - doorSites[oppDir][0], y - doorSites[oppDir][1], doorSites[oppDir][0], doorSites[oppDir][1]);
                grid[x][y] = 2; // Door site.
                if (D_INSPECT_ROOM_ADD) {
                    hiliteGrid(grid, /* Color. */green, 50);
                    await temporaryMessage("Added room.", true);
                }
                roomsBuilt++;
                break;
            }
        }
    }

    freeGrid(roomMap);
}

function adjustDungeonProfileForDepth(theDungeonProfile) {
    const descentPercent = clamp(Math.floor(100 * (rogue.depthLevel - 1) / (AMULET_LEVEL - 1)), 0, 100);

    theDungeonProfile.roomFrequencies[0] += Math.floor(20 * (100 - descentPercent) / 100);
    theDungeonProfile.roomFrequencies[1] += Math.floor(10 * (100 - descentPercent) / 100);
    theDungeonProfile.roomFrequencies[3] += Math.floor( 7 * (100 - descentPercent) / 100);
    theDungeonProfile.roomFrequencies[5] += Math.floor(10 * descentPercent / 100);

    theDungeonProfile.corridorChance += Math.floor(80 * (100 - descentPercent) / 100);
}

function adjustDungeonFirstRoomProfileForDepth(theDungeonProfile) {
    let i;
    const descentPercent = clamp( Math.floor(100 * (rogue.depthLevel - 1) / (AMULET_LEVEL - 1)), 0, 100);

    if (rogue.depthLevel == 1) {
        // All dungeons start with the entrance room on depth 1.
        for (i = 0; i < ROOM_TYPE_COUNT; i++) {
            theDungeonProfile.roomFrequencies[i] = 0;
        }
        theDungeonProfile.roomFrequencies[7] = 1;
    } else {
        theDungeonProfile.roomFrequencies[6] += Math.floor(50 * descentPercent / 100);
    }
}

// Called by digDungeon().
// Slaps a bunch of rooms and hallways into the grid.
// On the grid, a 0 denotes granite, a 1 denotes floor, and a 2 denotes a possible door site.
// -1 denotes off-limits areas -- rooms can't be placed there and also can't sprout off of there.
// Parent function will translate this grid into pmap[][] to make floors, walls, doors, etc.
async function carveDungeon(grid) {
    let dungeonProfile, theFirstRoomDP;

    dungeonProfile = cloneDeep(dungeonProfileCatalog[DP_BASIC]);
    adjustDungeonProfileForDepth(dungeonProfile);

    theFirstRoomDP = cloneDeep(dungeonProfileCatalog[DP_BASIC_FIRST_ROOM]);
    adjustDungeonFirstRoomProfileForDepth(theFirstRoomDP);

    await designRandomRoom(grid, false, NULL, theFirstRoomDP.roomFrequencies);

    if (D_INSPECT_ROOM_ADD) {
        colorOverDungeon(/* Color. */darkGray);
        hiliteGrid(grid, /* Color. */white, 100);
        await temporaryMessage("First room placed:", true);
    }

    await attachRooms(grid, dungeonProfile, 35, 35);

		if (D_INSPECT_LEVELGEN && !D_INSPECT_ROOM_ADD) {
			colorOverDungeon(/* Color. */darkGray);
 	  	hiliteGrid(grid, /* Color. */white, 100);
 	  	await temporaryMessage("How does this finished level look?", true);
		}
}

function finishWalls(includingDiagonals) {
    let i, j, x1, y1;
    let foundExposure;
    let dir;

    for (i=0; i<DCOLS; i++) {
		for (j=0; j<DROWS; j++) {
			if (pmap[i][j].layers[DUNGEON] == GRANITE) {
				foundExposure = false;
				for (dir = 0; dir < (includingDiagonals ? 8 : 4) && !foundExposure; dir++) {
					x1 = i + nbDirs[dir][0];
					y1 = j + nbDirs[dir][1];
					if (coordinatesAreInMap(x1, y1)
						&& (!cellHasTerrainFlag(x1, y1, T_OBSTRUCTS_VISION) || !cellHasTerrainFlag(x1, y1, T_OBSTRUCTS_PASSABILITY))) {

						pmap[i][j].layers[DUNGEON] = WALL;
						foundExposure = true;
					}
				}
			} else if (pmap[i][j].layers[DUNGEON] == WALL) {
				foundExposure = false;
				for (dir = 0; dir < (includingDiagonals ? 8 : 4) && !foundExposure; dir++) {
					x1 = i + nbDirs[dir][0];
					y1 = j + nbDirs[dir][1];
					if (coordinatesAreInMap(x1, y1)
						&& (!cellHasTerrainFlag(x1, y1, T_OBSTRUCTS_VISION) || !cellHasTerrainFlag(x1, y1, T_OBSTRUCTS_PASSABILITY))) {

						foundExposure = true;
					}
				}
				if (foundExposure == false) {
					pmap[i][j].layers[DUNGEON] = GRANITE;
				}
			}
		}
	}
}

function liquidType() {
	let randMin, randMax, rand;

	randMin = (rogue.depthLevel < 4 ? 1 : 0); // no lava before level 4
	randMax = (rogue.depthLevel < 17 ? 2 : 3); // no brimstone before level 18
	rand = rand_range(randMin, randMax);
    if (rogue.depthLevel == DEEPEST_LEVEL) {
        rand = 1;
    }

	switch(rand) {
		case 0:
			return {
				deep: LAVA,
				shallow: NOTHING,
				shallowWidth: 0,
			}
			break;
		case 1:
			return {
				deep: DEEP_WATER,
				shallow: SHALLOW_WATER,
				shallowWidth: 2,
			}
			break;
		case 2:
			return {
				deep: CHASM,
				shallow: CHASM_EDGE,
				shallowWidth: 1,
			}
			break;
		case 3:
			return {
				deep: INERT_BRIMSTONE,
				shallow: OBSIDIAN,
				shallowWidth: 2,
			}
			break;
	}
}

// Fills a lake marked in unfilledLakeMap with the specified liquid type, scanning outward to reach other lakes within scanWidth.
// Any wreath of shallow liquid must be done elsewhere.
function fillLake(x, y, liquid, scanWidth, wreathMap, unfilledLakeMap) {
	let i, j;

	for (i = x - scanWidth; i <= x + scanWidth; i++) {
		for (j = y - scanWidth; j <= y + scanWidth; j++) {
			if (coordinatesAreInMap(i, j) && unfilledLakeMap[i][j]) {
				unfilledLakeMap[i][j] = false;
				pmap[i][j].layers[LIQUID] = liquid;
				wreathMap[i][j] = 1;
				fillLake(i, j, liquid, scanWidth, wreathMap, unfilledLakeMap);	// recursive
			}
		}
	}
}

function lakeFloodFill(x, y, floodMap, grid, lakeMap, dungeonToGridX, dungeonToGridY) {
    let newX, newY;
    let dir;

    floodMap[x][y] = true;
    for (dir=0; dir<4; dir++) {
        newX = x + nbDirs[dir][0];
        newY = y + nbDirs[dir][1];
        if (coordinatesAreInMap(newX, newY)
            && !floodMap[newX][newY]
            && (!cellHasTerrainFlag(newX, newY, T_PATHING_BLOCKER) || cellHasTMFlag(newX, newY, TM_CONNECTS_LEVEL))
            && !lakeMap[newX][newY]
            && (!coordinatesAreInMap(newX+dungeonToGridX, newY+dungeonToGridY) || !grid[newX+dungeonToGridX][newY+dungeonToGridY])) {

            lakeFloodFill(newX, newY, floodMap, grid, lakeMap, dungeonToGridX, dungeonToGridY);
        }
    }
}

function lakeDisruptsPassability(grid, lakeMap, dungeonToGridX, dungeonToGridY) {
    let result;
    let i, j, x, y;
    let floodMap;

    floodMap = allocGrid();
    fillGrid(floodMap, 0);
    x = y = -1;
    // Get starting location for the fill.
    for (i=0; i<DCOLS && x == -1; i++) {
        for (j=0; j<DROWS && x == -1; j++) {
            if (!cellHasTerrainFlag(i, j, T_PATHING_BLOCKER)
                && !lakeMap[i][j]
                && (!coordinatesAreInMap(i+dungeonToGridX, j+dungeonToGridY) || !grid[i+dungeonToGridX][j+dungeonToGridY])) {

                x = i;
                y = j;
            }
        }
    }
    brogueAssert(x != -1);
    // Do the flood fill.
    lakeFloodFill(x, y, floodMap, grid, lakeMap, dungeonToGridX, dungeonToGridY);

    // See if any dry tiles weren't reached by the flood fill.
    result = false;
    for (i=0; i<DCOLS && result == false; i++) {
        for (j=0; j<DROWS && result == false; j++) {
            if (!cellHasTerrainFlag(i, j, T_PATHING_BLOCKER)
                && !lakeMap[i][j]
                && !floodMap[i][j]
                && (!coordinatesAreInMap(i+dungeonToGridX, j+dungeonToGridY) || !grid[i+dungeonToGridX][j+dungeonToGridY])) {

//                if (D_INSPECT_LEVELGEN) {
//                    dumpLevelToScreen();
//                    hiliteGrid(lakeMap, /* Color. */darkBlue, 75);
//                    hiliteGrid(floodMap, /* Color. */white, 20);
//                    plotCharWithColor('X', mapToWindowX(i), mapToWindowY(j), /* Color. */black, /* Color. */red);
//                    temporaryMessage("Failed here.", true);
//                }

                result = true;
            }
        }
    }

    freeGrid(floodMap);
    return result;
}

async function designLakes(lakeMap) {
    let i, j, k;
    let x, y;
    let lakeMaxHeight, lakeMaxWidth;

    let grid; // Holds the current lake.

    grid = allocGrid();
    fillGrid(lakeMap, 0);
		for (lakeMaxHeight = 15, lakeMaxWidth = 30; lakeMaxHeight >=10; lakeMaxHeight--, lakeMaxWidth -= 2) { // lake generations

        fillGrid(grid, 0);
        const bounds = createBlobOnGrid(grid, 5, 4, 4, lakeMaxWidth, lakeMaxHeight, 55, "ffffftttt", "ffffttttt");

//        if (D_INSPECT_LEVELGEN) {
//            colorOverDungeon(/* Color. */darkGray);
//            hiliteGrid(grid, /* Color. */white, 100);
//            temporaryMessage("Generated a lake.", true);
//        }

		for (k=0; k<20; k++) { // placement attempts
			// propose a position for the top-left of the grid in the dungeon
			x = rand_range(1 - bounds.x, DCOLS - bounds.width - bounds.x - 2);
			y = rand_range(1 - bounds.y, DROWS - bounds.height - bounds.y - 2);

        if (!lakeDisruptsPassability(grid, lakeMap, -x, -y)) { // level with lake is completely connected
				//printf("Placed a lake!");

				// copy in lake
				for (i = 0; i < bounds.width; i++) {
					for (j = 0; j < bounds.height; j++) {
              if (grid[i + bounds.x][j + bounds.y]) {
                  lakeMap[i + bounds.x + x][j + bounds.y + y] = true;
                  pmap[i + bounds.x + x][j + bounds.y + y].layers[DUNGEON] = FLOOR;
              }
					}
				}

				if (D_INSPECT_LAKES) {
					dumpLevelToScreen();
					hiliteGrid(lakeMap, /* Color. */white, 50);
					await temporaryMessage("Added a lake location.", true);
				}
				break;
			}
		}
	}
  freeGrid(grid);
}

function createWreath(shallowLiquid, wreathWidth, wreathMap) {
	let i, j, k, l;
	for (i=0; i<DCOLS; i++) {
		for (j=0; j<DROWS; j++) {
			if (wreathMap[i][j]) {
				for (k = i-wreathWidth; k<= i+wreathWidth; k++) {
					for (l = j-wreathWidth; l <= j+wreathWidth; l++) {
						if (coordinatesAreInMap(k, l) && pmap[k][l].layers[LIQUID] == NOTHING
							&& (i-k)*(i-k) + (j-l)*(j-l) <= wreathWidth*wreathWidth) {
							pmap[k][l].layers[LIQUID] = shallowLiquid;
							if (pmap[k][l].layers[DUNGEON] == DOOR) {
								pmap[k][l].layers[DUNGEON] = FLOOR;
							}
						}
					}
				}
			}
		}
	}
}

async function fillLakes(lakeMap) {
	let deepLiquid = CRYSTAL_WALL, shallowLiquid = CRYSTAL_WALL, shallowLiquidWidth = 0;
	let wreathMap = allocGrid(); // [DCOLS][DROWS];
  let i, j;

  for (i=0; i<DCOLS; i++) {
		for (j=0; j<DROWS; j++) {
			if (lakeMap[i][j]) {
				const liquid = liquidType();
				if (liquid) {
					deepLiquid = liquid.deep;
					shallowLiquid = liquid.shallow;
					shallowLiquidWidth = liquid.shallowWidth;
				}
				zeroOutGrid(wreathMap);
				fillLake(i, j, deepLiquid, 4, wreathMap, lakeMap);
				createWreath(shallowLiquid, shallowLiquidWidth, wreathMap);

				if (D_INSPECT_LAKES) {
					dumpLevelToScreen();
					hiliteGrid(lakeMap, /* Color. */blue, 75);
					hiliteGrid(wreathMap, /* Color. */white, 50);
					await temporaryMessage("Lake filled.", true);
				}
			}
		}
	}
	freeGrid(wreathMap);

	if (D_INSPECT_LEVELGEN && !D_INSPECT_LAKES) {
		dumpLevelToScreen();
		await temporaryMessage('Added lakes', true);
	}
}

function finishDoors() {
  let i, j;
  const secretDoorChance = clamp( Math.floor((rogue.depthLevel - 1) * 67 / 25), 0, 67);

	for (i=1; i<DCOLS-1; i++) {
		for (j=1; j<DROWS-1; j++) {
			if (pmap[i][j].layers[DUNGEON] == DOOR
          && pmap[i][j].machineNumber == 0)
			{
				if ((!cellHasTerrainFlag(i+1, j, T_OBSTRUCTS_PASSABILITY) || !cellHasTerrainFlag(i-1, j, T_OBSTRUCTS_PASSABILITY))
					&& (!cellHasTerrainFlag(i, j+1, T_OBSTRUCTS_PASSABILITY) || !cellHasTerrainFlag(i, j-1, T_OBSTRUCTS_PASSABILITY))) {
					// If there's passable terrain to the left or right, and there's passable terrain
					// above or below, then the door is orphaned and must be removed.
					pmap[i][j].layers[DUNGEON] = FLOOR;
				} else if ((cellHasTerrainFlag(i+1, j, T_PATHING_BLOCKER) ? 1 : 0)
						   + (cellHasTerrainFlag(i-1, j, T_PATHING_BLOCKER) ? 1 : 0)
						   + (cellHasTerrainFlag(i, j+1, T_PATHING_BLOCKER) ? 1 : 0)
						   + (cellHasTerrainFlag(i, j-1, T_PATHING_BLOCKER) ? 1 : 0) >= 3) {
					// If the door has three or more pathing blocker neighbors in the four cardinal directions,
					// then the door is orphaned and must be removed.
					pmap[i][j].layers[DUNGEON] = FLOOR;
				} else if (rand_percent(secretDoorChance)) {
					pmap[i][j].layers[DUNGEON] = SECRET_DOOR;
				}
			}
		}
	}
}

function clearLevel() {
    let i, j;

    for( i=0; i<DCOLS; i++ ) {
		for( j=0; j<DROWS; j++ ) {
			pmap[i][j].layers[DUNGEON] = GRANITE;
			pmap[i][j].layers[LIQUID] = NOTHING;
			pmap[i][j].layers[GAS] = NOTHING;
			pmap[i][j].layers[SURFACE] = NOTHING;
			pmap[i][j].machineNumber = 0;
			pmap[i][j].rememberedTerrain = NOTHING;
      pmap[i][j].rememberedTerrainFlags = (T_OBSTRUCTS_EVERYTHING);
      pmap[i][j].rememberedTMFlags = 0;
      pmap[i][j].rememberedCellFlags = 0;
			pmap[i][j].rememberedItemCategory = 0;
			pmap[i][j].rememberedItemKind = 0;
			pmap[i][j].rememberedItemQuantity = 0;
			pmap[i][j].flags = 0;
			pmap[i][j].volume = 0;
		}
	}
}

// Scans the map in random order looking for a good place to build a bridge.
// If it finds one, it builds a bridge there, halts and returns true.
function buildABridge() {
	let i, j, k, l, i2, j2;
	let nCols = []; // [DCOLS],
	let nRows = []; // [DROWS];
	let bridgeRatioX, bridgeRatioY;
	let foundExposure;

	bridgeRatioX = Math.floor(100 + Math.floor(100 + 100 * rogue.depthLevel / 9) * rand_range(10, 20) / 10);
	bridgeRatioY = Math.floor(100 + Math.floor(400 + 100 * rogue.depthLevel / 18) * rand_range(10, 20) / 10);

	fillSequentialList(nCols, DCOLS);
  shuffleList(nCols, DCOLS);
  fillSequentialList(nRows, DROWS);
  shuffleList(nRows, DROWS);

	for (i2=1; i2<DCOLS-1; i2++) {
		i = nCols[i2];
		for (j2=1; j2<DROWS-1; j2++) {
			j = nRows[j2];
			if (!cellHasTerrainFlag(i, j, (T_CAN_BE_BRIDGED | T_PATHING_BLOCKER))
				&& !pmap[i][j].machineNumber)
			{
				// try a horizontal bridge
				foundExposure = false;
				for (k = i + 1;
					 k < DCOLS // Iterate across the prospective length of the bridge.
					 && !pmap[k][j].machineNumber // No bridges in machines.
					 && cellHasTerrainFlag(k, j, T_CAN_BE_BRIDGED)	// Candidate tile must be chasm.
           && !cellHasTMFlag(k, j, TM_IS_SECRET) // Can't bridge over secret trapdoors.
					 && !cellHasTerrainFlag(k, j, T_OBSTRUCTS_PASSABILITY)	// Candidate tile cannot be a wall.
					 && cellHasTerrainFlag(k, j-1, (T_CAN_BE_BRIDGED | T_OBSTRUCTS_PASSABILITY))	// Only chasms or walls are permitted next to the length of the bridge.
					 && cellHasTerrainFlag(k, j+1, (T_CAN_BE_BRIDGED | T_OBSTRUCTS_PASSABILITY));
					 k++)
				 {
					if (!cellHasTerrainFlag(k, j-1, T_OBSTRUCTS_PASSABILITY) // Can't run against a wall the whole way.
						&& !cellHasTerrainFlag(k, j+1, T_OBSTRUCTS_PASSABILITY)) {
						foundExposure = true;
					}
				}
				if (k < DCOLS
					&& (k - i > 3) // Can't have bridges shorter than 3 spaces.
					&& foundExposure
					&& !cellHasTerrainFlag(k, j, T_PATHING_BLOCKER | T_CAN_BE_BRIDGED) // Must end on an unobstructed land tile.
					&& !pmap[k][j].machineNumber // Cannot end in a machine.
					&& Math.floor(100 * pathingDistance(i, j, k, j, T_PATHING_BLOCKER) / (k - i)) > bridgeRatioX) { // Must shorten the pathing distance enough.

					for (l=i+1; l < k; l++) {
						pmap[l][j].layers[LIQUID] = BRIDGE;
					}
					pmap[i][j].layers[SURFACE] = BRIDGE_EDGE;
					pmap[k][j].layers[SURFACE] = BRIDGE_EDGE;
					return true;
				}

				// try a vertical bridge
				foundExposure = false;
				for (k = j + 1;
					 k < DROWS
					 && !pmap[i][k].machineNumber
					 && cellHasTerrainFlag(i, k, T_CAN_BE_BRIDGED)
           && !cellHasTMFlag(i, k, TM_IS_SECRET)
					 && !cellHasTerrainFlag(i, k, T_OBSTRUCTS_PASSABILITY)
					 && cellHasTerrainFlag(i-1, k, (T_CAN_BE_BRIDGED | T_OBSTRUCTS_PASSABILITY))
					 && cellHasTerrainFlag(i+1, k, (T_CAN_BE_BRIDGED | T_OBSTRUCTS_PASSABILITY));
					 k++)
				 {
					if (!cellHasTerrainFlag(i-1, k, T_OBSTRUCTS_PASSABILITY)
						&& !cellHasTerrainFlag(i+1, k, T_OBSTRUCTS_PASSABILITY)) {
						foundExposure = true;
					}
				}
				if (k < DROWS
					&& (k - j > 3)
					&& foundExposure
					&& !cellHasTerrainFlag(i, k, T_PATHING_BLOCKER | T_CAN_BE_BRIDGED)
					&& !pmap[i][k].machineNumber // Cannot end in a machine.
					&& Math.floor(100 * pathingDistance(i, j, i, k, T_PATHING_BLOCKER) / (k - j)) > bridgeRatioY)
				{
					for (l=j+1; l < k; l++) {
						pmap[i][l].layers[LIQUID] = BRIDGE;
					}
					pmap[i][j].layers[SURFACE] = BRIDGE_EDGE;
					pmap[i][k].layers[SURFACE] = BRIDGE_EDGE;
					return true;
				}
			}
		}
	}
	return false;
}

// This is the master function for digging out a dungeon level.
// Finishing touches -- items, monsters, staircases, etc. -- are handled elsewhere.
async function digDungeon() {
	let i, j;
  let grid;

	rogue.machineNumber = 0;

	topBlobMinX = topBlobMinY = blobWidth = blobHeight = 0;

// #ifdef AUDIT_RNG
// 	const RNGMessage = STRING(); // [100];
// 	sprintf(RNGMessage, "\n\n\nDigging dungeon level %i:\n", rogue.depthLevel);
// 	RNGLog(RNGMessage);
// #endif

	// Clear level and fill with granite
	clearLevel();

	logRNG();

  grid = allocGrid();
  await carveDungeon(grid);
  await addLoops(grid, 20);
  for (i=0; i<DCOLS; i++) {
      for (j=0; j<DROWS; j++) {
          if (grid[i][j] == 1) {
              pmap[i][j].layers[DUNGEON] = FLOOR;
          } else if (grid[i][j] == 2) {
              pmap[i][j].layers[DUNGEON] = (rand_percent(60) && rogue.depthLevel < DEEPEST_LEVEL ? DOOR : FLOOR);
          }
      }
  }
  freeGrid(grid);

  finishWalls(false);

	if (D_INSPECT_LEVELGEN) {
		dumpLevelToScreen();
    await temporaryMessage("Carved into the granite:", true);
	}
	//DEBUG printf("\n%i loops created.", numLoops);
	//DEBUG logLevel();

	// Time to add lakes and chasms. Strategy is to generate a series of blob lakes of decreasing size. For each lake,
	// propose a position, and then check via a flood fill that the level would remain connected with that placement (i.e. that
	// each passable tile can still be reached). If not, make 9 more placement attempts before abandoning that lake
	// and proceeding to generate the next smaller one.
	// Canvas sizes start at 30x15 and decrease by 2x1 at a time down to a minimum of 20x10. Min generated size is always 4x4.

	// DEBUG logLevel();

	// Now design the lakes and then fill them with various liquids (lava, water, chasm, brimstone).
  let lakeMap = allocGrid();
	await designLakes(lakeMap);
	await fillLakes(lakeMap);
  freeGrid(lakeMap);

	// Run the non-machine autoGenerators.
	await runAutogenerators(false);

	// Remove diagonal openings.
	removeDiagonalOpenings();

	if (D_INSPECT_LEVELGEN) {
		dumpLevelToScreen();
		await temporaryMessage("Diagonal openings removed.", true);
	}

	// Now add some treasure machines.
	await addMachines();

	if (D_INSPECT_LEVELGEN) {
		dumpLevelToScreen();
		await temporaryMessage("Treasure Machines added.", true);
	}

	// Run the machine autoGenerators.
	await runAutogenerators(true);

	if (D_INSPECT_LEVELGEN) {
		dumpLevelToScreen();
		await temporaryMessage("Autogenerator Machines added.", true);
	}

	// Now knock down the boundaries between similar lakes where possible.
	cleanUpLakeBoundaries();

	if (D_INSPECT_LEVELGEN) {
		dumpLevelToScreen();
		await temporaryMessage("Lake boundaries cleaned up.", true);
	}

	// Now add some bridges.
	while (buildABridge());

	if (D_INSPECT_LEVELGEN) {
		dumpLevelToScreen();
		await temporaryMessage("Bridges added.", true);
	}

	// Now remove orphaned doors and upgrade some doors to secret doors
  finishDoors();

	// Now finish any exposed granite with walls and revert any unexposed walls to granite
	finishWalls(true);

	if (D_INSPECT_LEVELGEN) {
		dumpLevelToScreen();
		await temporaryMessage("Finishing touches added. Level has been generated.", true);
	}
}

function updateMapToShore() {
	let i, j;
	let costMap;

	rogue.updatedMapToShoreThisTurn = true;

	costMap = allocGrid();

	// Calculate the map to shore for this level
	if (!rogue.mapToShore) {
		rogue.mapToShore = allocGrid();
		fillGrid(rogue.mapToShore, 0);
	}
	for (i=0; i<DCOLS; i++) {
		for (j=0; j<DROWS; j++) {
			if (cellHasTerrainFlag(i, j, T_OBSTRUCTS_PASSABILITY)) {
				costMap[i][j] = cellHasTerrainFlag(i, j, T_OBSTRUCTS_DIAGONAL_MOVEMENT) ? PDS_OBSTRUCTION : PDS_FORBIDDEN;
				rogue.mapToShore[i][j] = 30000;
			} else {
				costMap[i][j] = 1;
				rogue.mapToShore[i][j] = (cellHasTerrainFlag(i, j, T_LAVA_INSTA_DEATH | T_IS_DEEP_WATER | T_AUTO_DESCENT)
										  && !cellHasTMFlag(i, j, TM_IS_SECRET)) ? 30000 : 0;
			}
		}
	}
	dijkstraScan(rogue.mapToShore, costMap, true);
	freeGrid(costMap);
}

// Calculates the distance map for the given waypoint.
// This is called on all waypoints during setUpWaypoints(),
// and then one waypoint is recalculated per turn thereafter.
function refreshWaypoint(wpIndex) {
    let costMap;
    let monst;

    costMap = allocGrid();
    populateGenericCostMap(costMap);

    for (monst = monsters.nextCreature; monst != NULL; monst = monst.nextCreature) {
        if ((monst.creatureState == MONSTER_SLEEPING || (monst.info.flags & MONST_IMMOBILE) || (monst.bookkeepingFlags & MB_CAPTIVE))
            && costMap[monst.xLoc][monst.yLoc] >= 0)
				{
            costMap[monst.xLoc][monst.yLoc] = PDS_FORBIDDEN;
        }
    }
    fillGrid(rogue.wpDistance[wpIndex], 30000);
    rogue.wpDistance[wpIndex][rogue.wpCoordinates[wpIndex][0]][rogue.wpCoordinates[wpIndex][1]] = 0;
    dijkstraScan(rogue.wpDistance[wpIndex], costMap, true);
    freeGrid(costMap);
}

function setUpWaypoints() {
	let i, j;
	let sCoord = []; // [DCOLS * DROWS],
	let x, y;
	let grid = allocGrid(); // [DCOLS][DROWS];

	zeroOutGrid(grid);
	for (i=0; i<DCOLS; i++) {
		for (j=0; j<DROWS; j++) {
            if (cellHasTerrainFlag(i, j, T_OBSTRUCTS_SCENT)) {
                grid[i][j] = 1;
            }
        }
    }
    rogue.wpCount = 0;
    rogue.wpRefreshTicker = 0;
    fillSequentialList(sCoord, DCOLS*DROWS);
    shuffleList(sCoord, DCOLS*DROWS);
    for (i = 0; i < DCOLS*DROWS && rogue.wpCount < MAX_WAYPOINT_COUNT; i++) {
        x = Math.floor(sCoord[i]/DROWS);
        y = sCoord[i] % DROWS;
        if (!grid[x][y]) {
            getFOVMask(grid, x, y, WAYPOINT_SIGHT_RADIUS << FP_BASE, T_OBSTRUCTS_SCENT, 0, false);
            grid[x][y] = true;
            rogue.wpCoordinates[rogue.wpCount] = [x,y];
            rogue.wpCount++;
//            blackOutScreen();
//            dumpLevelToScreen();
//            hiliteCharGrid(grid, /* Color. */yellow, 50);
//            temporaryMessage("Waypoint coverage so far:", true);
        }
    }

    for (i=0; i<rogue.wpCount; i++) {
        refreshWaypoint(i);
//        blackOutScreen();
//        dumpLevelToScreen();
//        displayGrid(rogue.wpDistance[i]);
//        temporaryMessage("Waypoint distance map:", true);
    }

		freeGrid(grid);
}

function zeroOutGrid(grid) {
	let i, j;
	for (i=0; i<DCOLS; i++) {
		for (j=0; j<DROWS; j++) {
			grid[i][j] = 0;
		}
	}
}

function oppositeDirection(theDir) {
	switch (theDir) {
        case UP:
            return DOWN;
        case DOWN:
            return UP;
        case LEFT:
            return RIGHT;
        case RIGHT:
            return LEFT;
        case UPRIGHT:
            return DOWNLEFT;
        case DOWNLEFT:
            return UPRIGHT;
        case UPLEFT:
            return DOWNRIGHT;
        case DOWNRIGHT:
            return UPLEFT;
        case NO_DIRECTION:
            return NO_DIRECTION;
        default:
            return -1;
	}
}

// blockingMap is optional.
// Returns the size of the connected zone, and marks visited[][] with the zoneLabel.
function connectCell(x, y, zoneLabel, blockingMap, zoneMap) {
	let dir;
	let newX, newY, size;

	zoneMap[x][y] = zoneLabel;
	size = 1;

	for (dir = 0; dir < 4; dir++) {
		newX = x + nbDirs[dir][0];
		newY = y + nbDirs[dir][1];

		if (coordinatesAreInMap(newX, newY)
			&& zoneMap[newX][newY] == 0
			&& (!blockingMap || !blockingMap[newX][newY])
			&& cellIsPassableOrDoor(newX, newY))
		{
			size += connectCell(newX, newY, zoneLabel, blockingMap, zoneMap);
		}
	}
	return size;
}

// Make a zone map of connected passable regions that include at least one passable
// cell that borders the blockingMap if blockingMap blocks. Keep track of the size of each zone.
// Then pretend that the blockingMap no longer blocks, and grow these zones into the resulting area
// (without changing the stored zone sizes). If two or more zones now touch, then we block.
// At that point, return the size in cells of the smallest of all of the touching regions
// (or just 1, i.e. true, if countRegionSize is false). If no zones touch, then we don't block, and we return zero, i.e. false.
function levelIsDisconnectedWithBlockingMap(blockingMap, countRegionSize) {
	let zoneMap = allocGrid(); // [DCOLS][DROWS];
	let i, j, dir;
	let zoneSizes = []; // [200],
	let zoneCount, smallestQualifyingZoneSize, borderingZone;

	zoneCount = 0;
	smallestQualifyingZoneSize = 10000;
	zeroOutGrid(zoneMap);

//	dumpLevelToScreen();
//	hiliteCharGrid(blockingMap, /* Color. */omniscienceColor, 100);
//	temporaryMessage("Blocking map:", true);

	// Map out the zones with the blocking area blocked.
	for (i=1; i<DCOLS-1; i++) {
		for (j=1; j<DROWS-1; j++) {
			if (cellIsPassableOrDoor(i, j) && zoneMap[i][j] == 0 && !blockingMap[i][j]) {
				for (dir=0; dir<4; dir++) {
					if (blockingMap[i + nbDirs[dir][0]][j + nbDirs[dir][1]]) {
						zoneCount++;
						zoneSizes[zoneCount - 1] = connectCell(i, j, zoneCount, blockingMap, zoneMap);
						break;
					}
				}
			}
		}
	}

	// Expand the zones into the blocking area.
	for (i=1; i<DCOLS-1; i++) {
		for (j=1; j<DROWS-1; j++) {
			if (blockingMap[i][j] && zoneMap[i][j] == 0	&& cellIsPassableOrDoor(i, j)) {
				for (dir=0; dir<4; dir++) {
					borderingZone = zoneMap[i + nbDirs[dir][0]][j + nbDirs[dir][1]];
					if (borderingZone != 0) {
						connectCell(i, j, borderingZone, NULL, zoneMap);
						break;
					}
				}
			}
		}
	}

	// Figure out which zones touch.
	for (i=1; i<DCOLS-1; i++) {
		for (j=1; j<DROWS-1; j++) {
			if (zoneMap[i][j] != 0) {
				for (dir=0; dir<4; dir++) {
					borderingZone = zoneMap[i + nbDirs[dir][0]][j + nbDirs[dir][1]];
					if (zoneMap[i][j] != borderingZone && borderingZone != 0) {
						if (!countRegionSize) {
							return true;
						}
						smallestQualifyingZoneSize = Math.min(smallestQualifyingZoneSize, zoneSizes[zoneMap[i][j] - 1]);
						smallestQualifyingZoneSize = Math.min(smallestQualifyingZoneSize, zoneSizes[borderingZone - 1]);
						break;
					}
				}
			}
		}
	}
	freeGrid(zoneMap);
	return (smallestQualifyingZoneSize < 10000 ? smallestQualifyingZoneSize : 0);
}


function resetDFMessageEligibility() {
	let i;

	for (i=0; i<NUMBER_DUNGEON_FEATURES; i++) {
		dungeonFeatureCatalog[i].messageDisplayed = false;
	}
}

async function fillSpawnMap(layer,
					 surfaceTileType,
					 spawnMap,
					 blockedByOtherLayers,
					 refresh,
					 superpriority)
{
	let i, j;
	let monst;
	let theItem;
	let accomplishedSomething;

	accomplishedSomething = false;

	for (i=0; i<DCOLS; i++) {
		for (j=0; j<DROWS; j++) {
			if (	// If it's flagged for building in the spawn map,
				spawnMap[i][j]
					// and the new cell doesn't already contain the fill terrain,
				&& pmap[i][j].layers[layer] != surfaceTileType
					// and the terrain in the layer to be overwritten has a higher priority number (unless superpriority),
				&& (superpriority || tileCatalog[pmap[i][j].layers[layer]].drawPriority >= tileCatalog[surfaceTileType].drawPriority)
					// and we won't be painting into the surface layer when that cell forbids it,
				&& !(layer == SURFACE && cellHasTerrainFlag(i, j, T_OBSTRUCTS_SURFACE_EFFECTS))
					// and, if requested, the fill won't violate the priority of the most important terrain in this cell:
				&& (!blockedByOtherLayers || tileCatalog[pmap[i][j].layers[highestPriorityLayer(i, j, true)]].drawPriority >= tileCatalog[surfaceTileType].drawPriority)
				) {

				if ((tileCatalog[surfaceTileType].flags & T_IS_FIRE)
					&& !(tileCatalog[pmap[i][j].layers[layer]].flags & T_IS_FIRE))
				{
					pmap[i][j].flags |= CAUGHT_FIRE_THIS_TURN;
				}

				if ((tileCatalog[pmap[i][j].layers[layer]].flags & T_PATHING_BLOCKER)
					!= (tileCatalog[surfaceTileType].flags & T_PATHING_BLOCKER))
				{
					rogue.staleLoopMap = true;
				}

				pmap[i][j].layers[layer] = surfaceTileType; // Place the terrain!
				accomplishedSomething = true;

				if (refresh) {
					refreshDungeonCell(i, j);
					if (player.xLoc == i && player.yLoc == j && !player.status[STATUS_LEVITATING] && refresh) {
						flavorMessage(tileFlavor(player.xLoc, player.yLoc));
					}
					if (pmap[i][j].flags & (HAS_MONSTER)) {
						monst = monsterAtLoc(i, j);
						await applyInstantTileEffectsToCreature(monst);
						if (rogue.gameHasEnded) {
							return true;
						}
					}
					if (tileCatalog[surfaceTileType].flags & T_IS_FIRE) {
						if (pmap[i][j].flags & HAS_ITEM) {
							theItem = itemAtLoc(i, j);
							if (theItem.flags & ITEM_FLAMMABLE) {
								await burnItem(theItem);
							}
						}
					}
				}
			} else {
				spawnMap[i][j] = false; // so that the spawnmap reflects what actually got built
			}
		}
	}
	return accomplishedSomething;
}

function spawnMapDF(x, y,
				propagationTerrain,
				requirePropTerrain,
				startProb,
				probDec,
				spawnMap)
{
	let i, j, dir, t, x2, y2;
	let madeChange;

	spawnMap[x][y] = t = 1; // incremented before anything else happens

	madeChange = true;

	while (madeChange && startProb > 0) {
		madeChange = false;
		t++;
		for (i = 0; i < DCOLS; i++) {
			for (j=0; j < DROWS; j++) {
				if (spawnMap[i][j] == t - 1) {
					for (dir = 0; dir < 4; dir++) {
						x2 = i + nbDirs[dir][0];
						y2 = j + nbDirs[dir][1];
						if (coordinatesAreInMap(x2, y2)
							&& (!requirePropTerrain || (propagationTerrain > 0 && cellHasTerrainType(x2, y2, propagationTerrain)))
							&& (!cellHasTerrainFlag(x2, y2, T_OBSTRUCTS_SURFACE_EFFECTS) || (propagationTerrain > 0 && cellHasTerrainType(x2, y2, propagationTerrain)))
							&& rand_percent(startProb))
						{
							spawnMap[x2][y2] = t;
							madeChange = true;
						}
					}
				}
			}
		}
		startProb -= probDec;
		if (t > 100) {
			for (i = 0; i < DCOLS; i++) {
				for (j=0; j < DROWS; j++) {
					if (spawnMap[i][j] == t) {
						spawnMap[i][j] = 2;
					} else if (spawnMap[i][j] > 0) {
						spawnMap[i][j] = 1;
					}
				}
			}
			t = 2;
		}
	}
	if (requirePropTerrain && !cellHasTerrainType(x, y, propagationTerrain)) {
			spawnMap[x][y] = 0;
	}
}

function evacuateCreatures(blockingMap) {
	let i, j;
	let newLoc;
	let monst;

	for (i=0; i<DCOLS; i++) {
		for (j=0; j<DROWS; j++) {
			if (blockingMap[i][j]
				&& (pmap[i][j].flags & (HAS_MONSTER | HAS_PLAYER)))
			{
				monst = monsterAtLoc(i, j);
				const loc = getQualifyingLocNear(
									 i, j,
									 true,
									 blockingMap,
									 forbiddenFlagsForMonster(monst.info),
									 (HAS_MONSTER | HAS_PLAYER),
									 false,
									 false);
				monst.xLoc = loc[0];
				monst.yLoc = loc[1];
				pmap[i][j].flags &= ~(HAS_MONSTER | HAS_PLAYER);
				pmap[loc[0]][loc[1]].flags |= (monst === player ? HAS_PLAYER : HAS_MONSTER);
			}
		}
	}
}




// returns whether the feature was successfully generated (false if we aborted because of blocking)
async function spawnDungeonFeature(x, y, feat, refreshCell, abortIfBlocking) {
	let i, j, layer;
	let blocking;
	let succeeded;
	let monst;

  if ((feat.flags & DFF_RESURRECT_ALLY) && !resurrectAlly(x, y))
	{
      return false;
  }

  if (feat.description[0] && !feat.messageDisplayed && playerCanSee(x, y)) {
		feat.messageDisplayed = true;
		message(feat.description, false);
	}

	let blockingMap = allocGrid(); // [DCOLS][DROWS];
	zeroOutGrid(blockingMap);

  // Blocking keeps track of whether to abort if it turns out that the DF would obstruct the level.
  blocking = ((abortIfBlocking
               && !(feat.flags & DFF_PERMIT_BLOCKING)
               && ((tileCatalog[feat.tile].flags & (T_PATHING_BLOCKER))
                   || (feat.flags & DFF_TREAT_AS_BLOCKING))) ? true : false);

    if (feat.tile) {
        if (feat.layer == GAS) {
            pmap[x][y].volume += feat.startProbability;
            pmap[x][y].layers[GAS] = feat.tile;
            if (refreshCell) {
                refreshDungeonCell(x, y);
            }
            succeeded = true;
        } else {
            spawnMapDF(x, y,
                       feat.propagationTerrain,
                       (feat.propagationTerrain ? true : false),
                       feat.startProbability,
                       feat.probabilityDecrement,
                       blockingMap);

						if (D_INSPECT_AUTOGENERATORS) {
							let spawnCount = 0;
							for(i = 0; i < DCOLS; ++i) {
								for(j = 0; j < DROWS; ++j) {
									if (blockingMap[i][j]) {
										spawnCount += 1;
									}
								}
							}
							await temporaryMessage(`Spawn ${spawnCount} cells.`, true);
						}

            if (!blocking || !levelIsDisconnectedWithBlockingMap(blockingMap, false)) {
                if (feat.flags & DFF_EVACUATE_CREATURES_FIRST) { // first, evacuate creatures if necessary, so that they do not re-trigger the tile.
                    evacuateCreatures(blockingMap);
                }

                //succeeded = fillSpawnMap(feat.layer, feat.tile, blockingMap, (feat.flags & DFF_BLOCKED_BY_OTHER_LAYERS), refreshCell, (feat.flags & DFF_SUPERPRIORITY));
                await fillSpawnMap(feat.layer,
                             feat.tile,
                             blockingMap,
                             (feat.flags & DFF_BLOCKED_BY_OTHER_LAYERS),
                             refreshCell,
                             (feat.flags & DFF_SUPERPRIORITY)); // this can tweak the spawn map too
                succeeded = true; // fail ONLY if we blocked the level. We succeed even if, thanks to priority, nothing gets built.
            } else {
                succeeded = false;
            }
        }
    } else {
        blockingMap[x][y] = true;
        succeeded = true; // Automatically succeed if there is no terrain to place.
        if (feat.flags & DFF_EVACUATE_CREATURES_FIRST) { // first, evacuate creatures if necessary, so that they do not re-trigger the tile.
            evacuateCreatures(blockingMap);
        }
    }

    if (succeeded && (feat.flags & DFF_CLEAR_OTHER_TERRAIN)) {
        for (i=0; i<DCOLS; i++) {
            for (j=0; j<DROWS; j++) {
                if (blockingMap[i][j]) {
                    for (layer = 0; layer < NUMBER_TERRAIN_LAYERS; layer++) {
                        if (layer != feat.layer && layer != GAS) {
                            pmap[i][j].layers[layer] = (layer == DUNGEON ? FLOOR : NOTHING);
                        }
					}
				}
			}
		}
	}

  if (succeeded) {
      if ((feat.flags & DFF_AGGRAVATES_MONSTERS) && feat.effectRadius) {
          await aggravateMonsters(feat.effectRadius, x, y, /* Color. */gray);
      }
      if (refreshCell && feat.flashColor && feat.effectRadius) {
          await colorFlash(feat.flashColor, 0, (IN_FIELD_OF_VIEW | CLAIRVOYANT_VISIBLE), 4, feat.effectRadius, x, y);
      }
      if (refreshCell && feat.lightFlare) {
          createFlare(x, y, feat.lightFlare);
      }
  }

	if (refreshCell
		&& (tileCatalog[feat.tile].flags & (T_IS_FIRE | T_AUTO_DESCENT))
		&& cellHasTerrainFlag(player.xLoc, player.yLoc, (T_IS_FIRE | T_AUTO_DESCENT)))
	{
		await applyInstantTileEffectsToCreature(player);
	}
	if (rogue.gameHasEnded) {
		freeGrid(blockingMap);
		return succeeded;
	}
    //	if (succeeded && feat.description[0] && !feat.messageDisplayed && playerCanSee(x, y)) {
    //		feat.messageDisplayed = true;
    //		message(feat.description, false);
    //	}
    if (succeeded) {
        if (feat.subsequentDF) {
            if (feat.flags & DFF_SUBSEQ_EVERYWHERE) {
                for (i=0; i<DCOLS; i++) {
                    for (j=0; j<DROWS; j++) {
                        if (blockingMap[i][j]) {
                            await spawnDungeonFeature(i, j, dungeonFeatureCatalog[feat.subsequentDF], refreshCell, abortIfBlocking);
                        }
                    }
                }
            } else {
                await spawnDungeonFeature(x, y, dungeonFeatureCatalog[feat.subsequentDF], refreshCell, abortIfBlocking);
            }
        }
        if (feat.tile
            && (tileCatalog[feat.tile].flags & (T_IS_DEEP_WATER | T_LAVA_INSTA_DEATH | T_AUTO_DESCENT)))
				{
            rogue.updatedMapToShoreThisTurn = false;
        }

        // awaken dormant creatures?
        if (feat.flags & DFF_ACTIVATE_DORMANT_MONSTER) {
            for (monst = dormantMonsters.nextCreature; monst != NULL; monst = monst.nextCreature) {
                if (monst.xLoc == x && monst.yLoc == y || blockingMap[monst.xLoc][monst.yLoc]) {
                    // found it!
                    toggleMonsterDormancy(monst);
                    monst = dormantMonsters;
                }
            }
        }
    }

	freeGrid(blockingMap);
	return succeeded;
}

function restoreMonster(monst, mapToStairs, mapToPit) {
	let i, x, y, turnCount;//, loc[2];
	let leader;
	let foundLeader = false;
	let theMap;
  let dir;

	x = monst.xLoc;
	y = monst.yLoc;

	if (monst.status[STATUS_ENTERS_LEVEL_IN] > 0) {
		if (monst.bookkeepingFlags & (MB_APPROACHING_PIT)) {
			theMap = mapToPit;
		} else {
			theMap = mapToStairs;
		}
		if (theMap) {
			turnCount = (Math.floor(theMap[monst.xLoc][monst.yLoc] * monst.movementSpeed / 100) - monst.status[STATUS_ENTERS_LEVEL_IN]);
			for (i=0; i < turnCount; i++) {
				if ((dir = nextStep(theMap, monst.xLoc, monst.yLoc, NULL, true)) != NO_DIRECTION) {
					monst.xLoc += nbDirs[dir][0];
					monst.yLoc += nbDirs[dir][1];
				} else {
            break;
        }
			}
		}
		monst.bookkeepingFlags |= MB_PREPLACED;
	}

	if ((pmap[x][y].flags & (HAS_PLAYER | HAS_STAIRS))
		|| (monst.bookkeepingFlags & MB_PREPLACED)) {

		if (!(monst.bookkeepingFlags & MB_PREPLACED)) {
			// (If if it's preplaced, it won't have set the HAS_MONSTER flag in the first place,
			// so clearing it might screw up an existing monster.)
			pmap[x][y].flags &= ~HAS_MONSTER;
		}
        const loc = getQualifyingPathLocNear(x, y, true, T_DIVIDES_LEVEL & avoidedFlagsForMonster(monst.info), 0,
                                 avoidedFlagsForMonster(monst.info), (HAS_MONSTER | HAS_PLAYER | HAS_STAIRS), true);
				monst.xLoc = x = loc[0];
				monst.yLoc = y = loc[1];
	}
	pmap[x][y].flags |= HAS_MONSTER;
	monst.bookkeepingFlags &= ~(MB_PREPLACED | MB_APPROACHING_DOWNSTAIRS | MB_APPROACHING_UPSTAIRS | MB_APPROACHING_PIT | MB_ABSORBING);
    monst.status[STATUS_ENTERS_LEVEL_IN] = 0;
    monst.corpseAbsorptionCounter = 0;

	if ((monst.bookkeepingFlags & MB_SUBMERGED) && !cellHasTMFlag(x, y, TM_ALLOWS_SUBMERGING)) {
		monst.bookkeepingFlags &= ~MB_SUBMERGED;
	}

	if (monst.bookkeepingFlags & MB_FOLLOWER) {
		// is the leader on the same level?
		for (leader = monsters.nextCreature; leader != NULL; leader = leader.nextCreature) {
			if (leader == monst.leader) {
				foundLeader = true;
				break;
			}
		}
		// if not, it is time to spread your wings and fly solo
		if (!foundLeader) {
			monst.bookkeepingFlags &= ~MB_FOLLOWER;
			monst.leader = NULL;
		}
	}
}

function restoreItem(theItem) {
	let x, y;
	x = theItem.xLoc;
	y = theItem.yLoc;

	if (theItem.flags & ITEM_PREPLACED) {
		theItem.flags &= ~ITEM_PREPLACED;
		const loc = getQualifyingLocNear(x, y, true, 0, (T_OBSTRUCTS_ITEMS | T_AUTO_DESCENT | T_IS_DEEP_WATER | T_LAVA_INSTA_DEATH),
							 (HAS_MONSTER | HAS_ITEM | HAS_STAIRS), true, false);
		theItem.xLoc = x = loc[0];
		theItem.yLoc = y = loc[1];
	}
	pmap[x][y].flags |= HAS_ITEM;
	if (theItem.flags & ITEM_MAGIC_DETECTED && itemMagicChar(theItem)) {
		pmap[x][y].flags |= ITEM_DETECTED;
	}
}

// Returns true iff the location is a plain wall, three of the four cardinal neighbors are walls, the remaining cardinal neighbor
// is not a pathing blocker, the two diagonals between the three cardinal walls are also walls, and none of the eight neighbors are in machines.
function validStairLoc(x, y) {
	let newX, newY, dir, neighborWallCount;

	if (x < 1 || x >= DCOLS - 1 || y < 1 || y >= DROWS - 1 || pmap[x][y].layers[DUNGEON] != WALL) {
		return false;
	}

	for (dir=0; dir< DIRECTION_COUNT; dir++) {
		newX = x + nbDirs[dir][0];
		newY = y + nbDirs[dir][1];
		if (pmap[newX][newY].flags & IS_IN_MACHINE) {
			return false;
		}
  }

	neighborWallCount = 0;
	for (dir=0; dir<4; dir++) {
		newX = x + nbDirs[dir][0];
		newY = y + nbDirs[dir][1];

		if (cellHasTerrainFlag(newX, newY, T_OBSTRUCTS_PASSABILITY)) {
			// neighbor is a wall
			neighborWallCount++;
		} else {
			// neighbor is not a wall
			if (cellHasTerrainFlag(newX, newY, T_PATHING_BLOCKER)
				|| passableArcCount(newX, newY) >= 2) {
				return false;
			}
			// now check the two diagonals between the walls

			newX = x - nbDirs[dir][0] + nbDirs[dir][1];
			newY = y - nbDirs[dir][1] + nbDirs[dir][0];
			if (!cellHasTerrainFlag(newX, newY, T_OBSTRUCTS_PASSABILITY)) {
				return false;
			}

			newX = x - nbDirs[dir][0] - nbDirs[dir][1];
			newY = y - nbDirs[dir][1] - nbDirs[dir][0];
			if (!cellHasTerrainFlag(newX, newY, T_OBSTRUCTS_PASSABILITY)) {
				return false;
			}
		}
	}
	if (neighborWallCount != 3) {
		return false;
	}
	return true;
}

// The walls on either side become torches. Any adjacent granite then becomes top_wall. All wall neighbors are un-tunnelable.
// Grid is zeroed out within 5 spaces in all directions.
function prepareForStairs(x, y, grid) {
	let newX, newY, dir;

	// Add torches to either side.
	for (dir=0; dir<4; dir++) {
		if (!cellHasTerrainFlag(x + nbDirs[dir][0], y + nbDirs[dir][1], T_OBSTRUCTS_PASSABILITY)) {
			newX = x - nbDirs[dir][1];
			newY = y - nbDirs[dir][0];
			pmap[newX][newY].layers[DUNGEON] = TORCH_WALL;
			newX = x + nbDirs[dir][1];
			newY = y + nbDirs[dir][0];
			pmap[newX][newY].layers[DUNGEON] = TORCH_WALL;
			break;
		}
	}
	// Expose granite.
	for (dir=0; dir< DIRECTION_COUNT; dir++) {
		newX = x + nbDirs[dir][0];
		newY = y + nbDirs[dir][1];
		if (pmap[newX][newY].layers[DUNGEON] == GRANITE) {
			pmap[newX][newY].layers[DUNGEON] = WALL;
		}
        if (cellHasTerrainFlag(newX, newY, T_OBSTRUCTS_PASSABILITY)) {
            pmap[newX][newY].flags |= IMPREGNABLE;
        }
	}
	// Zero out grid in the vicinity.
	for (newX = Math.max(0, x - 5); newX < Math.min(DCOLS, x + 5); newX++) {
		for (newY = Math.max(0, y - 5); newY < Math.min(DROWS, y + 5); newY++) {
			grid[newX][newY] = false;
		}
	}
}

// Places the player, monsters, items and stairs.
async function initializeLevel() {
	let i, j, dir;
	let mapToStairs, mapToPit;
	let monst;
	let theItem;
	let grid = allocGrid(); // [DCOLS][DROWS];
	let n = rogue.depthLevel - 1;

	// Place the stairs.

	for (i=0; i < DCOLS; i++) {
		for (j=0; j < DROWS; j++) {
			grid[i][j] = validStairLoc(i, j);
		}
	}

	if (D_INSPECT_LEVELGEN) {
		dumpLevelToScreen();
		hiliteCharGrid(grid, /* Color. */teal, 100);
		await temporaryMessage("Stair location candidates:", true);
	}

	let downLoc = getQualifyingGridLocNear(levels[n].downStairsLoc[0], levels[n].downStairsLoc[1], grid, false);
  if (downLoc) {
      prepareForStairs(downLoc[0], downLoc[1], grid);
  } else {
      downLoc = getQualifyingLocNear(levels[n].downStairsLoc[0], levels[n].downStairsLoc[1], false, 0,
                           (T_OBSTRUCTS_PASSABILITY | T_OBSTRUCTS_ITEMS | T_AUTO_DESCENT | T_IS_DEEP_WATER | T_LAVA_INSTA_DEATH | T_IS_DF_TRAP),
                           (HAS_MONSTER | HAS_ITEM | HAS_STAIRS | IS_IN_MACHINE), true, false);
  }

  if (rogue.depthLevel == DEEPEST_LEVEL) {
      pmap[downLoc[0]][downLoc[1]].layers[DUNGEON] = DUNGEON_PORTAL;
  } else {
      pmap[downLoc[0]][downLoc[1]].layers[DUNGEON] = DOWN_STAIRS;
  }
  pmap[downLoc[0]][downLoc[1]].layers[LIQUID]     = NOTHING;
  pmap[downLoc[0]][downLoc[1]].layers[SURFACE]    = NOTHING;

  if (!levels[n+1].visited) {
      levels[n+1].upStairsLoc[0] = downLoc[0];
      levels[n+1].upStairsLoc[1] = downLoc[1];
  }
  levels[n].downStairsLoc[0] = downLoc[0];
  levels[n].downStairsLoc[1] = downLoc[1];

	let upLoc = getQualifyingGridLocNear(levels[n].upStairsLoc[0], levels[n].upStairsLoc[1], grid, false);
	if (upLoc) {
		prepareForStairs(upLoc[0], upLoc[1], grid);
	} else { // Hopefully this never happens.
		upLoc = getQualifyingLocNear(levels[n].upStairsLoc[0], levels[n].upStairsLoc[1], false, 0,
							 (T_OBSTRUCTS_PASSABILITY | T_OBSTRUCTS_ITEMS | T_AUTO_DESCENT | T_IS_DEEP_WATER | T_LAVA_INSTA_DEATH | T_IS_DF_TRAP),
							 (HAS_MONSTER | HAS_ITEM | HAS_STAIRS | IS_IN_MACHINE), true, false);
	}

	levels[n].upStairsLoc[0] = upLoc[0];
	levels[n].upStairsLoc[1] = upLoc[1];

	if (rogue.depthLevel == 1) {
		pmap[upLoc[0]][upLoc[1]].layers[DUNGEON] = DUNGEON_EXIT;
	} else {
		pmap[upLoc[0]][upLoc[1]].layers[DUNGEON] = UP_STAIRS;
	}
    pmap[upLoc[0]][upLoc[1]].layers[LIQUID] = NOTHING;
    pmap[upLoc[0]][upLoc[1]].layers[SURFACE] = NOTHING;

	rogue.downLoc[0] = downLoc[0];
	rogue.downLoc[1] = downLoc[1];
	pmap[downLoc[0]][downLoc[1]].flags |= HAS_STAIRS;
	rogue.upLoc[0] = upLoc[0];
	rogue.upLoc[1] = upLoc[1];
	pmap[upLoc[0]][upLoc[1]].flags |= HAS_STAIRS;

	if (!levels[rogue.depthLevel-1].visited) {

		// Run a field of view check from up stairs so that monsters do not spawn within sight of it.
    for (dir=0; dir<4; dir++) {
        if (coordinatesAreInMap(upLoc[0] + nbDirs[dir][0], upLoc[1] + nbDirs[dir][1])
            && !cellHasTerrainFlag(upLoc[0] + nbDirs[dir][0], upLoc[1] + nbDirs[dir][1], T_OBSTRUCTS_PASSABILITY))
				{
            upLoc[0] += nbDirs[dir][0];
            upLoc[1] += nbDirs[dir][1];
            break;
        }
    }
		zeroOutGrid(grid);
		getFOVMask(grid, upLoc[0], upLoc[1], Math.max(DCOLS, DROWS) << FP_BASE, (T_OBSTRUCTS_VISION), 0, false);
		for (i=0; i<DCOLS; i++) {
			for (j=0; j<DROWS; j++) {
				if (grid[i][j]) {
					pmap[i][j].flags |= IN_FIELD_OF_VIEW;
				}
			}
		}
		await populateItems(upLoc[0], upLoc[1]);
		await populateMonsters();
	}

    // Restore items that fell from the previous depth.
  for (theItem = floorItems.nextItem; theItem != NULL; theItem = theItem.nextItem) {
		restoreItem(theItem);
	}

    // Restore creatures that fell from the previous depth or that have been pathing toward the stairs.
  mapToStairs = allocGrid();
	mapToPit = allocGrid();
	fillGrid(mapToStairs, 0);
	fillGrid(mapToPit, 0);

	calculateDistances(mapToStairs, player.xLoc, player.yLoc, T_PATHING_BLOCKER, NULL, true, true);
	calculateDistances(mapToPit,
					   levels[rogue.depthLevel - 1].playerExitedVia[0],
					   levels[rogue.depthLevel - 1].playerExitedVia[1],
					   T_PATHING_BLOCKER,
					   NULL,
					   true,
					   true);
	for (monst = monsters.nextCreature; monst != NULL; monst = monst.nextCreature) {
		restoreMonster(monst, mapToStairs, mapToPit);
	}
	freeGrid(mapToStairs);
	freeGrid(mapToPit);
	freeGrid(grid);

	if (D_INSPECT_LEVELGEN) {
		blackOutScreen();
	}
}

// fills (*x, *y) with the coordinates of a random cell with
// no creatures, items or stairs and with either a matching liquid and dungeon type
// or at least one layer of type terrainType.
// A dungeon, liquid type of -1 will match anything.
function randomMatchingLocation(dungeonType, liquidType, terrainType) {
	let failsafeCount = 0;
	let x;
	let y;
	do {
		failsafeCount++;
		x = rand_range(0, DCOLS - 1);
		y = rand_range(0, DROWS - 1);
	} while (failsafeCount < 500 && ((terrainType >= 0 && !cellHasTerrainType(x, y, terrainType))
									 || (((dungeonType >= 0 && pmap[x][y].layers[DUNGEON] != dungeonType) || (liquidType >= 0 && pmap[x][y].layers[LIQUID] != liquidType)) && terrainType < 0)
									 || (pmap[x][y].flags & (HAS_PLAYER | HAS_MONSTER | HAS_STAIRS | HAS_ITEM | IS_IN_MACHINE))
									 || (terrainType < 0 && !(tileCatalog[dungeonType].flags & T_OBSTRUCTS_ITEMS)
										 && cellHasTerrainFlag(x, y, T_OBSTRUCTS_ITEMS))));
	if (failsafeCount >= 500) {
		return false;
	}
	return [ x, y ];
}
/*
 *  Time.c
 *  Brogue
 *
 *  Created by Brian Walker on 6/21/13.
 *  Copyright 2013. All rights reserved.
 *
 *  This file is part of Brogue.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

// #include "Rogue.h"
// #include "IncludeGlobals.h"
// #include <math.h>

function exposeCreatureToFire( /* creature */ monst) {
	const buf = STRING(), buf2 = STRING(); // char[COLS];
	if ( (monst.bookkeepingFlags & MB_IS_DYING)
		|| monst.status[STATUS_IMMUNE_TO_FIRE]
    || (monst.info.flags & MONST_INVULNERABLE)
		|| (monst.bookkeepingFlags & MB_SUBMERGED)
		|| ((!monst.status[STATUS_LEVITATING]) && cellHasTMFlag(monst.xLoc, monst.yLoc, TM_EXTINGUISHES_FIRE)))
  {
		return;
	}
	if (monst.status[STATUS_BURNING] == 0) {
		if (monst === player) {
			rogue.minersLight.lightColor = fireForeColor;
			player.info.foreColor = torchLightColor;
			refreshDungeonCell(player.xLoc, player.yLoc);
			//updateVision(); // this screws up the firebolt visual effect by erasing it while a message is displayed
			combatMessage("you catch fire!", badMessageColor);
		} else if (canDirectlySeeMonster(monst)) {
			monsterName(buf, monst, true);
			sprintf(buf2, "%s catches fire!", buf);
			combatMessage(buf2, messageColorFromVictim(monst));
		}
	}
	monst.status[STATUS_BURNING] = monst.maxStatus[STATUS_BURNING] = max(monst.status[STATUS_BURNING], 7);
}

function updateFlavorText() {
	const buf = STRING(); // char[DCOLS * 3];

	if (rogue.disturbed && !rogue.gameHasEnded) {
    if (rogue.armor
        && (rogue.armor.flags & ITEM_RUNIC)
        && rogue.armor.enchant2 == A_RESPIRATION
        && tileCatalog[pmap[player.xLoc][player.yLoc].layers[highestPriorityLayer(player.xLoc, player.yLoc, false)]].flags & T_RESPIRATION_IMMUNITIES)
		{
        flavorMessage("A pocket of cool, clean air swirls around you.");
		} else if (player.status[STATUS_LEVITATING]) {
			describeLocation(buf, player.xLoc, player.yLoc);
			flavorMessage(buf);
		} else {
			flavorMessage(tileFlavor(player.xLoc, player.yLoc));
		}
	}
}


function updatePlayerUnderwaterness() {
    if (rogue.inWater) {
        if (!cellHasTerrainFlag(player.xLoc, player.yLoc, T_IS_DEEP_WATER) || player.status[STATUS_LEVITATING]
            || cellHasTerrainFlag(player.xLoc, player.yLoc, (T_ENTANGLES | T_OBSTRUCTS_PASSABILITY)))
				{
            rogue.inWater = false;
            updateMinersLightRadius();
            updateVision(true);
            displayLevel();
        }
    } else {
        if (cellHasTerrainFlag(player.xLoc, player.yLoc, T_IS_DEEP_WATER) && !player.status[STATUS_LEVITATING]
            && !cellHasTerrainFlag(player.xLoc, player.yLoc, (T_ENTANGLES | T_OBSTRUCTS_PASSABILITY)))
				{
            rogue.inWater = true;
            updateMinersLightRadius();
            updateVision(true);
            displayLevel();
        }
    }
}


function monsterShouldFall(/* creature */ monst) {
	return (!(monst.status[STATUS_LEVITATING])
			&& cellHasTerrainFlag(monst.xLoc, monst.yLoc, T_AUTO_DESCENT)
			&& !cellHasTerrainFlag(monst.xLoc, monst.yLoc, T_ENTANGLES | T_OBSTRUCTS_PASSABILITY)
			&& !(monst.bookkeepingFlags & MB_PREPLACED));
}


// Called at least every 100 ticks; may be called more frequently.
async function applyInstantTileEffectsToCreature( /* creature */ monst) {
	const buf = STRING(), buf2 = STRING(); // char[COLS];
	let x = monst.xLoc, y = monst.yLoc, damage;
	let layer;		// enum dungeonLayers
	let theItem;	// item *

	if (monst.bookkeepingFlags & MB_IS_DYING) {
		return; // the monster is already dead.
	}

	if (monst === player) {
		if (!player.status[STATUS_LEVITATING]) {
			pmap[x][y].flags |= KNOWN_TO_BE_TRAP_FREE;
		}
	} else if (!player.status[STATUS_HALLUCINATING]
			   && !monst.status[STATUS_LEVITATING]
			   && canSeeMonster(monst)
			   && !(cellHasTerrainFlag(x, y, T_IS_DF_TRAP)))
  {
		pmap[x][y].flags |= KNOWN_TO_BE_TRAP_FREE;
	}

	// You will discover the secrets of any tile you stand on.
	if (monst === player
		&& !(monst.status[STATUS_LEVITATING])
		&& cellHasTMFlag(x, y, TM_IS_SECRET)
		&& playerCanSee(x, y))
	{
		discover(x, y);
	}

	// Submerged monsters in terrain that doesn't permit submersion should immediately surface.
	if ((monst.bookkeepingFlags & MB_SUBMERGED) && !cellHasTMFlag(x, y, TM_ALLOWS_SUBMERGING)) {
			monst.bookkeepingFlags &= ~MB_SUBMERGED;
	}

	// Visual effect for submersion in water.
	if (monst === player) {
    updatePlayerUnderwaterness();
	}

  // Obstructed krakens can't seize their prey.
  if ((monst.bookkeepingFlags & MB_SEIZING)
      && (cellHasTerrainFlag(x, y, T_OBSTRUCTS_PASSABILITY))
      && !(monst.info.flags & MONST_ATTACKABLE_THRU_WALLS))
  {
      monst.bookkeepingFlags &= ~MB_SEIZING;
  }

	// Creatures plunge into chasms and through trap doors.
	if (monsterShouldFall(monst)) {
			if (monst === player) {
					// player falling takes place at the end of the turn
					if (!(monst.bookkeepingFlags & MB_IS_FALLING)) {
							monst.bookkeepingFlags |= MB_IS_FALLING;
					}
					return;
			} else { // it's a monster
					monst.bookkeepingFlags |= MB_IS_FALLING; // handled at end of turn
			}
	}

	// lava
	if (!(monst.status[STATUS_LEVITATING])
		&& !(monst.status[STATUS_IMMUNE_TO_FIRE])
        && !(monst.info.flags & MONST_INVULNERABLE)
		&& !cellHasTerrainFlag(x, y, (T_ENTANGLES | T_OBSTRUCTS_PASSABILITY))
	  && !cellHasTMFlag(x, y, TM_EXTINGUISHES_FIRE)
		&& cellHasTerrainFlag(x, y, T_LAVA_INSTA_DEATH))
  {
		if (monst === player) {
			sprintf(buf, "you plunge into %s!",
					tileCatalog[pmap[x][y].layers[layerWithFlag(x, y, T_LAVA_INSTA_DEATH)]].description);
			await messageWithAck(buf);
			sprintf(buf, "Killed by %s",
					tileCatalog[pmap[x][y].layers[layerWithFlag(x, y, T_LAVA_INSTA_DEATH)]].description);
			await gameOver(buf, true);
			return;
		} else { // it's a monster
			if (canSeeMonster(monst)) {
				monsterName(buf, monst, true);
				sprintf(buf2, "%s is consumed by the %s instantly!", buf,
						tileCatalog[pmap[x][y].layers[layerWithFlag(x, y, T_LAVA_INSTA_DEATH)]].description);
				message(buf2, messageColorFromVictim(monst), false);
			}
			await killCreature(monst, false);
      await spawnDungeonFeature(x, y, dungeonFeatureCatalog[DF_CREATURE_FIRE], true, false);
			refreshDungeonCell(x, y);
			return;
		}
	}

	// Water puts out fire.
	if (cellHasTMFlag(x, y, TM_EXTINGUISHES_FIRE)
        && monst.status[STATUS_BURNING]
        && !monst.status[STATUS_LEVITATING]
        && !(monst.info.flags & MONST_ATTACKABLE_THRU_WALLS)
		&& !(monst.info.flags & MONST_FIERY))
  {
		extinguishFireOnCreature(monst);
	}

	// If you see a monster use a secret door, you discover it.
	if (playerCanSee(x, y)
    && cellHasTMFlag(x, y, TM_IS_SECRET)
		&& (cellHasTerrainFlag(x, y, T_OBSTRUCTS_PASSABILITY)))
  {
		await discover(x, y);
	}

	// Pressure plates.
	if (!(monst.status[STATUS_LEVITATING])
		&& !(monst.bookkeepingFlags & MB_SUBMERGED)
    && (!cellHasTMFlag(x, y, TM_ALLOWS_SUBMERGING) || !(monst.info.flags & MONST_SUBMERGES))
		&& cellHasTerrainFlag(x, y, T_IS_DF_TRAP)
		&& !(pmap[x][y].flags & PRESSURE_PLATE_DEPRESSED))
  {
		pmap[x][y].flags |= PRESSURE_PLATE_DEPRESSED;
		if (playerCanSee(x, y) && cellHasTMFlag(x, y, TM_IS_SECRET)) {
			await discover(x, y);
			refreshDungeonCell(x, y);
		}
		if (canSeeMonster(monst)) {
			monsterName(buf, monst, true);
			sprintf(buf2, "a pressure plate clicks underneath %s!", buf);
			await messageWithAck(buf2);
		} else if (playerCanSee(x, y)) {
			// usually means an invisible monster
			message("a pressure plate clicks!", false);
		}
		for (layer = 0; layer < NUMBER_TERRAIN_LAYERS; layer++) {
			if (tileCatalog[pmap[x][y].layers[layer]].flags & T_IS_DF_TRAP) {
				await spawnDungeonFeature(x, y, dungeonFeatureCatalog[tileCatalog[pmap[x][y].layers[layer]].fireType], true, false);
				await promoteTile(x, y, layer, false);
			}
		}
	}

	if (cellHasTMFlag(x, y, TM_PROMOTES_ON_STEP)) { // flying creatures activate too
		// Because this uses no pressure plate to keep track of whether it's already depressed,
		// it will trigger every time this function is called while the monster or player is on the tile.
		// Because this function can be called several times per turn, multiple promotions can
        // happen unpredictably if the tile does not promote to a tile without the T_PROMOTES_ON_STEP
        // attribute. That's acceptable for some effects, e.g. doors opening,
        // but not for others, e.g. magical glyphs activating.
		for (layer = 0; layer < NUMBER_TERRAIN_LAYERS; layer++) {
			if (tileCatalog[pmap[x][y].layers[layer]].mechFlags & TM_PROMOTES_ON_STEP) {
				await promoteTile(x, y, layer, false);
			}
		}
	}

	if (cellHasTMFlag(x, y, TM_PROMOTES_ON_PLAYER_ENTRY) && monst === player) {
		// Subject to same caveats as T_PROMOTES_ON_STEP above.
		for (layer = 0; layer < NUMBER_TERRAIN_LAYERS; layer++) {
			if (tileCatalog[pmap[x][y].layers[layer]].mechFlags & TM_PROMOTES_ON_PLAYER_ENTRY) {
				await promoteTile(x, y, layer, false);
			}
		}
	}

	if (cellHasTMFlag(x, y, TM_PROMOTES_ON_SACRIFICE_ENTRY)
			&& monst.machineHome == pmap[x][y].machineNumber
			&& (monst.bookkeepingFlags & MB_MARKED_FOR_SACRIFICE)) {
			// Subject to same caveats as T_PROMOTES_ON_STEP above.
			for (layer = 0; layer < NUMBER_TERRAIN_LAYERS; layer++) {
					if (tileCatalog[pmap[x][y].layers[layer]].mechFlags & TM_PROMOTES_ON_SACRIFICE_ENTRY) {
							await promoteTile(x, y, layer, false);
					}
			}
	}

	// spiderwebs
	if (cellHasTerrainFlag(x, y, T_ENTANGLES) && !monst.status[STATUS_STUCK]
		  && !(monst.info.flags & (MONST_IMMUNE_TO_WEBS | MONST_INVULNERABLE))
      && !(monst.bookkeepingFlags & MB_SUBMERGED))
  {
		monst.status[STATUS_STUCK] = monst.maxStatus[STATUS_STUCK] = rand_range(3, 7);
		if (monst === player) {
      if (!rogue.automationActive) {
          // Don't interrupt exploration with this message.
          sprintf(buf2, "you are stuck fast in %s!",
                  tileCatalog[pmap[x][y].layers[layerWithFlag(x, y, T_ENTANGLES)]].description);
          message(buf2, false);
      }
		} else if (canDirectlySeeMonster(monst)) { // it's a monster
      if (!rogue.automationActive) {
          monsterName(buf, monst, true);
          sprintf(buf2, "%s is stuck fast in %s!", buf,
                  tileCatalog[pmap[x][y].layers[layerWithFlag(x, y, T_ENTANGLES)]].description);
          message(buf2, false);
      }
		}
	}

	// explosions
	if (cellHasTerrainFlag(x, y, T_CAUSES_EXPLOSIVE_DAMAGE) && !monst.status[STATUS_EXPLOSION_IMMUNITY]
		&& !(monst.bookkeepingFlags & MB_SUBMERGED))
  {
		damage = rand_range(15, 20);
		damage = max(damage, monst.info.maxHP / 2);
		monst.status[STATUS_EXPLOSION_IMMUNITY] = 5;
		if (monst === player) {
			rogue.disturbed = true;
			for (layer = 0; layer < NUMBER_TERRAIN_LAYERS && !(tileCatalog[pmap[x][y].layers[layer]].flags & T_CAUSES_EXPLOSIVE_DAMAGE); layer++);
			message(tileCatalog[pmap[x][y].layers[layer]].flavorText, false);
      if (rogue.armor && (rogue.armor.flags & ITEM_RUNIC) && rogue.armor.enchant2 == A_DAMPENING) {
          itemName(rogue.armor, buf2, false, false, NULL);
          sprintf(buf, "Your %s pulses and absorbs the damage.", buf2);
          message(buf, goodMessageColor, false);
          autoIdentify(rogue.armor);
      } else if (await inflictDamage(NULL, player, damage, yellow, false)) {
				strcpy(buf2, tileCatalog[pmap[x][y].layers[layerWithFlag(x, y, T_CAUSES_EXPLOSIVE_DAMAGE)]].description);
				sprintf(buf, "Killed by %s", buf2);
				await gameOver(buf, true);
				return;
			}
		} else { // it's a monster
			if (monst.creatureState == MONSTER_SLEEPING) {
				monst.creatureState = MONSTER_TRACKING_SCENT;
			}
			monsterName(buf, monst, true);
			if (await inflictDamage(NULL, monst, damage, yellow, false)) {
				// if killed
				sprintf(buf2, "%s %s %s.", buf,
                  (monst.info.flags & MONST_INANIMATE) ? "is destroyed by" : "dies in",
		              tileCatalog[pmap[x][y].layers[layerWithFlag(x, y, T_CAUSES_EXPLOSIVE_DAMAGE)]].description);
				message(buf2, messageColorFromVictim(monst), false);
				refreshDungeonCell(x, y);
				return;
			} else {
				// if survived
				sprintf(buf2, "%s engulfs %s.",
						      tileCatalog[pmap[x][y].layers[layerWithFlag(x, y, T_CAUSES_EXPLOSIVE_DAMAGE)]].description, buf);
				message(buf2, messageColorFromVictim(monst), false);
			}
		}
	}

    // Toxic gases!
    // If it's the player, and he's wearing armor of respiration, then no effect from toxic gases.
    if (monst === player
        && cellHasTerrainFlag(x, y, T_RESPIRATION_IMMUNITIES)
        && rogue.armor
        && (rogue.armor.flags & ITEM_RUNIC)
        && rogue.armor.enchant2 == A_RESPIRATION)
    {
        if (!(rogue.armor.flags & ITEM_RUNIC_IDENTIFIED))
        {
          message("Your armor trembles and a pocket of clean air swirls around you.", false);
          autoIdentify(rogue.armor);
        }
    } else {
        // zombie gas
        if (cellHasTerrainFlag(x, y, T_CAUSES_NAUSEA)
            && !(monst.info.flags & (MONST_INANIMATE | MONST_INVULNERABLE))
            && !(monst.bookkeepingFlags & MB_SUBMERGED)) {
            if (monst === player) {
                rogue.disturbed = true;
            }
            if (canDirectlySeeMonster(monst) && !(monst.status[STATUS_NAUSEOUS])) {
                if (monst.creatureState == MONSTER_SLEEPING) {
                    monst.creatureState = MONSTER_TRACKING_SCENT;
                }
                await flashMonster(monst, brown, 100);
                monsterName(buf, monst, true);
                sprintf(buf2, "%s choke%s and gag%s on the overpowering stench of decay.", buf,
                        (monst === player ? "": "s"), (monst === player ? "": "s"));
                message(buf2, false);
            }
            monst.status[STATUS_NAUSEOUS] = monst.maxStatus[STATUS_NAUSEOUS] = max(monst.status[STATUS_NAUSEOUS], 20);
        }

        // confusion gas
        if (cellHasTerrainFlag(x, y, T_CAUSES_CONFUSION) && !(monst.info.flags & (MONST_INANIMATE | MONST_INVULNERABLE))) {
            if (monst === player) {
                rogue.disturbed = true;
            }
            if (canDirectlySeeMonster(monst) && !(monst.status[STATUS_CONFUSED])) {
                if (monst.creatureState == MONSTER_SLEEPING) {
                    monst.creatureState = MONSTER_TRACKING_SCENT;
                }
                await flashMonster(monst, confusionGasColor, 100);
                monsterName(buf, monst, true);
                sprintf(buf2, "%s %s very confused!", buf, (monst === player ? "feel": "looks"));
                message(buf2, false);
            }
            monst.status[STATUS_CONFUSED] = monst.maxStatus[STATUS_CONFUSED] = max(monst.status[STATUS_CONFUSED], 25);
        }

        // paralysis gas
        if (cellHasTerrainFlag(x, y, T_CAUSES_PARALYSIS)
            && !(monst.info.flags & (MONST_INANIMATE | MONST_INVULNERABLE))
            && !(monst.bookkeepingFlags & MB_SUBMERGED))
        {
            if (canDirectlySeeMonster(monst) && !monst.status[STATUS_PARALYZED]) {
                await flashMonster(monst, pink, 100);
                monsterName(buf, monst, true);
                sprintf(buf2, "%s %s paralyzed!", buf, (monst === player ? "are": "is"));
                if (monst === player) {
                   await messageWithAck(buf2);
                }
                else {
                   message(buf2);
                }
            }
            monst.status[STATUS_PARALYZED] = monst.maxStatus[STATUS_PARALYZED] = max(monst.status[STATUS_PARALYZED], 20);
            if (monst === player) {
                rogue.disturbed = true;
            }
        }
    }

    // poisonous lichen
    if (cellHasTerrainFlag(x, y, T_CAUSES_POISON)
        && !(monst.info.flags & (MONST_INANIMATE | MONST_INVULNERABLE))
        && !monst.status[STATUS_LEVITATING])
    {
        if (monst === player && !player.status[STATUS_POISONED]) {
            rogue.disturbed = true;
        }
        if (canDirectlySeeMonster(monst) && !(monst.status[STATUS_POISONED])) {
            if (monst.creatureState == MONSTER_SLEEPING) {
                monst.creatureState = MONSTER_TRACKING_SCENT;
            }
            await flashMonster(monst, green, 100);
            monsterName(buf, monst, true);
            sprintf(buf2, "the lichen's grasping tendrils poison %s.", buf);
            message(buf2, messageColorFromVictim(monst), false);
        }
        damage = max(0, 5 - monst.status[STATUS_POISONED]);
        addPoison(monst, damage, 0); // Lichen doesn't increase poison concentration above 1.
    }

	// fire
	if (cellHasTerrainFlag(x, y, T_IS_FIRE)) {
		exposeCreatureToFire(monst);
	} else if (cellHasTerrainFlag(x, y, T_IS_FLAMMABLE)
			   && !cellHasTerrainFlag(x, y, T_IS_FIRE)
			   && monst.status[STATUS_BURNING]
         && !(monst.bookkeepingFlags & (MB_SUBMERGED | MB_IS_FALLING)))
  {
		await exposeTileToFire(x, y, true);
	}

	// keys
	if (cellHasTMFlag(x, y, TM_PROMOTES_WITH_KEY) && (theItem = keyOnTileAt(x, y))) {
		await useKeyAt(theItem, x, y);
	}
}


async function applyGradualTileEffectsToCreature( /* creature */ monst, ticks) {
	let itemCandidates, randItemIndex;
	let x = monst.xLoc, y = monst.yLoc, damage;
	const buf = STRING(), buf2 = STRING(); // char[COLS * 3];
	let theItem;	// item *
	let layer;		// enum dungeonLayers

	if (!(monst.status[STATUS_LEVITATING])
    && cellHasTerrainFlag(x, y, T_IS_DEEP_WATER)
		&& !cellHasTerrainFlag(x, y, (T_ENTANGLES | T_OBSTRUCTS_PASSABILITY))
		&& !(monst.info.flags & MONST_IMMUNE_TO_WATER)) {
		if (monst === player) {
			if (!(pmap[x][y].flags & HAS_ITEM) && rand_percent(ticks * 50 / 100)) {
				itemCandidates = numberOfMatchingPackItems(ALL_ITEMS, 0, (ITEM_EQUIPPED), false);
				if (itemCandidates) {
					randItemIndex = rand_range(1, itemCandidates);
					for (theItem = packItems.nextItem; theItem != NULL; theItem = theItem.nextItem) {
						if (!(theItem.flags & (ITEM_EQUIPPED))) {
							if (randItemIndex == 1) {
								break;
							} else {
								randItemIndex--;
							}
						}
					}
					theItem = await dropItem(theItem);
					if (theItem) {
						itemName(theItem, buf2, false, true, NULL);
						sprintf(buf, "%s float%s away in the current!",
                                buf2,
                                (theItem.quantity == 1 ? "s" : ""));
						message(buf, itemMessageColor, false);
					}
				}
			}
		} else if (monst.carriedItem && !(pmap[x][y].flags & HAS_ITEM) && rand_percent(ticks * 50 / 100)) { // it's a monster with an item
			await makeMonsterDropItem(monst);
		}
	}

	if (cellHasTerrainFlag(x, y, T_CAUSES_DAMAGE)
		&& !(monst.info.flags & (MONST_INANIMATE | MONST_INVULNERABLE))
		&& !(monst.bookkeepingFlags & MB_SUBMERGED))
	{
		damage = (monst.info.maxHP / 15) * ticks / 100;
		damage = max(1, damage);
		for (layer = 0; layer < NUMBER_TERRAIN_LAYERS && !(tileCatalog[pmap[x][y].layers[layer]].flags & T_CAUSES_DAMAGE); layer++);
		if (monst === player) {
      if (rogue.armor && (rogue.armor.flags & ITEM_RUNIC) && rogue.armor.enchant2 == A_RESPIRATION) {
          if (!(rogue.armor.flags & ITEM_RUNIC_IDENTIFIED)) {
              message("Your armor trembles and a pocket of clean air swirls around you.", false);
              autoIdentify(rogue.armor);
          }
      } else {
          rogue.disturbed = true;
          message(tileCatalog[pmap[x][y].layers[layer]].flavorText, badMessageColor, false);
          if (await inflictDamage(NULL, player, damage, tileCatalog[pmap[x][y].layers[layer]].backColor, true)) {
              sprintf(buf, "Killed by %s", tileCatalog[pmap[x][y].layers[layer]].description);
              await gameOver(buf, true);
              return;
          }
      }
		} else { // it's a monster
			if (monst.creatureState == MONSTER_SLEEPING) {
				monst.creatureState = MONSTER_TRACKING_SCENT;
			}
			if (await inflictDamage(NULL, monst, damage, tileCatalog[pmap[x][y].layers[layer]].backColor, true)) {
				if (canSeeMonster(monst)) {
					monsterName(buf, monst, true);
					sprintf(buf2, "%s dies.", buf);
					message(buf2, messageColorFromVictim(monst), false);
				}
				refreshDungeonCell(x, y);
				return;
			}
		}
	}

  if (cellHasTerrainFlag(x, y, T_CAUSES_HEALING)
		&& !(monst.info.flags & MONST_INANIMATE)
		&& !(monst.bookkeepingFlags & MB_SUBMERGED))
	{
		damage = (monst.info.maxHP / 15) * ticks / 100;
		damage = max(1, damage);
    if (monst.currentHP < monst.info.maxHP) {
        monst.currentHP = min(monst.currentHP + damage, monst.info.maxHP);
        if (monst === player) {
            message("you feel much better.", goodMessageColor, false);
        }
    }
  }
}


function updateClairvoyance() {
	let i, j, clairvoyanceRadius, dx, dy;
	let cursed;
	let cFlags;

	for (i=0; i<DCOLS; i++) {
		for (j=0; j<DROWS; j++) {
			pmap[i][j].flags &= ~WAS_CLAIRVOYANT_VISIBLE;
			if (pmap[i][j].flags & CLAIRVOYANT_VISIBLE) {
				pmap[i][j].flags |= WAS_CLAIRVOYANT_VISIBLE;
			}
			pmap[i][j].flags &= ~(CLAIRVOYANT_VISIBLE | CLAIRVOYANT_DARKENED);
		}
	}

	cursed = (rogue.clairvoyance < 0);
	if (cursed) {
		clairvoyanceRadius = (rogue.clairvoyance - 1) * -1;
		cFlags = CLAIRVOYANT_DARKENED;
	} else {
		clairvoyanceRadius = (rogue.clairvoyance > 0) ? rogue.clairvoyance + 1 : 0;
		cFlags = CLAIRVOYANT_VISIBLE | DISCOVERED;
	}

	for (i = max(0, player.xLoc - clairvoyanceRadius); i < min(DCOLS, player.xLoc + clairvoyanceRadius + 1); i++) {
		for (j = max(0, player.yLoc - clairvoyanceRadius); j < min(DROWS, player.yLoc + clairvoyanceRadius + 1); j++) {

			dx = (player.xLoc - i);
			dy = (player.yLoc - j);

			if (dx*dx + dy*dy < clairvoyanceRadius*clairvoyanceRadius + clairvoyanceRadius
				&& (pmap[i][j].layers[DUNGEON] != GRANITE || pmap[i][j].flags & DISCOVERED))
      {
				if (cFlags & DISCOVERED) {
          discoverCell(i, j);
				}
				pmap[i][j].flags |= cFlags;
				if (!(pmap[i][j].flags & HAS_PLAYER) && !cursed) {
					pmap[i][j].flags &= ~STABLE_MEMORY;
				}
			}
		}
	}
}

function updateTelepathy() {
	let i, j;
	let monst;		// creature *
	const grid = GRID(DCOLS, DROWS); // boolean[DCOLS][DROWS];

	for (i=0; i<DCOLS; i++) {
		for (j=0; j<DROWS; j++) {
			pmap[i][j].flags &= ~WAS_TELEPATHIC_VISIBLE;
			if (pmap[i][j].flags & TELEPATHIC_VISIBLE) {
				pmap[i][j].flags |= WAS_TELEPATHIC_VISIBLE;
			}
			pmap[i][j].flags &= ~(TELEPATHIC_VISIBLE);
		}
	}

  zeroOutGrid(grid);
  for (monst = monsters.nextCreature; monst; monst = monst.nextCreature) {
      if (monsterRevealed(monst)) {
          getFOVMask(grid, monst.xLoc, monst.yLoc, 2 << FP_BASE, T_OBSTRUCTS_VISION, 0, false);
          pmap[monst.xLoc][monst.yLoc].flags |= TELEPATHIC_VISIBLE;
          discoverCell(monst.xLoc, monst.yLoc);
      }
  }
  for (monst = dormantMonsters.nextCreature; monst != NULL; monst = monst.nextCreature) {
      if (monsterRevealed(monst)) {
          getFOVMask(grid, monst.xLoc, monst.yLoc, 2 << FP_BASE, T_OBSTRUCTS_VISION, 0, false);
          pmap[monst.xLoc][monst.yLoc].flags |= TELEPATHIC_VISIBLE;
          discoverCell(monst.xLoc, monst.yLoc);
      }
  }
  for (i = 0; i < DCOLS; i++) {
      for (j = 0; j < DROWS; j++) {
          if (grid[i][j]) {
              pmap[i][j].flags |= TELEPATHIC_VISIBLE;
              discoverCell(i, j);
          }
      }
  }
}


function scentDistance(x1, y1, x2, y2) {
    if (abs(x1 - x2) > abs(y1 - y2)) {
        return 2 * abs(x1 - x2) + abs(y1 - y2);
    } else {
        return abs(x1 - x2) + 2 * abs(y1 - y2);
    }
}

function updateScent() {
	let i, j;
	const grid = GRID(DCOLS, DROWS); // char[DCOLS][DROWS];

	zeroOutGrid(grid);

	getFOVMask(grid, player.xLoc, player.yLoc, DCOLS << FP_BASE, T_OBSTRUCTS_SCENT, 0, false);

	for (i=0; i<DCOLS; i++) {
		for (j=0; j<DROWS; j++) {
			if (grid[i][j]) {
        addScentToCell(i, j, scentDistance(player.xLoc, player.yLoc, i, j));
			}
		}
	}
	addScentToCell(player.xLoc, player.yLoc, 0);
}

function armorAggroAdjustment( /* item */ theArmor) {
    if (!theArmor
        || !(theArmor.category & ARMOR))
		{
        return 0;
    }
    return max(0, armorTable[theArmor.kind].strengthRequired - 12);
}


function currentAggroValue() {
    // Default value of 14 in the light.
    let stealthVal = 14;

    if (player.status[STATUS_INVISIBLE]) {
        stealthVal = 1; // Invisibility means stealth range of 1, no matter what.
    } else {
        if (playerInDarkness()) {
            // In darkness, halve, rounded down.
            stealthVal = Math.floor(stealthVal / 2);
        } else if (pmap[player.xLoc][player.yLoc].flags & IS_IN_SHADOW) {
					// When not standing in a lit area, halve, rounded down (stacks with darkness halving).
					stealthVal = Math.floor(stealthVal / 2);
        }

        // Add 1 for each point of your armor's natural (unenchanted) strength requirement above 12.
        stealthVal += armorAggroAdjustment(rogue.armor);

        // Halve (rounded up) if you just rested.
        if (rogue.justRested) {
            stealthVal = (stealthVal + 1) / 2;
        }

				// Double while manually searching.
        if (player.status[STATUS_SEARCHING] > 0) {
            stealthVal *= 2;
        }

        if (player.status[STATUS_AGGRAVATING] > 0) {
            stealthVal += player.status[STATUS_AGGRAVATING];
        }

        // Subtract your bonuses from rings of stealth.
        // (Cursed rings of stealth will end up adding here.)
        stealthVal -= rogue.stealthBonus;

        // Can't go below 2 unless you just rested.
        if (stealthVal < 2 && !rogue.justRested) {
            stealthVal = 2;
        } else if (stealthVal < 1) { // Can't go below 1, ever.
            stealthVal = 1;
        }
    }
    return Math.floor(stealthVal);
}

function demoteVisibility() {
	let i, j;

	for (i=0; i<DCOLS; i++) {
		for (j=0; j<DROWS; j++) {
			pmap[i][j].flags &= ~WAS_VISIBLE;
			if (pmap[i][j].flags & VISIBLE) {
				pmap[i][j].flags &= ~VISIBLE;
				pmap[i][j].flags |= WAS_VISIBLE;
			}
		}
	}
}


function discoverCell( x, y) {
  pmap[x][y].flags &= ~STABLE_MEMORY;
  if (!(pmap[x][y].flags & DISCOVERED)) {
    pmap[x][y].flags |= DISCOVERED;
    if (!cellHasTerrainFlag(x, y, T_PATHING_BLOCKER)) {
      rogue.xpxpThisTurn++;
    }
  }
}

function updateVision(refreshDisplay) {
	let i, j;
	let grid = GRID(DCOLS, DROWS); // char[DCOLS][DROWS];
	let theItem;	// item *
	let monst;	// creature *

  demoteVisibility();
	for (i=0; i<DCOLS; i++) {
		for (j=0; j<DROWS; j++) {
			pmap[i][j].flags &= ~IN_FIELD_OF_VIEW;
		}
	}

	// Calculate player's field of view (distinct from what is visible, as lighting hasn't been done yet).
	zeroOutGrid(grid);
	getFOVMask(grid, player.xLoc, player.yLoc, (DCOLS + DROWS) << FP_BASE, (T_OBSTRUCTS_VISION), 0, false);
	for (i=0; i<DCOLS; i++) {
		for (j=0; j<DROWS; j++) {
			if (grid[i][j]) {
				pmap[i][j].flags |= IN_FIELD_OF_VIEW;
			}
		}
	}
	pmap[player.xLoc][player.yLoc].flags |= IN_FIELD_OF_VIEW | VISIBLE;

	if (rogue.clairvoyance < 0) {
    discoverCell(player.xLoc, player.yLoc);
	}

	if (rogue.clairvoyance != 0) {
		updateClairvoyance();
	}

  updateTelepathy();
	updateLighting();
	updateFieldOfViewDisplay(true, refreshDisplay);

  //	for (i=0; i<DCOLS; i++) {
  //		for (j=0; j<DROWS; j++) {
  //			if (pmap[i][j].flags & VISIBLE) {
  //				plotCharWithColor(' ', mapToWindowX(i), mapToWindowY(j), &yellow, &yellow);
  //			} else if (pmap[i][j].flags & IN_FIELD_OF_VIEW) {
  //				plotCharWithColor(' ', mapToWindowX(i), mapToWindowY(j), &blue, &blue);
  //			}
  //		}
  //	}
  //	displayMoreSign();

	if (player.status[STATUS_HALLUCINATING] > 0) {
		for (theItem = floorItems.nextItem; theItem != NULL; theItem = theItem.nextItem) {
			if ((pmap[theItem.xLoc][theItem.yLoc].flags & DISCOVERED) && refreshDisplay) {
				refreshDungeonCell(theItem.xLoc, theItem.yLoc);
			}
		}
		for (monst = monsters.nextCreature; monst != NULL; monst = monst.nextCreature) {
			if ((pmap[monst.xLoc][monst.yLoc].flags & DISCOVERED) && refreshDisplay) {
				refreshDungeonCell(monst.xLoc, monst.yLoc);
			}
		}
	}
}

async function checkNutrition() {
	let theItem;		// item *
	const buf = STRING(), foodWarning = STRING(); // char[DCOLS*3];

	if (numberOfMatchingPackItems(FOOD, 0, 0, false) == 0) {
		sprintf(foodWarning, " and have no food");
	} else {
		foodWarning.clear();
	}

	if (player.status[STATUS_NUTRITION] == HUNGER_THRESHOLD) {
    player.status[STATUS_NUTRITION]--;
		sprintf(buf, "you are hungry%s.", foodWarning);
		message(buf, foodWarning[0] || false);
	} else if (player.status[STATUS_NUTRITION] == WEAK_THRESHOLD) {
    player.status[STATUS_NUTRITION]--;
		sprintf(buf, "you feel weak with hunger%s.", foodWarning);
		await messageWithAck(buf);
	} else if (player.status[STATUS_NUTRITION] == FAINT_THRESHOLD) {
    player.status[STATUS_NUTRITION]--;
		sprintf(buf, "you feel faint with hunger%s.", foodWarning);
		await messageWithAck(buf);
	} else if (player.status[STATUS_NUTRITION] <= 1) {
    // Force the player to eat something if he has it
    for (theItem = packItems.nextItem; theItem != NULL; theItem = theItem.nextItem) {
        if (theItem.category == FOOD) {
            sprintf(buf, "unable to control your hunger, you eat a %s.", (theItem.kind == FRUIT ? "mango" : "ration of food"));
            await messageWithAck(buf, itemMessageColor);
            await apply(theItem, false);
            break;
        }
		}
	}

	if (player.status[STATUS_NUTRITION] == 1) {	// Didn't manage to eat any food above.
		player.status[STATUS_NUTRITION] = 0;	// So the status bar changes in time for the message:
		await messageWithAck("you are starving to death!");
	}
}


async function burnItem( /* item */ theItem) {
	let x, y;
	const buf1 = STRING(), buf2 = STRING(); // char[COLS * 3];

	itemName(theItem, buf1, false, true, NULL);
	sprintf(buf2, "%s burn%s up!",
            buf1,
            theItem.quantity == 1 ? "s" : "");
	x = theItem.xLoc;
	y = theItem.yLoc;
	removeItemFromChain(theItem, floorItems);
	pmap[x][y].flags &= ~(HAS_ITEM | ITEM_DETECTED);
	if (pmap[x][y].flags & (ANY_KIND_OF_VISIBLE | DISCOVERED | ITEM_DETECTED)) {
		refreshDungeonCell(x, y);
	}
	if (playerCanSee(x, y)) {
		message(buf2, itemMessageColor, false);
	}
  await spawnDungeonFeature(x, y, dungeonFeatureCatalog[DF_ITEM_FIRE], true, false);
}

async function flashCreatureAlert( /* creature */ monst, msg, /* color */ foreColor, /* color */ backColor) {
    let x, y;
    if (monst.yLoc > DROWS / 2) {
      y = mapToWindowY(monst.yLoc - 2);
    } else {
      y = mapToWindowY(monst.yLoc + 2);
    }
    x = mapToWindowX(monst.xLoc - Math.floor(strLenWithoutEscapes(msg) / 2) );
    if (x > COLS - strLenWithoutEscapes(msg)) {
        x = COLS - strLenWithoutEscapes(msg);
    }
    await flashMessage(msg, x, y, (rogue.playbackMode ? 100 : 1000), foreColor, backColor);
    rogue.disturbed = true;
}

async function handleHealthAlerts() {
	let i, currentPercent, previousPercent;
  const thresholds = [5, 10, 25, 40];
  const pThresholds = [100, 90, 50];
	const buf = STRING(); // char[DCOLS];
	const colorbuf = STRING(); // char[DCOLS + 4];

  // assureCosmeticRNG();

  const healthThresholdsCount = 4,
  poisonThresholdsCount = 3;

	currentPercent = Math.floor(player.currentHP * 100 / player.info.maxHP);
  previousPercent = Math.floor(player.previousHealthPoints * 100 / player.info.maxHP);

	if (currentPercent < previousPercent && !rogue.gameHasEnded) {
		for (i=0; i < healthThresholdsCount; i++) {
			if (currentPercent < thresholds[i] && previousPercent >= thresholds[i]) {
				sprintf(buf, " <%i%% health ", thresholds[i]);
				await flashCreatureAlert(player, buf, badMessageColor, darkRed);
				// if(rogue.warningPauseMode) {
				// 	encodeMessageColor(colorbuf, 0, badMessageColor);
				// 	strcat(colorbuf, "LOW HITPOINT WARNING:");
				// 	strcat(colorbuf, buf);	// strncat
				// 	await messageWithAck(colorbuf);
				// }
				break;
			}
		}
	}
	// rogue.previousHealthPercent = currentPercent;

  if (!rogue.gameHasEnded) {
    currentPercent = Math.floor(player.status[STATUS_POISONED] * player.poisonAmount * 100 / player.currentHP);

    if (currentPercent > rogue.previousPoisonPercent && !rogue.gameHasEnded) {
      for (i=0; i < poisonThresholdsCount; i++) {
        if (currentPercent > pThresholds[i] && rogue.previousPoisonPercent <= pThresholds[i]) {
            if (currentPercent < 100) {
              sprintf(buf, " >%i%% poisoned ", pThresholds[i]);
            } else {
							strcpy(buf, " Fatally poisoned ");
            }
            await flashCreatureAlert(player, buf, yellow, darkGreen);
            // if(rogue.warningPauseMode) {
						// 	encodeMessageColor(colorbuf, 0, badMessageColor);
						// 	strcat(colorbuf, "POISON WARNING:");
						// 	strncat(colorbuf, buf, DCOLS + 4 - 15);
						// 	await messageWithAck(colorbuf);
            // }
            break;
          }
      }
    }
    rogue.previousPoisonPercent = currentPercent;
  }

  // restoreRNG();
}

function addXPXPToAlly(XPXP, /* creature */ monst) {
    const theMonsterName = STRING(), buf = STRING(); // char[200];

    if (!(monst.info.flags & (MONST_INANIMATE | MONST_IMMOBILE))
        && !(monst.bookkeepingFlags & MB_TELEPATHICALLY_REVEALED)
        && monst.creatureState == MONSTER_ALLY
        && monst.spawnDepth <= rogue.depthLevel
        && rogue.depthLevel <= AMULET_LEVEL)
		{
        monst.xpxp += XPXP;
        //printf("\n%i xpxp added to your %s this turn.", rogue.xpxpThisTurn, monst.info.monsterName);
        if (monst.xpxp >= XPXP_NEEDED_FOR_TELEPATHIC_BOND
            && !(monst.bookkeepingFlags & MB_TELEPATHICALLY_REVEALED))
				{
            monst.bookkeepingFlags |= MB_TELEPATHICALLY_REVEALED;
            updateVision(true);
            monsterName(theMonsterName, monst, false);
            sprintf(buf, "you have developed a telepathic bond with your %s.", theMonsterName);
            message(buf, advancementMessageColor, false);
        }
        if (monst.xpxp > 1500 * 20) {
            rogue.featRecord[FEAT_COMPANION] = true;
        }
    }
}

function handleXPXP() {
	let monst;	// creature *
	//char buf[DCOLS*2], theMonsterName[50];

	for (monst = monsters.nextCreature; monst != NULL; monst = monst.nextCreature) {
        addXPXPToAlly(rogue.xpxpThisTurn, monst);
	}
  if (rogue.depthLevel > 1) {
      for (monst = levels[rogue.depthLevel - 2].monsters; monst != NULL; monst = monst.nextCreature) {
          addXPXPToAlly(rogue.xpxpThisTurn, monst);
      }
  }
  if (rogue.depthLevel < DEEPEST_LEVEL) {
      for (monst = levels[rogue.depthLevel].monsters; monst != NULL; monst = monst.nextCreature) {
          addXPXPToAlly(rogue.xpxpThisTurn, monst);
      }
  }
	rogue.xpxpThisTurn = 0;
}

async function playerFalls() {
	let damage;
	let layer;

  if (cellHasTMFlag(player.xLoc, player.yLoc, TM_IS_SECRET)
      && playerCanSee(player.xLoc, player.yLoc))
	{
		await discover(player.xLoc, player.yLoc);
  }

  await monstersFall();			// Monsters must fall with the player rather than getting suspended on the previous level.
  await updateFloorItems(); // Likewise, items should fall with the player rather than getting suspended above.

	layer = layerWithFlag(player.xLoc, player.yLoc, T_AUTO_DESCENT);
	if (layer >= 0) {
		await messageWithAck(tileCatalog[pmap[player.xLoc][player.yLoc].layers[layer]].flavorText);
	} else if (layer == -1) {
		await messageWithAck("You plunge downward!");
	}

  player.bookkeepingFlags &= ~(MB_IS_FALLING | MB_SEIZED | MB_SEIZING);
	rogue.disturbed = true;

  if (rogue.depthLevel < DEEPEST_LEVEL) {
      rogue.depthLevel++;
      await startLevel(rogue.depthLevel - 1, 0);
      damage = randClumpedRange(FALL_DAMAGE_MIN, FALL_DAMAGE_MAX, 2);
      message("You are damaged by the fall.", badMessageColor, false);
      if (await inflictDamage(NULL, player, damage, red, false)) {
          await gameOver("Killed by a fall", true);
      } else if (rogue.depthLevel > rogue.deepestLevel) {
          rogue.deepestLevel = rogue.depthLevel;
      }
  } else {
      message("A strange force seizes you as you fall.", false);
      await teleport(player, -1, -1, true);
  }
  createFlare(player.xLoc, player.yLoc, GENERIC_FLASH_LIGHT);
  await animateFlares(rogue.flares, rogue.flareCount);
  rogue.flareCount = 0;
}



async function activateMachine(machineNumber) {
	let i, j, x, y, layer, monsterCount, maxMonsters;
	let sRows = [], sCols = []; // short[DCOLS],
  let activatedMonsterList, monst;		// creature **

  fillSequentialList(sCols, DCOLS);
  shuffleList(sCols, DCOLS);
  fillSequentialList(sRows, DROWS);
  shuffleList(sRows, DROWS);

	for (i=0; i<DCOLS; i++) {
		for (j=0; j<DROWS; j++) {
			x = sCols[i];
			y = sRows[j];
			if ((pmap[x][y].flags & IS_IN_MACHINE)
				&& pmap[x][y].machineNumber == machineNumber
				&& !(pmap[x][y].flags & IS_POWERED)
				&& cellHasTMFlag(x, y, TM_IS_WIRED))
			{
				pmap[x][y].flags |= IS_POWERED;
				for (layer = 0; layer < NUMBER_TERRAIN_LAYERS; layer++) {
					if (tileCatalog[pmap[x][y].layers[layer]].mechFlags & TM_IS_WIRED) {
						await promoteTile(x, y, layer, false);
					}
				}
			}
		}
	}

  monsterCount = maxMonsters = 0;
  activatedMonsterList = [];
  for (monst = monsters.nextCreature; monst != NULL; monst = monst.nextCreature) {
      if (monst.machineHome == machineNumber
          && monst.spawnDepth == rogue.depthLevel
          && (monst.info.flags & MONST_GETS_TURN_ON_ACTIVATION))
			{
          activatedMonsterList.push(monst);
      }
  }
  for (i=0; i<activatedMonsterList.length; i++) {
      if (!(activatedMonsterList[i].bookkeepingFlags & MB_IS_DYING)) {
          await monstersTurn(activatedMonsterList[i]);
      }
  }

}


function circuitBreakersPreventActivation(machineNumber) {
  let i, j;
	for (i=0; i<DCOLS; i++) {
		for (j=0; j<DROWS; j++) {
      if (pmap[i][j].machineNumber == machineNumber
          && cellHasTMFlag(i, j, TM_IS_CIRCUIT_BREAKER))
			{
          return true;
      }
    }
  }
  return false;
}


async function promoteTile(x, y, /* dungeonLayers */ layer, useFireDF) {
	let i, j;
	let DFType;	// dungeonFeatureTypes
	let tile;	// floorTileType *

	tile = tileCatalog[pmap[x][y].layers[layer]];

	DFType = (useFireDF ? tile.fireType : tile.promoteType);

	if ((tile.mechFlags & TM_VANISHES_UPON_PROMOTION)) {
		if (tileCatalog[pmap[x][y].layers[layer]].flags & T_PATHING_BLOCKER) {
			rogue.staleLoopMap = true;
		}
		pmap[x][y].layers[layer] = (layer == DUNGEON ? FLOOR : NOTHING); // even the dungeon layer implicitly has floor underneath it
		if (layer == GAS) {
			pmap[x][y].volume = 0;
		}
		refreshDungeonCell(x, y);
	}
	if (DFType) {
		await spawnDungeonFeature(x, y, dungeonFeatureCatalog[DFType], true, false);
	}

	if (!useFireDF && (tile.mechFlags & TM_IS_WIRED)
        && !(pmap[x][y].flags & IS_POWERED)
        && !circuitBreakersPreventActivation(pmap[x][y].machineNumber))
	{
		// Send power through all cells in the same machine that are not IS_POWERED,
		// and on any such cell, promote each terrain layer that is T_IS_WIRED.
		// Note that machines need not be contiguous.
		pmap[x][y].flags |= IS_POWERED;
		await activateMachine(pmap[x][y].machineNumber); // It lives!!!

		// Power fades from the map immediately after we finish.
		for (i=0; i<DCOLS; i++) {
			for (j=0; j<DROWS; j++) {
				pmap[i][j].flags &= ~IS_POWERED;
			}
		}
	}
}

async function exposeTileToElectricity(x, y) {
	let layer;
  let promotedSomething = false;

	if (!cellHasTMFlag(x, y, TM_PROMOTES_ON_ELECTRICITY)) {
		return false;
	}
	for (layer=0; layer < NUMBER_TERRAIN_LAYERS; layer++) {
		if (tileCatalog[pmap[x][y].layers[layer]].mechFlags & TM_PROMOTES_ON_ELECTRICITY) {
            await promoteTile(x, y, layer, false);
            promotedSomething = true;
		}
	}
	return promotedSomething;
}

async function exposeTileToFire(x, y, alwaysIgnite) {
	let layer;		// enum dungeonLayers
	let ignitionChance = 0, bestExtinguishingPriority = 1000, explosiveNeighborCount = 0;
  let newX, newY;
  let dir;
	let fireIgnited = false, explosivePromotion = false;

	if (!cellHasTerrainFlag(x, y, T_IS_FLAMMABLE)) {
		return false;
	}

	// Pick the extinguishing layer with the best priority.
	for (layer=0; layer < NUMBER_TERRAIN_LAYERS; layer++) {
		if ((tileCatalog[pmap[x][y].layers[layer]].mechFlags & TM_EXTINGUISHES_FIRE)
			&& tileCatalog[pmap[x][y].layers[layer]].drawPriority < bestExtinguishingPriority)
		{
			bestExtinguishingPriority = tileCatalog[pmap[x][y].layers[layer]].drawPriority;
		}
	}

	// Pick the fire type of the most flammable layer that is either gas or equal-or-better priority than the best extinguishing layer.
	for (layer=0; layer < NUMBER_TERRAIN_LAYERS; layer++) {
		if ((tileCatalog[pmap[x][y].layers[layer]].flags & T_IS_FLAMMABLE)
			&& (layer == GAS || tileCatalog[pmap[x][y].layers[layer]].drawPriority <= bestExtinguishingPriority)
			&& tileCatalog[pmap[x][y].layers[layer]].chanceToIgnite > ignitionChance)
		{
			ignitionChance = tileCatalog[pmap[x][y].layers[layer]].chanceToIgnite;
		}
	}

	if (alwaysIgnite || (ignitionChance && rand_percent(ignitionChance))) {	// If it ignites...
		fireIgnited = true;

    // Count explosive neighbors.
    if (cellHasTMFlag(x, y, TM_EXPLOSIVE_PROMOTE)) {
        for (dir = 0, explosiveNeighborCount = 0; dir < DIRECTION_COUNT; dir++) {
            newX = x + nbDirs[dir][0];
            newY = y + nbDirs[dir][1];
            if (coordinatesAreInMap(newX, newY)
                && (cellHasTerrainFlag(newX, newY, T_IS_FIRE | T_OBSTRUCTS_GAS) || cellHasTMFlag(newX, newY, TM_EXPLOSIVE_PROMOTE)))
						{
                explosiveNeighborCount++;
            }
        }
        if (explosiveNeighborCount >= 8) {
            explosivePromotion = true;
        }
    }

		// Flammable layers are consumed.
		for (layer=0; layer < NUMBER_TERRAIN_LAYERS; layer++) {
			if (tileCatalog[pmap[x][y].layers[layer]].flags & T_IS_FLAMMABLE) {
				if (layer == GAS) {
					pmap[x][y].volume = 0; // Flammable gas burns its volume away.
				}
				await promoteTile(x, y, layer, !explosivePromotion);
			}
		}
		refreshDungeonCell(x, y);
	}
	return fireIgnited;
}


// Only the gas layer can be volumetric.
function updateVolumetricMedia() {
	let i, j, newX, newY, numSpaces;
	let highestNeighborVolume;
	let sum;
	let gasType;		// enum tileType
	let dir;				// enum directions
	let newGasVolume = GRID(DCOLS, DROWS); // short[DCOLS][DROWS];

	for (i=0; i<DCOLS; i++) {
		for (j=0; j<DROWS; j++) {
			newGasVolume[i][j] = 0;
		}
	}

	for (i=0; i<DCOLS; i++) {
		for (j=0; j<DROWS; j++) {
			if (!cellHasTerrainFlag(i, j, T_OBSTRUCTS_GAS)) {
				sum = pmap[i][j].volume;
				numSpaces = 1;
				highestNeighborVolume = pmap[i][j].volume;
				gasType = pmap[i][j].layers[GAS];
				for (dir=0; dir< DIRECTION_COUNT; dir++) {
					newX = i + nbDirs[dir][0];
					newY = j + nbDirs[dir][1];
					if (coordinatesAreInMap(newX, newY)
						&& !cellHasTerrainFlag(newX, newY, T_OBSTRUCTS_GAS))
					{
						sum += pmap[newX][newY].volume;
						numSpaces++;
						if (pmap[newX][newY].volume > highestNeighborVolume) {
							highestNeighborVolume = pmap[newX][newY].volume;
							gasType = pmap[newX][newY].layers[GAS];
						}
					}
				}
				if (cellHasTerrainFlag(i, j, T_AUTO_DESCENT)) { // if it's a chasm tile or trap door,
					numSpaces++; // this will allow gas to escape from the level entirely
				}
				newGasVolume[i][j] += Math.floor(sum / max(1, numSpaces));
				if (rand_range(0, Math.max(0, numSpaces - 1) ) < (sum % numSpaces)) {
					newGasVolume[i][j]++; // stochastic rounding
				}
				if (pmap[i][j].layers[GAS] != gasType && newGasVolume[i][j] > 3) {
					if (pmap[i][j].layers[GAS] != NOTHING) {
						newGasVolume[i][j] = min(3, newGasVolume[i][j]); // otherwise interactions between gases are crazy
					}
					pmap[i][j].layers[GAS] = gasType;
				} else if (pmap[i][j].layers[GAS] && newGasVolume[i][j] < 1) {
					pmap[i][j].layers[GAS] = NOTHING;
					refreshDungeonCell(i, j);
				}
				if (pmap[i][j].volume > 0) {
					if (tileCatalog[pmap[i][j].layers[GAS]].mechFlags & TM_GAS_DISSIPATES_QUICKLY) {
						newGasVolume[i][j] -= (rand_percent(50) ? 1 : 0);
					} else if (tileCatalog[pmap[i][j].layers[GAS]].mechFlags & TM_GAS_DISSIPATES) {
						newGasVolume[i][j] -= (rand_percent(20) ? 1 : 0);
					}
				}
			} else if (pmap[i][j].volume > 0) { // if has gas but can't hold gas,
				// disperse gas instantly into neighboring tiles that can hold gas
				numSpaces = 0;
				for (dir = 0; dir < DIRECTION_COUNT; dir++) {
					newX = i + nbDirs[dir][0];
					newY = j + nbDirs[dir][1];
					if (coordinatesAreInMap(newX, newY)
						&& !cellHasTerrainFlag(newX, newY, T_OBSTRUCTS_GAS))
					{
						numSpaces++;
					}
				}
				if (numSpaces > 0) {
					for (dir = 0; dir < DIRECTION_COUNT; dir++) {
						newX = i + nbDirs[dir][0];
						newY = j + nbDirs[dir][1];
						if (coordinatesAreInMap(newX, newY)
							&& !cellHasTerrainFlag(newX, newY, T_OBSTRUCTS_GAS))
						{
							newGasVolume[newX][newY] += Math.floor(pmap[i][j].volume / numSpaces);
							if ( Math.floor(pmap[i][j].volume / numSpaces) ) {
								pmap[newX][newY].layers[GAS] = pmap[i][j].layers[GAS];
							}
						}
					}
				}
				newGasVolume[i][j] = 0;
				pmap[i][j].layers[GAS] = NOTHING;
			}
		}
	}

	for (i=0; i<DCOLS; i++) {
		for (j=0; j<DROWS; j++) {
			if (pmap[i][j].volume != newGasVolume[i][j]) {
				pmap[i][j].volume = newGasVolume[i][j];
				refreshDungeonCell(i, j);
			}
		}
	}
}


function updateYendorWardenTracking() {
    let prevMonst;		// creature *
    let n;

    if (!rogue.yendorWarden) {
        return;
    }
    if (rogue.yendorWarden.depth == rogue.depthLevel) {
        return;
    }
    if (!(rogue.yendorWarden.bookkeepingFlags & MB_PREPLACED)) {
        levels[rogue.yendorWarden.depth - 1].mapStorage[rogue.yendorWarden.xLoc][rogue.yendorWarden.yLoc].flags &= ~HAS_MONSTER;
    }
    n = rogue.yendorWarden.depth - 1;

    // remove traversing monster from other level monster chain
    if (rogue.yendorWarden == levels[n].monsters) {
        levels[n].monsters = rogue.yendorWarden.nextCreature;
    } else {
        for (prevMonst = levels[n].monsters; prevMonst.nextCreature != rogue.yendorWarden; prevMonst = prevMonst.nextCreature);
        prevMonst.nextCreature = rogue.yendorWarden.nextCreature;
    }

    if (rogue.yendorWarden.depth > rogue.depthLevel) {
        rogue.yendorWarden.depth = rogue.depthLevel + 1;
        n = rogue.yendorWarden.depth - 1;
        rogue.yendorWarden.bookkeepingFlags |= MB_APPROACHING_UPSTAIRS;
        rogue.yendorWarden.xLoc = levels[n].downStairsLoc[0];
        rogue.yendorWarden.yLoc = levels[n].downStairsLoc[1];
    } else {
        rogue.yendorWarden.depth = rogue.depthLevel - 1;
        n = rogue.yendorWarden.depth - 1;
        rogue.yendorWarden.bookkeepingFlags |= MB_APPROACHING_DOWNSTAIRS;
        rogue.yendorWarden.xLoc = levels[n].upStairsLoc[0];
        rogue.yendorWarden.yLoc = levels[n].upStairsLoc[1];
    }
    rogue.yendorWarden.nextCreature = levels[rogue.yendorWarden.depth - 1].monsters;
    levels[rogue.yendorWarden.depth - 1].monsters = rogue.yendorWarden;
    rogue.yendorWarden.bookkeepingFlags |= MB_PREPLACED;
    rogue.yendorWarden.status[STATUS_ENTERS_LEVEL_IN] = 50;
}

// Monsters who are over chasms or other descent tiles won't fall until this is called.
// This is to avoid having the monster chain change unpredictably in the middle of a turn.
async function monstersFall() {
	let monst, previousCreature, nextCreature;	// creature *
	let x, y;
	const buf = STRING(), buf2 = STRING(); // char[DCOLS];

	// monsters plunge into chasms at the end of the turn
	for (monst = monsters.nextCreature; monst != NULL; monst = nextCreature) {
		nextCreature = monst.nextCreature;
		if ((monst.bookkeepingFlags & MB_IS_FALLING) || monsterShouldFall(monst)) {
			x = monst.xLoc;
			y = monst.yLoc;

			if (canSeeMonster(monst)) {
				monsterName(buf, monst, true);
				sprintf(buf2, "%s plunges out of sight!", buf);
				message(buf2, messageColorFromVictim(monst), false);
			}
      monst.status[STATUS_ENTRANCED] = 0;
			monst.bookkeepingFlags |= MB_PREPLACED;
			monst.bookkeepingFlags &= ~(MB_IS_FALLING | MB_SEIZED | MB_SEIZING);
      monst.targetCorpseLoc[0] = monst.targetCorpseLoc[1] = 0;
      if (monst.info.flags & MONST_GETS_TURN_ON_ACTIVATION) {
          // Guardians and mirrored totems never survive the fall. If they did, they might block the level below.
          await killCreature(monst, false);
      } else if (!await inflictDamage(NULL, monst, randClumpedRange(6, 12, 2), red, false)) {
				demoteMonsterFromLeadership(monst);

				// remove from monster chain
				for (previousCreature = monsters;
					 previousCreature.nextCreature != monst;
					 previousCreature = previousCreature.nextCreature);
				previousCreature.nextCreature = monst.nextCreature;

				// add to next level's chain
				monst.nextCreature = levels[rogue.depthLevel-1 + 1].monsters;
				levels[rogue.depthLevel-1 + 1].monsters = monst;

				monst.depth = rogue.depthLevel + 1;

		    if (monst == rogue.yendorWarden) {
		        updateYendorWardenTracking();
		    }
			}

			pmap[x][y].flags &= ~HAS_MONSTER;
			refreshDungeonCell(x, y);
		}
	}
}

async function updateEnvironment() {
	let i, j, direction, newX, newY;
	let promotions = GRID(DCOLS, DROWS); // short[DCOLS][DROWS];
  let promoteChance;
	let layer;	// enum dungeonLayers
	let tile;	// floorTileType *
	let isVolumetricGas = false;

	await monstersFall();

	// update gases twice
	for (i=0; i<DCOLS && !isVolumetricGas; i++) {
		for (j=0; j<DROWS && !isVolumetricGas; j++) {
			if (!isVolumetricGas && pmap[i][j].layers[GAS]) {
				isVolumetricGas = true;
			}
		}
	}
	if (isVolumetricGas) {
		updateVolumetricMedia();
		updateVolumetricMedia();
	}

	// Do random tile promotions in two passes to keep generations distinct.
	// First pass, make a note of each terrain layer at each coordinate that is going to promote:
	for (i=0; i<DCOLS; i++) {
		for (j=0; j<DROWS; j++) {
			promotions[i][j] = 0;
			for (layer = 0; layer < NUMBER_TERRAIN_LAYERS; layer++) {
				tile = tileCatalog[pmap[i][j].layers[layer]];
				if (tile.promoteChance < 0) {
					promoteChance = 0;
					for (direction = 0; direction < 4; direction++) {
						if (coordinatesAreInMap(i + nbDirs[direction][0], j + nbDirs[direction][1])
							&& !cellHasTerrainFlag(i + nbDirs[direction][0], j + nbDirs[direction][1], T_OBSTRUCTS_PASSABILITY)
							&& pmap[i + nbDirs[direction][0]][j + nbDirs[direction][1]].layers[layer] != pmap[i][j].layers[layer]
							&& !(pmap[i][j].flags & CAUGHT_FIRE_THIS_TURN))
						{
							promoteChance += -1 * tile.promoteChance;
						}
					}
				} else {
					promoteChance = tile.promoteChance;
				}
				if (promoteChance
					&& !(pmap[i][j].flags & CAUGHT_FIRE_THIS_TURN)
					&& rand_range(0, 10000) < promoteChance)
				{
					promotions[i][j] |= Fl(layer);
					//await promoteTile(i, j, layer, false);
				}
			}
		}
	}
	// Second pass, do the promotions:
	for (i=0; i<DCOLS; i++) {
		for (j=0; j<DROWS; j++) {
			for (layer = 0; layer < NUMBER_TERRAIN_LAYERS; layer++) {
				if ((promotions[i][j] & Fl(layer)))
				{
					//&& (tileCatalog[pmap[i][j].layers[layer]].promoteChance != 0)){
					// make sure that it's still a promotable layer
					await promoteTile(i, j, layer, false);
				}
			}
		}
	}

	// Bookkeeping for fire, pressure plates and key-activated tiles.
	for (i=0; i<DCOLS; i++) {
		for (j=0; j<DROWS; j++) {
			pmap[i][j].flags &= ~(CAUGHT_FIRE_THIS_TURN);
			if (!(pmap[i][j].flags & (HAS_PLAYER | HAS_MONSTER | HAS_ITEM))
                && (pmap[i][j].flags & PRESSURE_PLATE_DEPRESSED))
			{
				pmap[i][j].flags &= ~PRESSURE_PLATE_DEPRESSED;
			}
			if (cellHasTMFlag(i, j, TM_PROMOTES_WITHOUT_KEY) && !keyOnTileAt(i, j)) {
				for (layer = 0; layer < NUMBER_TERRAIN_LAYERS; layer++) {
					if (tileCatalog[pmap[i][j].layers[layer]].mechFlags & TM_PROMOTES_WITHOUT_KEY) {
						await promoteTile(i, j, layer, false);
					}
				}
			}
		}
	}

	// Update fire.
	for (i=0; i<DCOLS; i++) {
		for (j=0; j<DROWS; j++) {
			if (cellHasTerrainFlag(i, j, T_IS_FIRE) && !(pmap[i][j].flags & CAUGHT_FIRE_THIS_TURN)) {
				await exposeTileToFire(i, j, false);
				for (direction=0; direction<4; direction++) {
					newX = i + nbDirs[direction][0];
					newY = j + nbDirs[direction][1];
					if (coordinatesAreInMap(newX, newY)) {
						await exposeTileToFire(newX, newY, false);
					}
				}
			}
		}
	}

  // Terrain that affects items and vice versa
  await updateFloorItems();
}

function updateAllySafetyMap() {
	let i, j;
	let playerCostMap, monsterCostMap;

	rogue.updatedAllySafetyMapThisTurn = true;

	playerCostMap = allocGrid();
	monsterCostMap = allocGrid();

	for (i=0; i<DCOLS; i++) {
		for (j=0; j<DROWS; j++) {
			allySafetyMap[i][j] = 30000;

			playerCostMap[i][j] = monsterCostMap[i][j] = 1;

			if (cellHasTerrainFlag(i, j, T_OBSTRUCTS_PASSABILITY)
                && (!cellHasTMFlag(i, j, TM_IS_SECRET) || (discoveredTerrainFlagsAtLoc(i, j) & T_OBSTRUCTS_PASSABILITY)))
			{
				playerCostMap[i][j] = monsterCostMap[i][j] = cellHasTerrainFlag(i, j, T_OBSTRUCTS_DIAGONAL_MOVEMENT) ? PDS_OBSTRUCTION : PDS_FORBIDDEN;
			} else if (cellHasTerrainFlag(i, j, T_PATHING_BLOCKER & ~T_OBSTRUCTS_PASSABILITY)) {
				playerCostMap[i][j] = monsterCostMap[i][j] = PDS_FORBIDDEN;
			} else if (cellHasTerrainFlag(i, j, T_SACRED)) {
					playerCostMap[i][j] = 1;
					monsterCostMap[i][j] = PDS_FORBIDDEN;
			} else if ((pmap[i][j].flags & HAS_MONSTER) && monstersAreEnemies(player, monsterAtLoc(i, j))) {
				playerCostMap[i][j] = 1;
				monsterCostMap[i][j] = PDS_FORBIDDEN;
				allySafetyMap[i][j] = 0;
			}
		}
	}

	playerCostMap[player.xLoc][player.yLoc] = PDS_FORBIDDEN;
	monsterCostMap[player.xLoc][player.yLoc] = PDS_FORBIDDEN;

	dijkstraScan(allySafetyMap, playerCostMap, false);

	for (i=0; i<DCOLS; i++) {
		for (j=0; j<DROWS; j++) {
			if (monsterCostMap[i][j] < 0) {
				continue;
			}

			if (allySafetyMap[i][j] == 30000) {
				allySafetyMap[i][j] = 150;
			}

			allySafetyMap[i][j] = Math.floor(50 * allySafetyMap[i][j] / (50 + allySafetyMap[i][j]));

			allySafetyMap[i][j] *= -3;

			if (pmap[i][j].flags & IN_LOOP) {
				allySafetyMap[i][j] -= 10;
			}
		}
	}
	dijkstraScan(allySafetyMap, monsterCostMap, false);

	freeGrid(playerCostMap);
	freeGrid(monsterCostMap);
}

function resetDistanceCellInGrid(grid, x, y) {
    let dir;
    let newX, newY;
    for (dir = 0; dir < 4; dir++) {
        newX = x + nbDirs[dir][0];
        newY = y + nbDirs[dir][1];
        if (coordinatesAreInMap(newX, newY)
            && grid[x][y] > grid[newX][newY] + 1)
				{
            grid[x][y] = grid[newX][newY] + 1;
        }
    }
}

function updateSafetyMap() {
	let i, j;
	let playerCostMap, monsterCostMap;
	let monst;	// creature *

	rogue.updatedSafetyMapThisTurn = true;

	playerCostMap = allocGrid();
	monsterCostMap = allocGrid();

	for (i=0; i<DCOLS; i++) {
		for (j=0; j<DROWS; j++) {
			safetyMap[i][j] = 30000;

			playerCostMap[i][j] = monsterCostMap[i][j] = 1; // prophylactic

			if (cellHasTerrainFlag(i, j, T_OBSTRUCTS_PASSABILITY)
            && (!cellHasTMFlag(i, j, TM_IS_SECRET) || (discoveredTerrainFlagsAtLoc(i, j) & T_OBSTRUCTS_PASSABILITY)))
			{
				playerCostMap[i][j] = monsterCostMap[i][j] = cellHasTerrainFlag(i, j, T_OBSTRUCTS_DIAGONAL_MOVEMENT) ? PDS_OBSTRUCTION : PDS_FORBIDDEN;
			} else if (cellHasTerrainFlag(i, j, T_SACRED)) {
					playerCostMap[i][j] = 1;
					monsterCostMap[i][j] = PDS_FORBIDDEN;
			} else if (cellHasTerrainFlag(i, j, T_LAVA_INSTA_DEATH)) {
        monsterCostMap[i][j] = PDS_FORBIDDEN;
        if (player.status[STATUS_LEVITATING] || !player.status[STATUS_IMMUNE_TO_FIRE]) {
            playerCostMap[i][j] = 1;
        } else {
            playerCostMap[i][j] = PDS_FORBIDDEN;
        }
			} else {
				if (pmap[i][j].flags & HAS_MONSTER) {
					monst = monsterAtLoc(i, j);
					if ((monst.creatureState == MONSTER_SLEEPING
						 || monst.turnsSpentStationary > 2
             || (monst.info.flags & MONST_GETS_TURN_ON_ACTIVATION)
						 || monst.creatureState == MONSTER_ALLY)
						&& monst.creatureState != MONSTER_FLEEING)
					{
						playerCostMap[i][j] = 1;
						monsterCostMap[i][j] = PDS_FORBIDDEN;
						continue;
					}
				}

				if (cellHasTerrainFlag(i, j, (T_AUTO_DESCENT | T_IS_DF_TRAP))) {
					monsterCostMap[i][j] = PDS_FORBIDDEN;
          if (player.status[STATUS_LEVITATING]) {
              playerCostMap[i][j] = 1;
          } else {
              playerCostMap[i][j] = PDS_FORBIDDEN;
          }
				} else if (cellHasTerrainFlag(i, j, T_IS_FIRE)) {
					monsterCostMap[i][j] = PDS_FORBIDDEN;
          if (player.status[STATUS_IMMUNE_TO_FIRE]) {
              playerCostMap[i][j] = 1;
          } else {
              playerCostMap[i][j] = PDS_FORBIDDEN;
          }
				} else if (cellHasTerrainFlag(i, j, (T_IS_DEEP_WATER | T_SPONTANEOUSLY_IGNITES))) {
          if (player.status[STATUS_LEVITATING]) {
              playerCostMap[i][j] = 1;
          } else {
              playerCostMap[i][j] = 5;
          }
					monsterCostMap[i][j] = 5;
        } else if (cellHasTerrainFlag(i, j, T_OBSTRUCTS_PASSABILITY)
                   && cellHasTMFlag(i, j, TM_IS_SECRET) && !(discoveredTerrainFlagsAtLoc(i, j) & T_OBSTRUCTS_PASSABILITY)
                   && !(pmap[i][j].flags & IN_FIELD_OF_VIEW))
			 {
            // Secret door that the player can't currently see
            playerCostMap[i][j] = 100;
            monsterCostMap[i][j] = 1;
				} else {
					playerCostMap[i][j] = monsterCostMap[i][j] = 1;
				}
			}
		}
	}

	safetyMap[player.xLoc][player.yLoc] = 0;
	playerCostMap[player.xLoc][player.yLoc] = 1;
	monsterCostMap[player.xLoc][player.yLoc] = PDS_FORBIDDEN;

	playerCostMap[rogue.upLoc[0]][rogue.upLoc[1]] = PDS_FORBIDDEN;
	monsterCostMap[rogue.upLoc[0]][rogue.upLoc[1]] = PDS_FORBIDDEN;
	playerCostMap[rogue.downLoc[0]][rogue.downLoc[1]] = PDS_FORBIDDEN;
	monsterCostMap[rogue.downLoc[0]][rogue.downLoc[1]] = PDS_FORBIDDEN;

	dijkstraScan(safetyMap, playerCostMap, false);

	for (i=0; i<DCOLS; i++) {
		for (j=0; j<DROWS; j++) {
      if (cellHasTerrainFlag(i, j, T_OBSTRUCTS_PASSABILITY)
          && cellHasTMFlag(i, j, TM_IS_SECRET) && !(discoveredTerrainFlagsAtLoc(i, j) & T_OBSTRUCTS_PASSABILITY)
          && !(pmap[i][j].flags & IN_FIELD_OF_VIEW))
			{
          // Secret doors that the player can't see are not particularly safe themselves;
          // the areas behind them are.
          resetDistanceCellInGrid(safetyMap, i, j);
      }
    }
  }

	for (i=0; i<DCOLS; i++) {
		for (j=0; j<DROWS; j++) {
			if (monsterCostMap[i][j] < 0) {
				continue;
			}

			if (safetyMap[i][j] == 30000) {
				safetyMap[i][j] = 150;
			}

			safetyMap[i][j] = Math.floor(50 * safetyMap[i][j] / (50 + safetyMap[i][j]));

			safetyMap[i][j] *= -3;

			if (pmap[i][j].flags & IN_LOOP) {
				safetyMap[i][j] -= 10;
			}
		}
	}
	dijkstraScan(safetyMap, monsterCostMap, false);
	for (i=0; i<DCOLS; i++) {
		for (j=0; j<DROWS; j++) {
			if (monsterCostMap[i][j] < 0) {
				safetyMap[i][j] = 30000;
			}
		}
	}
	freeGrid(playerCostMap);
	freeGrid(monsterCostMap);
}

function updateSafeTerrainMap() {
	let i, j;
	let costMap;
	let monst;		// creature *

	rogue.updatedMapToSafeTerrainThisTurn = true;
	costMap = allocGrid();

	for (i=0; i<DCOLS; i++) {
		for (j=0; j<DROWS; j++) {
			monst = monsterAtLoc(i, j);
			if (cellHasTerrainFlag(i, j, T_OBSTRUCTS_PASSABILITY)
                && (!cellHasTMFlag(i, j, TM_IS_SECRET) || (discoveredTerrainFlagsAtLoc(i, j) & T_OBSTRUCTS_PASSABILITY)))
			{
				costMap[i][j] = cellHasTerrainFlag(i, j, T_OBSTRUCTS_DIAGONAL_MOVEMENT) ? PDS_OBSTRUCTION : PDS_FORBIDDEN;
				rogue.mapToSafeTerrain[i][j] = 30000; // OOS prophylactic
			} else if ((monst && (monst.turnsSpentStationary > 1 || (monst.info.flags & MONST_GETS_TURN_ON_ACTIVATION)))
                       || (cellHasTerrainFlag(i, j, T_PATHING_BLOCKER & ~T_HARMFUL_TERRAIN) && !cellHasTMFlag(i, j, TM_IS_SECRET)))
		  {
				costMap[i][j] = PDS_FORBIDDEN;
				rogue.mapToSafeTerrain[i][j] = 30000;
			} else if (cellHasTerrainFlag(i, j, T_HARMFUL_TERRAIN) || pmap[i][j].layers[DUNGEON] == DOOR) {
				// The door thing is an aesthetically offensive but necessary hack to make sure
				// that monsters trying to find their way out of caustic gas do not sprint for
				// the doors. Doors are superficially free of gas, but as soon as they are opened,
				// gas will fill their tile, so they are not actually safe. Without this fix,
				// allies will fidget back and forth in a doorway while they asphyxiate.
				// This will have to do. It's a difficult problem to solve elegantly.
				costMap[i][j] = 1;
				rogue.mapToSafeTerrain[i][j] = 30000;
			} else {
				costMap[i][j] = 1;
				rogue.mapToSafeTerrain[i][j] = 0;
			}
		}
	}
	dijkstraScan(rogue.mapToSafeTerrain, costMap, false);
	freeGrid(costMap);
}


function processIncrementalAutoID() {
  let theItem; // item *
	let autoIdentifyItems = [rogue.armor, rogue.ringLeft, rogue.ringRight];
  const buf = STRING(), theItemName = STRING(); // char[DCOLS*3];
  let i;

	for (i=0; i<3; i++) {
		theItem = autoIdentifyItems[i];
		if (theItem
			&& theItem.charges > 0
			&& (!(theItem.flags & ITEM_IDENTIFIED) || ((theItem.category & RING) && !ringTable[theItem.kind].identified)))
		{
			theItem.charges--;
			if (theItem.charges <= 0) {
				itemName(theItem, theItemName, false, false, NULL);
				sprintf(buf, "you are now familiar enough with your %s to identify it.", theItemName);
				message(buf, itemMessageColor, false);

				if (theItem.category & ARMOR) {
					// Don't necessarily reveal the armor's runic specifically, just that it has one.
					theItem.flags |= ITEM_IDENTIFIED;
				} else if (theItem.category & RING) {
					identify(theItem);
				}
				updateIdentifiableItems();

				itemName(theItem, theItemName, true, true, NULL);
				sprintf(buf, "%s %s.", (theItem.quantity > 1 ? "they are" : "it is"), theItemName);
				message(buf, itemMessageColor, false);
			}
		}
	}
}

function staffChargeDuration( /* item */ theItem) {
    // staffs of blinking and obstruction recharge half as fast so they're less powerful
    return Math.floor((theItem.kind == STAFF_BLINKING || theItem.kind == STAFF_OBSTRUCTION ? 10000 : 5000) / theItem.enchant1);
}

// Multiplier can be negative, in which case staffs and charms will be drained instead of recharged.
function rechargeItemsIncrementally(multiplier) {
	let theItem;		// item *
	const buf = STRING(), theItemName = STRING(); // char[DCOLS*3];
	let rechargeIncrement, staffRechargeDuration;

	if (rogue.wisdomBonus) {
		rechargeIncrement = fp_ringWisdomMultiplier(rogue.wisdomBonus << FP_BASE); // at level 27, you recharge anything to full in one turn
	} else {
		rechargeIncrement = 10;
	}

  rechargeIncrement *= multiplier;

	for (theItem = packItems.nextItem; theItem != NULL; theItem = theItem.nextItem) {
		if (theItem.category & STAFF) {
      if (theItem.charges < theItem.enchant1 && rechargeIncrement > 0
          || theItem.charges > 0 && rechargeIncrement < 0)
			{
          theItem.enchant2 -= rechargeIncrement;
      }
      staffRechargeDuration = staffChargeDuration(theItem);
      while (theItem.enchant2 <= 0) {
          // if it's time to add a staff charge
          if (theItem.charges < theItem.enchant1) {
              theItem.charges++;
          }
          theItem.enchant2 += randClumpedRange(max(staffRechargeDuration / 3, 1), staffRechargeDuration * 5 / 3, 3);
      }
      while (theItem.enchant2 > staffRechargeDuration * 5 / 3) {
          // if it's time to drain a staff charge
          if (theItem.charges > 0) {
              theItem.charges--;
          }
          theItem.enchant2 -= staffRechargeDuration;
      }
		} else if ((theItem.category & CHARM) && (theItem.charges > 0)) {
      theItem.charges = clamp(theItem.charges - multiplier, 0, charmRechargeDelay(theItem.kind, theItem.enchant1));
      if (theItem.charges == 0) {
				itemName(theItem, theItemName, false, false, NULL);
				sprintf(buf, "your %s has recharged.", theItemName);
        message(buf, false);
      }
    }
	}
}


function extinguishFireOnCreature( /* creature */ monst) {

	monst.status[STATUS_BURNING] = 0;
	if (monst === player) {
		player.info.foreColor = white;
		rogue.minersLight.lightColor = minersLightColor;
		refreshDungeonCell(player.xLoc, player.yLoc);
		updateVision(true);
		message("you are no longer on fire.", false);
	}
}

// n is the monster's depthLevel - 1.
async function monsterEntersLevel( /* creature */ monst, n) {
  let prevMonst;	// creature *
	const monstName = STRING(), buf = STRING(); // char[COLS];
	let pit = false;

  // place traversing monster near the stairs on this level
  if (monst.bookkeepingFlags & MB_APPROACHING_DOWNSTAIRS) {
      monst.xLoc = rogue.upLoc[0];
      monst.yLoc = rogue.upLoc[1];
  } else if (monst.bookkeepingFlags & MB_APPROACHING_UPSTAIRS) {
      monst.xLoc = rogue.downLoc[0];
      monst.yLoc = rogue.downLoc[1];
  } else if (monst.bookkeepingFlags & MB_APPROACHING_PIT) { // jumping down pit
      pit = true;
      monst.xLoc = levels[n].playerExitedVia[0];
      monst.yLoc = levels[n].playerExitedVia[1];
  } else {
      brogueAssert(false);
  }
  monst.depth = rogue.depthLevel;
  monst.targetCorpseLoc[0] = monst.targetCorpseLoc[1] = 0;

  if (!pit) {
      const loc = getQualifyingPathLocNear(monst.xLoc, monst.yLoc, true,
                               T_DIVIDES_LEVEL & avoidedFlagsForMonster(monst.info), 0,
                               avoidedFlagsForMonster(monst.info), HAS_STAIRS, false);
			if (!loc) ERROR('EXPECTED LOCATION');
			monst.xLoc = loc[0];
			monst.yLoc = loc[1];
  }
  if (!pit
      && (pmap[monst.xLoc][monst.yLoc].flags & (HAS_PLAYER | HAS_MONSTER))
      && !(terrainFlags(monst.xLoc, monst.yLoc) & avoidedFlagsForMonster(monst.info)))
	{
      // Monsters using the stairs will displace any creatures already located there, to thwart stair-dancing.
      prevMonst = monsterAtLoc(monst.xLoc, monst.yLoc);
      brogueAssert(prevMonst);
      const loc = getQualifyingPathLocNear(monst.xLoc, monst.yLoc, true,
                               T_DIVIDES_LEVEL & avoidedFlagsForMonster(prevMonst.info), 0,
                               avoidedFlagsForMonster(prevMonst.info), (HAS_MONSTER | HAS_PLAYER | HAS_STAIRS), false);
		  if (!loc) ERROR('EXPECTED LOCATION');
			prevMonst.xLoc = loc[0];
			prevMonst.yLoc = loc[1];

      pmap[monst.xLoc][monst.yLoc].flags &= ~(HAS_PLAYER | HAS_MONSTER);
      pmap[prevMonst.xLoc][prevMonst.yLoc].flags |= (prevMonst === player ? HAS_PLAYER : HAS_MONSTER);
      refreshDungeonCell(prevMonst.xLoc, prevMonst.yLoc);
      //DEBUG printf("\nBumped a creature (%s) from (%i, %i) to (%i, %i).", prevMonst.info.monsterName, monst.xLoc, monst.yLoc, prevMonst.xLoc, prevMonst.yLoc);
  }

  // remove traversing monster from other level monster chain
  if (monst == levels[n].monsters) {
      levels[n].monsters = monst.nextCreature;
  } else {
      for (prevMonst = levels[n].monsters; prevMonst.nextCreature != monst; prevMonst = prevMonst.nextCreature);
      prevMonst.nextCreature = monst.nextCreature;
  }

  // prepend traversing monster to current level monster chain
  monst.nextCreature = monsters.nextCreature;
  monsters.nextCreature = monst;

  monst.status[STATUS_ENTERS_LEVEL_IN] = 0;
  monst.bookkeepingFlags |= MB_PREPLACED;
  monst.bookkeepingFlags &= ~MB_IS_FALLING;
  restoreMonster(monst, NULL, NULL);
  //DEBUG printf("\nPlaced a creature (%s) at (%i, %i).", monst.info.monsterName, monst.xLoc, monst.yLoc);
  monst.ticksUntilTurn = monst.movementSpeed;
  refreshDungeonCell(monst.xLoc, monst.yLoc);

  if (pit) {
      monsterName(monstName, monst, true);
      if (!monst.status[STATUS_LEVITATING]) {
          if (await inflictDamage(NULL, monst, randClumpedRange(6, 12, 2), red, false)) {
              if (canSeeMonster(monst)) {
                  sprintf(buf, "%s plummets from above and splatters against the ground!", monstName);
                  message(buf, messageColorFromVictim(monst), false);
              }
          } else {
              if (canSeeMonster(monst)) {
                  sprintf(buf, "%s falls from above and crashes to the ground!", monstName);
                  message(buf, false);
              }
          }
      } else if (canSeeMonster(monst)) {
          sprintf(buf, "%s swoops into the cavern from above.", monstName);
          message(buf, false);
      }
  }
}


async function monstersApproachStairs() {
	let monst, nextMonst;		// creature *
	let n;

	for (n = rogue.depthLevel - 2; n <= rogue.depthLevel; n += 2) { // cycle through previous and next level
		if (n >= 0 && n < DEEPEST_LEVEL && levels[n].visited) {
			for (monst = levels[n].monsters; monst != NULL;) {
				nextMonst = monst.nextCreature;
				if (monst.status[STATUS_ENTERS_LEVEL_IN] > 1) {
					monst.status[STATUS_ENTERS_LEVEL_IN]--;
				} else if (monst.status[STATUS_ENTERS_LEVEL_IN] == 1) {
            await monsterEntersLevel(monst, n);
        }
				monst = nextMonst;
			}
		}
	}

    if (rogue.yendorWarden
        && abs(rogue.depthLevel - rogue.yendorWarden.depth) > 1)
		{
        updateYendorWardenTracking();
    }
}

async function decrementPlayerStatus() {
    // Handle hunger.
    if (!player.status[STATUS_PARALYZED]) {
      // No nutrition is expended while paralyzed.
      if (player.status[STATUS_NUTRITION] > 0) {
          if (!numberOfMatchingPackItems(AMULET, 0, 0, false) || rand_percent(20)) {
              player.status[STATUS_NUTRITION]--;
          }
      }
      await checkNutrition();
    }

	if (player.status[STATUS_TELEPATHIC] > 0 && !--player.status[STATUS_TELEPATHIC]) {
		updateVision(true);
		message("your preternatural mental sensitivity fades.", false);
	}

	if (player.status[STATUS_DARKNESS] > 0) {
		player.status[STATUS_DARKNESS]--;
		updateMinersLightRadius();
		//updateVision();
	}

	if (player.status[STATUS_HALLUCINATING] > 0 && !--player.status[STATUS_HALLUCINATING]) {
		displayLevel();
		message("your hallucinations fade.", false);
	}

	if (player.status[STATUS_LEVITATING] > 0 && !--player.status[STATUS_LEVITATING]) {
		message("you are no longer levitating.", false);
	}

	if (player.status[STATUS_CONFUSED] > 0 && !--player.status[STATUS_CONFUSED]) {
		message("you no longer feel confused.", false);
	}

	if (player.status[STATUS_NAUSEOUS] > 0 && !--player.status[STATUS_NAUSEOUS]) {
		message("you feel less nauseous.", false);
	}

	if (player.status[STATUS_PARALYZED] > 0 && !--player.status[STATUS_PARALYZED]) {
		message("you can move again.", false);
	}

	if (player.status[STATUS_HASTED] > 0 && !--player.status[STATUS_HASTED]) {
		player.movementSpeed = player.info.movementSpeed;
		player.attackSpeed = player.info.attackSpeed;
    synchronizePlayerTimeState();
		message("your supernatural speed fades.", false);
	}

	if (player.status[STATUS_SLOWED] > 0 && !--player.status[STATUS_SLOWED]) {
		player.movementSpeed = player.info.movementSpeed;
		player.attackSpeed = player.info.attackSpeed;
    synchronizePlayerTimeState();
		message("your normal speed resumes.", false);
	}

	if (player.status[STATUS_WEAKENED] > 0 && !--player.status[STATUS_WEAKENED]) {
		player.weaknessAmount = 0;
		message("strength returns to your muscles as the weakening toxin wears off.", false);
		updateEncumbrance();
	}

    if (player.status[STATUS_DONNING]) {
        player.status[STATUS_DONNING]--;
        recalculateEquipmentBonuses();
    }

	if (player.status[STATUS_IMMUNE_TO_FIRE] > 0 && !--player.status[STATUS_IMMUNE_TO_FIRE]) {
		message("you no longer feel immune to fire.", false);
	}

	if (player.status[STATUS_STUCK] && !cellHasTerrainFlag(player.xLoc, player.yLoc, T_ENTANGLES)) {
		player.status[STATUS_STUCK] = 0;
	}

	if (player.status[STATUS_EXPLOSION_IMMUNITY]) {
		player.status[STATUS_EXPLOSION_IMMUNITY]--;
	}

	if (player.status[STATUS_DISCORDANT]) {
		player.status[STATUS_DISCORDANT]--;
	}

	if (player.status[STATUS_AGGRAVATING]) {
		player.status[STATUS_AGGRAVATING]--;
	}

	if (player.status[STATUS_SHIELDED]) {
		player.status[STATUS_SHIELDED] -= player.maxStatus[STATUS_SHIELDED] / 20;
        if (player.status[STATUS_SHIELDED] <= 0) {
            player.status[STATUS_SHIELDED] = player.maxStatus[STATUS_SHIELDED] = 0;
        }
	}

	if (player.status[STATUS_INVISIBLE] > 0 && !--player.status[STATUS_INVISIBLE]) {
		message("you are no longer invisible.", false);
	}

	if (rogue.monsterSpawnFuse <= 0) {
		await spawnPeriodicHorde();
		rogue.monsterSpawnFuse = rand_range(125, 175);
	}
}

function dangerChanged(danger /* boolean[4] */) {
    let dir;
    let newX, newY;
    for (dir = 0; dir < 4; dir++) {
        newX = player.xLoc + nbDirs[dir][0];
        newY = player.yLoc + nbDirs[dir][1];
        if (danger[dir] != monsterAvoids(player, newX, newY)) {
            return true;
        }
    }
    return false;
}

async function autoRest() {
	let i = 0;
	let initiallyEmbedded; // Stop as soon as we're free from crystal.
	const danger = []; // boolean[4];
	let newX, newY;
	let dir;

	for (dir = 0; dir < 4; dir++) {
			newX = player.xLoc + nbDirs[dir][0];
			newY = player.yLoc + nbDirs[dir][1];
			danger[dir] = monsterAvoids(player, newX, newY);
	}

	rogue.disturbed = false;
	rogue.automationActive = true;
	initiallyEmbedded = cellHasTerrainFlag(player.xLoc, player.yLoc, T_OBSTRUCTS_PASSABILITY);

	if ((player.currentHP < player.info.maxHP
		 || player.status[STATUS_HALLUCINATING]
		 || player.status[STATUS_CONFUSED]
		 || player.status[STATUS_NAUSEOUS]
		 || player.status[STATUS_POISONED]
		 || player.status[STATUS_DARKNESS]
		 || initiallyEmbedded)
		&& !rogue.disturbed)
	{
		while (i++ < TURNS_FOR_FULL_REGEN
			   && (player.currentHP < player.info.maxHP
				   || player.status[STATUS_HALLUCINATING]
				   || player.status[STATUS_CONFUSED]
				   || player.status[STATUS_NAUSEOUS]
				   || player.status[STATUS_POISONED]
				   || player.status[STATUS_DARKNESS]
				   || cellHasTerrainFlag(player.xLoc, player.yLoc, T_OBSTRUCTS_PASSABILITY))
			   && !rogue.disturbed
			   && (!initiallyEmbedded || cellHasTerrainFlag(player.xLoc, player.yLoc, T_OBSTRUCTS_PASSABILITY)))
	 {
			recordKeystroke(REST_KEY, false, false);
			rogue.justRested = true;
			await playerTurnEnded();
			if (dangerChanged(danger) || await pauseBrogue(1)) {
				rogue.disturbed = true;
			}
		}
	} else {
		for (i=0; i<100 && !rogue.disturbed; i++) {
			recordKeystroke(REST_KEY, false, false);
			rogue.justRested = true;
			await playerTurnEnded();
			//refreshSideBar(-1, -1, false);
			if (dangerChanged(danger) || await pauseBrogue(1)) {
				rogue.disturbed = true;
			}
			//refreshSideBar(-1, -1, false);
		}
	}
	rogue.automationActive = false;
}


async function searchTurn() {
    let foundSomething = false;
    recordKeystroke(SEARCH_KEY, false, false);
    if (player.status[STATUS_SEARCHING] <= 0) {
        player.status[STATUS_SEARCHING] = player.maxStatus[STATUS_SEARCHING] = 5;
    } else {
        player.status[STATUS_SEARCHING]--;
        if (player.status[STATUS_SEARCHING] <= 0) {
            // Manual search complete!
            foundSomething = await search(200);
            if (foundSomething) {
                message("you finish searching the area.", false);
            } else {
                message("you finish searching the area, but find nothing.", false);
            }
        }
    }
    rogue.justSearched = true;
    await playerTurnEnded();
}

async function manualSearch() {
    if (rogue.playbackMode) {
        await searchTurn();
    } else {
        rogue.disturbed = false;
        rogue.automationActive = true;
        do {
            await searchTurn();
            if (await pauseBrogue(80)) {
                rogue.disturbed = true;
            }
        } while (player.status[STATUS_SEARCHING] > 0 && !rogue.disturbed);
        rogue.automationActive = false;
    }
}


// Call this periodically (when haste/slow wears off and when moving between depths)
// to keep environmental updates in sync with player turns.
function synchronizePlayerTimeState() {
    rogue.ticksTillUpdateEnvironment = player.ticksUntilTurn;
}

function playerRecoversFromAttacking(anAttackHit) {
    if (player.ticksUntilTurn >= 0) {
        // Don't do this if the player's weapon of speed just fired.
        if (rogue.weapon && (rogue.weapon.flags & ITEM_ATTACKS_STAGGER) && anAttackHit) {		// ITEM_ATTACKS_HIT_SLOWLY
            player.ticksUntilTurn += 2 * player.attackSpeed;
        } else if (rogue.weapon && (rogue.weapon.flags & ITEM_ATTACKS_QUICKLY)) {
            player.ticksUntilTurn += player.attackSpeed / 2;
        } else {
            player.ticksUntilTurn += player.attackSpeed;
        }
    }
}

// This is the dungeon schedule manager, called every time the player's turn comes to an end.
// It hands control over to monsters until they've all expended their accumulated ticks,
// updating the environment (gas spreading, flames spreading and burning out, etc.) every
// 100 ticks.
async function playerTurnEnded() {
	let soonestTurn, damage, turnsRequiredToShore, turnsToShore;
	const buf = STRING(), buf2 = STRING(); // char[COLS];
	let monst, monst2, nextMonst;		// creature *
	let fastForward = false;

  brogueAssert(rogue.RNG == RNG_SUBSTANTIVE);

	handleXPXP();
	resetDFMessageEligibility();

	if (player.bookkeepingFlags & MB_IS_FALLING) {
		await playerFalls();
    if (!rogue.gameHasEnded) {
        await handleHealthAlerts();
    }
		return;
	}

	do {
		if (rogue.gameHasEnded) {
			return;
		}

		if (!player.status[STATUS_PARALYZED]) {
			rogue.playerTurnNumber++; // So recordings don't register more turns than you actually have.
		}
    rogue.absoluteTurnNumber++;

    if (player.status[STATUS_INVISIBLE]) {
        rogue.scentTurnNumber += 10; // Your scent fades very quickly while you are invisible.
    } else {
        rogue.scentTurnNumber += 3; // this must happen per subjective player time
    }
		if (rogue.scentTurnNumber > 20000) {
			resetScentTurnNumber();
		}

		//updateFlavorText();

		// Regeneration/starvation:
		if (player.status[STATUS_NUTRITION] <= 0) {
			player.currentHP--;
			if (player.currentHP <= 0) {
				await gameOver("Starved to death", true);
				return;
			}
		} else if (player.currentHP < player.info.maxHP
				   && !player.status[STATUS_POISONED])
	  {
			if ((player.turnsUntilRegen -= 1000) <= 0) {
				player.currentHP++;
				if (player.previousHealthPoints < player.currentHP) {
						player.previousHealthPoints++; // Regeneration doesn't display on the status bar.
				}
				player.turnsUntilRegen += player.info.turnsBetweenRegen;
			}
			if (player.regenPerTurn) {
				player.currentHP += player.regenPerTurn;
				if (player.previousHealthPoints < player.currentHP) {
						player.previousHealthPoints = min(player.currentHP, player.previousHealthPoints + player.regenPerTurn);
				}
			}
		}

		if (rogue.awarenessBonus > -30 && !(pmap[player.xLoc][player.yLoc].flags & SEARCHED_FROM_HERE)) {
			await search(rogue.awarenessBonus + 30);
			pmap[player.xLoc][player.yLoc].flags |= SEARCHED_FROM_HERE;
		}
    if (!rogue.justSearched && player.status[STATUS_SEARCHING] > 0) {
        // If you don't resume manually searching when interrupted, abort the search and post a message.
        player.status[STATUS_SEARCHING] = 0;
        message("you abandon your search.", false);
    }

		if (rogue.staleLoopMap) {
			analyzeMap(false); // Don't need to update the chokemap.
		}

		for (monst = monsters.nextCreature; monst != NULL; monst = nextMonst) {
			nextMonst = monst.nextCreature;
			if ((monst.bookkeepingFlags & MB_BOUND_TO_LEADER)
				&& (!monst.leader || !(monst.bookkeepingFlags & MB_FOLLOWER))
				&& (monst.creatureState != MONSTER_ALLY))
			{
				await killCreature(monst, false);
				if (canSeeMonster(monst)) {
					monsterName(buf2, monst, true);
					sprintf(buf, "%s dissipates into thin air", buf2);
					combatMessage(buf, messageColorFromVictim(monst));
				}
			}
		}

		if (player.status[STATUS_BURNING] > 0) {
			damage = rand_range(1, 3);
			if (!(player.status[STATUS_IMMUNE_TO_FIRE]) && await inflictDamage(NULL, player, damage, orange, true)) {
				await gameOver("Burned to death", true);
			}
			if (!--player.status[STATUS_BURNING]) {
				player.status[STATUS_BURNING]++; // ugh
				extinguishFireOnCreature(player);
			}
		}

		if (player.status[STATUS_POISONED] > 0) {
			player.status[STATUS_POISONED]--;
			if (await inflictDamage(NULL, player, player.poisonAmount, green, true)) {
				await gameOver("Died from poison", true);
			}
      if (!player.status[STATUS_POISONED]) {
          player.poisonAmount = 0;
      }
		}

		if (player.ticksUntilTurn == 0) { // attacking adds ticks elsewhere
			player.ticksUntilTurn += player.movementSpeed;
		} else if (player.ticksUntilTurn < 0) { // if he gets a free turn
			player.ticksUntilTurn = 0;
		}

		updateScent();
//		updateVision(true);
//        rogue.aggroRange = currentAggroValue();
//        if (rogue.displayAggroRangeMode) {
//            displayLevel();
//        }
		rogue.updatedSafetyMapThisTurn			= false;
		rogue.updatedAllySafetyMapThisTurn		= false;
		rogue.updatedMapToSafeTerrainThisTurn	= false;

		for (monst = monsters.nextCreature; monst != NULL; monst = monst.nextCreature) {
			if (D_SAFETY_VISION || monst.creatureState == MONSTER_FLEEING && pmap[monst.xLoc][monst.yLoc].flags & IN_FIELD_OF_VIEW) {
				updateSafetyMap(); // only if there is a fleeing monster who can see the player
				break;
			}
		}

		if (D_BULLET_TIME && !rogue.justRested) {
			player.ticksUntilTurn = 0;
		}

		await applyGradualTileEffectsToCreature(player, player.ticksUntilTurn);

		if (rogue.gameHasEnded) {
			return;
		}

		rogue.heardCombatThisTurn = false;

		while (player.ticksUntilTurn > 0) {
			soonestTurn = 10000;
			for(monst = monsters.nextCreature; monst != NULL; monst = monst.nextCreature) {
				soonestTurn = min(soonestTurn, monst.ticksUntilTurn);
			}
			soonestTurn = min(soonestTurn, player.ticksUntilTurn);
			soonestTurn = min(soonestTurn, rogue.ticksTillUpdateEnvironment);
			for(monst = monsters.nextCreature; monst != NULL; monst = monst.nextCreature) {
				monst.ticksUntilTurn -= soonestTurn;
			}
			rogue.ticksTillUpdateEnvironment -= soonestTurn;
			if (rogue.ticksTillUpdateEnvironment <= 0) {
				rogue.ticksTillUpdateEnvironment += 100;

				// stuff that happens periodically according to an objective time measurement goes here:
				rechargeItemsIncrementally(1); // staffs recharge every so often
        processIncrementalAutoID();   // become more familiar with worn armor and rings
				rogue.monsterSpawnFuse--; // monsters spawn in the level every so often

				for (monst = monsters.nextCreature; monst != NULL;) {
					nextMonst = monst.nextCreature;
					await applyInstantTileEffectsToCreature(monst);
					monst = nextMonst; // this weirdness is in case the monster dies in the previous step
				}

				for (monst = monsters.nextCreature; monst != NULL;) {
					nextMonst = monst.nextCreature;
					await decrementMonsterStatus(monst);
					monst = nextMonst;
				}

				// monsters with a dungeon feature spawn it every so often
				for (monst = monsters.nextCreature; monst != NULL;) {
					nextMonst = monst.nextCreature;
					if (monst.info.DFChance
              && !(monst.info.flags & MONST_GETS_TURN_ON_ACTIVATION)
              && rand_percent(monst.info.DFChance))
					{
						await spawnDungeonFeature(monst.xLoc, monst.yLoc, dungeonFeatureCatalog[monst.info.DFType], true, false);
					}
					monst = nextMonst;
				}

				await updateEnvironment(); // Update fire and gas, items floating around in water, monsters falling into chasms, etc.
				await decrementPlayerStatus();
				await applyInstantTileEffectsToCreature(player);
				if (rogue.gameHasEnded) { // caustic gas, lava, trapdoor, etc.
					return;
				}
				await monstersApproachStairs();

				if (player.ticksUntilTurn > 100 && !fastForward) {
						fastForward = rogue.playbackFastForward || await pauseBrogue(25);
				}

        // Rolling waypoint refresh:
        rogue.wpRefreshTicker++;
        if (rogue.wpRefreshTicker >= rogue.wpCount) {
            rogue.wpRefreshTicker = 0;
        }
        refreshWaypoint(rogue.wpRefreshTicker);
			}

			let monsterActed = false;
			for (monst = monsters.nextCreature; (monst != NULL) && (rogue.gameHasEnded == false); monst = monst.nextCreature) {
				if (monst.ticksUntilTurn <= 0) {
          if (monst.currentHP > monst.info.maxHP) {
              monst.currentHP = monst.info.maxHP;
          }

          if ((monst.info.flags & MONST_GETS_TURN_ON_ACTIVATION)
              || monst.status[STATUS_PARALYZED]
              || monst.status[STATUS_ENTRANCED]
              || (monst.bookkeepingFlags & MB_CAPTIVE))
					{
              // Do not pass go; do not collect 200 gold.
              monst.ticksUntilTurn = monst.movementSpeed;
          } else {
              await monstersTurn(monst);
							if (canSeeMonster(monst)) {
								monsterActed = true;
							}
							monst.ticksUntilTurn = monst.movementSpeed;
          }

					for(monst2 = monsters.nextCreature; monst2 != NULL; monst2 = monst2.nextCreature) {
						if (monst2 === monst) { // monst still alive and on the level
							await applyGradualTileEffectsToCreature(monst, monst.ticksUntilTurn);
							break;
						}
					}
					monst = monsters; // loop through from the beginning to be safe
				}
			}

			// SWC - See enemy movements
			if (monsterActed) {
				await pauseBrogue(50);
			}

			player.ticksUntilTurn -= soonestTurn;

			if (rogue.gameHasEnded) {
				return;
			}
		}
		// DEBUG displayLevel();
		//checkForDungeonErrors();

    updateVision(true);
    rogue.aggroRange = currentAggroValue();
    if (rogue.displayAggroRangeMode) {
        displayLevel();
    }

		for(monst = monsters.nextCreature; monst != NULL; monst = monst.nextCreature) {
			if (canSeeMonster(monst) && !(monst.bookkeepingFlags & (MB_WAS_VISIBLE | MB_ALREADY_SEEN))) {
				monst.bookkeepingFlags |= MB_WAS_VISIBLE;
				if (monst.creatureState != MONSTER_ALLY) {
					rogue.disturbed = true;
					if (rogue.cautiousMode || rogue.automationActive) {
						// assureCosmeticRNG();
						monsterName(buf2, monst, false);
						sprintf(buf, "you %s a%s %s",
								playerCanDirectlySee(monst.xLoc, monst.yLoc) ? "see" : "sense",
								(isVowelish(buf2) ? "n" : ""),
								buf2);
						if (rogue.cautiousMode) {
							strcat(buf, ".");
							await messageWithAck(buf);
						} else {
							combatMessage(buf, 0);
						}
						// restoreRNG();
					}
				}
				if (cellHasTerrainFlag(monst.xLoc, monst.yLoc, T_OBSTRUCTS_PASSABILITY)
					&& cellHasTMFlag(monst.xLoc, monst.yLoc, TM_IS_SECRET))
				{
					await	discover(monst.xLoc, monst.yLoc);
				}
        if (canDirectlySeeMonster(monst)) {
            if (rogue.weapon && rogue.weapon.flags & ITEM_RUNIC
                && rogue.weapon.enchant2 == W_SLAYING
                && !(rogue.weapon.flags & ITEM_RUNIC_HINTED)
                && monsterIsInClass(monst, rogue.weapon.vorpalEnemy))
						{
                rogue.weapon.flags |= ITEM_RUNIC_HINTED;
                buf2 = itemName(rogue.weapon, false, false, NULL);
                sprintf(buf, "the runes on your %s gleam balefully.", buf2);
                await messageWithAck(buf, itemMessageColor);
            }
            if (rogue.armor && rogue.armor.flags & ITEM_RUNIC
                && rogue.armor.enchant2 == A_IMMUNITY
                && !(rogue.armor.flags & ITEM_RUNIC_HINTED)
                && monsterIsInClass(monst, rogue.armor.vorpalEnemy))
						{
                rogue.armor.flags |= ITEM_RUNIC_HINTED;
                buf2 = itemName(rogue.armor, false, false, NULL);
                sprintf(buf, "the runes on your %s glow protectively.", buf2);
                await messageWithAck(buf, itemMessageColor);
            }
        }
			} else if (!canSeeMonster(monst)
					   && (monst.bookkeepingFlags & MB_WAS_VISIBLE)
					   && !(monst.bookkeepingFlags & MB_CAPTIVE))
		  {
				monst.bookkeepingFlags &= ~MB_WAS_VISIBLE;
			}
		}

		displayCombatText();

		if (player.status[STATUS_PARALYZED]) {
			if (!fastForward) {
				fastForward = rogue.playbackFastForward || await pauseBrogue(25);
			}
		}

		//checkNutrition(); // Now handled within decrementPlayerStatus().
    if (!rogue.playbackFastForward) {
        shuffleTerrainColors(100, false);
    }

		displayAnnotation();

		refreshSideBar(-1, -1, false);

		await applyInstantTileEffectsToCreature(player);
		if (rogue.gameHasEnded) { // caustic gas, lava, trapdoor, etc.
			return;
		}

    if (player.currentHP > player.info.maxHP) {
        player.currentHP = player.info.maxHP;
    }

    if (player.bookkeepingFlags & MB_IS_FALLING) {
        await playerFalls();
        await handleHealthAlerts();
        return;
    }
	} while (player.status[STATUS_PARALYZED]);

	rogue.justRested = false;
	rogue.justSearched = false;
	updateFlavorText();

	if (!rogue.updatedMapToShoreThisTurn) {
		updateMapToShore();
	}

	// "point of no return" check
	if ((player.status[STATUS_LEVITATING] && cellHasTerrainFlag(player.xLoc, player.yLoc, T_LAVA_INSTA_DEATH | T_IS_DEEP_WATER | T_AUTO_DESCENT))
		|| (player.status[STATUS_IMMUNE_TO_FIRE] && cellHasTerrainFlag(player.xLoc, player.yLoc, T_LAVA_INSTA_DEATH)))
	{
		if (!rogue.receivedLevitationWarning) {
			turnsRequiredToShore = Math.ceil(rogue.mapToShore[player.xLoc][player.yLoc] * player.movementSpeed / 100);
			if (cellHasTerrainFlag(player.xLoc, player.yLoc, T_LAVA_INSTA_DEATH)) {
				turnsToShore = max(player.status[STATUS_LEVITATING], player.status[STATUS_IMMUNE_TO_FIRE]) * 100 / player.movementSpeed;
			} else {
				turnsToShore = player.status[STATUS_LEVITATING] * 100 / player.movementSpeed;
			}
			turnsToShore = Math.ceil(turnsToShore);

			if (turnsRequiredToShore == turnsToShore || turnsRequiredToShore + 1 == turnsToShore) {
				await messageWithAck("better head back to solid ground!");
				rogue.receivedLevitationWarning = true;
			} else if (turnsRequiredToShore > turnsToShore
			 					&& turnsRequiredToShore < 10000)
			{
				await messageWithAck("you're past the point of no return!");
				rogue.receivedLevitationWarning = true;
			}
		}
	} else {
		rogue.receivedLevitationWarning = false;
	}

	emptyGraveyard();
	rogue.playbackBetweenTurns = true;
	RNGCheck();
	await handleHealthAlerts();

  if (rogue.flareCount > 0) {
      await animateFlares(rogue.flares, rogue.flareCount);
      rogue.flareCount = 0;
  }
}


function resetScentTurnNumber() { // don't want player.scentTurnNumber to roll over the short maxint!
	let i, j, d;
	rogue.scentTurnNumber -= 15000;
  for (d = 0; d < DEEPEST_LEVEL; d++) {
    if (levels[d].visited) {
      for (i=0; i<DCOLS; i++) {
        for (j=0; j<DROWS; j++) {
          if (levels[d].scentMap[i][j] > 15000) {
            levels[d].scentMap[i][j] -= 15000;
          } else {
            levels[d].scentMap[i][j] = 0;
          }
        }
      }
    }
  }
}
/*
 *  Light.c
 *  Brogue
 *
 *  Created by Brian Walker on 1/21/09.
 *  Copyright 2012. All rights reserved.
 *
 *  This file is part of Brogue.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

// #include <math.h>
// #include "Rogue.h"
// #include "IncludeGlobals.h"

// void logLights() {
//
// 	short i, j;
//
// 	printf("    ");
// 	for (i=0; i<COLS-2; i++) {
// 		printf("%i", i % 10);
// 	}
// 	printf("\n");
// 	for( j=0; j<DROWS-2; j++ ) {
// 		if (j < 10) {
// 			printf(" ");
// 		}
// 		printf("%i: ", j);
// 		for( i=0; i<DCOLS-2; i++ ) {
// 			if (tmap[i][j].light[0] == 0) {
// 				printf(" ");
// 			} else {
// 				printf("%i", max(0, tmap[i][j].light[0] / 10 - 1));
// 			}
// 		}
// 		printf("\n");
// 	}
// 	printf("\n");
// }

// Returns true if any part of the light hit cells that are in the player's field of view.
function paintLight( /* lightSource */theLight, x, y, isMinersLight, maintainShadows) {
	let i, j, k;
	let colorComponents = [0,0,0], randComponent, lightMultiplier;
	let fadeToPercent, radiusRounded;
	let radius;
	let grid = GRID(DCOLS, DROWS); // char[DCOLS][DROWS];
	let dispelShadows, overlappedFieldOfView;

  brogueAssert(rogue.RNG == RNG_SUBSTANTIVE);

	radius = Math.floor((randClump(theLight.lightRadius) << FP_BASE) / 100);
	radiusRounded = Math.floor(radius >> FP_BASE);

	randComponent = rand_range(0, theLight.lightColor.rand);
	colorComponents[0] = randComponent + theLight.lightColor.red + rand_range(0, theLight.lightColor.redRand);
	colorComponents[1] = randComponent + theLight.lightColor.green + rand_range(0, theLight.lightColor.greenRand);
	colorComponents[2] = randComponent + theLight.lightColor.blue + rand_range(0, theLight.lightColor.blueRand);

	// the miner's light does not dispel IS_IN_SHADOW,
	// so the player can be in shadow despite casting his own light.
	dispelShadows = !maintainShadows && (colorComponents[0] + colorComponents[1] + colorComponents[2]) > 0;

	fadeToPercent = theLight.radialFadeToPercent;

	// zero out only the relevant rectangle of the grid
	for (i = max(0, x - radiusRounded); i < DCOLS && i < x + radiusRounded; i++) {
		for (j = max(0, y - radiusRounded); j < DROWS && j < y + radiusRounded; j++) {
			grid[i][j] = 0;
		}
	}

	getFOVMask(grid, x, y, radius, T_OBSTRUCTS_VISION, (theLight.passThroughCreatures ? 0 : (HAS_MONSTER | HAS_PLAYER)), (!isMinersLight));

  overlappedFieldOfView = false;

	for (i = max(0, x - radiusRounded); i < DCOLS && i < x + radiusRounded; i++) {
		for (j = max(0, y - radiusRounded); j < DROWS && j < y + radiusRounded; j++) {
			if (grid[i][j]) {
				lightMultiplier = Math.floor(100 - (100 - fadeToPercent) * (fp_sqrt( ((i-x) * (i-x) + (j-y) * (j-y)) << FP_BASE) / radius));
				for (k=0; k<3; k++) {
					tmap[i][j].light[k] += Math.floor(colorComponents[k] * lightMultiplier / 100);
				}
				if (dispelShadows) {
					pmap[i][j].flags &= ~IS_IN_SHADOW;
				}
        if (pmap[i][j].flags & (IN_FIELD_OF_VIEW | ANY_KIND_OF_VISIBLE)) {
            overlappedFieldOfView = true;
        }
			}
		}
	}

	tmap[x][y].light[0] += colorComponents[0];
	tmap[x][y].light[1] += colorComponents[1];
	tmap[x][y].light[2] += colorComponents[2];

	if (dispelShadows) {
		pmap[x][y].flags &= ~IS_IN_SHADOW;
	}

  return overlappedFieldOfView;
}


// sets miner's light strength and characteristics based on rings of illumination, scrolls of darkness and water submersion
function updateMinersLightRadius() {
	let base_fraction, fraction, lightRadius;

	lightRadius = 100 * rogue.minersLightRadius;

	if (rogue.lightMultiplier < 0) {
		lightRadius = lightRadius / (-1 * rogue.lightMultiplier + 1);
	} else {
		lightRadius *= (rogue.lightMultiplier);
		lightRadius = max(lightRadius, (rogue.lightMultiplier * 2 + 2) << FP_BASE);
	}

	if (player.status[STATUS_DARKNESS]) {
        base_fraction = FP_FACTOR - (player.status[STATUS_DARKNESS] << FP_BASE) / player.maxStatus[STATUS_DARKNESS];
        fraction = (base_fraction * base_fraction >> FP_BASE) * base_fraction >> FP_BASE;
        //fraction = (double) pow(1.0 - (((double) player.status[STATUS_DARKNESS]) / player.maxStatus[STATUS_DARKNESS]), 3);
		if (fraction < FP_FACTOR / 20) {
			fraction = FP_FACTOR / 20;
    }
    lightRadius = lightRadius * fraction >> FP_BASE;
  } else {
      fraction = FP_FACTOR;
  }

	if (lightRadius < 2 << FP_BASE) {
		lightRadius = 2 << FP_BASE;
	}

	if (rogue.inWater && lightRadius > 3 << FP_BASE) {
		lightRadius = max(lightRadius / 2, 3 << FP_BASE);
	}

	rogue.minersLight.radialFadeToPercent = 35 + max(0, min(65, rogue.lightMultiplier * 5)) * fraction >> FP_BASE;
	rogue.minersLight.lightRadius.upperBound = rogue.minersLight.lightRadius.lowerBound = clamp(lightRadius >> FP_BASE, -30000, 30000);
}


function updateDisplayDetail() {
	let i, j;

	for (i = 0; i < DCOLS; i++) {
		for (j = 0; j < DROWS; j++) {
			if (tmap[i][j].light[0] < -10
				&& tmap[i][j].light[1] < -10
				&& tmap[i][j].light[2] < -10) {

				displayDetail[i][j] = DV_DARK;
			} else if (pmap[i][j].flags & IS_IN_SHADOW) {
				displayDetail[i][j] = DV_UNLIT;
			} else {
				displayDetail[i][j] = DV_LIT;
			}
		}
	}
}

function backUpLighting( lights /* short[DCOLS][DROWS][3] */ ) {
	let i, j, k;
	for (i=0; i<DCOLS; i++) {
		for (j=0; j<DROWS; j++) {
			for (k=0; k<3; k++) {
				lights[i][j][k] = tmap[i][j].light[k];
			}
		}
	}
}

function restoreLighting( lights /* short[DCOLS][DROWS][3] */) {
	let i, j, k;
	for (i=0; i<DCOLS; i++) {
		for (j=0; j<DROWS; j++) {
			for (k=0; k<3; k++) {
				tmap[i][j].light[k] = lights[i][j][k];
			}
		}
	}
}

function recordOldLights() {
    let i, j, k;
    for (i = 0; i < DCOLS; i++) {
		for (j = 0; j < DROWS; j++) {
			for (k=0; k<3; k++) {
				tmap[i][j].oldLight[k] = tmap[i][j].light[k];
			}
		}
	}
}

function updateLighting() {
	let i, j, k;
	let layer;		// enum dungeonLayers
	let tile;			// enum tileType
	let monst;		// creature *

	// Copy Light over oldLight
  recordOldLights();

    // and then zero out Light.
	for (i = 0; i < DCOLS; i++) {
		for (j = 0; j < DROWS; j++) {
			for (k=0; k<3; k++) {
				tmap[i][j].light[k] = 0;
			}
			pmap[i][j].flags |= IS_IN_SHADOW;
		}
	}

	// Paint all glowing tiles.
	for (i = 0; i < DCOLS; i++) {
		for (j = 0; j < DROWS; j++) {
			for (layer = 0; layer < NUMBER_TERRAIN_LAYERS; layer++) {
				tile = pmap[i][j].layers[layer];
				if (tileCatalog[tile].glowLight) {
					paintLight(lightCatalog[tileCatalog[tile].glowLight], i, j, false, false);
				}
			}
		}
	}

	// Cycle through monsters and paint their lights:
	CYCLE_MONSTERS_AND_PLAYERS( (monst) => {
		if (monst.info.intrinsicLightType) {
			paintLight(lightCatalog[monst.info.intrinsicLightType], monst.xLoc, monst.yLoc, false, false);
		}
    if (monst.mutationIndex >= 0 && mutationCatalog[monst.mutationIndex].light != NO_LIGHT) {
        paintLight(lightCatalog[mutationCatalog[monst.mutationIndex].light], monst.xLoc, monst.yLoc, false, false);
    }
		if (monst.status[STATUS_BURNING] && !(monst.info.flags & MONST_FIERY)) {
			paintLight(lightCatalog[BURNING_CREATURE_LIGHT], monst.xLoc, monst.yLoc, false, false);
		}
		if (monsterRevealed(monst)) {
			paintLight(lightCatalog[TELEPATHY_LIGHT], monst.xLoc, monst.yLoc, false, true);
		}
	});

	// Also paint telepathy lights for dormant monsters.
  for (monst = dormantMonsters.nextCreature; monst != NULL; monst = monst.nextCreature) {
      if (monsterRevealed(monst)) {
          paintLight(lightCatalog[TELEPATHY_LIGHT], monst.xLoc, monst.yLoc, false, true);
      }
  }

	updateDisplayDetail();

	// Miner's light:
	paintLight(rogue.minersLight, player.xLoc, player.yLoc, true, true);

  if (player.status[STATUS_INVISIBLE]) {
      player.info.foreColor = playerInvisibleColor;
	} else if (playerInDarkness()) {
		player.info.foreColor = playerInDarknessColor;
	} else if (pmap[player.xLoc][player.yLoc].flags & IS_IN_SHADOW) {
		player.info.foreColor = playerInShadowColor;
	} else {
		player.info.foreColor = playerInLightColor;
	}
}


function playerInDarkness() {
	return (tmap[player.xLoc][player.yLoc].light[0] + 10 < minersLightColor.red
			&& tmap[player.xLoc][player.yLoc].light[1] + 10 < minersLightColor.green
			&& tmap[player.xLoc][player.yLoc].light[2] + 10 < minersLightColor.blue);
}

const flarePrecision = 1000;


function newFlare( /* lightSource */ light, x, y, changePerFrame, limit) {
    const theFlare = flare(); // malloc(sizeof(flare));
	// memset(theFlare, '\0', sizeof(flare));
    theFlare.light = light;
    theFlare.xLoc = x;
    theFlare.yLoc = y;
    theFlare.coeffChangeAmount = changePerFrame;
    if (theFlare.coeffChangeAmount == 0) {
        theFlare.coeffChangeAmount = 1; // no change would mean it lasts forever, which usually breaks things
    }
    theFlare.coeffLimit = limit;
    theFlare.coeff = 100 * flarePrecision;
    theFlare.turnNumber = rogue.absoluteTurnNumber;
    return theFlare;
}

// Creates a new fading flare as described and sticks it into the stack so it will fire at the end of the turn.
function createFlare(x, y, /* lightType */ lightIndex) {
    let theFlare;	// flare *

    theFlare = newFlare(lightCatalog[lightIndex], x, y, -15, 0);

    // if (rogue.flareCount >= rogue.flareCapacity) {
    //     rogue.flareCapacity += 10;
    //     rogue.flares = realloc(rogue.flares, sizeof(flare *) * rogue.flareCapacity);
    // }
    rogue.flares[rogue.flareCount] = theFlare;
    rogue.flareCount++;
}

function flareIsActive( /* flare */ theFlare) {
    const increasing = (theFlare.coeffChangeAmount > 0);
    let active = true;

    if (theFlare.turnNumber > 0 && theFlare.turnNumber < rogue.absoluteTurnNumber - 1) {
        active = false;
    }
    if (increasing) {
        if ( Math.floor(theFlare.coeff / flarePrecision) > theFlare.coeffLimit) {
            active = false;
        }
    } else {
        if ( Math.floor(theFlare.coeff / flarePrecision) < theFlare.coeffLimit) {
            active = false;
        }
    }
    return active;
}

// Returns true if the flare is still active; false if it's not.
function updateFlare( /* flare */ theFlare) {
    if (!flareIsActive(theFlare)) {
        return false;
    }
    theFlare.coeff += (theFlare.coeffChangeAmount) * flarePrecision / 10;
    theFlare.coeffChangeAmount = theFlare.coeffChangeAmount * 12 / 10;
    return flareIsActive(theFlare);
}

// Returns whether it overlaps with the field of view.
function drawFlareFrame( /* flare */ theFlare) {
    let inView;
    const tempLight = lightSource(theFlare.light);
    const tempColor = color(tempLight.lightColor);

    if (!flareIsActive(theFlare)) {
        return false;
    }
    tempLight.lightRadius.lowerBound = Math.floor( tempLight.lightRadius.lowerBound) * theFlare.coeff / (flarePrecision * 100);
    tempLight.lightRadius.upperBound = Math.floor( tempLight.lightRadius.upperBound) * theFlare.coeff / (flarePrecision * 100);
    applyColorScalar(tempColor, theFlare.coeff / flarePrecision);
    tempLight.lightColor = tempColor;
    inView = paintLight(tempLight, theFlare.xLoc, theFlare.yLoc, false, true);

    return inView;
}

// Frees the flares as they expire.
async function animateFlares( /* flare** */ flares, count) {
	const lights = GRID(DCOLS, DROWS, () => [0, 0, 0] ); 	// short[DCOLS][DROWS][3];
	let inView, fastForward, atLeastOneFlareStillActive;
	let i; // i iterates through the flare list

	brogueAssert(rogue.RNG == RNG_SUBSTANTIVE);

	backUpLighting(lights);
	fastForward = rogue.trueColorMode || rogue.playbackFastForward;

	do {
			inView = false;
			atLeastOneFlareStillActive = false;
			for (i = 0; i < count; i++) {
					if (flares[i]) {
							if (updateFlare(flares[i])) {
									atLeastOneFlareStillActive = true;
									if (drawFlareFrame(flares[i])) {
											inView = true;
									}
							} else {
									// free(flares[i]);
									flares[i] = NULL;
							}
					}
			}
			demoteVisibility();
			updateFieldOfViewDisplay(false, true);
			if (!fastForward && (inView || rogue.playbackOmniscience) && atLeastOneFlareStillActive) {
					fastForward = await pauseBrogue(10);
			}
			recordOldLights();
			restoreLighting(lights);
	} while (atLeastOneFlareStillActive);
	updateFieldOfViewDisplay(false, true);

}

function deleteAllFlares() {
    let i;
    for (i=0; i<rogue.flareCount; i++) {
        const flare = rogue.flares[i];
        flare.light = null;
        rogue.flares[i] = null;
    }
    rogue.flareCount = 0;
}
/*
 *  Movement.c
 *  Brogue
 *
 *  Created by Brian Walker on 1/10/09.
 *  Copyright 2012. All rights reserved.
 *
 *  This file is part of Brogue.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

// #include "Rogue.h"
// #include "IncludeGlobals.h"
// #include <math.h>

async function playerRuns(direction) {
	let newX, newY, dir;
	const cardinalPassability = []; // short[4];

	rogue.disturbed = (player.status[STATUS_CONFUSED] ? true : false);

	for (dir = 0; dir < 4; dir++) {
		newX = player.xLoc + nbDirs[dir][0];
		newY = player.yLoc + nbDirs[dir][1];
		cardinalPassability[dir] = monsterAvoids(player, newX, newY);
	}

	while (!rogue.disturbed) {
		if (!await playerMoves(direction)) {
			rogue.disturbed = true;
			break;
		}

		newX = player.xLoc + nbDirs[direction][0];
		newY = player.yLoc + nbDirs[direction][1];
		if (!coordinatesAreInMap(newX, newY)
			|| monsterAvoids(player, newX, newY)) {

			rogue.disturbed = true;
		}
		if (isDisturbed(player.xLoc, player.yLoc)) {
			rogue.disturbed = true;
		} else if (direction < 4) {
			for (dir = 0; dir < 4; dir++) {
				newX = player.xLoc + nbDirs[dir][0];
				newY = player.yLoc + nbDirs[dir][1];
				if (cardinalPassability[dir] != monsterAvoids(player, newX, newY)
					&& !(nbDirs[dir][0] + nbDirs[direction][0] == 0 &&
						 nbDirs[dir][1] + nbDirs[direction][1] == 0)) {
						// dir is not the x-opposite or y-opposite of direction
					rogue.disturbed = true;
				}
			}
		}
	}
	updateFlavorText();
}


function highestPriorityLayer(x, y, skipGas) {	// enum dungeonLayers
	let bestPriority = 10000;
	let tt, best;

	for (tt = 0; tt < NUMBER_TERRAIN_LAYERS; tt++) {
		if (tt == GAS && skipGas) {
			continue;
		}
		if (pmap[x][y].layers[tt] && tileCatalog[pmap[x][y].layers[tt]].drawPriority < bestPriority) {
			bestPriority = tileCatalog[pmap[x][y].layers[tt]].drawPriority;
			best = tt;
		}
	}
	return best;
}

function layerWithTMFlag(x, y, flag) {	// enum dungeonLayers
	let layer;

	for (layer = 0; layer < NUMBER_TERRAIN_LAYERS; layer++) {
		if (tileCatalog[pmap[x][y].layers[layer]].mechFlags & flag) {
			return layer;
		}
	}
	return NO_LAYER;
}

function layerWithFlag(x, y, flag) {
	let layer;

	for (layer = 0; layer < NUMBER_TERRAIN_LAYERS; layer++) {
		if (tileCatalog[pmap[x][y].layers[layer]].flags & flag) {
			return layer;
		}
	}
	return NO_LAYER;
}

// Retrieves a pointer to the flavor text of the highest-priority terrain at the given location
function tileFlavor(x, y) {	// char *
	return tileCatalog[pmap[x][y].layers[highestPriorityLayer(x, y, false)]].flavorText;
}

// Retrieves a pointer to the description text of the highest-priority terrain at the given location
function tileText(x, y) {	// char *
	return tileCatalog[pmap[x][y].layers[highestPriorityLayer(x, y, false)]].description;
}

function describedItemBasedOnParameters(theCategory, theKind, theQuantity, buf) {
    let tempItem = initializeItem();
    tempItem.category = theCategory;
    tempItem.kind = theKind;
    tempItem.quantity = theQuantity;
    itemName(tempItem, buf, false, true, NULL);
}

// Describes the item in question either by naming it if the player has already seen its name,
// or by tersely identifying its category otherwise.
function describedItemName( /* item */ theItem, buf) {
	if (rogue.playbackOmniscience || (!player.status[STATUS_HALLUCINATING])) {
		itemName(theItem, buf, (theItem.category & (WEAPON | ARMOR) ? false : true), true, NULL);
	} else {
    describeHallucinatedItem(buf);
	}
}


function describeLocation(buf, x, y) {
	let monst;	// creature *
	let theItem, magicItem;		// item *
	let standsInTerrain;
	let subjectMoving;
	let prepositionLocked = false;
	let monsterDormant;

	const subject = STRING(); 		// char[COLS * 3];
	const verb = STRING(); 		// char[COLS * 3];
	const preposition = STRING(); 		// char[COLS * 3];
	const object = STRING(); 		// char[COLS * 3];
	const adjective = STRING(); 		// char[COLS * 3];

	// assureCosmeticRNG();

	if (x == player.xLoc && y == player.yLoc) {
		if (player.status[STATUS_LEVITATING]) {
			sprintf(buf, "you are hovering above %s.", tileText(x, y));
		} else {
			strcpy(buf, tileFlavor(x, y));
		}
		// restoreRNG();
		return buf;
	}

	monst = NULL;
	standsInTerrain = ((tileCatalog[pmap[x][y].layers[highestPriorityLayer(x, y, false)]].mechFlags & TM_STAND_IN_TILE) ? true : false);
	theItem = itemAtLoc(x, y);
	monsterDormant = false;
	if (pmap[x][y].flags & HAS_MONSTER) {
		monst = monsterAtLoc(x, y);
	} else if (pmap[x][y].flags & HAS_DORMANT_MONSTER) {
		monst = dormantMonsterAtLoc(x, y);
		monsterDormant = true;
	}

	// detecting magical items
	magicItem = NULL;
	if (theItem && !playerCanSeeOrSense(x, y)
		&& (theItem.flags & ITEM_MAGIC_DETECTED)
		&& itemMagicChar(theItem))
	{
		magicItem = theItem;
	} else if (monst && !canSeeMonster(monst)
			   && monst.carriedItem
			   && (monst.carriedItem.flags & ITEM_MAGIC_DETECTED)
			   && itemMagicChar(monst.carriedItem))
  {
		magicItem = monst.carriedItem;
	}
	if (magicItem) {
		switch (itemMagicChar(magicItem)) {
			case GOOD_MAGIC_CHAR:
			strcpy(object, "benevolent magic");
			break;
		case BAD_MAGIC_CHAR:
			strcpy(object, "malevolent magic");
			break;
		case AMULET_CHAR:
			strcpy(object, "the Amulet of Yendor");
			break;
		default:
			strcpy(object, "mysterious magic");
			break;
		}
		sprintf(buf, "you can detect the aura of %s here.", object);
		// restoreRNG();
		return;
	}

	// telepathy
	if (monst
        && !canSeeMonster(monst)
        && monsterRevealed(monst))
	{
		strcpy(adjective, (((!player.status[STATUS_HALLUCINATING] || rogue.playbackOmniscience) && monst.info.displayChar >= 'a' && monst.info.displayChar <= 'z')
						   || (player.status[STATUS_HALLUCINATING] && !rogue.playbackOmniscience && cosmetic_range(0, 1)) ? "small" : "large"));
		if (pmap[x][y].flags & DISCOVERED) {
			strcpy(object, tileText(x, y));
			if (monst.bookkeepingFlags & MB_SUBMERGED) {
				strcpy(preposition, "under ");
			} else if (monsterDormant) {
				strcpy(preposition, "coming from within ");
			} else if (standsInTerrain) {
				strcpy(preposition, "in ");
			} else {
				strcpy(preposition, "over ");
			}
		} else {
			strcpy(object, "here");
			strcpy(preposition, "");
		}

		sprintf(buf, "you can sense a %s psychic emanation %s%s.", adjective, preposition, object);
		// restoreRNG();
		return;
	}

	if (monst && !canSeeMonster(monst) && !rogue.playbackOmniscience) {
        // Monster is not visible.
		monst = NULL;
	}

	if (!playerCanSeeOrSense(x, y)) {
		if (pmap[x][y].flags & DISCOVERED) { // memory
			if (pmap[x][y].rememberedItemCategory) {
        if (player.status[STATUS_HALLUCINATING] && !rogue.playbackOmniscience) {
            describeHallucinatedItem(object);
        } else {
            describedItemBasedOnParameters(pmap[x][y].rememberedItemCategory, pmap[x][y].rememberedItemKind, pmap[x][y].rememberedItemQuantity, object);
        }
			} else {
				strcpy(object, tileCatalog[pmap[x][y].rememberedTerrain].description);
			}
			sprintf(buf, "you remember seeing %s here.", object);
			// restoreRNG();
			return;
		} else if (pmap[x][y].flags & MAGIC_MAPPED) { // magic mapped
			sprintf(buf, "you expect %s to be here.", tileCatalog[pmap[x][y].rememberedTerrain].description);
			// restoreRNG();
			return;
		}
		strcpy(buf, "");
		// restoreRNG();
		return;
	}

	if (monst) {
		monsterName(subject, monst, true);

		if (pmap[x][y].layers[GAS] && monst.status[STATUS_INVISIBLE]) { // phantoms in gas
			sprintf(buf, "you can perceive the faint outline of %s in %s.", subject, tileCatalog[pmap[x][y].layers[GAS]].description);
			// restoreRNG();
			return;
		}

		subjectMoving = (monst.turnsSpentStationary == 0
                         && !(monst.info.flags & (MONST_GETS_TURN_ON_ACTIVATION | MONST_IMMOBILE))
                         && monst.creatureState != MONSTER_SLEEPING
                         && !(monst.bookkeepingFlags & (MB_SEIZED | MB_CAPTIVE)));
		if ((monst.info.flags & MONST_ATTACKABLE_THRU_WALLS)
        && cellHasTerrainFlag(x, y, T_OBSTRUCTS_PASSABILITY))
		{
    	strcpy(verb, "is embedded");
    } else if (cellHasTerrainFlag(x, y, T_OBSTRUCTS_PASSABILITY)) {
			strcpy(verb, "is trapped");
			subjectMoving = false;
		} else if (monst.bookkeepingFlags & MB_CAPTIVE) {
			strcpy(verb, "is shackled in place");
			subjectMoving = false;
		} else if (monst.status[STATUS_PARALYZED]) {
			strcpy(verb, "is frozen in place");
			subjectMoving = false;
		} else if (monst.status[STATUS_STUCK]) {
			strcpy(verb, "is entangled");
			subjectMoving = false;
		} else if (monst.status[STATUS_LEVITATING]) {
			strcpy(verb, (subjectMoving ? "is flying" : "is hovering"));
			strcpy(preposition, "over");
			prepositionLocked = true;
		} else if (monsterCanSubmergeNow(monst)) {
			strcpy(verb, (subjectMoving ? "is gliding" : "is drifting"));
		} else if (cellHasTerrainFlag(x, y, T_MOVES_ITEMS) && !(monst.info.flags & MONST_SUBMERGES)) {
			strcpy(verb, (subjectMoving ? "is swimming" : "is struggling"));
		} else if (cellHasTerrainFlag(x, y, T_AUTO_DESCENT)) {
			strcpy(verb, "is suspended in mid-air");
			strcpy(preposition, "over");
			prepositionLocked = true;
			subjectMoving = false;
		} else if (monst.status[STATUS_CONFUSED]) {
			strcpy(verb, "is staggering");
		} else if ((monst.info.flags & MONST_RESTRICTED_TO_LIQUID)
				   && !cellHasTMFlag(monst.xLoc, monst.yLoc, TM_ALLOWS_SUBMERGING))
 	  {
			strcpy(verb, "is lying");
			subjectMoving = false;
		} else if (monst.info.flags & MONST_IMMOBILE) {
			strcpy(verb, "is resting");
		} else {
			switch (monst.creatureState) {
				case MONSTER_SLEEPING:
					strcpy(verb, "is sleeping");
					subjectMoving = false;
					break;
				case MONSTER_WANDERING:
					strcpy(verb, (subjectMoving ? "is wandering" : "is standing"));
					break;
				case MONSTER_FLEEING:
					strcpy(verb, (subjectMoving ? "is fleeing" : "is standing"));
					break;
				case MONSTER_TRACKING_SCENT:
					strcpy(verb, (subjectMoving ? "is charging" : "is standing"));
					break;
				case MONSTER_ALLY:
					strcpy(verb, (subjectMoving ? "is following you" : "is standing"));
					break;
				default:
					strcpy(verb, "is standing");
					break;
			}
		}
		if (monst.status[STATUS_BURNING] && !(monst.info.flags & MONST_FIERY)) {
			strcat(verb, ", burning,");
		}

		if (theItem) {
			strcpy(preposition, "over");
			describedItemName(theItem, object);
		} else {
			if (!prepositionLocked) {
				strcpy(preposition, subjectMoving ? (standsInTerrain ? "through" : "across")
					   : (standsInTerrain ? "in" : "on"));
			}
			strcpy(object, tileText(x, y));
		}
	} else { // no monster
		strcpy(object, tileText(x, y));
		if (theItem) {
			describedItemName(theItem, object);
			subjectMoving = cellHasTerrainFlag(x, y, T_MOVES_ITEMS);
			if (player.status[STATUS_HALLUCINATING] && !rogue.playbackOmniscience) {
          strcpy(verb, "is");
      } else {
          strcpy(verb, (theItem.quantity > 1 || (theItem.category & GOLD)) ? "are" : "is");
      }
			if (cellHasTerrainFlag(x, y, T_OBSTRUCTS_PASSABILITY)) {
				strcat(verb, " enclosed");
			} else {
				strcat(verb, subjectMoving ? " drifting" : " lying");
			}
			strcpy(preposition, standsInTerrain ? (subjectMoving ? "through" : "in")
				   : (subjectMoving ? "across" : "on"));
		} else { // no item
			sprintf(buf, "you %s %s.", (playerCanDirectlySee(x, y) ? "see" : "sense"), object);
      // restoreRNG();
			return;
		}
	}

	sprintf(buf, "%s %s %s %s.", subject, verb, preposition, object);
	// restoreRNG();
	return;
}


function printLocationDescription(x, y) {
	const buf = STRING(); // char[DCOLS*3];
	describeLocation(buf, x, y);
	flavorMessage(buf);
}

async function useKeyAt( /* item */ theItem, x, y) {
	let layer, i;
	let monst;		/// creature *
	const buf = STRING(), buf2 = STRING(), terrainName = STRING(), preposition = STRING(); // char[10];
	let disposable;

	strcpy(terrainName, "unknown terrain"); // redundant failsafe
	for (layer = 0; layer < NUMBER_TERRAIN_LAYERS; layer++) {
		if (tileCatalog[pmap[x][y].layers[layer]].mechFlags & TM_PROMOTES_WITH_KEY) {
			if (tileCatalog[pmap[x][y].layers[layer]].description[0] == 'a'
				&& tileCatalog[pmap[x][y].layers[layer]].description[1] == ' ')
			{
				sprintf(terrainName, "the %s", tileCatalog[pmap[x][y].layers[layer]].description.substring(2));	// [2]
			} else {
				strcpy(terrainName, tileCatalog[pmap[x][y].layers[layer]].description);
			}
			if (tileCatalog[pmap[x][y].layers[layer]].mechFlags & TM_STAND_IN_TILE) {
				strcpy(preposition, "in");
			} else {
				strcpy(preposition, "on");
			}
			await promoteTile(x, y, layer, false);
		}
	}

	disposable = false;
	for (i=0; i < KEY_ID_MAXIMUM && (theItem.keyLoc[i].x || theItem.keyLoc[i].machine); i++) {
		if (theItem.keyLoc[i].x == x && theItem.keyLoc[i].y == y && theItem.keyLoc[i].disposableHere) {
			disposable = true;
		} else if (theItem.keyLoc[i].machine == pmap[x][y].machineNumber && theItem.keyLoc[i].disposableHere) {
			disposable = true;
		}
	}

	if (disposable) {
		if (removeItemFromChain(theItem, packItems)) {
			itemName(theItem, buf2, true, false, NULL);
			sprintf(buf, "you use your %s %s %s.",
					buf2,
					preposition,
					terrainName);
			message(buf, itemMessageColor, false);
			deleteItem(theItem);
		} else if (removeItemFromChain(theItem, floorItems)) {
			deleteItem(theItem);
			pmap[x][y].flags &= ~HAS_ITEM;
		} else if (pmap[x][y].flags & HAS_MONSTER) {
			monst = monsterAtLoc(x, y);
			if (monst.carriedItem && monst.carriedItem == theItem) {
				monst.carriedItem = NULL;
				deleteItem(theItem);
			}
		}
	}
}

function randValidDirectionFrom( /* creature */ monst, x, y, respectAvoidancePreferences) {
	let i, newX, newY, validDirectionCount = 0, randIndex;

  brogueAssert(rogue.RNG == RNG_SUBSTANTIVE);
	for (i=0; i<8; i++) {
		newX = x + nbDirs[i][0];
		newY = y + nbDirs[i][1];
		if (coordinatesAreInMap(newX, newY)
			&& !cellHasTerrainFlag(newX, newY, T_OBSTRUCTS_PASSABILITY)
      && !diagonalBlocked(x, y, newX, newY, false)
			&& (!respectAvoidancePreferences
				|| (!monsterAvoids(monst, newX, newY))
				|| ((pmap[newX][newY].flags & HAS_PLAYER) && monst.creatureState != MONSTER_ALLY)))
		{
			validDirectionCount++;
		}
	}

	if (validDirectionCount == 0) {
        // Rare, and important in this case that the function returns BEFORE a random roll is made to avoid OOS.
		return NO_DIRECTION;
	}

	randIndex = rand_range(1, validDirectionCount);
	validDirectionCount = 0;

	for (i=0; i<8; i++) {
		newX = x + nbDirs[i][0];
		newY = y + nbDirs[i][1];
		if (coordinatesAreInMap(newX, newY)
			&& !cellHasTerrainFlag(newX, newY, T_OBSTRUCTS_PASSABILITY)
			&& !diagonalBlocked(x, y, newX, newY, false)
			&& (!respectAvoidancePreferences
				|| (!monsterAvoids(monst, newX, newY))
				|| ((pmap[newX][newY].flags & HAS_PLAYER) && monst.creatureState != MONSTER_ALLY)))
		{
			validDirectionCount++;
			if (validDirectionCount == randIndex) {
				return i;
			}
		}
	}
	return NO_DIRECTION; // should rarely get here
}

async function vomit(/* creature */ monst) {
	const buf = STRING(), monstName = STRING(); // char[COLS];
	await spawnDungeonFeature(monst.xLoc, monst.yLoc, dungeonFeatureCatalog[DF_VOMIT], true, false);

	if (canDirectlySeeMonster(monst)
        && !rogue.automationActive)
	{
		monsterName(monstName, monst, true);
		sprintf(buf, "%s vomit%s profusely", monstName, (monst === player ? "" : "s"));
		combatMessage(buf, NULL);
	}
}


async function moveEntrancedMonsters(dir) {
	let monst, nextMonst;	// creature *

	dir = oppositeDirection(dir);

	for (monst = monsters.nextCreature; monst != NULL; monst = nextMonst) {
    nextMonst = monst.nextCreature;
		if (monst.status[STATUS_ENTRANCED]
			&& !monst.status[STATUS_STUCK]
			&& !monst.status[STATUS_PARALYZED]
			&& !(monst.bookkeepingFlags & MB_CAPTIVE))
		{
			await moveMonster(monst, nbDirs[dir][0], nbDirs[dir][1]);
		}
	}
}


async function becomeAllyWith( /* creature */ monst) {
	demoteMonsterFromLeadership(monst);
	// Drop your item.
	if (monst.carriedItem) {
		await makeMonsterDropItem(monst);
	}
	// If you're going to change into something, it should be friendly.
	if (monst.carriedMonster) {
		await becomeAllyWith(monst.carriedMonster);
	}
	monst.creatureState = MONSTER_ALLY;
	monst.bookkeepingFlags |= MB_FOLLOWER;
	monst.leader = player;
	monst.bookkeepingFlags &= ~(MB_CAPTIVE | MB_SEIZED);
	refreshDungeonCell(monst.xLoc, monst.yLoc);
}

async function freeCaptive( /* creature */ monst) {
	const buf = STRING(), monstName = STRING(); // char[COLS];

	await becomeAllyWith(monst);
	monsterName(monstName, monst, false);
	sprintf(buf, "you free the grateful %s and gain a faithful ally.", monstName);
	message(buf, false);
}

async function freeCaptivesEmbeddedAt(x, y) {
	let monst;	// creature *

	if (pmap[x][y].flags & HAS_MONSTER) {
		// Free any captives trapped in the tunnelized terrain.
		monst = monsterAtLoc(x, y);
		if ((monst.bookkeepingFlags & MB_CAPTIVE)
			&& !(monst.info.flags & MONST_ATTACKABLE_THRU_WALLS)
			&& (cellHasTerrainFlag(x, y, T_OBSTRUCTS_PASSABILITY)))
		{
			await freeCaptive(monst);
			return true;
		}
	}
	return false;
}

// Do we need confirmation so we don't accidently hit an acid mound?
async function abortAttackAgainstAcidicTarget(/* creature[] */hitList) {
  let i;
	const monstName = STRING(), weaponName = STRING(); // char[COLS];
	const buf = STRING(); // char[COLS*3];

    if (rogue.weapon
        && !(rogue.weapon.flags & ITEM_PROTECTED)
        && !player.status[STATUS_HALLUCINATING]
        && !player.status[STATUS_CONFUSED])
		{
        for (i=0; i<8; i++) {
            if (hitList[i]
                && (hitList[i].info.flags & MONST_DEFEND_DEGRADE_WEAPON)
                && canSeeMonster(hitList[i])
                && (!(rogue.weapon.flags & ITEM_RUNIC)
                    || !(rogue.weapon.flags & ITEM_RUNIC_IDENTIFIED)
                    || rogue.weapon.enchant2 != W_SLAYING
                    || !monsterIsInClass(hitList[i], rogue.weapon.vorpalEnemy)))
						{
                monsterName(monstName, hitList[i], true);
                itemName(rogue.weapon, weaponName, false, false, NULL);
                sprintf(buf, "Degrade your %s by attacking %s?", weaponName, monstName);
                if (await confirm(buf, false)) {
                    return false; // Fire when ready!
                } else {
                    return true; // Abort!
                }
            }
        }
    }
    return false;
}

// Returns true if a whip attack was launched.
// If "aborted" pointer is provided, sets it to true if it was aborted because
// the player opted not to attack an acid mound (in which case the whole turn
// should be aborted), as opposed to there being no valid whip attack available
// (in which case the player/monster should move instead).
async function handleWhipAttacks( /* creature */ attacker, dir) {
    let theBolt; // bolt
    let defender, hitList = []; // creature *
    let strikeLoc = [-1, -1], originLoc = [-1, -1], targetLoc = [-1, -1];

    const boltChar = "||~~\\//\\";

    brogueAssert(dir > NO_DIRECTION && dir < DIRECTION_COUNT);

    if (attacker === player) {
        if (!rogue.weapon || !(rogue.weapon.flags & ITEM_ATTACKS_EXTEND)) {
            return WHIP_FAILED;
        }
    } else if (!(attacker.info.abilityFlags & MA_ATTACKS_EXTEND)) {
        return WHIP_FAILED;
    }

    originLoc[0] = attacker.xLoc;
    originLoc[1] = attacker.yLoc;
    targetLoc[0] = attacker.xLoc + nbDirs[dir][0];
    targetLoc[1] = attacker.yLoc + nbDirs[dir][1];
    getImpactLoc(strikeLoc, originLoc, targetLoc, 5, false);

    defender = monsterAtLoc(strikeLoc[0], strikeLoc[1]);
    if (defender
        && (attacker !== player || canSeeMonster(defender))
        && !monsterIsHidden(defender, attacker)
        && monsterWillAttackTarget(attacker, defender))
		{
        if (attacker === player) {
            hitList[0] = defender;
            if (await abortAttackAgainstAcidicTarget(hitList)) {
                if (aborted) {
                    return WHIP_ABORTED;
                }
                return WHIP_FAILED;
            }
        }
        attacker.bookkeepingFlags &= ~MB_SUBMERGED;
        theBolt = boltCatalog[BOLT_WHIP];
        theBolt.theChar = boltChar[dir];
        await zap(originLoc, targetLoc, theBolt, false);
        return WHIP_SUCCESS;
    }
    return WHIP_FAILED;
}

// Returns true if a spear attack was launched.
// If "aborted" pointer is provided, sets it to true if it was aborted because
// the player opted not to attack an acid mound (in which case the whole turn
// should be aborted), as opposed to there being no valid spear attack available
// (in which case the player/monster should move instead).
async function handleSpearAttacks(/* creature */ attacker, dir, opts) {
    let defender;
		const hitList = [];
    const originLoc = [-1, -1], targetLoc = [-1, -1];
		let range = 2, i = 0, h = 0;
    let proceed = false, visualEffect = false;

    const boltChar = "||--\\//\\";

    brogueAssert(dir > NO_DIRECTION && dir < DIRECTION_COUNT);

    if (attacker === player) {
        if (!rogue.weapon || !(rogue.weapon.flags & ITEM_ATTACKS_PENETRATE)) {
            return false;
        }
    } else if (!(attacker.info.abilityFlags & MA_ATTACKS_PENETRATE)) {
        return false;
    }
    originLoc[0] = attacker.xLoc;
    originLoc[1] = attacker.yLoc;

    for (i = 0; i < range; i++) {
        targetLoc[0] = attacker.xLoc + (1 + i) * nbDirs[dir][0];
        targetLoc[1] = attacker.yLoc + (1 + i) * nbDirs[dir][1];
        if (!coordinatesAreInMap(targetLoc[0], targetLoc[1])) {
            break;
        }
        defender = monsterAtLoc(targetLoc[0], targetLoc[1]);
        if (defender
            && (!cellHasTerrainFlag(targetLoc[0], targetLoc[1], T_OBSTRUCTS_PASSABILITY)
                || (defender.info.flags & MONST_ATTACKABLE_THRU_WALLS))
            && (attacker !== player || defender.creatureState != MONSTER_ALLY)
            && (!monsterHiddenBySubmersion(defender, attacker) || i == 0)) {
            // Monster will get hit if we choose to attack.
            hitList[h++] = defender;
            if ((!monsterIsHidden(defender, attacker) || i == 0)
                && monsterWillAttackTarget(attacker, defender)
                && (attacker !== player || canSeeMonster(defender) || i == 0)) {
                // We'll attack.
                proceed = true;
            }
        }
        if (cellHasTerrainFlag(targetLoc[0], targetLoc[1], (T_OBSTRUCTS_PASSABILITY | T_OBSTRUCTS_VISION))) {
            break;
        }
    }
    range = i;
    if (proceed) {
        if (attacker === player) {
            if (await abortAttackAgainstAcidicTarget(hitList)) {
                if (opts) {
                    ops.aborted = true;
                }
                return false;
            }
        }
        if (!rogue.playbackFastForward) {
            for (i = 0; i < range; i++) {
                targetLoc[0] = attacker.xLoc + (1 + i) * nbDirs[dir][0];
                targetLoc[1] = attacker.yLoc + (1 + i) * nbDirs[dir][1];
                if (coordinatesAreInMap(targetLoc[0], targetLoc[1])
                    && playerCanSeeOrSense(targetLoc[0], targetLoc[1]))
								{
                    visualEffect = true;
                    plotForegroundChar(boltChar[dir], targetLoc[0], targetLoc[1], lightBlue, true);
                }
            }
        }
        attacker.bookkeepingFlags &= ~MB_SUBMERGED;
        // Artificially reverse the order of the attacks,
        // so that spears of force can send both monsters flying.
        for (i = h - 1; i >= 0; i--) {
            await attack(attacker, hitList[i], false);
        }
        if (visualEffect) {
            await pauseBrogue(16);
            for (i = 0; i < range; i++) {
                targetLoc[0] = attacker.xLoc + (1 + i) * nbDirs[dir][0];
                targetLoc[1] = attacker.yLoc + (1 + i) * nbDirs[dir][1];
                if (coordinatesAreInMap(targetLoc[0], targetLoc[1])) {
                    refreshDungeonCell(targetLoc[0], targetLoc[1]);
                }
            }
        }
        return true;
    }
    return false;
}


function buildFlailHitList(x, y, newX, newY, hitList /* creature *[16] */) {
    let monst;	// creature *
    let mx, my;
    let i = 0;

    for (monst = monsters.nextCreature; monst != NULL; monst = monst.nextCreature) {
        mx = monst.xLoc;
        my = monst.yLoc;
        if (distanceBetween(x, y, mx, my) == 1
            && distanceBetween(newX, newY, mx, my) == 1
            && canSeeMonster(monst)
            && monstersAreEnemies(player, monst)
            && monst.creatureState != MONSTER_ALLY
            && !(monst.bookkeepingFlags & MB_IS_DYING)
            && (!cellHasTerrainFlag(monst.xLoc, monst.yLoc, T_OBSTRUCTS_PASSABILITY) || (monst.info.flags & MONST_ATTACKABLE_THRU_WALLS)))
				{
            while (hitList[i]) {
                i++;
            }
            hitList[i] = monst;
        }
    }
}


function diagonalBlocked(x1, y1, x2, y2, limitToPlayerKnowledge) {
    let tFlags;
    if (x1 == x2 || y1 == y2) {
      return false; // If it's not a diagonal, it's not diagonally blocked.
    }
    const locFlags1 = getLocationFlags(x1, y2, limitToPlayerKnowledge);
    if (locFlags1.terrainFlags & T_OBSTRUCTS_DIAGONAL_MOVEMENT) {
        return true;
    }
    const locFlags2 = getLocationFlags(x2, y1, limitToPlayerKnowledge);
    if (locFlags2.terrainFlags & T_OBSTRUCTS_DIAGONAL_MOVEMENT) {
        return true;
    }
    return false;
}

// Called whenever the player voluntarily tries to move in a given direction.
// Can be called from movement keys, exploration, or auto-travel.
async function playerMoves(direction) {
	let initialDirection = direction, i, layer;
	let x = player.xLoc, y = player.yLoc;
	let newX, newY, newestX, newestY;
	let playerMoved = false, alreadyRecorded = false, specialAttackAborted = false, anyAttackHit = false;
	let defender = NULL, tempMonst = NULL, hitList = []; // creature *, creature *, creature *[16];
	const monstName = STRING(); // char[COLS];
	const buf = STRING(); // char[COLS*3];
	const directionKeys = [UP_KEY, DOWN_KEY, LEFT_KEY, RIGHT_KEY, UPLEFT_KEY, DOWNLEFT_KEY, UPRIGHT_KEY, DOWNRIGHT_KEY];

  brogueAssert(direction >= 0 && direction < DIRECTION_COUNT);

	newX = x + nbDirs[direction][0];
	newY = y + nbDirs[direction][1];

	if (!coordinatesAreInMap(newX, newY)) {
		return false;
	}

	if (player.status[STATUS_CONFUSED]) {
    // Confirmation dialog if you're moving while confused and you're next to lava and not levitating or immune to fire.
    if (player.status[STATUS_LEVITATING] <= 1
        && player.status[STATUS_IMMUNE_TO_FIRE] <= 1)
		{
        for (i=0; i<8; i++) {
            newestX = x + nbDirs[i][0];
            newestY = y + nbDirs[i][1];
            if (coordinatesAreInMap(newestX, newestY)
                && (pmap[newestX][newestY].flags & (DISCOVERED | MAGIC_MAPPED))
                && !diagonalBlocked(x, y, newestX, newestY, false)
                && cellHasTerrainFlag(newestX, newestY, T_LAVA_INSTA_DEATH)
                && !cellHasTerrainFlag(newestX, newestY, T_OBSTRUCTS_PASSABILITY | T_ENTANGLES)
                && !((pmap[newestX][newestY].flags & HAS_MONSTER)
                     && canSeeMonster(monsterAtLoc(newestX, newestY))
                     && monsterAtLoc(newestX, newestY).creatureState != MONSTER_ALLY))
					  {
                if (! await confirm("Risk stumbling into lava?", false)) {
                    return false;
                } else {
                    break;
                }
            }
        }
    }

		direction = randValidDirectionFrom(player, x, y, false);
		if (direction == NO_DIRECTION) {
			return false;
		} else {
			newX = x + nbDirs[direction][0];
			newY = y + nbDirs[direction][1];
			if (!coordinatesAreInMap(newX, newY)) {
				return false;
			}
			if (!alreadyRecorded) {
				recordKeystroke(directionKeys[initialDirection], false, false);
				alreadyRecorded = true;
			}
		}
	}

	if (pmap[newX][newY].flags & HAS_MONSTER) {
		defender = monsterAtLoc(newX, newY);
	}

  // If there's no enemy at the movement location that the player is aware of, consider terrain promotions.
  if (!defender
      || (!canSeeMonster(defender) && !monsterRevealed(defender))
      || !monstersAreEnemies(player, defender))
	{
      if (cellHasTerrainFlag(newX, newY, T_OBSTRUCTS_PASSABILITY) && cellHasTMFlag(newX, newY, TM_PROMOTES_ON_PLAYER_ENTRY)) {
          layer = layerWithTMFlag(newX, newY, TM_PROMOTES_ON_PLAYER_ENTRY);
          if (tileCatalog[pmap[newX][newY].layers[layer]].flags & T_OBSTRUCTS_PASSABILITY) {
              if (!alreadyRecorded) {
                  recordKeystroke(directionKeys[initialDirection], false, false);
                  alreadyRecorded = true;
              }
              message(tileCatalog[pmap[newX][newY].layers[layer]].flavorText, false);
              await promoteTile(newX, newY, layer, false);
              await playerTurnEnded();
              return true;
          }
      }

			if (player.status[STATUS_STUCK] && cellHasTerrainFlag(x, y, T_ENTANGLES)) {
							 // Don't interrupt exploration with this message.
					 if (--player.status[STATUS_STUCK]) {
							 if (!rogue.automationActive) {
									 message("you struggle but cannot free yourself.", false);
							 }
					 } else {
							 if (!rogue.automationActive) {
									 message("you break free!", false);
							 }
							 if (tileCatalog[pmap[x][y].layers[SURFACE]].flags & T_ENTANGLES) {
									 pmap[x][y].layers[SURFACE] = NOTHING;
							 }
					 }
					 await moveEntrancedMonsters(direction);
					 if (!alreadyRecorded) {
							 recordKeystroke(directionKeys[initialDirection], false, false);
							 alreadyRecorded = true;
					 }
					 if (player.status[STATUS_STUCK]) {
							 await playerTurnEnded();
							 return true;
					 }
			 }

  }

	if (((!cellHasTerrainFlag(newX, newY, T_OBSTRUCTS_PASSABILITY) || (cellHasTMFlag(newX, newY, TM_PROMOTES_WITH_KEY) && keyInPackFor(newX, newY)))
         && !diagonalBlocked(x, y, newX, newY, false)
         && (!cellHasTerrainFlag(x, y, T_OBSTRUCTS_PASSABILITY) || (cellHasTMFlag(x, y, TM_PROMOTES_WITH_KEY) && keyInPackFor(x, y))))
		|| (defender && defender.info.flags & MONST_ATTACKABLE_THRU_WALLS))
	{
		// if the move is not blocked

		const opts = {};
		if (await handleWhipAttacks(player, direction, opts)
				|| await handleSpearAttacks(player, direction, opts))
		{
				if (!alreadyRecorded) {
						recordKeystroke(directionKeys[initialDirection], false, false);
						alreadyRecorded = true;
				}
				playerRecoversFromAttacking(true);
				await moveEntrancedMonsters(direction);
				await playerTurnEnded();
				return true;
		} else if (opts.aborted) { // Canceled an attack against an acid mound.
				brogueAssert(!alreadyRecorded);
				rogue.disturbed = true;
				return false;
		}

		if (defender) {
			// if there is a monster there

			if (defender.bookkeepingFlags & MB_CAPTIVE) {
				monsterName(monstName, defender, false);
				sprintf(buf, "Free the captive %s?", monstName);
				if (alreadyRecorded || await confirm(buf, false)) {
					if (!alreadyRecorded) {
						recordKeystroke(directionKeys[initialDirection], false, false);
						alreadyRecorded = true;
					}
					if (cellHasTMFlag(newX, newY, TM_PROMOTES_WITH_KEY) && keyInPackFor(newX, newY)) {
						await useKeyAt(keyInPackFor(newX, newY), newX, newY);
					}
					await freeCaptive(defender);
					player.ticksUntilTurn += player.attackSpeed;
					await playerTurnEnded();
					return true;
				} else {
					return false;
				}
			}

			if (defender.creatureState != MONSTER_ALLY) {
				// Make a hit list of monsters the player is attacking this turn.
				// We separate this tallying phase from the actual attacking phase because sometimes the attacks themselves
				// create more monsters, and those shouldn't be attacked in the same turn.

				buildHitList(hitList, player, defender,
                             // rogue.weapon && (rogue.weapon.flags & ITEM_ATTACKS_PENETRATE),
                             rogue.weapon && (rogue.weapon.flags & ITEM_ATTACKS_ALL_ADJACENT));

				if (await abortAttackAgainstAcidicTarget(hitList)) { // Acid mound attack confirmation.
            brogueAssert(!alreadyRecorded);
            rogue.disturbed = true;
            return false;
        }

        if (player.status[STATUS_NAUSEOUS]) {
            if (!alreadyRecorded) {
                recordKeystroke(directionKeys[initialDirection], false, false);
                alreadyRecorded = true;
            }
            if (rand_percent(25)) {
                await vomit(player);
                await playerTurnEnded();
                return false;
            }
        }

				// Proceeding with the attack.

				if (!alreadyRecorded) {
					recordKeystroke(directionKeys[initialDirection], false, false);
					alreadyRecorded = true;
				}

				// Attack!
				for (i=0; i<16; i++) {
					if (hitList[i]
						&& monsterWillAttackTarget(player, hitList[i])
						&& !(hitList[i].bookkeepingFlags & MB_IS_DYING)
            && !rogue.gameHasEnded)
					{
						if (await attack(player, hitList[i], false)) {
                anyAttackHit = true;
            }
					}
				}

        playerRecoversFromAttacking(anyAttackHit);
				await moveEntrancedMonsters(direction);
				await playerTurnEnded();
				return true;
			}
		}

		// const whipResult = await handleWhipAttacks(player, direction);
    // if (whipResult == WHIP_SUCCESS ) {
    //     if (!alreadyRecorded) {
    //         recordKeystroke(directionKeys[initialDirection], false, false);
    //         alreadyRecorded = true;
    //     }
    //     playerRecoversFromAttacking(true);
    //     await moveEntrancedMonsters(direction);
    //     await playerTurnEnded();
    //     return true;
    // } else if (whipResult == WHIP_ABORTED) { // Canceled an attack against an acid mound.
    //     brogueAssert(!alreadyRecorded);
    //     rogue.disturbed = true;
    //     return false;
    // }

		if (player.bookkeepingFlags & MB_SEIZED) {
			for (tempMonst = monsters.nextCreature; tempMonst != NULL; tempMonst = tempMonst.nextCreature) {
				if ((tempMonst.bookkeepingFlags & MB_SEIZING)
					&& monstersAreEnemies(player, tempMonst)
					&& distanceBetween(player.xLoc, player.yLoc, tempMonst.xLoc, tempMonst.yLoc) == 1
					&& !diagonalBlocked(player.xLoc, player.yLoc, tempMonst.xLoc, tempMonst.yLoc, false)
          && !tempMonst.status[STATUS_ENTRANCED])
				{
          monsterName(monstname, tempMonst, true);
          if (alreadyRecorded || !canSeeMonster(tempMonst)) {
              if (!alreadyRecorded) {
                  recordKeystroke(directionKeys[initialDirection], false, false);
                  alreadyRecorded = true;
              }
              sprintf(buf, "you struggle but %s is holding your legs!", monstName);
              await moveEntrancedMonsters(direction);
              message(buf, false);
              await playerTurnEnded();
              return true;
          } else {
              sprintf(buf, "you cannot move; %s is holding your legs!", monstName);
              message(buf, false);
              return false;
          }
				}
			}
			player.bookkeepingFlags &= ~MB_SEIZED; // failsafe
		}

		if (pmap[newX][newY].flags & (DISCOVERED | MAGIC_MAPPED)
            && player.status[STATUS_LEVITATING] <= 1
            && !player.status[STATUS_CONFUSED]
            && cellHasTerrainFlag(newX, newY, T_LAVA_INSTA_DEATH)
            && player.status[STATUS_IMMUNE_TO_FIRE] <= 1
            && !cellHasTerrainFlag(newX, newY, T_ENTANGLES)
            && !cellHasTMFlag(newX, newY, TM_IS_SECRET))
		{
			message("that would be certain death!", false);
			return false; // player won't willingly step into lava
		} else if (pmap[newX][newY].flags & (DISCOVERED | MAGIC_MAPPED)
				   && player.status[STATUS_LEVITATING] <= 1
				   && !player.status[STATUS_CONFUSED]
				   && cellHasTerrainFlag(newX, newY, T_AUTO_DESCENT)
				   && !cellHasTerrainFlag(newX, newY, T_ENTANGLES)
           && !cellHasTMFlag(newX, newY, TM_IS_SECRET)
				   && !await confirm("Dive into the depths?", false))
	  {
			return false;
		} else if (playerCanSee(newX, newY)
				   && !player.status[STATUS_CONFUSED]
				   && !player.status[STATUS_BURNING]
				   && player.status[STATUS_IMMUNE_TO_FIRE] <= 1
				   && cellHasTerrainFlag(newX, newY, T_IS_FIRE)
				   && !cellHasTMFlag(newX, newY, TM_EXTINGUISHES_FIRE)
				   && !await confirm("Venture into flame?", false))
	  {
			return false;
		} else if (playerCanSee(newX, newY)
							 && !player.status[STATUS_CONFUSED]
							 && !player.status[STATUS_BURNING]
							 && cellHasTerrainFlag(newX, newY, T_CAUSES_CONFUSION | T_CAUSES_PARALYSIS)
							 && (!rogue.armor || !(rogue.armor.flags & ITEM_RUNIC) || !(rogue.armor.flags & ITEM_RUNIC_IDENTIFIED) || rogue.armor.enchant2 != A_RESPIRATION)
							 && !await confirm("Venture into dangerous gas?", false)) {
				return false;
		} else if (pmap[newX][newY].flags & (ANY_KIND_OF_VISIBLE | MAGIC_MAPPED)
				   && player.status[STATUS_LEVITATING] <= 1
				   && !player.status[STATUS_CONFUSED]
				   && cellHasTerrainFlag(newX, newY, T_IS_DF_TRAP)
				   && !(pmap[newX][newY].flags & PRESSURE_PLATE_DEPRESSED)
				   && !cellHasTMFlag(newX, newY, TM_IS_SECRET)
				   && !await confirm("Step onto the pressure plate?", false))
		{
			return false;
		}

    if (rogue.weapon && (rogue.weapon.flags & ITEM_LUNGE_ATTACKS)) {
        newestX = player.xLoc + 2 * nbDirs[direction][0];
        newestY = player.yLoc + 2 * nbDirs[direction][1];
        if (coordinatesAreInMap(newestX, newestY) && (pmap[newestX][newestY].flags & HAS_MONSTER)) {
            tempMonst = monsterAtLoc(newestX, newestY);
            if (tempMonst
                && canSeeMonster(tempMonst)
                && monstersAreEnemies(player, tempMonst)
                && tempMonst.creatureState != MONSTER_ALLY
                && !(tempMonst.bookkeepingFlags & MB_IS_DYING)
                && (!cellHasTerrainFlag(tempMonst.xLoc, tempMonst.yLoc, T_OBSTRUCTS_PASSABILITY) || (tempMonst.info.flags & MONST_ATTACKABLE_THRU_WALLS)))
						{
                hitList[0] = tempMonst;
                if (await abortAttackAgainstAcidicTarget(hitList)) { // Acid mound attack confirmation.
                    brogueAssert(!alreadyRecorded);
                    rogue.disturbed = true;
                    return false;
                }
            }
        }
    }
    if (rogue.weapon && (rogue.weapon.flags & ITEM_PASS_ATTACKS)) {
        buildFlailHitList(x, y, newX, newY, hitList);
        if (await abortAttackAgainstAcidicTarget(hitList)) { // Acid mound attack confirmation.
            brogueAssert(!alreadyRecorded);
            rogue.disturbed = true;
            return false;
        }
    }

    if (player.status[STATUS_NAUSEOUS]) {
        if (!alreadyRecorded) {
            recordKeystroke(directionKeys[initialDirection], false, false);
            alreadyRecorded = true;
        }
        if (rand_percent(25)) {
            await vomit(player);
            await playerTurnEnded();
            return true;
        }
    }

		// Are we taking the stairs?
		if (rogue.downLoc[0] == newX && rogue.downLoc[1] == newY) {
			if (!alreadyRecorded) {
				recordKeystroke(directionKeys[initialDirection], false, false);
				alreadyRecorded = true;
			}
			await useStairs(1);
		} else if (rogue.upLoc[0] == newX && rogue.upLoc[1] == newY) {
			if (!alreadyRecorded) {
				recordKeystroke(directionKeys[initialDirection], false, false);
				alreadyRecorded = true;
			}
			await useStairs(-1);
		} else {
			// Okay, we're finally moving!
			if (!alreadyRecorded) {
				recordKeystroke(directionKeys[initialDirection], false, false);
				alreadyRecorded = true;
			}

			player.xLoc += nbDirs[direction][0];
			player.yLoc += nbDirs[direction][1];
			pmap[x][y].flags &= ~HAS_PLAYER;
			pmap[player.xLoc][player.yLoc].flags |= HAS_PLAYER;
			pmap[player.xLoc][player.yLoc].flags &= ~IS_IN_PATH;
      if (defender && defender.creatureState == MONSTER_ALLY) { // Swap places with ally.
				pmap[defender.xLoc][defender.yLoc].flags &= ~HAS_MONSTER;
        defender.xLoc = x;
				defender.yLoc = y;
        if (monsterAvoids(defender, x, y)) {
            const loc = getQualifyingPathLocNear(player.xLoc, player.yLoc, true, forbiddenFlagsForMonster(defender.info), 0, 0, (HAS_PLAYER | HAS_MONSTER | HAS_STAIRS), false);
						if (!loc) ERROR('EXPECTED LOCATION');
						defender.xLoc = loc[0];
						defender.yLoc = loc[1];
        }
        //getQualifyingLocNear(loc, player.xLoc, player.yLoc, true, NULL, forbiddenFlagsForMonster(&(defender.info)) & ~(T_IS_DF_TRAP | T_IS_DEEP_WATER | T_SPONTANEOUSLY_IGNITES), HAS_MONSTER, false, false);
				//defender.xLoc = loc[0];
				//defender.yLoc = loc[1];
				pmap[defender.xLoc][defender.yLoc].flags |= HAS_MONSTER;
			}

			if (pmap[player.xLoc][player.yLoc].flags & HAS_ITEM) {
				await pickUpItemAt(player.xLoc, player.yLoc);
				rogue.disturbed = true;
			}
			refreshDungeonCell(x, y);
			refreshDungeonCell(player.xLoc, player.yLoc);
			playerMoved = true;

			await checkForMissingKeys(x, y);
	    if (monsterShouldFall(player)) {
	        player.bookkeepingFlags |= MB_IS_FALLING;
	    }
			await moveEntrancedMonsters(direction);

      // Perform a lunge or flail attack if appropriate.
      for (i=0; i<16; i++) {
          if (hitList[i]) {
              if (await attack(player, hitList[i], (rogue.weapon && (rogue.weapon.flags & ITEM_LUNGE_ATTACKS)))) {
                  anyAttackHit = true;
              }
          }
      }
      if (hitList[0]) {
          playerRecoversFromAttacking(anyAttackHit);
      }

			await playerTurnEnded();
		}
	} else if (cellHasTerrainFlag(newX, newY, T_OBSTRUCTS_PASSABILITY)) {
		i = pmap[newX][newY].layers[layerWithFlag(newX, newY, T_OBSTRUCTS_PASSABILITY)];
		if ((tileCatalog[i].flags & T_OBSTRUCTS_PASSABILITY)
        && (!diagonalBlocked(x, y, newX, newY, false) || !cellHasTMFlag(newX, newY, TM_PROMOTES_WITH_KEY)))
		{
      if (!(pmap[newX][newY].flags & DISCOVERED)) {
          if (!alreadyRecorded) {
              recordKeystroke(directionKeys[initialDirection], false, false);
              alreadyRecorded = true;
          }
          discoverCell(newX, newY);
          refreshDungeonCell(newX, newY);
      }
			message(tileCatalog[i].flavorText, backgroundMessageColor, false);
		}
	}
	return playerMoved;
}


// Returns -1 if there are no beneficial moves.
// If preferDiagonals is true, we will prefer diagonal moves.
// Always rolls downhill on the distance map.
// If monst is provided, do not return a direction pointing to
// a cell that the monster avoids.
function nextStep( /* short **/ distanceMap, x, y, /* creature */ monst, preferDiagonals) {
	let newX, newY, bestScore;
  let dir, bestDir;
  let blocker;	// creature *
  let blocked;

  brogueAssert(coordinatesAreInMap(x, y));

	bestScore = 0;
	bestDir = NO_DIRECTION;

	for (dir = (preferDiagonals ? 7 : 0);
		 (preferDiagonals ? dir >= 0 : dir < DIRECTION_COUNT);
		 (preferDiagonals ? dir-- : dir++))
  {
		newX = x + nbDirs[dir][0];
		newY = y + nbDirs[dir][1];

    brogueAssert(coordinatesAreInMap(newX, newY));
    if (coordinatesAreInMap(newX, newY)) {
        blocked = false;
        blocker = monsterAtLoc(newX, newY);
        if (monst
            && monsterAvoids(monst, newX, newY))
				{
            blocked = true;
        } else if (monst
                   && blocker
                   && !canPass(monst, blocker)
                   && !monstersAreTeammates(monst, blocker)
                   && !monstersAreEnemies(monst, blocker))
				{
            blocked = true;
        }
        if ((distanceMap[x][y] - distanceMap[newX][newY]) > bestScore
            && !diagonalBlocked(x, y, newX, newY, monst === player)
            && knownToPlayerAsPassableOrSecretDoor(newX, newY)
            && !blocked)
				{
            bestDir = dir;
            bestScore = distanceMap[x][y] - distanceMap[newX][newY];
        }
    }
	}
	return bestDir;
}

function displayRoute(/* short **/ distanceMap, removeRoute) {
	let currentX = player.xLoc, currentY = player.yLoc, dir, newX, newY;
	let advanced;

	if (distanceMap[player.xLoc][player.yLoc] < 0 || distanceMap[player.xLoc][player.yLoc] == 30000) {
		return;
	}
	do {
		if (removeRoute) {
			refreshDungeonCell(currentX, currentY);
		} else {
			hiliteCell(currentX, currentY, hiliteColor, 50, true);
		}
		advanced = false;
		for (dir = 7; dir >= 0; dir--) {
			newX = currentX + nbDirs[dir][0];
			newY = currentY + nbDirs[dir][1];
			if (coordinatesAreInMap(newX, newY)
				&& distanceMap[newX][newY] >= 0 && distanceMap[newX][newY] < distanceMap[currentX][currentY]
				&& !diagonalBlocked(currentX, currentY, newX, newY, true))
			{
				currentX = newX;
				currentY = newY;
				advanced = true;
				break;
			}
		}
	} while (advanced);
}

async function travelRoute( path /* short[1000][2] */, steps) {
	let i, j;
	let dir;
  let monst;		// creature *

  brogueAssert(!rogue.playbackMode);

	rogue.disturbed = false;
	rogue.automationActive = true;

  for (monst = monsters.nextCreature; monst != NULL; monst = monst.nextCreature) {
      if (canSeeMonster(monst)) {
          monst.bookkeepingFlags |= MB_ALREADY_SEEN;
      } else {
          monst.bookkeepingFlags &= ~MB_ALREADY_SEEN;
      }
  }

	for (i=0; i < steps && !rogue.disturbed; i++) {
    for (j = i + 1; j < steps - 1; j++) {
        // Check to see if the path has become obstructed or avoided since the last time we saw it.
        if (diagonalBlocked(path[j-1][0], path[j-1][1], path[j][0], path[j][1], true)
            || monsterAvoids(player, path[j][0], path[j][1]))
				{
            rogue.disturbed = true;
            break;
        }
    }
		for (dir = 0; dir < DIRECTION_COUNT && !rogue.disturbed; dir++) {
			if (player.xLoc + nbDirs[dir][0] == path[i][0]
				&& player.yLoc + nbDirs[dir][1] == path[i][1])
			{
				if (! await playerMoves(dir)) {
					rogue.disturbed = true;
				}
				if (await pauseBrogue(25)) {
					rogue.disturbed = true;
				}
				break;
			}
		}
	}
	rogue.disturbed = true;
	rogue.automationActive = false;
	updateFlavorText();
}

async function travelMap( /* short **/ distanceMap) {
	let currentX = player.xLoc, currentY = player.yLoc, dir, newX, newY;
	let advanced;

	rogue.disturbed = false;
	rogue.automationActive = true;

	if (distanceMap[player.xLoc][player.yLoc] < 0 || distanceMap[player.xLoc][player.yLoc] == 30000) {
		return;
	}
	do {
		advanced = false;
		for (dir = 7; dir >= 0; dir--) {
			newX = currentX + nbDirs[dir][0];
			newY = currentY + nbDirs[dir][1];
			if (coordinatesAreInMap(newX, newY)
				&& distanceMap[newX][newY] >= 0
				&& distanceMap[newX][newY] < distanceMap[currentX][currentY]
				&& !diagonalBlocked(currentX, currentY, newX, newY, true))
			{
				if (! await playerMoves(dir)) {
					rogue.disturbed = true;
				}
				if (await pauseBrogue(500)) {
					rogue.disturbed = true;
				}
				currentX = newX;
				currentY = newY;
				advanced = true;
				break;
			}
		}
	} while (advanced && !rogue.disturbed);
	rogue.disturbed = true;
	rogue.automationActive = false;
	updateFlavorText();
}


async function travel( x, y, autoConfirm) {
	let distanceMap, i;
	const theEvent = rogueEvent();
	let staircaseConfirmKey;

	confirmMessages();

	if (D_WORMHOLING) {
		recordMouseClick(mapToWindowX(x), mapToWindowY(y), true, false);
		pmap[player.xLoc][player.yLoc].flags &= ~HAS_PLAYER;
		refreshDungeonCell(player.xLoc, player.yLoc);
		player.xLoc = x;
		player.yLoc = y;
		pmap[x][y].flags |= HAS_PLAYER;
    updatePlayerUnderwaterness();
		refreshDungeonCell(x, y);
		updateVision(true);
		return;
	}

	if (abs(player.xLoc - x) + abs(player.yLoc - y) == 1) {
		// targeting a cardinal neighbor
		for (i=0; i<4; i++) {
			if (nbDirs[i][0] == (x - player.xLoc) && nbDirs[i][1] == (y - player.yLoc)) {
				await playerMoves(i);
				break;
			}
		}
		return;
	}

	if (!(pmap[x][y].flags & (DISCOVERED | MAGIC_MAPPED))) {
		message("You have not explored that location.", false);
		return;
	}

	distanceMap = allocGrid();

	calculateDistances(distanceMap, x, y, 0, player, false, false);
	if (distanceMap[player.xLoc][player.yLoc] < 30000) {
		if (autoConfirm) {
			await travelMap(distanceMap);
			//refreshSideBar(-1, -1, false);
		} else {
			if (rogue.upLoc[0] == x && rogue.upLoc[1] == y) {
				staircaseConfirmKey = ASCEND_KEY;
			} else if (rogue.downLoc[0] == x && rogue.downLoc[1] == y) {
				staircaseConfirmKey = DESCEND_KEY;
			} else {
				staircaseConfirmKey = 0;
			}
			displayRoute(distanceMap, false);
			message("Travel this route? (y/n)", false);

			do {
				await nextBrogueEvent(theEvent, true, false, false);
			} while (theEvent.eventType != MOUSE_UP && theEvent.eventType != KEYSTROKE);

			displayRoute(distanceMap, true); // clear route display
			confirmMessages();

			if ((theEvent.eventType == MOUSE_UP && windowToMapX(theEvent.param1) == x && windowToMapY(theEvent.param2) == y)
				|| (theEvent.eventType == KEYSTROKE && (theEvent.param1 == 'Y' || theEvent.param1 == 'y'
														|| theEvent.param1 == RETURN_KEY
														|| theEvent.param1 == ENTER_KEY
														|| (theEvent.param1 == staircaseConfirmKey
															&& theEvent.param1 != 0)))) {
				await travelMap(distanceMap);
				//refreshSideBar(-1, -1, false);
				commitDraws();
			} else if (theEvent.eventType == MOUSE_UP) {
				await executeMouseClick(theEvent);
			}
		}
//		if (player.xLoc == x && player.yLoc == y) {
//			rogue.cursorLoc[0] = rogue.cursorLoc[1] = 0;
//		} else {
//			rogue.cursorLoc[0] = x;
//			rogue.cursorLoc[1] = y;
//		}
	} else {
		rogue.cursorLoc[0] = rogue.cursorLoc[1] = -1;
		message("No path is available.", false);
	}
	freeGrid(distanceMap);
}


function populateGenericCostMap(/* short **/ costMap) {
  let i, j;

	for (i=0; i<DCOLS; i++) {
		for (j=0; j<DROWS; j++) {
      if (cellHasTerrainFlag(i, j, T_OBSTRUCTS_PASSABILITY)
          && (!cellHasTMFlag(i, j, TM_IS_SECRET) || (discoveredTerrainFlagsAtLoc(i, j) & T_OBSTRUCTS_PASSABILITY)))
			{
				costMap[i][j] = cellHasTerrainFlag(i, j, T_OBSTRUCTS_DIAGONAL_MOVEMENT) ? PDS_OBSTRUCTION : PDS_FORBIDDEN;
      } else if (cellHasTerrainFlag(i, j, T_PATHING_BLOCKER & ~T_OBSTRUCTS_PASSABILITY)) {
				costMap[i][j] = PDS_FORBIDDEN;
      } else {
        costMap[i][j] = 1;
      }
    }
  }
}


const LOCATION_FLAGS = {
	terrainFlags: 0,
	TMFlags: 0,
	cellFlags: 0
};

function getLocationFlags(x, y, limitToPlayerKnowledge)
{
  if (limitToPlayerKnowledge
      && (pmap[x][y].flags & (DISCOVERED | MAGIC_MAPPED))
      && !playerCanSee(x, y))
	{
      LOCATION_FLAGS.terrainFlags = pmap[x][y].rememberedTerrainFlags;
      LOCATION_FLAGS.TMFlags = pmap[x][y].rememberedTMFlags;
      LOCATION_FLAGS.cellFlags = pmap[x][y].rememberedCellFlags;
  } else {
      LOCATION_FLAGS.terrainFlags = terrainFlags(x, y);
      LOCATION_FLAGS.TMFlags = terrainMechFlags(x, y);
      LOCATION_FLAGS.cellFlags = pmap[x][y].flags;
  }

	return LOCATION_FLAGS;
}


function populateCreatureCostMap(costMap, /* creature */ monst) {
	let i, j, unexploredCellCost;
  let currentTenant;	// creature *
  let theItem;		// item *
  let terrainFlags, cFlags;

	unexploredCellCost = 10 + (clamp(rogue.depthLevel, 5, 15) - 5) * 2;

	for (i=0; i<DCOLS; i++) {
		for (j=0; j<DROWS; j++) {
			if (monst === player && !(pmap[i][j].flags & (DISCOVERED | MAGIC_MAPPED))) {
				costMap[i][j] = PDS_OBSTRUCTION;
        continue;
			}

      const locFlags = getLocationFlags(i, j, monst === player);

      if ((locFlags.terrainFlags & T_OBSTRUCTS_PASSABILITY)
           && (!cellHasTMFlag(i, j, TM_IS_SECRET) || (discoveredTerrainFlagsAtLoc(i, j) & T_OBSTRUCTS_PASSABILITY) || monst === player))
		  {
					costMap[i][j] = (locFlags.terrainFlags & T_OBSTRUCTS_DIAGONAL_MOVEMENT) ? PDS_OBSTRUCTION : PDS_FORBIDDEN;
          continue;
      }

      if ((locFlags.terrainFlags & T_LAVA_INSTA_DEATH)
          && !(monst.info.flags & (MONST_IMMUNE_TO_FIRE | MONST_FLIES | MONST_INVULNERABLE))
          && (monst.status[STATUS_LEVITATING] || monst.status[STATUS_IMMUNE_TO_FIRE])
          && max(monst.status[STATUS_LEVITATING], monst.status[STATUS_IMMUNE_TO_FIRE]) < (rogue.mapToShore[i][j] + distanceBetween(i, j, monst.xLoc, monst.yLoc) * monst.movementSpeed / 100))
			{
          // Only a temporary effect will permit the monster to survive the lava, and the remaining duration either isn't
          // enough to get it to the spot, or it won't suffice to let it return to shore if it does get there.
          // Treat these locations as obstacles.
					costMap[i][j] = PDS_FORBIDDEN;
          continue;
			}

    if (((locFlags.terrainFlags & T_AUTO_DESCENT) || (locFlags.terrainFlags & T_IS_DEEP_WATER) && !(monst.info.flags & MONST_IMMUNE_TO_WATER))
        && !(monst.info.flags & MONST_FLIES)
        && (monst.status[STATUS_LEVITATING])
        && monst.status[STATUS_LEVITATING] < (rogue.mapToShore[i][j] + distanceBetween(i, j, monst.xLoc, monst.yLoc) * monst.movementSpeed / 100))
		{
        // Only a temporary effect will permit the monster to levitate over the chasm/water, and the remaining duration either isn't
        // enough to get it to the spot, or it won't suffice to let it return to shore if it does get there.
        // Treat these locations as obstacles.
				costMap[i][j] = PDS_FORBIDDEN;
        continue;
			}

      if (monsterAvoids(monst, i, j)) {
				costMap[i][j] = PDS_FORBIDDEN;
        continue;
			}

      if (cFlags & HAS_MONSTER) {
          currentTenant = monsterAtLoc(i, j);
          if (currentTenant
              && (currentTenant.info.flags & (MONST_IMMUNE_TO_WEAPONS | MONST_INVULNERABLE))
              && !canPass(monst, currentTenant))
					{
              costMap[i][j] = PDS_FORBIDDEN;
              continue;
          }
			}

      if ((locFlags.cellFlags & KNOWN_TO_BE_TRAP_FREE)
          || (monst !== player && monst.creatureState != MONSTER_ALLY))
			{
          costMap[i][j] = 10;
      } else {
          // Player and allies give locations that are known to be free of traps
          // an advantage that increases with depth level, based on the depths
          // at which traps are generated.
          costMap[i][j] = unexploredCellCost;
      }

      if (!(monst.info.flags & MONST_INVULNERABLE)) {
          if ((locFlags.terrainFlags & T_CAUSES_NAUSEA)
              || cellHasTMFlag(i, j, TM_PROMOTES_ON_ITEM_PICKUP)
              || (locFlags.terrainFlags & T_ENTANGLES) && !(monst.info.flags & MONST_IMMUNE_TO_WEBS))
					{
              costMap[i][j] += 20;
          }
      }

      if (monst === player) {
          theItem = itemAtLoc(i, j);
          if (theItem && (theItem.flags & ITEM_PLAYER_AVOIDS)) {
              costMap[i][j] += 10;
          }
      }
		}
	}
}

function adjacentFightingDir() {
  let newX, newY;
  let dir;
  let monst;	// creature *

	if (cellHasTerrainFlag(player.xLoc, player.yLoc, T_OBSTRUCTS_PASSABILITY)) {
			return NO_DIRECTION;
	}

  for (dir = 0; dir < DIRECTION_COUNT; dir++) {
      newX = player.xLoc + nbDirs[dir][0];
      newY = player.yLoc + nbDirs[dir][1];
      monst = monsterAtLoc(newX, newY);
      if (monst
          && canSeeMonster(monst)
          && (!diagonalBlocked(player.xLoc, player.yLoc, newX, newY, false) || (monst.info.flags & MONST_ATTACKABLE_THRU_WALLS))
          && monstersAreEnemies(player, monst)
          && !(monst.info.flags & (MONST_IMMUNE_TO_WEAPONS | MONST_INVULNERABLE)))
			{
          return dir;
      }
  }
  return NO_DIRECTION;
}

function exploreGoalValue(x, y) {	return Math.floor(0 - abs((x) - DCOLS / 2) / 3 - abs((x) - DCOLS / 2) / 4); }

function getExploreMap(/* short **/ map, headingToStairs) {// calculate explore map
	let i, j;
	let costMap;	// short **
	let theItem;	// item *

	costMap = allocGrid();
	populateCreatureCostMap(costMap, player);

	for (i=0; i<DCOLS; i++) {
		for (j=0; j<DROWS; j++) {
			map[i][j] = 30000; // Can be overridden later.
      theItem = itemAtLoc(i, j);
			if (!(pmap[i][j].flags & DISCOVERED)) {
        if ((pmap[i][j].flags & MAGIC_MAPPED)
            && (tileCatalog[pmap[i][j].layers[DUNGEON]].flags | tileCatalog[pmap[i][j].layers[LIQUID]].flags) & T_PATHING_BLOCKER) {
            // Magic-mapped cells revealed as obstructions should be treated as such even though they're not discovered.
            costMap[i][j] = cellHasTerrainFlag(i, j, T_OBSTRUCTS_DIAGONAL_MOVEMENT) ? PDS_OBSTRUCTION : PDS_FORBIDDEN;
        } else {
            costMap[i][j] = 1;
            map[i][j] = exploreGoalValue(i, j);
        }
			} else if (theItem
					   && !monsterAvoids(player, i, j))
		  {
				if (theItem.flags & ITEM_PLAYER_AVOIDS) {
					costMap[i][j] = 20;
				} else {
					costMap[i][j] = 1;
					map[i][j] = exploreGoalValue(i, j) - 10;
				}
			}
		}
	}

	costMap[rogue.downLoc[0]][rogue.downLoc[1]]	= 100;
	costMap[rogue.upLoc[0]][rogue.upLoc[1]]		= 100;

	if (headingToStairs) {
		map[rogue.downLoc[0]][rogue.downLoc[1]] = 0; // head to the stairs
	}

	dijkstraScan(map, costMap, true);

	//displayGrid(costMap);
	freeGrid(costMap);
}

async function explore(frameDelay) {
	let distanceMap;	// short **
  const path = ARRAY(1000, () => [-1, -1]); // short[1000][2],
	let steps;
	let madeProgress, headingToStairs;
	let dir;
	let monst;	// creature *

  // Explore commands should never be written to a recording.
  // Instead, the elemental movement commands that compose it
  // should be written individually.
  brogueAssert(!rogue.playbackMode);

	clearCursorPath();

	madeProgress	= false;
	headingToStairs	= false;

	if (player.status[STATUS_CONFUSED]) {
		message("Not while you're confused.", false);
		return false;
	}
	if (cellHasTerrainFlag(player.xLoc, player.yLoc, T_OBSTRUCTS_PASSABILITY)) {
			message("Not while you're trapped.", false);
			return false;
	}

  for (monst = monsters.nextCreature; monst != NULL; monst = monst.nextCreature) {
      if (canSeeMonster(monst)) {
          monst.bookkeepingFlags |= MB_ALREADY_SEEN;
      } else {
          monst.bookkeepingFlags &= ~MB_ALREADY_SEEN;
      }
  }

	// fight any adjacent enemies
  dir = adjacentFightingDir();
  if (dir != NO_DIRECTION
      && await startFighting(dir, (player.status[STATUS_HALLUCINATING] ? true : false)))
	{
      return true;
  }

	if (!rogue.autoPlayingLevel) {
		message(KEYBOARD_LABELS ? "Exploring... press any key to stop." : "Exploring... touch anywhere to stop.",
                false);
		// A little hack so the exploring message remains bright while exploring and then auto-dims when
		// another message is displayed:
		confirmMessages();
		printString(KEYBOARD_LABELS ? "Exploring... press any key to stop." : "Exploring... touch anywhere to stop.",
                    mapToWindowX(0), mapToWindowY(-1), white, black, NULL);
	}
	rogue.disturbed = false;
	rogue.automationActive = true;

	distanceMap = allocGrid();
	do {
    // fight any adjacent enemies
    dir = adjacentFightingDir();
    if (dir != NO_DIRECTION) {
        await startFighting(dir, (player.status[STATUS_HALLUCINATING] ? true : false));
        if (rogue.disturbed) {
            madeProgress = true;
            continue;
        }
    }
    if (rogue.disturbed) {
        continue;
    }

		getExploreMap(distanceMap, headingToStairs);

    // hilite path
    steps = getPlayerPathOnMap(path, distanceMap, player.xLoc, player.yLoc);
    hilitePath(path, steps, false);

		// take a step
		dir = nextStep(distanceMap, player.xLoc, player.yLoc, NULL, false);

		if (!headingToStairs && rogue.autoPlayingLevel && dir == NO_DIRECTION) {
			headingToStairs = true;
			continue;
		}

		refreshSideBar(-1, -1, false);

		if (dir == NO_DIRECTION) {
			rogue.disturbed = true;
		} else if (! await playerMoves(dir)) {
			rogue.disturbed = true;
		} else {
			madeProgress = true;
			if (await pauseBrogue(frameDelay)) {
				rogue.disturbed = true;
				rogue.autoPlayingLevel = false;
			}
		}
    hilitePath(path, steps, true);
	} while (!rogue.disturbed);
	//clearCursorPath();
	rogue.automationActive = false;
	refreshSideBar(-1, -1, false);
	freeGrid(distanceMap);
	return madeProgress;
}


async function autoPlayLevel(fastForward) {
	let madeProgress;

	rogue.autoPlayingLevel = true;

	confirmMessages();
	message(KEYBOARD_LABELS ? "Playing... press any key to stop." : "Playing... touch anywhere to stop.", false);

	// explore until we are not making progress
	do {
		madeProgress = await explore(fastForward ? 1 : 50);
		//refreshSideBar(-1, -1, false);

		if (!madeProgress && rogue.downLoc[0] == player.xLoc && rogue.downLoc[1] == player.yLoc) {
			await useStairs(1);
			madeProgress = true;
		}
	} while (madeProgress && rogue.autoPlayingLevel);

	confirmMessages();

	rogue.autoPlayingLevel = false;
}

// short directionOfKeypress(unsigned short ch) {
// 	switch (ch) {
// 		case LEFT_KEY:
// 		case LEFT_ARROW:
// 		case NUMPAD_4:
// 			return LEFT;
// 		case RIGHT_KEY:
// 		case RIGHT_ARROW:
// 		case NUMPAD_6:
// 			return RIGHT;
// 		case UP_KEY:
// 		case UP_ARROW:
// 		case NUMPAD_8:
// 			return UP;
// 		case DOWN_KEY:
// 		case DOWN_ARROW:
// 		case NUMPAD_2:
// 			return DOWN;
// 		case UPLEFT_KEY:
// 		case NUMPAD_7:
// 			return UPLEFT;
// 		case UPRIGHT_KEY:
// 		case NUMPAD_9:
// 			return UPRIGHT;
// 		case DOWNLEFT_KEY:
// 		case NUMPAD_1:
// 			return DOWNLEFT;
// 		case DOWNRIGHT_KEY:
// 		case NUMPAD_3:
// 			return DOWNRIGHT;
// 		default:
// 			return -1;
// 	}
// }

async function startFighting(dir, tillDeath) {
	let x, y, expectedDamage;
	let monst;	// creature *

	x = player.xLoc + nbDirs[dir][0];
	y = player.yLoc + nbDirs[dir][1];
	monst = monsterAtLoc(x, y);
  if (monst.info.flags & (MONST_IMMUNE_TO_WEAPONS | MONST_INVULNERABLE)) {
      return false;
  }
	expectedDamage = monst.info.damage.upperBound * fp_monsterDamageAdjustmentAmount(monst) >> FP_BASE;
	if (rogue.easyMode) {
		expectedDamage /= 5;
	}
	rogue.blockCombatText = true;
	rogue.disturbed = false;
	do {
		if (!await playerMoves(dir)) {
			break;
		}
		if (await pauseBrogue(1)) {
			break;
		}
	} while (!rogue.disturbed && !rogue.gameHasEnded && (tillDeath || player.currentHP > expectedDamage)
			 && (pmap[x][y].flags & HAS_MONSTER) && monsterAtLoc(x, y) == monst);

	rogue.blockCombatText = false;
  return rogue.disturbed;
}

function isDisturbed(x, y) {
	let i;
	let monst;	// creature *

	for (i=0; i< DIRECTION_COUNT; i++) {
		monst = monsterAtLoc(x + nbDirs[i][0], y + nbDirs[i][1]);
		if (pmap[x + nbDirs[i][0]][y + nbDirs[i][1]].flags & (HAS_ITEM)) {
			// Do not trigger for submerged or invisible or unseen monsters.
			return true;
		}
		if (monst
			&& !(monst.creatureState == MONSTER_ALLY)
			&& (canSeeMonster(monst) || monsterRevealed(monst))) {
			// Do not trigger for submerged or invisible or unseen monsters.
			return true;
		}
	}
	return false;
}

async function discover(x, y) {
	let layer;		// enum dungeonLayers
	let feat;			// dungeonFeature *
	if (cellHasTMFlag(x, y, TM_IS_SECRET)) {
		for (layer = 0; layer < NUMBER_TERRAIN_LAYERS; layer++) {
			if (tileCatalog[pmap[x][y].layers[layer]].mechFlags & TM_IS_SECRET) {
				feat = dungeonFeatureCatalog[tileCatalog[pmap[x][y].layers[layer]].discoverType];
				pmap[x][y].layers[layer] = (layer == DUNGEON ? FLOOR : NOTHING);
				await spawnDungeonFeature(x, y, feat, true, false);
			}
		}
		refreshDungeonCell(x, y);

    if (playerCanSee(x, y)) {
        rogue.disturbed = true;
    }
	}
}

// returns true if found anything
async function search(searchStrength) {
	let i, j, radius, x, y, percent;
	let foundSomething = false;

	radius = Math.floor(searchStrength / 10);
	x = player.xLoc;
	y = player.yLoc;

	for (i = x - radius; i <= x + radius; i++) {
		for (j = y - radius; j <= y + radius; j++) {
			if (coordinatesAreInMap(i, j)
				&& playerCanDirectlySee(i, j))
			{
        percent = searchStrength - distanceBetween(x, y, i, j) * 10;
        if (cellHasTerrainFlag(i, j, T_OBSTRUCTS_PASSABILITY)) {
            percent = percent * 2/3;
        }
				if (percent >= 100) {
						pmap[i][j].flags |= KNOWN_TO_BE_TRAP_FREE;
				}
        percent = min(percent, 100);

				if (cellHasTMFlag(i, j, TM_IS_SECRET)) {
					if (rand_percent(percent)) {
            await discover(i, j);
            foundSomething = true;
        	}
				}
			}
		}
	}
	return foundSomething;
}

function proposeOrConfirmLocation(x, y, failureMessage) {
  let retval = false;

	if (player.xLoc == x && player.yLoc == y) {
		message("you are already there.", false);
	} else if (pmap[x][y].flags & (DISCOVERED | MAGIC_MAPPED)) {
		if (rogue.cursorLoc[0] == x && rogue.cursorLoc[1] == y) {
    	retval = true;
		} else {
			rogue.cursorLoc[0] = x;
			rogue.cursorLoc[1] = y;
		}
	} else {
		message(failureMessage, false);
	}
  return retval;
}

async function useStairs(stairDirection) {
	let succeeded = false;
  //cellDisplayBuffer fromBuf[COLS][ROWS], toBuf[COLS][ROWS];

	if (stairDirection == 1) {
    if (rogue.depthLevel < DEEPEST_LEVEL) {
        //copyDisplayBuffer(fromBuf, displayBuffer);
        rogue.cursorLoc[0] = rogue.cursorLoc[1] = -1;
        rogue.depthLevel++;
        message("You descend.", false);
        await startLevel(rogue.depthLevel - 1, stairDirection);
        if (rogue.depthLevel > rogue.deepestLevel) {
            rogue.deepestLevel = rogue.depthLevel;
        }
        //copyDisplayBuffer(toBuf, displayBuffer);
        //irisFadeBetweenBuffers(fromBuf, toBuf, mapToWindowX(player.xLoc), mapToWindowY(player.yLoc), 10, false);
    } else if (numberOfMatchingPackItems(AMULET, 0, 0, false)) {
        await victory(true);
    } else {
				confirmMessages();
        message("the crystal archway repels you with a mysterious force!", lightBlue, false);
        message("(Only the bearer of the Amulet of Yendor may pass.)", backgroundMessageColor, false);
    }
		succeeded = true;
	} else {
		if (rogue.depthLevel > 1 || numberOfMatchingPackItems(AMULET, 0, 0, false)) {
			rogue.cursorLoc[0] = rogue.cursorLoc[1] = -1;
			rogue.depthLevel--;
			if (rogue.depthLevel == 0) {
				await victory(false);
			} else {
        //copyDisplayBuffer(fromBuf, displayBuffer);
				message("You ascend.", false);
				startLevel(rogue.depthLevel + 1, stairDirection);
        //copyDisplayBuffer(toBuf, displayBuffer);
        //irisFadeBetweenBuffers(fromBuf, toBuf, mapToWindowX(player.xLoc), mapToWindowY(player.yLoc), 10, true);
			}
			succeeded = true;
		} else {
			confirmMessages();
      message("The dungeon exit is magically sealed!", lightBlue, false);
      message("(Only the bearer of the Amulet of Yendor may pass.)", backgroundMessageColor, false);
		}
	}

	if (succeeded) {
      updatePlayerUnderwaterness();
	}

	return succeeded;
}


function storeMemories(x, y) {
    pmap[x][y].rememberedTerrainFlags = terrainFlags(x, y);
    pmap[x][y].rememberedTMFlags = terrainMechFlags(x, y);
    pmap[x][y].rememberedCellFlags = pmap[x][y].flags;
    pmap[x][y].rememberedTerrain = pmap[x][y].layers[highestPriorityLayer(x, y, false)];
}


function updateFieldOfViewDisplay(updateDancingTerrain, refreshDisplay) {
	let i, j;
	let theItem;	// item *
  const buf = STRING(), name = STRING();	// char[]

	// assureCosmeticRNG();

	for (i=0; i<DCOLS; i++) {
		for (j=0; j<DROWS; j++) {
			if (pmap[i][j].flags & IN_FIELD_OF_VIEW
				&& (max(0, tmap[i][j].light[0])
              + max(0, tmap[i][j].light[1])
              + max(0, tmap[i][j].light[2]) > VISIBILITY_THRESHOLD)
				&& !(pmap[i][j].flags & CLAIRVOYANT_DARKENED))
			{
				pmap[i][j].flags |= VISIBLE;
			}

			if ((pmap[i][j].flags & VISIBLE) && !(pmap[i][j].flags & WAS_VISIBLE)) { // if the cell became visible this move
				if (!(pmap[i][j].flags & DISCOVERED) && rogue.automationActive) {
            if (pmap[i][j].flags & HAS_ITEM) {
                theItem = itemAtLoc(i, j);
                if (theItem && (theItem.category & KEY)) {
                    itemName(theItem, name, false, true, NULL);
                    sprintf(buf, "you see %s.", name);
                    message(buf, itemMessageColor, false);
                }
            }
            if (!(pmap[i][j].flags & MAGIC_MAPPED)
                && cellHasTMFlag(i, j, TM_INTERRUPT_EXPLORATION_WHEN_SEEN))
						{
                strcpy(name, tileCatalog[pmap[i][j].layers[layerWithTMFlag(i, j, TM_INTERRUPT_EXPLORATION_WHEN_SEEN)]].description);
                sprintf(buf, "you see %s.", name);
                message(buf, backgroundMessageColor, false);
            }
        }
        discoverCell(i, j);
				if (refreshDisplay) {
					refreshDungeonCell(i, j);
				}
			} else if (!(pmap[i][j].flags & VISIBLE) && (pmap[i][j].flags & WAS_VISIBLE)) { // if the cell ceased being visible this move
        storeMemories(i, j);
				if (refreshDisplay) {
					refreshDungeonCell(i, j);
				}
			} else if (!(pmap[i][j].flags & CLAIRVOYANT_VISIBLE) && (pmap[i][j].flags & WAS_CLAIRVOYANT_VISIBLE)) { // ceased being clairvoyantly visible
				storeMemories(i, j);
				if (refreshDisplay) {
					refreshDungeonCell(i, j);
				}
			} else if (!(pmap[i][j].flags & WAS_CLAIRVOYANT_VISIBLE) && (pmap[i][j].flags & CLAIRVOYANT_VISIBLE)) { // became clairvoyantly visible
				pmap[i][j].flags &= ~STABLE_MEMORY;
				if (refreshDisplay) {
					refreshDungeonCell(i, j);
				}
			} else if (!(pmap[i][j].flags & TELEPATHIC_VISIBLE) && (pmap[i][j].flags & WAS_TELEPATHIC_VISIBLE)) { // ceased being telepathically visible
        storeMemories(i, j);
				if (refreshDisplay) {
					refreshDungeonCell(i, j);
				}
			} else if (!(pmap[i][j].flags & WAS_TELEPATHIC_VISIBLE) && (pmap[i][j].flags & TELEPATHIC_VISIBLE)) { // became telepathically visible
        if (!(pmap[i][j].flags & DISCOVERED)
					&& !cellHasTerrainFlag(i, j, T_PATHING_BLOCKER))
				{
					rogue.xpxpThisTurn++;
        }

				pmap[i][j].flags &= ~STABLE_MEMORY;
				if (refreshDisplay) {
					refreshDungeonCell(i, j);
				}
			} else if (playerCanSeeOrSense(i, j)
					   && (tmap[i][j].light[0] != tmap[i][j].oldLight[0] ||
						   tmap[i][j].light[1] != tmap[i][j].oldLight[1] ||
						   tmap[i][j].light[2] != tmap[i][j].oldLight[2])) // if the cell's light color changed this move
			{
			   if (refreshDisplay) {
				   refreshDungeonCell(i, j);
			   }
	   } else if (updateDancingTerrain
				  && playerCanSee(i, j)
				  && (!rogue.automationActive || !(rogue.playerTurnNumber % 5))
				  && ((tileCatalog[pmap[i][j].layers[DUNGEON]].backColor)       && tileCatalog[pmap[i][j].layers[DUNGEON]].backColor.colorDances
					  || (tileCatalog[pmap[i][j].layers[DUNGEON]].foreColor)    && tileCatalog[pmap[i][j].layers[DUNGEON]].foreColor.colorDances
					  || (tileCatalog[pmap[i][j].layers[LIQUID]].backColor)     && tileCatalog[pmap[i][j].layers[LIQUID]].backColor.colorDances
					  || (tileCatalog[pmap[i][j].layers[LIQUID]].foreColor)     && tileCatalog[pmap[i][j].layers[LIQUID]].foreColor.colorDances
					  || (tileCatalog[pmap[i][j].layers[SURFACE]].backColor)    && tileCatalog[pmap[i][j].layers[SURFACE]].backColor.colorDances
					  || (tileCatalog[pmap[i][j].layers[SURFACE]].foreColor)    && tileCatalog[pmap[i][j].layers[SURFACE]].foreColor.colorDances
					  || (tileCatalog[pmap[i][j].layers[GAS]].backColor)        && tileCatalog[pmap[i][j].layers[GAS]].backColor.colorDances
					  || (tileCatalog[pmap[i][j].layers[GAS]].foreColor)        && tileCatalog[pmap[i][j].layers[GAS]].foreColor.colorDances
					  || player.status[STATUS_HALLUCINATING]))
			{
				  pmap[i][j].flags &= ~STABLE_MEMORY;
				  if (refreshDisplay) {
					  refreshDungeonCell(i, j);
				  }
			  }
		}
	}
	// restoreRNG();
}


//		   Octants:      //
//			\7|8/        //
//			6\|/1        //
//			--@--        //
//			5/|\2        //
//			/4|3\        //

function betweenOctant1andN(x, y, x0, y0, n) {
	let x1 = x, y1 = y;
	let dx = x1 - x0, dy = y1 - y0;
	switch (n) {
		case 1:
			return [x,y];
		case 2:
			return [x, y0 - dy];
		case 5:
			return [x0 - dx, y0 - dy];
		case 6:
			return [x0 - dx, y];
		case 8:
			return [x0 - dy, y0 - dx];
		case 3:
			return [x0 - dy, y0 + dx];
		case 7:
			return [x0 + dy, y0 - dx];
		case 4:
			return [x0 + dy, y0 + dx];
	}
}

// Returns a boolean grid indicating whether each square is in the field of view of (xLoc, yLoc).
// forbiddenTerrain is the set of terrain flags that will block vision (but the blocking cell itself is
// illuminated); forbiddenFlags is the set of map flags that will block vision.
// If cautiousOnWalls is set, we will not illuminate blocking tiles unless the tile one space closer to the origin
// is visible to the player; this is to prevent lights from illuminating a wall when the player is on the other
// side of the wall.
function getFOVMask( grid /* char[DCOLS][DROWS] */, xLoc, yLoc, maxRadius,
				forbiddenTerrain,	forbiddenFlags, cautiousOnWalls)
{
	let i;

	for (i=1; i<=8; i++) {
		scanOctantFOV(grid, xLoc, yLoc, i, maxRadius, 1, LOS_SLOPE_GRANULARITY * -1, 0,
					  forbiddenTerrain, forbiddenFlags, cautiousOnWalls);
	}
}

// Number.parseInt((t * t).toString(16).padStart(16, '0').substring(0, 8), 16)

// This is a custom implementation of recursive shadowcasting.
function scanOctantFOV( grid /* char[DCOLS][DROWS] */, xLoc, yLoc, octant, maxRadius,
				   columnsRightFromOrigin, startSlope, endSlope, forbiddenTerrain,
				   forbiddenFlags, cautiousOnWalls)
{
	if (columnsRightFromOrigin << FP_BASE >= maxRadius) return;

	let i, a, b, iStart, iEnd, x, y, x2, y2; // x and y are temporary variables on which we do the octant transform
	let newStartSlope, newEndSlope;
	let cellObstructed;
	let loc;

	if (Math.floor(maxRadius) != maxRadius) {
			maxRadius = Math.floor(maxRadius);
	}
	newStartSlope = startSlope;

	a = Math.round(((LOS_SLOPE_GRANULARITY / -2 + 1) + startSlope * columnsRightFromOrigin) / LOS_SLOPE_GRANULARITY);
	b = Math.round(((LOS_SLOPE_GRANULARITY / -2 + 1) + endSlope * columnsRightFromOrigin) / LOS_SLOPE_GRANULARITY);

	iStart = min(a, b);
	iEnd = max(a, b);

	// restrict vision to a circle of radius maxRadius

	// !!!!!!!!!!!!!!!
	// SEAN FIXME!!!!!!  WE CANNOT DO 32 Bit Shift
	// !!!!!!!!!!!!!!!
	const radiusSquared = Number(BigInt(maxRadius*maxRadius) >> (BIG_BASE*2n));
	if ((columnsRightFromOrigin*columnsRightFromOrigin + iEnd*iEnd) >= radiusSquared ) {
		return;
	}
	if ((columnsRightFromOrigin*columnsRightFromOrigin + iStart*iStart) >= radiusSquared ) {
		const bigRadiusSquared = Number(BigInt(maxRadius*maxRadius) >> BIG_BASE); // (maxRadius*maxRadius >> FP_BASE)
		const bigColumsRightFromOriginSquared = Number(BigInt(columnsRightFromOrigin*columnsRightFromOrigin) << BIG_BASE);	// (columnsRightFromOrigin*columnsRightFromOrigin << FP_BASE)
		iStart = Math.floor(-1 * fp_sqrt(bigRadiusSquared - bigColumsRightFromOriginSquared) >> FP_BASE);
	}

	x = xLoc + columnsRightFromOrigin;
	y = yLoc + iStart;
	loc = betweenOctant1andN(x, y, xLoc, yLoc, octant);
	x = loc[0];
	y = loc[1];
	let currentlyLit = coordinatesAreInMap(x, y) && !(cellHasTerrainFlag(x, y, forbiddenTerrain) ||
														  (pmap[x][y].flags & forbiddenFlags));
	for (i = iStart; i <= iEnd; i++) {
		x = xLoc + columnsRightFromOrigin;
		y = yLoc + i;
		loc = betweenOctant1andN(x, y, xLoc, yLoc, octant);
		x = loc[0];
		y = loc[1];
		if (!coordinatesAreInMap(x, y)) {
			// We're off the map -- here there be memory corruption.
			continue;
		}
		cellObstructed = (cellHasTerrainFlag(x, y, forbiddenTerrain) || (pmap[x][y].flags & forbiddenFlags));
		// if we're cautious on walls and this is a wall:
		if (cautiousOnWalls && cellObstructed) {
			// (x2, y2) is the tile one space closer to the origin from the tile we're on:
			x2 = xLoc + columnsRightFromOrigin - 1;
			y2 = yLoc + i;
			if (i < 0) {
				y2++;
			} else if (i > 0) {
				y2--;
			}
			loc = betweenOctant1andN(x2, y2, xLoc, yLoc, octant);
			x2 = loc[0];
			y2 = loc[1];

			if (pmap[x2][y2].flags & IN_FIELD_OF_VIEW) {
				// previous tile is visible, so illuminate
				grid[x][y] = 1;
			}
		} else {
			// illuminate
			grid[x][y] = 1;
		}
		if (!cellObstructed && !currentlyLit) { // next column slope starts here
			newStartSlope = Math.round((LOS_SLOPE_GRANULARITY * (i) - LOS_SLOPE_GRANULARITY / 2) / (columnsRightFromOrigin * 2 + 1) * 2);
			currentlyLit = true;
		} else if (cellObstructed && currentlyLit) { // next column slope ends here
			newEndSlope = Math.round((LOS_SLOPE_GRANULARITY * (i) - LOS_SLOPE_GRANULARITY / 2)
							/ (columnsRightFromOrigin * 2 - 1) * 2);
			if (newStartSlope <= newEndSlope) {
				// run next column
				scanOctantFOV(grid, xLoc, yLoc, octant, maxRadius, columnsRightFromOrigin + 1, newStartSlope, newEndSlope,
							  forbiddenTerrain, forbiddenFlags, cautiousOnWalls);
			}
			currentlyLit = false;
		}
	}
	if (currentlyLit) { // got to the bottom of the scan while lit
		newEndSlope = endSlope;
		if (newStartSlope <= newEndSlope) {
			// run next column
			scanOctantFOV(grid, xLoc, yLoc, octant, maxRadius, columnsRightFromOrigin + 1, newStartSlope, newEndSlope,
						  forbiddenTerrain, forbiddenFlags, cautiousOnWalls);
		}
	}
}

function addScentToCell(x, y, distance) {
  let value;
	if (!cellHasTerrainFlag(x, y, T_OBSTRUCTS_SCENT) || !cellHasTerrainFlag(x, y, T_OBSTRUCTS_PASSABILITY)) {
    value = Math.floor(rogue.scentTurnNumber - distance);
		scentMap[x][y] = max(value, Math.floor(scentMap[x][y]) );
	}
}
/*
 *  Combat.c
 *  Brogue
 *
 *  Created by Brian Walker on 6/11/09.
 *  Copyright 2012. All rights reserved.
 *
 *  This file is part of Brogue.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

// #include <math.h>
// #include "Rogue.h"
// #include "IncludeGlobals.h"


/* Combat rules:
 * Each combatant has an accuracy rating. This is the percentage of their attacks that will ordinarily hit;
 * higher numbers are better for them. Numbers over 100 are permitted.
 *
 * Each combatant also has a defense rating. The "hit probability" is calculated as given by this formula:
 *
 * 			hit probability = (accuracy) * 0.987 ^ (defense)
 *
 * when hit determinations are made. Negative numbers and numbers over 100 are permitted.
 * The hit is then randomly determined according to this final percentage.
 *
 * Some environmental factors can modify these numbers. An unaware, sleeping, stuck or paralyzed
 * combatant is always hit. An unaware, sleeping or paralyzed combatant also takes treble damage.
 *
 * If the hit lands, damage is calculated in the range provided. However, the clumping factor affects the
 * probability distribution. If the range is 0-10 with a clumping factor of 1, it's a uniform distribution.
 * With a clumping factor of 2, it's calculated as 2d5 (with d5 meaing a die numbered from 0 through 5).
 * With 3, it's 3d3, and so on. Note that a range not divisible by the clumping factor is defective,
 * as it will never be resolved in the top few numbers of the range. In fact, the top
 * (rangeWidth % clumpingFactor) will never succeed. Thus we increment the maximum of the first
 * (rangeWidth % clumpingFactor) die by 1, so that in fact 0-10 with a CF of 3 would be 1d4 + 2d3. Similarly,
 * 0-10 with CF 4 would be 2d3 + 2d2. By playing with the numbers, one can approximate a gaussian
 * distribution of any mean and standard deviation.
 *
 * Player combatants take their base defense value of their actual armor. Their accuracy is a combination of weapon, armor
 * and strength.
 *
 * Players have a base accuracy value of 100 throughout the game. Each point of weapon enchantment (net of
 * strength penalty/benefit) increases
 */

function fp_strengthModifier( /* item */ theItem) {
	let difference = (rogue.strength - player.weaknessAmount) - theItem.strengthRequired;
	if (difference > 0) {
		return (difference << FP_BASE) / 4;			// 0.25x
	} else {
		return (difference << FP_BASE) * 5/2;		// 2.5x
	}
}

function fp_netEnchant(/* item */ theItem) {
  let retval;
	if (theItem.category & (WEAPON | ARMOR)) {
		retval = (Math.floor(theItem.enchant1) << FP_BASE) + fp_strengthModifier(theItem);
	} else {
		retval = (Math.floor(theItem.enchant1) << FP_BASE);
	}
    // Clamp all net enchantment values to [-20, 50].
    return clamp(retval, -20 << FP_BASE, 50 << FP_BASE);
}

function fp_monsterDamageAdjustmentAmount(/* creature */ monst) {
    if (monst === player) {
        // Handled through player strength routines elsewhere.
        return FP_FACTOR;
    } else {
        return fp_damageFraction((monst.weaknessAmount << FP_BASE) * -3/2);
    }
}

function monsterDefenseAdjusted(/* creature */ monst) {
    let retval;
    if (monst === player) {
        // Weakness is already taken into account in recalculateEquipmentBonuses() for the player.
        retval = monst.info.defense;
    } else {
        retval = monst.info.defense - 25 * monst.weaknessAmount;
    }
    return max(retval, 0);
}

function monsterAccuracyAdjusted(/* creature */ monst) {
    let retval = monst.info.accuracy * fp_accuracyFraction((monst.weaknessAmount << FP_BASE) * -3/2) >> FP_BASE;
    return max(retval, 0);
}


// does NOT account for auto-hit from sleeping or unaware defenders; does account for auto-hit from
// stuck or captive defenders and from weapons of slaying.
function hitProbability(/* creature */ attacker, /* creature */ defender) {
	let accuracy = monsterAccuracyAdjusted(attacker);
	let defense = monsterDefenseAdjusted(defender);
	let probability;

	if (defender.status[STATUS_STUCK] || (defender.bookkeepingFlags & MB_CAPTIVE)) {
		return 100;
	}

  if ((defender.bookkeepingFlags & MB_SEIZED)
      && (attacker.bookkeepingFlags & MB_SEIZING))
	{
      return 100;
  }

	if (attacker === player && rogue.weapon) {
    if ((rogue.weapon.flags & ITEM_RUNIC)
        && rogue.weapon.enchant2 == W_SLAYING
        && monsterIsInClass(defender, rogue.weapon.vorpalEnemy))
		{
        return 100;
    }
		accuracy = player.info.accuracy * fp_accuracyFraction(fp_netEnchant(rogue.weapon)) >> FP_BASE;
	}

	probability = accuracy * fp_defenseFraction(defense) >> FP_BASE;

	if (probability > 100) {
		probability = 100;
	} else if (probability < 0) {
		probability = 0;
	}

	return probability;
}

function attackHit(/* creature */ attacker, /* creature */ defender) {

	// automatically hit if the monster is sleeping or captive or stuck in a web
	if (defender.status[STATUS_STUCK]
		|| defender.status[STATUS_PARALYZED]
		|| (defender.bookkeepingFlags & MB_CAPTIVE))
	{
		return true;
	}

	return rand_percent(hitProbability(attacker, defender));
}

function addMonsterToContiguousMonsterGrid(x, y, /* creature */ monst, grid /* char[DCOLS][DROWS] */) {
	let newX, newY;
  let dir;	//   enum directions
	let tempMonst;	// creature *

	grid[x][y] = true;
	for (dir=0; dir<4; dir++) {
		newX = x + nbDirs[dir][0];
		newY = y + nbDirs[dir][1];

		if (coordinatesAreInMap(newX, newY) && !grid[newX][newY]) {
			tempMonst = monsterAtLoc(newX, newY);
			if (tempMonst && monstersAreTeammates(monst, tempMonst)) {
				addMonsterToContiguousMonsterGrid(newX, newY, monst, grid);
			}
		}
	}
}


// Splits a monster in half.
// The split occurs only if there is a spot adjacent to the contiguous
// group of monsters that the monster would not avoid.
// The contiguous group is supplemented with the given (x, y) coordinates, if any;
// this is so that jellies et al. can spawn behind the player in a hallway.
async function splitMonster( /* creature */ monst, x, y) {
	let i, j, b, dir, newX, newY, eligibleLocationCount, randIndex;
	const buf = STRING(); // char[DCOLS * 3];
	const monstName = STRING(); // char[DCOLS];
	const monsterGrid = GRID(DCOLS, DROWS), eligibleGrid = GRID(DCOLS, DROWS); // char[DCOLS][DROWS];
	let clone;	// creature *

	zeroOutGrid(monsterGrid);
	zeroOutGrid(eligibleGrid);
	eligibleLocationCount = 0;

	// Add the (x, y) location to the contiguous group, if any.
	if (x > 0 && y > 0) {
		monsterGrid[x][y] = true;
	}

	// Find the contiguous group of monsters.
	addMonsterToContiguousMonsterGrid(monst.xLoc, monst.yLoc, monst, monsterGrid);

	// Find the eligible edges around the group of monsters.
	for (i=0; i<DCOLS; i++) {
		for (j=0; j<DROWS; j++) {
			if (monsterGrid[i][j]) {
				for (dir=0; dir<4; dir++) {
					newX = i + nbDirs[dir][0];
					newY = j + nbDirs[dir][1];
					if (coordinatesAreInMap(newX, newY)
						&& !eligibleGrid[newX][newY]
						&& !monsterGrid[newX][newY]
						&& !(pmap[newX][newY].flags & (HAS_PLAYER | HAS_MONSTER))
						&& !monsterAvoids(monst, newX, newY))
					{
						eligibleGrid[newX][newY] = true;
						eligibleLocationCount++;
					}
				}
			}
		}
	}
//    DEBUG {
//        hiliteCharGrid(eligibleGrid, &green, 75);
//        hiliteCharGrid(monsterGrid, &blue, 75);
//        temporaryMessage("Jelly spawn possibilities (green = eligible, blue = monster):", true);
//        displayLevel();
//    }

	// Pick a random location on the eligibleGrid and add the clone there.
	if (eligibleLocationCount) {
		randIndex = rand_range(1, eligibleLocationCount);
		for (i=0; i<DCOLS; i++) {
			for (j=0; j<DROWS; j++) {
				if (eligibleGrid[i][j] && !--randIndex) {
					// Found the spot!

					monsterName(monstName, monst, true);
					monst.currentHP = (monst.currentHP + 1) / 2;
					clone = await cloneMonster(monst, false, false);

          // Split monsters don't inherit the learnings of their parents.
          // Sorry, but self-healing jelly armies are too much.
          // Mutation effects can be inherited, however; they're not learned abilities.
          if (monst.mutationIndex >= 0) {
              clone.info.flags           &= (monsterCatalog[clone.info.monsterID].flags | mutationCatalog[monst.mutationIndex].monsterFlags);
              clone.info.abilityFlags    &= (monsterCatalog[clone.info.monsterID].abilityFlags | mutationCatalog[monst.mutationIndex].monsterAbilityFlags);
          } else {
              clone.info.flags           &= monsterCatalog[clone.info.monsterID].flags;
              clone.info.abilityFlags    &= monsterCatalog[clone.info.monsterID].abilityFlags;
          }
          for (b = 0; b < 20; b++) {
              clone.info.bolts[b] = monsterCatalog[clone.info.monsterID].bolts[b];
          }

          if (!(clone.info.flags & MONST_FLIES)
              && clone.status[STATUS_LEVITATING] == 1000)
					{
              clone.status[STATUS_LEVITATING] = 0;
          }

					clone.xLoc = i;
					clone.yLoc = j;
					pmap[i][j].flags |= HAS_MONSTER;
					clone.ticksUntilTurn = max(clone.ticksUntilTurn, 101);
					fadeInMonster(clone);
					refreshSideBar(-1, -1, false);

					if (canDirectlySeeMonster(monst)) {
						sprintf(buf, "%s splits in two!", monstName);
						message(buf, false);
					}

					return;
				}
			}
		}
	}
}

function alliedCloneCount(/* creature */ monst) {
  let count;
  let temp;	// creature *

  count = 0;
  for (temp = monsters.nextCreature; temp != NULL; temp = temp.nextCreature) {
      if (temp != monst
          && temp.info.monsterID == monst.info.monsterID
          && monstersAreTeammates(temp, monst))
			{
          count++;
      }
  }
  if (rogue.depthLevel > 0) {
      for (temp = levels[rogue.depthLevel - 2].monsters; temp != NULL; temp = temp.nextCreature) {
          if (temp != monst
              && temp.info.monsterID == monst.info.monsterID
              && monstersAreTeammates(temp, monst))
					{
              count++;
          }
      }
  }
  if (rogue.depthLevel < DEEPEST_LEVEL) {
      for (temp = levels[rogue.depthLevel].monsters; temp != NULL; temp = temp.nextCreature) {
          if (temp != monst
              && temp.info.monsterID == monst.info.monsterID
              && monstersAreTeammates(temp, monst))
					{
              count++;
          }
      }
  }
  return count;
}

// This function is called whenever one creature acts aggressively against another in a way that directly causes damage.
// This can be things like melee attacks, fire/lightning attacks or throwing a weapon.
async function moralAttack( /* creature */ attacker, /* creature */ defender) {

  if (attacker === player && canSeeMonster(defender)) {
      rogue.featRecord[FEAT_PACIFIST] = false;
      if (defender.creatureState != MONSTER_TRACKING_SCENT) {
          rogue.featRecord[FEAT_PALADIN] = false;
      }
  }

	if (defender.currentHP > 0
		&& !(defender.bookkeepingFlags & MB_IS_DYING))
	{
        if (defender.status[STATUS_PARALYZED]) {
            defender.status[STATUS_PARALYZED] = 0;
             // Paralyzed creature gets a turn to react before the attacker moves again.
            defender.ticksUntilTurn = min(attacker.attackSpeed, 100) - 1;
        }
		if (defender.status[STATUS_MAGICAL_FEAR]) {
			defender.status[STATUS_MAGICAL_FEAR] = 1;
		}
		defender.status[STATUS_ENTRANCED] = 0;

		if (attacker === player
			&& defender.creatureState == MONSTER_ALLY
			&& !defender.status[STATUS_DISCORDANT]
			&& !attacker.status[STATUS_CONFUSED]
      && !(attacker.bookkeepingFlags & MB_IS_DYING))
		{
			unAlly(defender);
		}

    if ((attacker === player || attacker.creatureState == MONSTER_ALLY)
        && defender !== player
        && defender.creatureState != MONSTER_ALLY)
		{
        alertMonster(defender); // this alerts the monster that you're nearby
    }

		if ((defender.info.abilityFlags & MA_CLONE_SELF_ON_DEFEND) && alliedCloneCount(defender) < 100) {
			if (distanceBetween(defender.xLoc, defender.yLoc, attacker.xLoc, attacker.yLoc) <= 1) {
				await splitMonster(defender, attacker.xLoc, attacker.yLoc);
			} else {
				await splitMonster(defender, 0, 0);
			}
		}
	}
}


function playerImmuneToMonster(/* creature */ monst) {
	if (monst !== player
		&& rogue.armor
		&& (rogue.armor.flags & ITEM_RUNIC)
		&& (rogue.armor.enchant2 == A_IMMUNITY)
		&& monsterIsInClass(monst, rogue.armor.vorpalEnemy))
	{
		return true;
	} else {
		return false;
	}
}

async function specialHit( /* creature */ attacker, /* creature */ defender, damage) {
	let itemCandidates, randItemIndex, stolenQuantity;
	let theItem = NULL, itemFromTopOfStack;		// item *
	const buf = STRING(), buf2 = STRING(), buf3 = STRING();

	if (!(attacker.info.abilityFlags & SPECIAL_HIT)) {
		return;
	}

	// Special hits that can affect only the player:
	if (defender === player) {
      if (playerImmuneToMonster(attacker)) {
		return;
	}

	if (attacker.info.abilityFlags & MA_HIT_DEGRADE_ARMOR
		&& defender === player
		&& rogue.armor
		&& !(rogue.armor.flags & ITEM_PROTECTED)
		&& ( Math.floor(rogue.armor.enchant1 + rogue.armor.armor/10) > -10))
	{
		rogue.armor.enchant1--;
		equipItem(rogue.armor, true);
		itemName(rogue.armor, buf2, false, false, NULL);
    sprintf(buf, "your %s weakens!", buf2);
		message(buf, itemMessageColor, false);
    checkForDisenchantment(rogue.armor);
	}

	if (attacker.info.abilityFlags & MA_HIT_HALLUCINATE) {
		if (!player.status[STATUS_HALLUCINATING]) {
			combatMessage("you begin to hallucinate", 0);
		}
		if (!player.status[STATUS_HALLUCINATING]) {
			player.maxStatus[STATUS_HALLUCINATING] = 0;
		}
		player.status[STATUS_HALLUCINATING] += 20;
		player.maxStatus[STATUS_HALLUCINATING] = max(player.maxStatus[STATUS_HALLUCINATING], player.status[STATUS_HALLUCINATING]);
	}

	if (attacker.info.abilityFlags & MA_HIT_BURN
			 && !defender.status[STATUS_IMMUNE_TO_FIRE])
 	{
			await exposeCreatureToFire(defender);
	}

	if (attacker.info.abilityFlags & MA_HIT_STEAL_FLEE
		&& !(attacker.carriedItem)
		&& (packItems.nextItem)
		&& attacker.currentHP > 0
  	&& !attacker.status[STATUS_CONFUSED] // No stealing from the player if you bump him while confused.
		&& attackHit(attacker, defender))
	{
			itemCandidates = numberOfMatchingPackItems(ALL_ITEMS, 0, (ITEM_EQUIPPED), false);
			if (itemCandidates) {
				randItemIndex = rand_range(1, itemCandidates);
				for (theItem = packItems.nextItem; theItem != NULL; theItem = theItem.nextItem) {
					if (!(theItem.flags & (ITEM_EQUIPPED))) {
						if (randItemIndex == 1) {
							break;
						} else {
							randItemIndex--;
						}
					}
				}
				if (theItem) {
          if (theItem.category & WEAPON) { // Monkeys will steal half of a stack of weapons, and one of any other stack.
              if (theItem.quantity > 3) {
                  stolenQuantity = (theItem.quantity + 1) / 2;
              } else {
                  stolenQuantity = theItem.quantity;
              }
          } else {
              stolenQuantity = 1;
          }
					if (stolenQuantity < theItem.quantity) { // Peel off stolen item(s).
						itemFromTopOfStack = generateItem(ALL_ITEMS, -1);
						copyItem(itemFromTopOfStack, theItem); // Clone the item.
						theItem.quantity -= stolenQuantity;
						itemFromTopOfStack.quantity = stolenQuantity;
						theItem = itemFromTopOfStack; // Redirect pointer.
					} else {
						removeItemFromChain(theItem, packItems);
					}
					theItem.flags &= ~ITEM_PLAYER_AVOIDS; // Explore will seek the item out if it ends up on the floor again.
					attacker.carriedItem = theItem;
					attacker.creatureMode = MODE_PERM_FLEEING;
					attacker.creatureState = MONSTER_FLEEING;
					monsterName(buf2, attacker, true);
					itemName(theItem, buf3, false, true, NULL);
					sprintf(buf, "%s stole %s!", buf2, buf3);
					message(buf, badMessageColor, false);
				}
			}
		}
	}
	if ((attacker.info.abilityFlags & MA_POISONS)
        && damage > 0
        && !(defender.info.flags & (MONST_INANIMATE | MONST_INVULNERABLE)))
	{
        addPoison(defender, damage, 1);
	}
	if ((attacker.info.abilityFlags & MA_CAUSES_WEAKNESS)
        && damage > 0
        && !(defender.info.flags & (MONST_INANIMATE | MONST_INVULNERABLE)))
	{
		weaken(defender, 300);
	}

	if (attacker.info.abilityFlags & MA_ATTACKS_STAGGER) {
			processStaggerHit(attacker, defender);
	}

}

// function runicWeaponChance( /* item */ theItem, customEnchantLevel, enchantLevel) {
// 	const effectChances = [
// 		0.16,	// W_SPEED
// 		0.06,	// W_QUIETUS
// 		0.07,	// W_PARALYSIS
// 		0.15,	// W_MULTIPLICITY
// 		0.14,	// W_SLOWING
// 		0.11,	// W_CONFUSION
//   	0.15, // W_FORCE
// 		0,		// W_SLAYING
// 		0,		// W_MERCY
// 		0];		// W_PLENTY
// 	let rootChance, modifier;		// float
// 	let runicType = theItem.enchant2;
// 	let chance, adjustedBaseDamage;
//
// 	if (runicType === W_SLAYING) {
// 		return 0;
// 	}
// 	if (runicType >= NUMBER_GOOD_WEAPON_ENCHANT_KINDS) { // bad runic
// 		return 15;
// 	}
// 	if (!customEnchantLevel) {
// 		enchantLevel = netEnchant(theItem);
// 	}
//
// 	rootChance = effectChances[runicType] || 0;
//
// 	// Innately high-damage weapon types are less likely to trigger runic effects.
// 	adjustedBaseDamage = Math.floor((theItem.damage.lowerBound + theItem.damage.upperBound) / 2);
//
//   if (theItem.flags & ITEM_ATTACKS_HIT_SLOWLY) {
// 		adjustedBaseDamage = Math.floor(adjustedBaseDamage / 2); // Normalize as though they attacked once per turn instead of every other turn.
// 	}
// //    if (theItem.flags & ITEM_ATTACKS_QUICKLY) {
// //		adjustedBaseDamage *= 2; // Normalize as though they attacked once per turn instead of twice per turn.
// //	} // Testing disabling this for balance reasons...
//
//   modifier = 1.0 - min(0.99, (adjustedBaseDamage) / 18.0);
// 	rootChance *= modifier;
//
// 	chance = 100 - Math.floor(100 * pow(1.0 - rootChance, enchantLevel) + FLOAT_FUDGE); // good runic
//
// 	// Slow weapons get an adjusted chance of 1 - (1-p)^2 to reflect two bites at the apple instead of one.
// 	if (theItem.flags & ITEM_ATTACKS_HIT_SLOWLY) {
// 		chance = 100 - (100 - chance) * (100 - chance) / 100;
// 	}
//     // Fast weapons get an adjusted chance of 1 - sqrt(1-p) to reflect one bite at the apple instead of two.
// 	if (theItem.flags & ITEM_ATTACKS_QUICKLY) {
// 		chance = 100 * (1.0 - sqrt(1 - ((chance)/100.0)));
// 	}
//
// 	// The lowest percent change that a weapon will ever have is its enchantment level (if greater than 0).
// 	// That is so that even really heavy weapons will improve at least 1% per enchantment.
// 	chance = clamp(chance, max(1, Math.floor(enchantLevel)), 100);
//
// 	return chance;
// }



async function forceWeaponHit( /* creature */ defender, /* item */ theItem) {
	let oldLoc = [-1, -1], newLoc = [-1, -1], forceDamage;
	const buf = STRING(), buf2 = STRING(), monstName = STRING(); // char[DCOLS];
  let otherMonster = NULL;	// creature *
  let knowFirstMonsterDied = false, autoID = false;
  let theBolt;		// bolt

  monsterName(monstName, defender, true);

  oldLoc[0] = defender.xLoc;
  oldLoc[1] = defender.yLoc;
  newLoc[0] = defender.xLoc + clamp(defender.xLoc - player.xLoc, -1, 1);
  newLoc[1] = defender.yLoc + clamp(defender.yLoc - player.yLoc, -1, 1);
  if (canDirectlySeeMonster(defender)
      && !cellHasTerrainFlag(newLoc[0], newLoc[1], T_OBSTRUCTS_PASSABILITY | T_OBSTRUCTS_VISION)
      && !(pmap[newLoc[0]][newLoc[1]].flags & (HAS_MONSTER | HAS_PLAYER)))
	{
      sprintf(buf, "you launch %s backward with the force of your blow", monstName);
      // buf[DCOLS] = '\0';
      combatMessage(buf, messageColorFromVictim(defender));
      autoID = true;
  }
  theBolt = boltCatalog[BOLT_BLINKING];
  theBolt.magnitude = max(1, fp_netEnchant(theItem) >> FP_BASE);
  await zap(oldLoc, newLoc, theBolt, false);
  if (!(defender.bookkeepingFlags & MB_IS_DYING)
      && distanceBetween(oldLoc[0], oldLoc[1], defender.xLoc, defender.yLoc) > 0
      && distanceBetween(oldLoc[0], oldLoc[1], defender.xLoc, defender.yLoc) << FP_BASE < fp_weaponForceDistance(fp_netEnchant(theItem)))
	{
      if (pmap[defender.xLoc + newLoc[0] - oldLoc[0]][defender.yLoc + newLoc[1] - oldLoc[1]].flags & (HAS_MONSTER | HAS_PLAYER)) {
          otherMonster = monsterAtLoc(defender.xLoc + newLoc[0] - oldLoc[0], defender.yLoc + newLoc[1] - oldLoc[1]);
          monsterName(buf2, otherMonster, true);
      } else {
          otherMonster = NULL;
          strcpy(buf2, tileCatalog[pmap[defender.xLoc + newLoc[0] - oldLoc[0]][defender.yLoc + newLoc[1] - oldLoc[1]].layers[highestPriorityLayer(defender.xLoc + newLoc[0] - oldLoc[0], defender.yLoc + newLoc[1] - oldLoc[1], true)]].description);
      }

      forceDamage = distanceBetween(oldLoc[0], oldLoc[1], defender.xLoc, defender.yLoc);

      if (!(defender.info.flags & (MONST_IMMUNE_TO_WEAPONS | MONST_INVULNERABLE))
          && await inflictDamage(NULL, defender, forceDamage, white, false))
			{
          if (canDirectlySeeMonster(defender)) {
              knowFirstMonsterDied = true;
              sprintf(buf, "%s %s on impact with %s",
                      monstName,
                      (defender.info.flags & MONST_INANIMATE) ? "is destroyed" : "dies",
                      buf2);
              // buf[DCOLS] = '\0';
              combatMessage(buf, messageColorFromVictim(defender));
              autoID = true;
          }
      } else {
          if (canDirectlySeeMonster(defender)) {
              sprintf(buf, "%s slams against %s",
                      monstName,
                      buf2);
              // buf[DCOLS] = '\0';
              combatMessage(buf, messageColorFromVictim(defender));
              autoID = true;
          }
      }
      await moralAttack(player, defender);

      if (otherMonster
          && !(defender.info.flags & (MONST_IMMUNE_TO_WEAPONS | MONST_INVULNERABLE)))
			{
          if (await inflictDamage(NULL, otherMonster, forceDamage, white, false)) {
              if (canDirectlySeeMonster(otherMonster)) {
                  sprintf(buf, "%s %s%s when %s slams into $HIMHER",
                          buf2,
                          (knowFirstMonsterDied ? "also " : ""),
                          (defender.info.flags & MONST_INANIMATE) ? "is destroyed" : "dies",
                          monstName);
                  resolvePronounEscapes(buf, otherMonster);
                  // buf[DCOLS] = '\0';
                  combatMessage(buf, messageColorFromVictim(otherMonster));
                  autoID = true;
              }
          }
          if (otherMonster.creatureState != MONSTER_ALLY) {
              // Allies won't defect if you throw another monster at them, even though it hurts.
              await moralAttack(player, otherMonster);
          }
      }
  }
  return autoID;
}


async function magicWeaponHit(/* creature */ defender, /* item */ theItem, backstabbed) {
	const buf = STRING(), monstName = STRING(), theItemName = STRING(); // char[DCOLS];

	const effectColors = [white, 		black, 		yellow, 			pink, 				green, 			confusionGasColor, NULL, 		NULL, 		darkRed, rainbow];
	   								//	W_SPEED, W_QUIETUS, W_PARALYSIS, W_MULTIPLICITY, W_SLOWING, W_CONFUSION, 			W_FORCE, W_SLAYING, W_MERCY, W_PLENTY
	let chance, i;
	let enchant;	// float
	let enchantType = theItem.enchant2;		// enum weaponEnchants
	let newMonst;		// creature *
  let autoID = false;

	// If the defender is already dead, proceed only if the runic is speed or multiplicity.
	// (Everything else acts on the victim, which would literally be overkill.)
	if ((defender.bookkeepingFlags & MB_IS_DYING)
		&& theItem.enchant2 != W_SPEED
		&& theItem.enchant2 != W_MULTIPLICITY)
	{
		return;
	}

	enchant = fp_netEnchant(theItem);

	if (theItem.enchant2 == W_SLAYING) {
		chance = (monsterIsInClass(defender, theItem.vorpalEnemy) ? 100 : 0);
	} else if (defender.info.flags & (MONST_INANIMATE | MONST_INVULNERABLE)) {
      chance = 0;
  } else {
		chance = runicWeaponChance(theItem, false, 0);
		if (backstabbed && chance < 100) {
			chance = min(chance * 2, (chance + 100) / 2);
		}
  }

	if (chance > 0 && rand_percent(chance)) {
		if (!(defender.bookkeepingFlags & MB_SUBMERGED)) {
      switch (enchantType) {
		    case W_SPEED:
		        createFlare(player.xLoc, player.yLoc, SCROLL_ENCHANTMENT_LIGHT);
		        break;
		    case W_QUIETUS:
		        createFlare(defender.xLoc, defender.yLoc, QUIETUS_FLARE_LIGHT);
		        break;
		    case W_SLAYING:
		        createFlare(defender.xLoc, defender.yLoc, SLAYING_FLARE_LIGHT);
		        break;
		    default:
		        flashMonster(defender, effectColors[enchantType], 100);
		        break;
      }
			autoID = true;
		}
		rogue.disturbed = true;
		monsterName(monstName, defender, true);
		itemName(theItem, theItemName, false, false, NULL);

		switch (enchantType) {
			case W_SPEED:
				if (player.ticksUntilTurn != -1) {
					sprintf(buf, "your %s trembles and time freezes for a moment", theItemName);
					// buf[DCOLS] = '\0';
					combatMessage(buf, 0);
					player.ticksUntilTurn = -1; // free turn!
          autoID = true;
				}
				break;
			case W_SLAYING:
			case W_QUIETUS:
				await inflictLethalDamage(player, defender);
				sprintf(buf, "%s suddenly %s",
                        monstName,
                        (defender.info.flags & MONST_INANIMATE) ? "shatters" : "dies");
				// buf[DCOLS] = '\0';
				combatMessage(buf, messageColorFromVictim(defender));
        autoID = true;
				break;
			case W_PARALYSIS:
				defender.status[STATUS_PARALYZED] = max(defender.status[STATUS_PARALYZED], fp_weaponParalysisDuration(enchant));
				defender.maxStatus[STATUS_PARALYZED] = defender.status[STATUS_PARALYZED];
				if (canDirectlySeeMonster(defender)) {
					sprintf(buf, "%s is frozen in place", monstName);
					buf[DCOLS] = '\0';
					combatMessage(buf, messageColorFromVictim(defender));
                    autoID = true;
				}
				break;
			case W_MULTIPLICITY:
				sprintf(buf, "Your %s emits a flash of light, and %sspectral duplicate%s appear%s!",
						theItemName,
						(fp_weaponImageCount(enchant) == 1 ? "a " : ""),
						(fp_weaponImageCount(enchant) == 1 ? "" : "s"),
						(fp_weaponImageCount(enchant) == 1 ? "s" : ""));
				buf[DCOLS] = '\0';

				for (i = 0; i < (fp_weaponImageCount(enchant)); i++) {
					newMonst = generateMonster(MK_SPECTRAL_IMAGE, true, false);
          const loc = getQualifyingPathLocNear(defender.xLoc, defender.yLoc, true,
                                   T_DIVIDES_LEVEL & avoidedFlagsForMonster((newMonst.info)), HAS_PLAYER,
                                   avoidedFlagsForMonster((newMonst.info)), (HAS_PLAYER | HAS_MONSTER | HAS_STAIRS), false);
					if (!loc) ERROR('Expected location');
					newMonst.xLoc = loc[0];
					newMonst.yLoc = loc[1];
					newMonst.bookkeepingFlags |= (MB_FOLLOWER | MB_BOUND_TO_LEADER | MB_DOES_NOT_TRACK_LEADER | MB_TELEPATHICALLY_REVEALED);
					newMonst.bookkeepingFlags &= ~MB_JUST_SUMMONED;
					newMonst.leader = player;
					newMonst.creatureState = MONSTER_ALLY;
					// if (theItem.flags & ITEM_ATTACKS_HIT_SLOWLY) {
					// 	newMonst.info.attackSpeed *= 2;
					// }
					if (theItem.flags & ITEM_ATTACKS_STAGGER) {
						newMonst.info.attackSpeed *= 2;
						newMonst.info.abilityFlags |= MA_ATTACKS_STAGGER;
					}
					if (theItem.flags & ITEM_ATTACKS_QUICKLY) {
						newMonst.info.attackSpeed = Math.floor(newMonst.info.attackSpeed / 2);
					}
          if (theItem.flags & ITEM_ATTACKS_PENETRATE) {
              newMonst.info.abilityFlags |= MA_ATTACKS_PENETRATE;
          }
          if (theItem.flags & ITEM_ATTACKS_ALL_ADJACENT) {
              newMonst.info.abilityFlags |= MA_ATTACKS_ALL_ADJACENT;
          }
          if (theItem.flags & ITEM_ATTACKS_EXTEND) {
              newMonst.info.abilityFlags |= MA_ATTACKS_EXTEND;
          }
					newMonst.ticksUntilTurn = 100;
					newMonst.info.accuracy = player.info.accuracy + Math.floor(5 * fp_netEnchant(theItem) >> FP_BASE);
					newMonst.info.damage = player.info.damage;
					newMonst.status[STATUS_LIFESPAN_REMAINING] = newMonst.maxStatus[STATUS_LIFESPAN_REMAINING] = fp_weaponImageDuration(enchant);
					if (strLenWithoutEscapes(theItemName) <= 8) {
						sprintf(newMonst.info.monsterName, "spectral %s", theItemName);
					} else {
						switch (rogue.weapon.kind) {
							case BROADSWORD:
								strcpy(newMonst.info.monsterName, "spectral sword");
								break;
							case HAMMER:
								strcpy(newMonst.info.monsterName, "spectral hammer");
								break;
							case PIKE:
								strcpy(newMonst.info.monsterName, "spectral pike");
								break;
							case WAR_AXE:
								strcpy(newMonst.info.monsterName, "spectral axe");
								break;
							default:
								strcpy(newMonst.info.monsterName, "spectral weapon");
								break;
						}
					}
					pmap[newMonst.xLoc][newMonst.yLoc].flags |= HAS_MONSTER;
					fadeInMonster(newMonst);
				}
        updateVision(true);

				message(buf, false);
        autoID = true;
				break;
			case W_SLOWING:
				slow(defender, fp_weaponSlowDuration(enchant));
				if (canDirectlySeeMonster(defender)) {
					sprintf(buf, "%s slows down", monstName);
					buf[DCOLS] = '\0';
					combatMessage(buf, messageColorFromVictim(defender));
          autoID = true;
				}
				break;
			case W_CONFUSION:
				defender.status[STATUS_CONFUSED] = max(defender.status[STATUS_CONFUSED], fp_weaponConfusionDuration(enchant));
				defender.maxStatus[STATUS_CONFUSED] = defender.status[STATUS_CONFUSED];
				if (canDirectlySeeMonster(defender)) {
					sprintf(buf, "%s looks very confused", monstName);
					buf[DCOLS] = '\0';
					combatMessage(buf, messageColorFromVictim(defender));
          autoID = true;
				}
				break;
			case W_FORCE:
        autoID = await forceWeaponHit(defender, theItem);
				break;
			case W_MERCY:
				heal(defender, 50, false);
        if (canSeeMonster(defender)) {
            autoID = true;
        }
				break;
			case W_PLENTY:
				newMonst = await cloneMonster(defender, true, true);
				if (newMonst) {
					flashMonster(newMonst, effectColors[enchantType], 100);
          if (canSeeMonster(newMonst)) {
              autoID = true;
          }
				}
				break;
			default:
				break;
		}
	}
  if (autoID) {
      autoIdentify(theItem);
  }
}

function attackVerb(returnString /* char[DCOLS] */, /* creature */ attacker, hitPercentile) {
	let verbCount, increment;

	if (attacker !== player && (player.status[STATUS_HALLUCINATING] || !canSeeMonster(attacker))) {
		strcpy(returnString, "hits");
		return;
	}

  if (attacker === player && !rogue.weapon) {
		strcpy(returnString, "punch");
		return;
  }

	for (verbCount = 0; verbCount < 4 && strlen(monsterText[attacker.info.monsterID].attack[verbCount + 1]); verbCount++);

	increment = Math.floor(100 / (verbCount + 1));
	hitPercentile = max(0, min(hitPercentile, Math.floor(increment * (verbCount + 1) - 1)));
	strcpy(returnString, monsterText[attacker.info.monsterID].attack[ Math.floor(hitPercentile / increment) ]);
  resolvePronounEscapes(returnString, attacker);
}

async function applyArmorRunicEffect( returnString, /* creature */ attacker, damage, melee) {
	let returnDamage = damage;
	let armorName = STRING(), attackerName = STRING(), monstName = STRING(), buf = STRING(); // char[DCOLS * 3];
	let runicKnown;
	let runicDiscovered;
	let newDamage, dir, newX, newY, count, i;
	let enchant;
	let monst, hitList = [];	// creature *, creature* [8]

	returnString.clear();

	if (!(rogue.armor && rogue.armor.flags & ITEM_RUNIC)) {
		return; // just in case
	}

	enchant = fp_netEnchant(rogue.armor);

	runicKnown = rogue.armor.flags & ITEM_RUNIC_IDENTIFIED;
	runicDiscovered = false;

	armorName = itemName(rogue.armor, false, false, NULL);

	monsterName(attackerName, attacker, true);

	switch (rogue.armor.enchant2) {
		case A_MULTIPLICITY:
			if (melee && !(attacker.info.flags & (MONST_INANIMATE | MONST_INVULNERABLE)) && rand_percent(33)) {
				for (i = 0; i < fp_armorImageCount(enchant); i++) {
					monst = await cloneMonster(attacker, false, true);
					monst.bookkeepingFlags |= (MB_FOLLOWER | MB_BOUND_TO_LEADER | MB_DOES_NOT_TRACK_LEADER | MB_TELEPATHICALLY_REVEALED);
					monst.info.flags |= MONST_DIES_IF_NEGATED;
					monst.bookkeepingFlags &= ~(MB_JUST_SUMMONED | MB_SEIZED | MB_SEIZING);
					monst.info.abilityFlags &= ~(MA_CAST_SUMMON | MA_DF_ON_DEATH); // No summoning by spectral images. Gotta draw the line!
                                                                                    // Also no exploding or infecting by spectral clones.
					monst.leader = player;
					monst.creatureState = MONSTER_ALLY;
          monst.status[STATUS_DISCORDANT] = 0; // Otherwise things can get out of control...
					monst.ticksUntilTurn = 100;
					monst.info.monsterID = MK_SPECTRAL_IMAGE;
          if (monst.carriedMonster) {
              killCreature(monst.carriedMonster, true); // Otherwise you can get infinite phoenixes from a discordant phoenix.
              monst.carriedMonster = NULL;
          }

					// Give it the glowy red light and color.
					monst.info.intrinsicLightType = SPECTRAL_IMAGE_LIGHT;
					monst.info.foreColor = spectralImageColor;

					// Temporary guest!
					monst.status[STATUS_LIFESPAN_REMAINING] = monst.maxStatus[STATUS_LIFESPAN_REMAINING] = 3;
					monst.currentHP = monst.info.maxHP = 1;
					monst.info.defense = 0;

					if (strLenWithoutEscapes(attacker.info.monsterName) <= 6) {
						sprintf(monst.info.monsterName, "spectral %s", attacker.info.monsterName);
					} else {
						strcpy(monst.info.monsterName, "spectral clone");
					}
					fadeInMonster(monst);
				}
        updateVision(true);

				runicDiscovered = true;
				sprintf(returnString, "Your %s flashes, and spectral images of %s appear!", armorName, attackerName);
			}
			break;
		case A_MUTUALITY:
			if (returnDamage > 0) {
				count = 0;
				for (i=0; i<8; i++) {
					hitList[i] = NULL;
					dir = i % 8;
					newX = player.xLoc + nbDirs[dir][0];
					newY = player.yLoc + nbDirs[dir][1];
					if (coordinatesAreInMap(newX, newY) && (pmap[newX][newY].flags & HAS_MONSTER)) {
						monst = monsterAtLoc(newX, newY);
						if (monst
							&& monst != attacker
							&& monstersAreEnemies(player, monst)
							&& !(monst.info.flags & (MONST_IMMUNE_TO_WEAPONS | MONST_INVULNERABLE))
							&& !(monst.bookkeepingFlags & MB_IS_DYING))
						{
							hitList[i] = monst;
							count++;
						}
					}
				}
				if (count) {
					for (i=0; i<8; i++) {
						if (hitList[i] && !(hitList[i].bookkeepingFlags & MB_IS_DYING)) {
							monsterName(monstName, hitList[i], true);
							if (await inflictDamage(player, hitList[i], (returnDamage + count) / (count + 1), blue, true)
								&& canSeeMonster(hitList[i]))
							{
								sprintf(buf, "%s %s", monstName, ((hitList[i].info.flags & MONST_INANIMATE) ? "is destroyed" : "dies"));
								combatMessage(buf, messageColorFromVictim(hitList[i]));
							}
						}
					}
					runicDiscovered = true;
					if (!runicKnown) {
						sprintf(returnString, "Your %s pulses, and the damage is shared with %s!",
								armorName,
								(count == 1 ? monstName : "the other adjacent enemies"));
					}
					returnDamage = (returnDamage + count) / (count + 1);
				}
			}
			break;
		case A_ABSORPTION:
			returnDamage -= rand_range(0, fp_armorAbsorptionMax(enchant));
			if (returnDamage <= 0) {
				returnDamage = 0;
				runicDiscovered = true;
				if (!runicKnown) {
					sprintf(returnString, "your %s pulses and absorbs the blow!", armorName);
				}
			}
			break;
		case A_REPRISAL:
			if (melee && !(attacker.info.flags & (MONST_INANIMATE | MONST_INVULNERABLE))) {
				newDamage = max(1, fp_armorReprisalPercent(enchant) * (returnDamage) / 100); // 5% reprisal per armor level
				if (await inflictDamage(player, attacker, newDamage, blue, true)) {
					if (canSeeMonster(attacker)) {
						sprintf(returnString, "your %s pulses and %s drops dead!", armorName, attackerName);
						runicDiscovered = true;
					}
				} else if (!runicKnown) {
					if (canSeeMonster(attacker)) {
						sprintf(returnString, "your %s pulses and %s shudders in pain!", armorName, attackerName);
						runicDiscovered = true;
					}
				}
			}
			break;
		case A_IMMUNITY:
			if (monsterIsInClass(attacker, rogue.armor.vorpalEnemy)) {
				returnDamage = 0;
				runicDiscovered = true;
			}
			break;
		case A_BURDEN:
			if (rand_percent(10)) {
				rogue.armor.strengthRequired++;
				sprintf(returnString, "your %s suddenly feels heavier!", armorName);
				equipItem(rogue.armor, true);
				runicDiscovered = true;
			}
			break;
		case A_VULNERABILITY:
			returnDamage *= 2;
			if (!runicKnown) {
				sprintf(returnString, "your %s pulses and you are wracked with pain!", armorName);
				runicDiscovered = true;
			}
			break;
    case A_IMMOLATION:
      if (rand_percent(10)) {
        sprintf(buf, "flames suddenly explode out of your %s!", armorName);
				if (!runicKnown) {
					await messageWithAck(returnString);
				}
				else {
					message(returnString);
				}
        returnString.clear();
        await spawnDungeonFeature(player.xLoc, player.yLoc, dungeonFeatureCatalog[DF_ARMOR_IMMOLATION], true, false);
        runicDiscovered = true;
      }
		default:
			break;
	}

	if (runicDiscovered && !runicKnown) {
		autoIdentify(rogue.armor);
	}

	return returnDamage;
}

function decrementWeaponAutoIDTimer() {
    const buf = STRING(), buf2 = STRING(); // char[COLS*3];

    if (rogue.weapon
        && !(rogue.weapon.flags & ITEM_IDENTIFIED)
        && !--rogue.weapon.charges)
		{
        rogue.weapon.flags |= ITEM_IDENTIFIED;
        updateIdentifiableItems();
        message("you are now familiar enough with your weapon to identify it.", itemMessageColor);
        itemName(rogue.weapon, buf2, true, true, NULL);
        sprintf(buf, "%s %s.", (rogue.weapon.quantity > 1 ? "they are" : "it is"), buf2);
        message(buf, itemMessageColor);
    }
}

function processStaggerHit(/* creature */ attacker, /* creature */ defender) {
    if ((defender.info.flags & (MONST_INVULNERABLE | MONST_IMMOBILE | MONST_INANIMATE))
        || (defender.bookkeepingFlags & MB_CAPTIVE)
        || cellHasTerrainFlag(defender.xLoc, defender.yLoc, T_OBSTRUCTS_PASSABILITY))
		{
        return;
    }
    let newX = clamp(defender.xLoc - attacker.xLoc, -1, 1) + defender.xLoc;
    let newY = clamp(defender.yLoc - attacker.yLoc, -1, 1) + defender.yLoc;
    if (coordinatesAreInMap(newX, newY)
        && !cellHasTerrainFlag(newX, newY, T_OBSTRUCTS_PASSABILITY)
        && !(pmap[newX][newY].flags & (HAS_MONSTER | HAS_PLAYER)))
		{
        setMonsterLocation(defender, newX, newY);
    }
}


// // returns whether the attack hit
async function attack( /* creature */ attacker, /* creature */ defender, lungeAttack)
{
	let damage, specialDamage, poisonDamage;
	const buf = STRING(), buf2 = STRING(), attackerName = STRING(), defenderName = STRING(), verb = STRING(), explicationClause = STRING(), armorRunicString = STRING();
	let sneakAttack, defenderWasAsleep, defenderWasParalyzed, degradesAttackerWeapon, sightUnseen;

  if (attacker === player && canSeeMonster(defender)) {
      rogue.featRecord[FEAT_PURE_MAGE] = false;
  }

	if (attacker.info.abilityFlags & MA_KAMIKAZE) {
		await killCreature(attacker, false);
		return true;
	}

	poisonDamage = 0;

	degradesAttackerWeapon = (defender.info.flags & MONST_DEFEND_DEGRADE_WEAPON ? true : false);

	sightUnseen = !canSeeMonster(attacker) && !canSeeMonster(defender);

	if (defender.status[STATUS_LEVITATING] && (attacker.info.flags & MONST_RESTRICTED_TO_LIQUID)) {
		return false; // aquatic or other liquid-bound monsters cannot attack flying opponents
	}

	if ((attacker === player || defender === player) && !rogue.blockCombatText) {
		rogue.disturbed = true;
	}

	defender.status[STATUS_ENTRANCED] = 0;
	if (defender.status[STATUS_MAGICAL_FEAR]) {
		defender.status[STATUS_MAGICAL_FEAR] = 1;
	}

  if (attacker === player && defender.creatureState != MONSTER_TRACKING_SCENT)
	{
      rogue.featRecord[FEAT_PALADIN] = false;
  }

	if (attacker !== player && defender === player && attacker.creatureState == MONSTER_WANDERING) {
		attacker.creatureState = MONSTER_TRACKING_SCENT;
	}

  if (defender.info.flags & MONST_INANIMATE) {
      sneakAttack = false;
      defenderWasAsleep = false;
      defenderWasParalyzed = false;
  } else {
      sneakAttack = (defender !== player && attacker === player && (defender.creatureState == MONSTER_WANDERING) ? true : false);
      defenderWasAsleep = (defender !== player && (defender.creatureState == MONSTER_SLEEPING) ? true : false);
      defenderWasParalyzed = defender.status[STATUS_PARALYZED] > 0;
  }

	monsterName(attackerName, attacker, true);
	monsterName(defenderName, defender, true);

	if ((attacker.info.abilityFlags & MA_SEIZES)
        && (!(attacker.bookkeepingFlags & MB_SEIZING) || !(defender.bookkeepingFlags & MB_SEIZED)))
	{
		attacker.bookkeepingFlags |= MB_SEIZING;
		defender.bookkeepingFlags |= MB_SEIZED;
		if (canSeeMonster(attacker) || canSeeMonster(defender)) {
			sprintf(buf, "%s seizes %s!", attackerName, (defender === player ? "your legs" : defenderName));
			message(buf, white);
		}
		return false;
	}

	if (sneakAttack || defenderWasAsleep || defenderWasParalyzed || lungeAttack || attackHit(attacker, defender)) {
		// If the attack hit:
		damage = (defender.info.flags & (MONST_IMMUNE_TO_WEAPONS | MONST_INVULNERABLE)
                  ? 0 : randClump(attacker.info.damage) * fp_monsterDamageAdjustmentAmount(attacker) >> FP_BASE);

		if (sneakAttack || defenderWasAsleep || defenderWasParalyzed) {
        if (defender !== player) {
            // The non-player defender doesn't hit back this turn because it's still flat-footed.
            defender.ticksUntilTurn += max(defender.movementSpeed, defender.attackSpeed);
            if (defender.creatureState != MONSTER_ALLY) {
                defender.creatureState = MONSTER_TRACKING_SCENT; // Wake up!
            }
        }
    }
    if (sneakAttack || defenderWasAsleep || defenderWasParalyzed || lungeAttack) {
        if (attacker === player
            && rogue.weapon
            && (rogue.weapon.flags & ITEM_SNEAK_ATTACK_BONUS))
				{
            damage *= 5; // 5x damage for dagger sneak attacks.
        } else {
            damage *= 3; // Treble damage for general sneak attacks.
        }
		}

		if (defender === player && rogue.armor && (rogue.armor.flags & ITEM_RUNIC)) {
			damage = await applyArmorRunicEffect(armorRunicString, attacker, damage, true);
		}

    if (attacker === player
        && rogue.reaping
        && !(defender.info.flags & (MONST_INANIMATE | MONST_INVULNERABLE)))
		{
        specialDamage = min(damage, defender.currentHP) * rogue.reaping; // Maximum reaped damage can't exceed the victim's remaining health.
        if (rogue.reaping > 0) {
            specialDamage = rand_range(0, specialDamage);
        } else {
            specialDamage = rand_range(specialDamage, 0);
        }
        if (specialDamage) {
            rechargeItemsIncrementally(specialDamage);
        }
    }

		if (damage == 0) {
			sprintf(explicationClause, " but %s no damage", (attacker === player ? "do" : "does"));
			if (attacker === player) {
				rogue.disturbed = true;
			}
    } else if (lungeAttack) {
			strcpy(explicationClause, " with a vicious lunge attack");
		} else if (defenderWasParalyzed) {
			sprintf(explicationClause, " while $HESHE %s paralyzed", (defender === player ? "are" : "is"));
		} else if (defenderWasAsleep) {
			strcpy(explicationClause, " in $HISHER sleep");
		} else if (sneakAttack) {
			strcpy(explicationClause, ", catching $HIMHER unaware");
		} else if (defender.status[STATUS_STUCK] || defender.bookkeepingFlags & MB_CAPTIVE) {
			sprintf(explicationClause, " while %s dangle%s helplessly",
					(canSeeMonster(defender) ? "$HESHE" : "it"),
					(defender === player ? "" : "s"));
		}
		resolvePronounEscapes(explicationClause, defender);

		if ((attacker.info.abilityFlags & MA_POISONS) && damage > 0) {
			poisonDamage = damage;
			damage = 1;
		}

		if (await inflictDamage(attacker, defender, damage, red, false)) { // if the attack killed the defender
			if (defenderWasAsleep || sneakAttack || defenderWasParalyzed || lungeAttack) {
				sprintf(buf, "%s %s %s%s", attackerName,
						((defender.info.flags & MONST_INANIMATE) ? "destroyed" : "dispatched"),
						defenderName,
						explicationClause);
			} else {
				sprintf(buf, "%s %s %s%s",
						attackerName,
						((defender.info.flags & MONST_INANIMATE) ? "destroyed" : "defeated"),
						defenderName,
						explicationClause);
			}
			if (sightUnseen) {
				if (defender.info.flags & MONST_INANIMATE) {
					combatMessage("you hear something get destroyed in combat");
				} else {
					combatMessage("you hear something die in combat");
				}
			} else {
				combatMessage(buf, (damage > 0 ? messageColorFromVictim(defender) : white));
			}
			if (player === defender) {
				await gameOver(attacker.info.monsterName, false);
				return true;
			}
			else if (player === attacker && defender.info.monsterID == MK_DRAGON) {
          rogue.featRecord[FEAT_DRAGONSLAYER] = true;
      }
		} else { // if the defender survived
			if (!rogue.blockCombatText && (canSeeMonster(attacker) || canSeeMonster(defender))) {
				attackVerb(verb, attacker, max(damage - attacker.info.damage.lowerBound * fp_monsterDamageAdjustmentAmount(attacker) >> FP_BASE, 0) * 100
						   / max(1, (attacker.info.damage.upperBound - attacker.info.damage.lowerBound) * fp_monsterDamageAdjustmentAmount(attacker) >> FP_BASE));
				sprintf(buf, "%s %s %s%s", attackerName, verb, defenderName, explicationClause);
				if (sightUnseen) {
					if (!rogue.heardCombatThisTurn) {
						rogue.heardCombatThisTurn = true;
						combatMessage("you hear combat in the distance");
					}
				} else {
					combatMessage(buf, messageColorFromVictim(defender));
				}
			}
			if (attacker === player && rogue.weapon && (rogue.weapon.flags & ITEM_ATTACKS_STAGGER)) {
				processStaggerHit(attacker, defender);
		 	}
			if (attacker.info.abilityFlags & SPECIAL_HIT) {
				specialHit(attacker, defender, (attacker.info.abilityFlags & MA_POISONS) ? poisonDamage : damage);
			}
			if (strlen(armorRunicString)) {
				message(armorRunicString);
				if (rogue.armor && (rogue.armor.flags & ITEM_RUNIC) && rogue.armor.enchant2 == A_BURDEN) {
					strengthCheck(rogue.armor);
				}
			}
		}

		await moralAttack(attacker, defender);

		if (attacker === player && rogue.weapon && (rogue.weapon.flags & ITEM_RUNIC)) {
			await magicWeaponHit(defender, rogue.weapon, sneakAttack || defenderWasAsleep || defenderWasParalyzed);
		}

    if (attacker === player
        && (defender.bookkeepingFlags & MB_IS_DYING)
        && (defender.bookkeepingFlags & MB_HAS_SOUL))
		{
        decrementWeaponAutoIDTimer();
    }

		if (degradesAttackerWeapon
			&& attacker === player
			&& rogue.weapon
			&& !(rogue.weapon.flags & ITEM_PROTECTED)
				// Can't damage a Weapon of Acid Mound Slaying by attacking an acid mound... just ain't right!
			&& !((rogue.weapon.flags & ITEM_RUNIC) && rogue.weapon.enchant2 == W_SLAYING && monsterIsInClass(defender, rogue.weapon.vorpalEnemy))
			&& rogue.weapon.enchant1 >= -10)
		{
			rogue.weapon.enchant1--;
      if (rogue.weapon.quiverNumber) {
          rogue.weapon.quiverNumber = rand_range(1, 60000);
      }
			equipItem(rogue.weapon, true);
			itemName(rogue.weapon, buf2, false, false, NULL);
			sprintf(buf, "your %s weakens!", buf2);
			message(buf, itemMessageColor);
      checkForDisenchantment(rogue.weapon);
		}
		return true;
	} else { // if the attack missed
		if (!rogue.blockCombatText) {
			if (sightUnseen) {
				if (!rogue.heardCombatThisTurn) {
					rogue.heardCombatThisTurn = true;
					combatMessage("you hear combat in the distance");
				}
			} else {
				sprintf(buf, "%s missed %s", attackerName, defenderName);
				combatMessage(buf);
			}
		}
		return false;
	}
}



// Gets the length of a string without the color escape sequences, since those aren't displayed.
function strLenWithoutEscapes(text) {
	text = STRING(text);
	return text.textLength;
}


function combatMessage(theMsg, /* color */ theColor) {
	const newMsg = STRING(); // char[COLS * 2];

	if (!theColor) {
		theColor = white;
	}

	// newMsg[0] = '\0';
	encodeMessageColor(newMsg, 0, theColor);
	strcat(newMsg, theMsg);

	if (strLenWithoutEscapes(combatText) + strLenWithoutEscapes(newMsg) + 3 > DCOLS) {
		// the "3" is for the semicolon, space and period that get added to conjoined combat texts.
		displayCombatText();
	}

	if ( strlen(combatText) ) {
    strcat(combatText, "; ");
    strcat(combatText, newMsg);
	} else {
		strcpy(combatText, newMsg);
	}
}

function displayCombatText() {
	const buf = STRING();
	if ( strlen(combatText) ) {
		sprintf(buf, "%s.", combatText);
		combatText.clear();
		message(buf /* , rogue.cautiousMode */);	// NO ACK
		rogue.cautiousMode = false;
	}
}

function flashMonster( /* creature */ monst, /* color */ theColor, strength) {
    if (!theColor) {
        return;
    }
	if (!(monst.bookkeepingFlags & MB_WILL_FLASH) || monst.flashStrength < strength) {
		monst.bookkeepingFlags |= MB_WILL_FLASH;
		monst.flashStrength = strength;
		monst.flashColor.copy(theColor);
		rogue.creaturesWillFlashThisTurn = true;
	}
}


function canAbsorb( /* creature */ ally, ourBolts /* boolean[NUMBER_BOLT_KINDS] */, /* creature */ prey, grid) {
  let i;

	if (ally.creatureState == MONSTER_ALLY
        && ally.newPowerCount > 0
        && (ally.targetCorpseLoc[0] <= 0)
        && !((ally.info.flags | prey.info.flags) & (MONST_INANIMATE | MONST_IMMOBILE))
        && !monsterAvoids(ally, prey.xLoc, prey.yLoc)
        && grid[ally.xLoc][ally.yLoc] <= 10)
	{
        if (~(ally.info.abilityFlags) & prey.info.abilityFlags & LEARNABLE_ABILITIES) {
            return true;
        } else if (~(ally.info.flags) & prey.info.flags & LEARNABLE_BEHAVIORS) {
            return true;
        } else {
            for (i = 0; i < NUMBER_BOLT_KINDS; i++) {
                ourBolts[i] = false;
            }
            for (i = 0; ally.info.bolts[i] != BOLT_NONE; i++) {
                ourBolts[ally.info.bolts[i]] = true;
            }

            for (i=0; prey.info.bolts[i] != BOLT_NONE; i++) {
                if (!(boltCatalog[prey.info.bolts[i]].flags & BF_NOT_LEARNABLE)
                    && !ourBolts[prey.info.bolts[i]])
								{
                    return true;
                }
            }
        }
    }
    return false;
}

function anyoneWantABite(/* creature */ decedent) {
	let candidates, randIndex, i;
	let grid;
	let ally;	// creature *
  let success = false;
  let ourBolts = [false]; // boolean[NUMBER_BOLT_KINDS];

	candidates = 0;
	if ((!(decedent.info.abilityFlags & LEARNABLE_ABILITIES)
		 && !(decedent.info.flags & LEARNABLE_BEHAVIORS)
         && decedent.info.bolts[0] == BOLT_NONE)
		|| (cellHasTerrainFlag(decedent.xLoc, decedent.yLoc, T_PATHING_BLOCKER))
		|| (decedent.info.flags & (MONST_INANIMATE | MONST_IMMOBILE)))
	{
		return false;
	}

	grid = allocGrid();
	fillGrid(grid, 0);
	calculateDistances(grid, decedent.xLoc, decedent.yLoc, T_PATHING_BLOCKER, NULL, true, true);
	for (ally = monsters.nextCreature; ally != NULL; ally = ally.nextCreature) {
		if (canAbsorb(ally, ourBolts, decedent, grid)) {
			candidates++;
		}
	}
	if (candidates > 0) {
		randIndex = rand_range(1, candidates);
		for (ally = monsters.nextCreature; ally != NULL; ally = ally.nextCreature) {
			// CanAbsorb() populates ourBolts if it returns true and there are no learnable behaviors or flags:
			if (canAbsorb(ally, ourBolts, decedent, grid) && !--randIndex) {
				break;
			}
		}
		if (ally) {
			ally.targetCorpseLoc[0] = decedent.xLoc;
			ally.targetCorpseLoc[1] = decedent.yLoc;
			strcpy(ally.targetCorpseName, decedent.info.monsterName);
			ally.corpseAbsorptionCounter = 20; // 20 turns to get there and start eating before he loses interest

			// Choose a superpower.
      // First, select from among learnable ability or behavior flags, if one is available.
			candidates = 0;
			for (i=0; i<32; i++) {
				if (Fl(i) & ~(ally.info.abilityFlags) & decedent.info.abilityFlags & LEARNABLE_ABILITIES) {
					candidates++;
				}
			}
			for (i=0; i<32; i++) {
				if (Fl(i) & ~(ally.info.flags) & decedent.info.flags & LEARNABLE_BEHAVIORS) {
					candidates++;
				}
			}
			if (candidates > 0) {
				randIndex = rand_range(1, candidates);
				for (i=0; i<32; i++) {
					if ((Fl(i) & ~(ally.info.abilityFlags) & decedent.info.abilityFlags & LEARNABLE_ABILITIES)
						&& !--randIndex)
					{
						ally.absorptionFlags = Fl(i);
						ally.absorbBehavior = false;
						success = true;
            break;
					}
				}
				for (i=0; i<32 && !success; i++) {
					if ((Fl(i) & ~(ally.info.flags) & decedent.info.flags & LEARNABLE_BEHAVIORS)
						&& !--randIndex)
					{
						ally.absorptionFlags = Fl(i);
						ally.absorbBehavior = true;
						success = true;
            break;
					}
				}
			} else if (decedent.info.bolts[0] != BOLT_NONE) {
          // If there are no learnable ability or behavior flags, pick a learnable bolt.
          candidates = 0;
          for (i=0; decedent.info.bolts[i] != BOLT_NONE; i++) {
              if (!(boltCatalog[decedent.info.bolts[i]].flags & BF_NOT_LEARNABLE)
                  && !ourBolts[decedent.info.bolts[i]])
							{
                  candidates++;
              }
          }
          if (candidates > 0) {
              randIndex = rand_range(1, candidates);
              for (i=0; decedent.info.bolts[i] != BOLT_NONE; i++) {
                  if (!(boltCatalog[decedent.info.bolts[i]].flags & BF_NOT_LEARNABLE)
                      && !ourBolts[decedent.info.bolts[i]]
                      && !--randIndex)
									{
                      ally.absorptionBolt = decedent.info.bolts[i];
                      success = true;
                      break;
                  }
              }
          }
      }
		}
	}
	freeGrid(grid);
	return success;
}

const MIN_FLASH_STRENGTH	= 50;

async function inflictLethalDamage(/* creature */ attacker, /* creature */ defender) {
    return await inflictDamage(attacker, defender, defender.currentHP, NULL, true);
}

// returns true if this was a killing stroke; does NOT free the pointer, but DOES remove it from the monster chain
// flashColor indicates the color that the damage will cause the creature to flash
async function inflictDamage( /* creature */ attacker, /* creature */ defender,
                      damage, /* color */ flashColor, ignoresProtectionShield)
{
	let killed = false;
	let theBlood;	// dungeonFeature
  let transferenceAmount;

	if (damage == 0
        || (defender.info.flags & MONST_INVULNERABLE))
	{
		return false;
	}

	if (!ignoresProtectionShield
        && defender.status[STATUS_SHIELDED])
	{
		if (defender.status[STATUS_SHIELDED] > damage * 10) {
			defender.status[STATUS_SHIELDED] -= damage * 10;
			damage = 0;
		} else {
			damage -= (defender.status[STATUS_SHIELDED] + 9) / 10;
			defender.status[STATUS_SHIELDED] = defender.maxStatus[STATUS_SHIELDED] = 0;
		}
	}

	defender.bookkeepingFlags &= ~MB_ABSORBING; // Stop eating a corpse if you are getting hurt.

	// bleed all over the place, proportionately to damage inflicted:
	if (damage > 0 && defender.info.bloodType) {
		theBlood = dungeonFeatureCatalog[defender.info.bloodType];
		theBlood.startProbability = (theBlood.startProbability * (15 + min(damage, defender.currentHP) * 3 / 2) / 100);
		if (theBlood.layer == GAS) {
			theBlood.startProbability *= 100;
		}
		await spawnDungeonFeature(defender.xLoc, defender.yLoc, theBlood, true, false);
	}

	if (defender !== player && defender.creatureState == MONSTER_SLEEPING) {
		wakeUp(defender);
	}

	if (defender === player
        && rogue.easyMode
        && damage > 0)
	{
		damage = max(1, damage/5);
	}

    if (((attacker === player && rogue.transference) || (attacker && attacker !== player && (attacker.info.abilityFlags & MA_TRANSFERENCE)))
        && !(defender.info.flags & (MONST_INANIMATE | MONST_INVULNERABLE)))
		{
        transferenceAmount = min(damage, defender.currentHP); // Maximum transferred damage can't exceed the victim's remaining health.

        if (attacker === player) {
            transferenceAmount = transferenceAmount * rogue.transference / 20;
            if (transferenceAmount == 0) {
                transferenceAmount = ((rogue.transference > 0) ? 1 : -1);
            }
        } else if (attacker.creatureState == MONSTER_ALLY) {
            transferenceAmount = transferenceAmount * 4 / 10; // allies get 40% recovery rate
        } else {
            transferenceAmount = transferenceAmount * 9 / 10; // enemies get 90% recovery rate, deal with it
        }

        attacker.currentHP += transferenceAmount;

        if (attacker === player && player.currentHP <= 0) {
            await gameOver("Drained by a cursed ring", true);
            return false;
        }
    }

	if (defender.currentHP <= damage) { // killed
		await killCreature(defender, false);
		anyoneWantABite(defender);
		killed = true;
	} else { // survived
		if (damage < 0 && defender.currentHP - damage > defender.info.maxHP) {
			defender.currentHP = max(defender.currentHP, defender.info.maxHP);
		} else {
			defender.currentHP -= damage; // inflict the damage!
      if (defender === player && damage > 0) {
          rogue.featRecord[FEAT_INDOMITABLE] = false;
      }
		}

		if (defender !== player && defender.creatureState != MONSTER_ALLY
			&& defender.info.flags & MONST_FLEES_NEAR_DEATH
			&& defender.info.maxHP / 4 >= defender.currentHP)
		{
			defender.creatureState = MONSTER_FLEEING;
		}
		if (flashColor && damage > 0) {
			flashMonster(defender, flashColor, MIN_FLASH_STRENGTH + (100 - MIN_FLASH_STRENGTH) * damage / defender.info.maxHP);
		}
	}

	refreshSideBar(-1, -1, false);
	return killed;
}

function addPoison( /* creature */ monst, durationIncrement, concentrationIncrement) {
    if (durationIncrement > 0) {
        if (monst === player && !player.status[STATUS_POISONED]) {
            combatMessage("scalding poison fills your veins", badMessageColor);
        }
        if (!monst.status[STATUS_POISONED]) {
            monst.maxStatus[STATUS_POISONED] = 0;
        }
        monst.poisonAmount += concentrationIncrement;
        if (monst.poisonAmount == 0) {
            monst.poisonAmount = 1;
        }
        monst.status[STATUS_POISONED] += durationIncrement;
        monst.maxStatus[STATUS_POISONED] = monst.info.maxHP / monst.poisonAmount;

        if (canSeeMonster(monst)) {
            flashMonster(monst, poisonColor, 100);
        }
    }
}


// Removes the decedent from the screen and from the monster chain; inserts it into the graveyard chain; does NOT free the memory.
// Or, if the decedent is a player ally at the moment of death, insert it into the purgatory chain for possible future resurrection.
// Use "administrativeDeath" if the monster is being deleted for administrative purposes, as opposed to dying as a result of physical actions.
// AdministrativeDeath means the monster simply disappears, with no messages, dropped item, DFs or other effect.
async function killCreature( /* creature */ decedent, administrativeDeath) {
	let x, y;
	const monstName = STRING(), buf = STRING(); // char[DCOLS];

	if (decedent.bookkeepingFlags & MB_IS_DYING) {
		// monster has already been killed; let's avoid overkill
		return;
	}

  if (decedent !== player) {
    decedent.bookkeepingFlags |= MB_IS_DYING;
  }

	if (rogue.lastTarget === decedent) {
		rogue.lastTarget = NULL;
	}
  if (rogue.yendorWarden === decedent) {
      rogue.yendorWarden = NULL;
  }

	if (decedent.carriedItem) {
		if (administrativeDeath) {
			deleteItem(decedent.carriedItem);
			decedent.carriedItem = NULL;
		} else {
			await makeMonsterDropItem(decedent);
		}
	}

	if (!administrativeDeath && (decedent.info.abilityFlags & MA_DF_ON_DEATH)) {
		await spawnDungeonFeature(decedent.xLoc, decedent.yLoc, dungeonFeatureCatalog[decedent.info.DFType], true, false);

		if (monsterText[decedent.info.monsterID].DFMessage[0] && canSeeMonster(decedent)) {
			monsterName(monstName, decedent, true);
			sprintf(buf, "%s %s", monstName, monsterText[decedent.info.monsterID].DFMessage);
			resolvePronounEscapes(buf, decedent);
			message(buf, false);
		}
	}

	if (decedent === player) { // the player died
		// game over handled elsewhere
	} else {
		if (!administrativeDeath
			&& decedent.creatureState == MONSTER_ALLY
			&& !canSeeMonster(decedent)
			&& !(decedent.info.flags & MONST_INANIMATE)
			&& !(decedent.bookkeepingFlags & MB_BOUND_TO_LEADER)
			&& !decedent.carriedMonster)
		{
			message("you feel a sense of loss.", badMessageColor, false);
		}
		x = decedent.xLoc;
		y = decedent.yLoc;
		if (decedent.bookkeepingFlags & MB_IS_DORMANT) {
			pmap[x][y].flags &= ~HAS_DORMANT_MONSTER;
		} else {
			pmap[x][y].flags &= ~HAS_MONSTER;
		}
		removeMonsterFromChain(decedent, dormantMonsters);
		removeMonsterFromChain(decedent, monsters);

    if (decedent.leader === player
        && !(decedent.info.flags & MONST_INANIMATE)
        && (decedent.bookkeepingFlags & MB_HAS_SOUL)
        && !administrativeDeath)
		{
        decedent.nextCreature = purgatory.nextCreature;
        purgatory.nextCreature = decedent;
    } else {
        decedent.nextCreature = graveyard.nextCreature;
        graveyard.nextCreature = decedent;
    }

		if (!administrativeDeath && !(decedent.bookkeepingFlags & MB_IS_DORMANT)) {
			// Was there another monster inside?
			if (decedent.carriedMonster) {
				// Insert it into the chain.
				decedent.carriedMonster.nextCreature = monsters.nextCreature;
				monsters.nextCreature = decedent.carriedMonster;
				decedent.carriedMonster.xLoc = x;
				decedent.carriedMonster.yLoc = y;
				decedent.carriedMonster.ticksUntilTurn = 200;
				pmap[x][y].flags |= HAS_MONSTER;
				fadeInMonster(decedent.carriedMonster);

				if (canSeeMonster(decedent.carriedMonster)) {
					monsterName(monstName, decedent.carriedMonster, true);
					sprintf(buf, "%s appears", monstName);
					combatMessage(buf, NULL);
				}

				await applyInstantTileEffectsToCreature(decedent.carriedMonster);
				decedent.carriedMonster = NULL;
			}
			refreshDungeonCell(x, y);
		}
	}
	decedent.currentHP = 0;
	demoteMonsterFromLeadership(decedent);
  if (decedent.leader) {
      checkForContinuedLeadership(decedent.leader);
  }
}


function buildHitList(/* creature **/ hitList,
		/* creature */ attacker, /* creature */ defender, /* penetrate, */ sweep)
{
  let i, x, y, newX, newY, newestX, newestY;
  let dir, newDir;	// enum directions

  x = attacker.xLoc;
  y = attacker.yLoc;
  newX = defender.xLoc;
  newY = defender.yLoc;

  dir = NO_DIRECTION;
  for (i = 0; i < DIRECTION_COUNT; i++) {
      if (nbDirs[i][0] == newX - x
          && nbDirs[i][1] == newY - y)
			{
          dir = i;
          break;
      }
  }
	//
  // if (penetrate && dir != NO_DIRECTION) {
  //     hitList[0] = defender;
  //     newestX = newX + nbDirs[dir][0];
  //     newestY = newY + nbDirs[dir][1];
  //     if (coordinatesAreInMap(newestX, newestY) && (pmap[newestX][newestY].flags & HAS_MONSTER)) {
  //         defender = monsterAtLoc(newestX, newestY);
  //         if (defender
  //             && monsterWillAttackTarget(attacker, defender)
  //             && (!cellHasTerrainFlag(defender.xLoc, defender.yLoc, T_OBSTRUCTS_PASSABILITY) || (defender.info.flags & MONST_ATTACKABLE_THRU_WALLS)))
	// 				{
  //             // NOTE: Attack the outermost monster first, so that spears of force can potentially send both of them flying.
  //             hitList[1] = hitList[0];
  //             hitList[0] = defender;
  //         }
  //     }
  // } else
	if (sweep) {
      if (dir == NO_DIRECTION) {
          dir = UP; // Just pick one.
      }
      for (i=0; i<8; i++) {
          newDir = (dir + i) % DIRECTION_COUNT;
          newestX = x + cDirs[newDir][0];
          newestY = y + cDirs[newDir][1];
          if (coordinatesAreInMap(newestX, newestY) && (pmap[newestX][newestY].flags & (HAS_MONSTER | HAS_PLAYER))) {
              defender = monsterAtLoc(newestX, newestY);
              if (defender
                  && monsterWillAttackTarget(attacker, defender)
                  && (!cellHasTerrainFlag(defender.xLoc, defender.yLoc, T_OBSTRUCTS_PASSABILITY) || (defender.info.flags & MONST_ATTACKABLE_THRU_WALLS)))
							{
                  hitList[i] = defender;
              }
          }
      }
  } else {
      hitList[0] = defender;
  }
}

// // Basically runs a simplified deterministic melee combat simulation against a hypothetical
// // monster with infinite HP (the dummy) and returns the amount of damage the tested
// // monster deals before succumbing. Takes into account various environmental factors
// // (e.g. current status effects).
// function monsterPower( /*creature */ theMonst) {
// 	const damageDealt = [0, 0]; // short[2] = {0, 0};
// 	const statuses = []; // short[NUMBER_OF_STATUS_EFFECTS];
// 	const ticksTillTurn = [0, 0];
// 	let speed;
// 	let i, k;
// 	const damagePerHit = [0, 0];
// 	const hitChance = [0, 0];
//
// 	// [0] is the tested monster and [1] is the dummy.
// 	// damageDealt measures how much damage each contestant has inflicted.
//
// 	for (i=0; i<NUMBER_OF_STATUS_EFFECTS; i++) {
// 		statuses[i] = theMonst.status[i];
// 	}
//
// 	damagePerHit[0] = (theMonst.info.damage.lowerBound + theMonst.info.damage.upperBound) * monsterDamageAdjustmentAmount(theMonst) / 2;
// 	damagePerHit[1] = 10;
// 	hitChance[0] = monsterAccuracyAdjusted(theMonst) * pow(DEFENSE_FACTOR, 100); // Assumes the dummy has 100 armor.
// 	hitChance[1] = monsterAccuracyAdjusted(theMonst) * pow(DEFENSE_FACTOR, theMonst.info.defense);
//
// 	while (damageDealt[1] < theMonst.currentHP) { // Loop until the dummy kills the monster in the simulation.
// 		for (k=0; k<=1; k++) { // k is whose turn it is
//
// 			if (k==0) { // monster
// 				speed = theMonst.info.attackSpeed;
// 				if (statuses[STATUS_POISONED]) {
// 					damageDealt[1] += theMonst.poisonAmount; // dummy gets credit for poison
// 				}
// 				if (statuses[STATUS_HASTED]) {
// 					speed /= 2;
// 				}
// 				if (statuses[STATUS_SLOWED]) {
// 					speed *= 2;
// 				}
// 				for (i=0; i<NUMBER_OF_STATUS_EFFECTS; i++) {
// 					if (statuses[i] > 0) {
// 						statuses[i]--;
// 					}
// 				}
// 			}
//
// 			while (ticksTillTurn[k] <= 0) {
// 				if (k == 1 || !statuses[STATUS_PARALYZED]) {
// 					damageDealt[k] += damagePerHit[k] * hitChance[k];
// 				}
// 				ticksTillTurn[k] += k ? 100 : speed;
// 			}
// 			ticksTillTurn[k] -= 100;
// 		}
// 	}
//
// 	return Math.floor(damageDealt[0]);
// }
/*
 *  Items.c
 *  Brogue
 *
 *  Created by Brian Walker on 1/17/09.
 *  Copyright 2012. All rights reserved.
 *
 *  This file is part of Brogue.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */


// #include "Rogue.h"
// #include "IncludeGlobals.h"
// #include <math.h>

function initializeItem() {
	let i;
	let theItem;	// item *

	theItem = item(); // (item *) malloc(sizeof(item));

	theItem.category = 0;
	theItem.kind = 0;
	theItem.flags = 0;
	theItem.displayChar = '&';
	theItem.foreColor = itemColor;
	theItem.inventoryColor = white;
	theItem.inventoryLetter = '';
	theItem.armor = 0;
	theItem.strengthRequired = 0;
	theItem.enchant1 = 0;
	theItem.enchant2 = 0;
  theItem.timesEnchanted = 0;
	theItem.vorpalEnemy = 0;
	theItem.charges = 0;
	theItem.quantity = 1;
	theItem.quiverNumber = 0;
	theItem.originDepth = 0;
	theItem.inscription.clear();
	theItem.nextItem = NULL;

	for (i=0; i < KEY_ID_MAXIMUM; i++) {
		theItem.keyLoc[i].x = 0;
		theItem.keyLoc[i].y = 0;
		theItem.keyLoc[i].machine = 0;
		theItem.keyLoc[i].disposableHere = false;
	}

  return theItem;
}

// Allocates space, generates a specified item (or random category/kind if -1)
// and returns a pointer to that item. The item is not given a location here
// and is not inserted into the item chain!
function generateItem(theCategory, theKind) {
	const theItem = initializeItem();
	makeItemInto(theItem, theCategory, theKind);
	return theItem;
}


function copyItem(dest, src) {
			dest.category = src.category
			dest.kind = src.kind;
			dest.flags = src.flags;
			dest.damage = randomRange(src.damage);		/* randomRange */
			dest.armor = src.armor;
			dest.charges = src.charges;
			dest.enchant1 = src.enchant1;
			dest.enchant2 = src.enchant2;
		  dest.timesEnchanted = src.timesEnchanted;
			dest.vorpalEnemy = src.vorpalEnemy;	/* ENUM monsterTypes */
			dest.strengthRequired = src.strengthRequired;
			dest.quiverNumber = src.quiverNumber;
			dest.displayChar = src.displayChar;
			dest.foreColor = src.foreColor;
			dest.inventoryColor = src.inventoryColor;
			dest.quantity = src.quantity;
			dest.inventoryLetter = src.inventoryLetter;
			dest.inscription.copy(src.inscription); // [DCOLS];
			dest.xLoc = src.xLoc;
			dest.yLoc = src.yLoc;
			dest.originDepth = src.originDepth;
			dest.nextItem = src.nextItem;		/* struct item */

			for(let i = 0; i < KEY_ID_MAXIMUM; ++i) {
				const dk = dest.keyLoc[i];
				const sk = src.keyLoc[i];

				dk.x = sk.x;
				dk.y = sk.y;
				dk.machine = sk.machine;
				dk.disposableHere = dk.disposableHere;
			}

}

function pickItemCategory(theCategory) {
	let i, sum, randIndex;
	const probabilities           =	[50,	  42,		  52,		  3,		  3,		10,		  8,		  2,		3,      2,        0,		  0,		0];
	const correspondingCategories =	[GOLD,	SCROLL,	POTION,	STAFF,	WAND,	WEAPON,	ARMOR,	FOOD,	RING,   CHARM,    AMULET,	GEM,	KEY];

	sum = 0;

	for (i=0; i<correspondingCategories.length; i++) {
		if (theCategory <= 0 || theCategory & correspondingCategories[i]) {
			sum += probabilities[i];
		}
	}

	if (sum == 0) {
		return theCategory; // e.g. when you pass in AMULET or GEM, since they have no frequency
	}

	randIndex = rand_range(1, sum);

	for (i=0; ; i++) {
		if (theCategory <= 0 || theCategory & correspondingCategories[i]) {
			if (randIndex <= probabilities[i]) {
				return correspondingCategories[i];
			}
			randIndex -= probabilities[i];
		}
	}
}

// Sets an item to the given type and category (or chooses randomly if -1) with all other stats
function makeItemInto(/* item */ theItem, itemCategory, itemKind) {
	let theEntry = NULL;  // itemTable *

	if (itemCategory <= 0) {
		itemCategory = ALL_ITEMS;
	}

	itemCategory = pickItemCategory(itemCategory);

	theItem.category = itemCategory;

	switch (itemCategory)
  {
		case FOOD:
			if (itemKind < 0) {
				itemKind = chooseKind(foodTable, NUMBER_FOOD_KINDS);
			}
			theEntry = foodTable[itemKind];
			theItem.displayChar = FOOD_CHAR;
			theItem.flags |= ITEM_IDENTIFIED;
			break;

		case WEAPON:
			if (itemKind < 0) {
				itemKind = chooseKind(weaponTable, NUMBER_WEAPON_KINDS);
			}
			theEntry = weaponTable[itemKind];
			theItem.damage = weaponTable[itemKind].range;
			theItem.strengthRequired = weaponTable[itemKind].strengthRequired;
			theItem.displayChar = WEAPON_CHAR;

			switch (itemKind) {
        case DAGGER:
            theItem.flags |= ITEM_SNEAK_ATTACK_BONUS;
            break;
				case MACE:
				case HAMMER:
					// theItem.flags |= ITEM_ATTACKS_HIT_SLOWLY;
					theItem.flags |= ITEM_ATTACKS_STAGGER;
					break;
        case WHIP:
            theItem.flags |= ITEM_ATTACKS_EXTEND;
            break;
				case RAPIER:
					theItem.flags |= (ITEM_ATTACKS_QUICKLY | ITEM_LUNGE_ATTACKS);
					break;
        case FLAIL:
            theItem.flags |= ITEM_PASS_ATTACKS;
            break;
				case SPEAR:
				case PIKE:
					theItem.flags |= ITEM_ATTACKS_PENETRATE;
					break;
				case AXE:
				case WAR_AXE:
					theItem.flags |= ITEM_ATTACKS_ALL_ADJACENT;
					break;
				default:
					break;
			}

			if (rand_percent(40)) {
				theItem.enchant1 += rand_range(1, 3);
				if (rand_percent(50)) {
					// cursed
					theItem.enchant1 *= -1;
					theItem.flags |= ITEM_CURSED;
					if (rand_percent(33)) { // give it a bad runic
						theItem.enchant2 = rand_range(NUMBER_GOOD_WEAPON_ENCHANT_KINDS, NUMBER_WEAPON_RUNIC_KINDS - 1);
						theItem.flags |= ITEM_RUNIC;
					}
				} else if (rand_range(3, 10)
                           * ((theItem.flags & ITEM_ATTACKS_STAGGER) ? 2 : 1)
                           / ((theItem.flags & ITEM_ATTACKS_QUICKLY) ? 2 : 1)
													 * ((theItem.flags & ITEM_ATTACKS_EXTEND)  ? 2 : 1)
                           > theItem.damage.lowerBound)
				{
					// give it a good runic; lower damage items are more likely to be runic
					theItem.enchant2 = rand_range(0, NUMBER_GOOD_WEAPON_ENCHANT_KINDS - 1);
					theItem.flags |= ITEM_RUNIC;
					if (theItem.enchant2 == W_SLAYING) {
						theItem.vorpalEnemy = chooseVorpalEnemy();
					}
				} else {
            while (rand_percent(10)) {
                theItem.enchant1++;
            }
        }
			}
			if (itemKind == DART || itemKind == INCENDIARY_DART || itemKind == JAVELIN) {
				if (itemKind == INCENDIARY_DART) {
					theItem.quantity = rand_range(3, 6);
				} else {
					theItem.quantity = rand_range(5, 18);
				}
				theItem.quiverNumber = rand_range(1, 60000);
				theItem.flags &= ~(ITEM_CURSED | ITEM_RUNIC); // throwing weapons can't be cursed or runic
				theItem.enchant1 = 0; // throwing weapons can't be magical
			}
			theItem.charges = WEAPON_KILLS_TO_AUTO_ID; // kill 20 enemies to auto-identify
			break;

		case ARMOR:
			if (itemKind < 0) {
				itemKind = chooseKind(armorTable, NUMBER_ARMOR_KINDS);
			}
			theEntry = armorTable[itemKind];
			theItem.armor = randClump(armorTable[itemKind].range);
			theItem.strengthRequired = armorTable[itemKind].strengthRequired;
			theItem.displayChar = ARMOR_CHAR;
			theItem.charges = ARMOR_DELAY_TO_AUTO_ID; // this many turns until it reveals its enchants and whether runic
			if (rand_percent(40)) {
				theItem.enchant1 += rand_range(1, 3);
				if (rand_percent(50)) {
					// cursed
					theItem.enchant1 *= -1;
					theItem.flags |= ITEM_CURSED;
					if (rand_percent(33)) { // give it a bad runic
						theItem.enchant2 = rand_range(NUMBER_GOOD_ARMOR_ENCHANT_KINDS, NUMBER_ARMOR_ENCHANT_KINDS - 1);
						theItem.flags |= ITEM_RUNIC;
					}
				} else if (rand_range(0, 95) > theItem.armor) { // give it a good runic
					theItem.enchant2 = rand_range(0, NUMBER_GOOD_ARMOR_ENCHANT_KINDS - 1);
					theItem.flags |= ITEM_RUNIC;
					if (theItem.enchant2 == A_IMMUNITY) {
						theItem.vorpalEnemy = chooseVorpalEnemy();
					}
				} else {
            while (rand_percent(10)) {
                theItem.enchant1++;
            }
        }
			}
			break;
		case SCROLL:
			if (itemKind < 0) {
				itemKind = chooseKind(scrollTable, NUMBER_SCROLL_KINDS);
			}
			theEntry = scrollTable[itemKind];
			theItem.displayChar = SCROLL_CHAR;
			theItem.flags |= ITEM_FLAMMABLE;
			break;
		case POTION:
			if (itemKind < 0) {
				itemKind = chooseKind(potionTable, NUMBER_POTION_KINDS);
			}
			theEntry = potionTable[itemKind];
			theItem.displayChar = POTION_CHAR;
			break;
		case STAFF:
			if (itemKind < 0) {
				itemKind = chooseKind(staffTable, NUMBER_STAFF_KINDS);
			}
			theEntry = staffTable[itemKind];
			theItem.displayChar = STAFF_CHAR;
			theItem.charges = 2;
			if (rand_percent(50)) {
				theItem.charges++;
				if (rand_percent(15)) {
					theItem.charges++;
          while (rand_percent(10)) {
              theItem.charges++;
          }
				}
			}
			theItem.enchant1 = theItem.charges;
			theItem.enchant2 = (itemKind == STAFF_BLINKING || itemKind == STAFF_OBSTRUCTION ? 1000 : 500); // start with no recharging mojo
			break;
		case WAND:
			if (itemKind < 0) {
				itemKind = chooseKind(wandTable, NUMBER_WAND_KINDS);
			}
			theEntry = wandTable[itemKind];
			theItem.displayChar = WAND_CHAR;
			theItem.charges = randClump(wandTable[itemKind].range);
			break;
		case RING:
			if (itemKind < 0) {
				itemKind = chooseKind(ringTable, NUMBER_RING_KINDS);
			}
			theEntry = ringTable[itemKind];
			theItem.displayChar = RING_CHAR;
			theItem.enchant1 = randClump(ringTable[itemKind].range);
			theItem.charges = RING_DELAY_TO_AUTO_ID; // how many turns of being worn until it auto-identifies
			if (rand_percent(16)) {
				// cursed
				theItem.enchant1 *= -1;
				theItem.flags |= ITEM_CURSED;
			} else {
          while (rand_percent(10)) {
              theItem.enchant1++;
          }
      }
			break;
    case CHARM:
			if (itemKind < 0) {
				itemKind = chooseKind(charmTable, NUMBER_CHARM_KINDS);
			}
      theItem.displayChar = CHARM_CHAR;
      theItem.charges = 0; // Charms are initially ready for use.
      theItem.enchant1 = randClump(charmTable[itemKind].range);
      while (rand_percent(7)) {
          theItem.enchant1++;
      }
			theItem.flags |= ITEM_IDENTIFIED;
      break;
		case GOLD:
			theEntry = NULL;
			theItem.displayChar = GOLD_CHAR;
			theItem.quantity = rand_range(50 + rogue.depthLevel * 10, 100 + rogue.depthLevel * 15);
			break;
		case AMULET:
			theEntry = NULL;
			theItem.displayChar = AMULET_CHAR;
			itemKind = 0;
			theItem.flags |= ITEM_IDENTIFIED;
			break;
		case GEM:
			theEntry = NULL;
			theItem.displayChar = GEM_CHAR;
			itemKind = 0;
			theItem.flags |= ITEM_IDENTIFIED;
			break;
		case KEY:
			theEntry = NULL;
			theItem.displayChar = KEY_CHAR;
			theItem.flags |= ITEM_IDENTIFIED;
			break;
		default:
			theEntry = NULL;
			ERROR("something has gone terribly wrong!", true);
			break;
	}
	if (theItem
		&& !(theItem.flags & ITEM_IDENTIFIED)
		&& (!(theItem.category & (POTION | SCROLL) ) || (theEntry && !theEntry.identified)))
	{
		theItem.flags |= ITEM_CAN_BE_IDENTIFIED;
	}
	theItem.kind = itemKind;

	return theItem;
}


function chooseKind(/* itemTable */ theTable, numKinds) {
	let i, totalFrequencies = 0, randomFrequency;
	for (i=0; i<numKinds; i++) {
		totalFrequencies += max(0, theTable[i].frequency);
	}
	randomFrequency = rand_range(1, totalFrequencies);
	for (i=0; randomFrequency > theTable[i].frequency; i++) {
		randomFrequency -= max(0, theTable[i].frequency);
	}
	return i;
}

// Places an item at (x,y) if provided or else a random location if they're 0. Inserts item into the floor list.
async function placeItem(/* item */ theItem, x, y, administrative) {
	let loc;
	let layer;		// enum dungeonLayers
	const theItemName = STRING(), buf = STRING(); // char[DCOLS];

	if (x <= 0 || y <= 0) {
		loc = randomMatchingLocation(FLOOR, NOTHING, -1);
		x = loc[0];
		y = loc[1];
	}

	theItem.xLoc = x;
	theItem.yLoc = y;

	if (D_MESSAGE_ITEM_GENERATION) {
		itemName(theItem, theItemName, false);
		sprintf(buf, "Generated Item: %s @ %i,%i", theItemName, theItem.xLoc, theItem.yLoc);
		printf(buf);
		message(buf, false);
	}

	removeItemFromChain(theItem, floorItems); // just in case; double-placing an item will result in game-crashing loops in the item list
  addItemToChain(theItem, floorItems);
	pmap[x][y].flags |= HAS_ITEM;
	if ((theItem.flags & ITEM_MAGIC_DETECTED) && itemMagicChar(theItem)) {
		pmap[x][y].flags |= ITEM_DETECTED;
	}
	if (D_ITEM_OMNISCIENCE) {
		pmap[x][y].flags |= ITEM_DETECTED;
		refreshDungeonCell(x, y);
	}
	if (cellHasTerrainFlag(x, y, T_IS_DF_TRAP)
    && !cellHasTerrainFlag(x, y, T_MOVES_ITEMS)
		&& !(pmap[x][y].flags & PRESSURE_PLATE_DEPRESSED))
	{
		pmap[x][y].flags |= PRESSURE_PLATE_DEPRESSED;
		if (!administrative && playerCanSee(x, y)) {
			if (cellHasTMFlag(x, y, TM_IS_SECRET)) {
				await discover(x, y);
				refreshDungeonCell(x, y);
			}
			itemName(theItem, theItemName, false, false, NULL);
			sprintf(buf, "a pressure plate clicks underneath the %s!", theItemName);
			await messageWithAck(buf);
		}
		for (layer = 0; layer < NUMBER_TERRAIN_LAYERS; layer++) {
			if (tileCatalog[pmap[x][y].layers[layer]].flags & T_IS_DF_TRAP) {
				await spawnDungeonFeature(x, y, dungeonFeatureCatalog[tileCatalog[pmap[x][y].layers[layer]].fireType], true, false);
				await promoteTile(x, y, layer, false);
			}
		}
	}
	return theItem;
}

function fillItemSpawnHeatMap(heatMap /* short[DCOLS][DROWS] */, heatLevel, x, y) {
	let dir;
	let newX, newY;

	if (pmap[x][y].layers[DUNGEON] == DOOR) {
		heatLevel += 10;
	} else if (pmap[x][y].layers[DUNGEON] == SECRET_DOOR) {
		heatLevel += 3000;
	}
	if (heatMap[x][y] > heatLevel) {
		heatMap[x][y] = heatLevel;
	}
	for (dir = 0; dir < 4; dir++) {
		newX = x + nbDirs[dir][0];
		newY = y + nbDirs[dir][1];
		if (coordinatesAreInMap(newX, newY)
			&& !cellHasTerrainFlag(newX, newY, T_IS_DEEP_WATER | T_LAVA_INSTA_DEATH | T_AUTO_DESCENT)
			&& isPassableOrSecretDoor(newX, newY)
			&& heatLevel < heatMap[newX][newY])
		{
			fillItemSpawnHeatMap(heatMap, heatLevel, newX, newY);
		}
	}
}

function coolHeatMapAt( heatMap /* short[DCOLS][DROWS] */, x, y, totalHeat) {
	let k, l;
	let currentHeat;

	currentHeat = heatMap[x][y];
	if (currentHeat == 0) {
		return totalHeat;
	}
	totalHeat -= heatMap[x][y];
	heatMap[x][y] = 0;

	// lower the heat near the chosen location
	for (k = -5; k <= 5; k++) {
		for (l = -5; l <= 5; l++) {
			if (coordinatesAreInMap(x+k, y+l) && heatMap[x+k][y+l] == currentHeat) {
				heatMap[x+k][y+l] = max(1, Math.floor(heatMap[x+k][y+l] / 10) );
				totalHeat -= (currentHeat - heatMap[x+k][y+l]);
			}
		}
	}

	return totalHeat;
}

// Returns false if no place could be found.
// That should happen only if the total heat is zero.
function getItemSpawnLoc(heatMap /* short[DCOLS][DROWS]*/, totalHeat) {
	let randIndex;
	let currentHeat;
	let i, j;

	if (totalHeat <= 0) {
		return false;
	}

	randIndex = rand_range(1, totalHeat);

	//printf("\nrandIndex: %i", randIndex);

	for (i=0; i<DCOLS; i++) {
		for (j=0; j<DROWS; j++) {
			currentHeat = heatMap[i][j];
			if (randIndex <= currentHeat) { // this is the spot!
				return [i, j];
			}
			randIndex -= currentHeat;
		}
	}
  brogueAssert(0); // should never get here!
	return false;
}

// function aggregateGoldLowerBound(d)	{ return Math.floor(pow((d), 3.05) + 320 * (d) + FLOAT_FUDGE); }
// function aggregateGoldUpperBound(d)	{ return Math.floor(pow((d), 3.05) + 420 * (d) + FLOAT_FUDGE); }

const POW_GOLD = [
		// b^3.05, with b from 0 to 25:
		0, 1, 8, 28, 68, 135, 236, 378, 568, 813, 1122, 1500, 1956, 2497, 3131,
		3864, 4705, 5660, 6738, 7946, 9292, 10783, 12427, 14232, 16204, 18353];

function aggregateGoldLowerBound(d)	{ return (POW_GOLD[d] + 320 * (d)); }
function aggregateGoldUpperBound(d)	{ return (POW_GOLD[d] + 420 * (d)); }

const POW_FOOD = [
		// b^1.35 << FP_BASE, with b from 1 to 50 (for future-proofing):
		65536, 167059, 288797, 425854, 575558, 736180, 906488, 1085553, 1272645,
		1467168, 1668630, 1876612, 2090756, 2310749, 2536314, 2767208, 3003211,
		3244126, 3489773, 3739989, 3994624, 4253540, 4516609, 4783712, 5054741,
		5329591, 5608167, 5890379, 6176141, 6465373, 6758000, 7053950, 7353155,
		7655551, 7961076, 8269672, 8581283, 8895856, 9213341, 9533687, 9856849,
		10182782, 10511443, 10842789, 11176783, 11513384, 11852556, 12194264,
		12538472, 12885148];



// Generates and places items for the level. Must pass the location of the up-stairway on the level.
async function populateItems(upstairsX, upstairsY) {
	if (!ITEMS_ENABLED) {
		return;
	}
	let theItem;	// item *
	const itemSpawnHeatMap = GRID(DCOLS, DROWS); // unsigned short[DCOLS][DROWS];
	let i, j, numberOfItems, numberOfGoldPiles, goldBonusProbability, x = 0, y = 0;
	let totalHeat;
	let theCategory, theKind, randomDepthOffset = 0;
	const buf = STRING(), buf2 = STRING();

// #ifdef AUDIT_RNG
// 	char RNGmessage[100];
// #endif

	if (rogue.depthLevel > AMULET_LEVEL) {
    if (rogue.depthLevel - AMULET_LEVEL - 1 >= 8) {
        numberOfItems = 1;
    } else {
        const lumenstoneDistribution = [3, 3, 3, 2, 2, 2, 2, 2];
        numberOfItems = lumenstoneDistribution[rogue.depthLevel - AMULET_LEVEL - 1];
    }
		numberOfGoldPiles = 0;
	} else {
    rogue.lifePotionFrequency += 34;
		rogue.strengthPotionFrequency += 17;
		rogue.enchantScrollFrequency += 30;
		numberOfItems = 3;
		while (rand_percent(60)) {
			numberOfItems++;
		}
		if (rogue.depthLevel <= 2) {
			numberOfItems += 2; // 4 extra items to kickstart your career as a rogue
		} else if (rogue.depthLevel <= 4) {
			numberOfItems++; // and 2 more here
		}

		numberOfGoldPiles = min(5, Math.floor(rogue.depthLevel / 4));
		for (goldBonusProbability = 60;
			 rand_percent(goldBonusProbability) && numberOfGoldPiles <= 10;
			 goldBonusProbability -= 15)
		{
			numberOfGoldPiles++;
		}
		// Adjust the amount of gold if we're past depth 5 and we were below or above
		// the production schedule as of the previous depth.
		if (rogue.depthLevel > 5) {
			if (rogue.goldGenerated < aggregateGoldLowerBound(rogue.depthLevel - 1)) {
				numberOfGoldPiles += 2;
			} else if (rogue.goldGenerated > aggregateGoldUpperBound(rogue.depthLevel - 1)) {
				numberOfGoldPiles -= 2;
			}
		}
	}

  // Create an item spawn heat map to bias item generation behind secret doors (and, to a lesser
  // extent, regular doors). This is in terms of the number of secret/regular doors that must be
  // passed to reach the area when pathing to it from the upward staircase.
	// This is why there are often several items in well hidden secret rooms. Otherwise,
	// those rooms are usually empty, which is demoralizing after you take the trouble to find them.
	for (i=0; i<DCOLS; i++) {
		for (j=0; j<DROWS; j++) {
			itemSpawnHeatMap[i][j] = 50000;
		}
	}
	fillItemSpawnHeatMap(itemSpawnHeatMap, 5, upstairsX, upstairsY);
	totalHeat = 0;

// #ifdef AUDIT_RNG
// 	sprintf(RNGmessage, "\n\nInitial heat map for level %i:\n", rogue.currentTurnNumber);
// 	RNGLog(RNGmessage);
// #endif

	for (j=0; j<DROWS; j++) {
		for (i=0; i<DCOLS; i++) {
			if (cellHasTerrainFlag(i, j, T_OBSTRUCTS_ITEMS | T_PATHING_BLOCKER)
				|| (pmap[i][j].flags & (IS_CHOKEPOINT | IN_LOOP | IS_IN_MACHINE))
				|| passableArcCount(i, j) > 1) // Not in walls, hallways, quest rooms, loops or chokepoints, please.
			{
				itemSpawnHeatMap[i][j] = 0;
			}
			else if (itemSpawnHeatMap[i][j] == 50000)
			{
				itemSpawnHeatMap[i][j] = 0;
				pmap[i][j].layers[DUNGEON] = WALL; // due to a bug that created occasional isolated one-cell islands;
                                           // not sure if it's still around, but this is a good-enough failsafe
			}
// #ifdef AUDIT_RNG
// 			sprintf(RNGmessage, "%u%s%s\t%s",
// 					itemSpawnHeatMap[i][j],
// 					((pmap[i][j].flags & IS_CHOKEPOINT) ? " (C)": ""), // chokepoint
// 					((pmap[i][j].flags & IN_LOOP) ? " (L)": ""), // loop
// 					(i == DCOLS-1 ? "\n" : ""));
// 			RNGLog(RNGmessage);
// #endif
			totalHeat += itemSpawnHeatMap[i][j];
		}
	}

	if (D_INSPECT_ITEM_GEN) {
		let map = allocGrid(); // short **
		for (i=0; i<DCOLS; i++) {
			for (j=0; j<DROWS; j++) {
				map[i][j] = itemSpawnHeatMap[i][j] * -1;
			}
		}
		dumpLevelToScreen();
		displayGrid(map);
		freeGrid(map);
		await temporaryMessage("Item spawn heat map:", true);
	}

  if (rogue.depthLevel > 2) {
      // Include a random factor in food and potion of life generation to make things slightly less predictable.
      randomDepthOffset = rand_range(-1, 1);
      randomDepthOffset += rand_range(-1, 1);
  }

	for (i=0; i<numberOfItems; i++) {
		theCategory = ALL_ITEMS & ~GOLD; // gold is placed separately, below, so it's not a punishment
		theKind = -1;

		scrollTable[SCROLL_ENCHANTING].frequency = rogue.enchantScrollFrequency;
		potionTable[POTION_STRENGTH].frequency = rogue.strengthPotionFrequency;
    potionTable[POTION_LIFE].frequency = rogue.lifePotionFrequency;

		// Adjust the desired item category if necessary.
		if ( (rogue.foodSpawned + Math.floor(foodTable[RATION].strengthRequired / 3)) * 4 << FP_BASE
			<= Math.floor((POW_FOOD[rogue.depthLevel - 1] + (randomDepthOffset << FP_BASE)) * foodTable[RATION].strengthRequired * 45/100))
		{
			// Guarantee a certain nutrition minimum of the approximate equivalent of one ration every four levels,
			// with more food on deeper levels since they generally take more turns to complete.
			theCategory = FOOD;
			if (rogue.depthLevel > AMULET_LEVEL) {
				numberOfItems++; // Food isn't at the expense of lumenstones.
			}
		} else if (rogue.depthLevel > AMULET_LEVEL) {
			theCategory = GEM;
		} else if (rogue.lifePotionsSpawned * 4 + 3 < rogue.depthLevel + randomDepthOffset) {
        theCategory = POTION;
        theKind = POTION_LIFE;
    }

		// Generate the item.
		theItem = generateItem(theCategory, theKind);
    theItem.originDepth = rogue.depthLevel;

		// printf("Generated item - ", theItem.category, theItem.kind);

		if (theItem.category & FOOD) {
			rogue.foodSpawned += foodTable[theItem.kind].strengthRequired;
      if (D_MESSAGE_ITEM_GENERATION) printf("\n(:)  Depth %i: generated food", rogue.depthLevel);
		}

		// Choose a placement location.
    if ((theItem.category & FOOD) || ((theItem.category & POTION) && theItem.kind == POTION_STRENGTH)) {
      do {
				const loc = randomMatchingLocation(FLOOR, NOTHING, -1); // Food and gain strength don't follow the heat map.
				x = loc[0];
				y = loc[1];
      } while (passableArcCount(x, y) > 1); // Not in a hallway.
    } else {
        const loc = getItemSpawnLoc(itemSpawnHeatMap, totalHeat);
				x = loc[0];
				y = loc[1];
    }

		brogueAssert(coordinatesAreInMap(x, y));
		// Cool off the item spawning heat map at the chosen location:
		totalHeat = coolHeatMapAt(itemSpawnHeatMap, x, y, totalHeat);

		// Regulate the frequency of enchantment scrolls and strength/life potions.
		if ((theItem.category & SCROLL) && theItem.kind == SCROLL_ENCHANTING) {
			rogue.enchantScrollFrequency -= 50;
			if (D_MESSAGE_ITEM_GENERATION) printf("\n(?)  Depth %i: generated an enchant scroll at %i frequency", rogue.depthLevel, rogue.enchantScrollFrequency);
		} else if (theItem.category & POTION && theItem.kind == POTION_LIFE) {
			if (D_MESSAGE_ITEM_GENERATION) printf("\n(!l) Depth %i: generated a life potion at %i frequency", rogue.depthLevel, rogue.lifePotionFrequency);
			rogue.lifePotionFrequency -= 150;
      rogue.lifePotionsSpawned++;
		} else if (theItem.category & POTION && theItem.kind == POTION_STRENGTH) {
			if (D_MESSAGE_ITEM_GENERATION) printf("\n(!s) Depth %i: generated a strength potion at %i frequency", rogue.depthLevel, rogue.strengthPotionFrequency);
			rogue.strengthPotionFrequency -= 50;
		}

		// Place the item.
		await placeItem(theItem, x, y, true); // Random valid location already obtained according to heat map.
    brogueAssert(!cellHasTerrainFlag(x, y, T_OBSTRUCTS_PASSABILITY));

		if (D_INSPECT_ITEM_GEN) {
			const map = allocGrid();
			let i2, j2;
			for (i2=0; i2<DCOLS; i2++) {
				for (j2=0; j2<DROWS; j2++) {
					map[i2][j2] = itemSpawnHeatMap[i2][j2] * -1;
				}
			}
			dumpLevelToScreen();
			displayGrid(map);
			freeGrid(map);
			plotCharWithColor(theItem.displayChar, mapToWindowX(x), mapToWindowY(y), black, purple);
			await temporaryMessage("Added an item.", true);
		}

	}

	if (D_INSPECT_ITEM_GEN) {
		dumpLevelToScreen();
	}

	// Now generate gold.
	for (i=0; i<numberOfGoldPiles; i++) {
		theItem = generateItem(GOLD, -1);
		const loc = getItemSpawnLoc(itemSpawnHeatMap, totalHeat);
		if (loc) {
			x = loc[0]; y = loc[1];
		}
		totalHeat = coolHeatMapAt(itemSpawnHeatMap, x, y, totalHeat);
		await placeItem(theItem, x, y);
		if (D_INSPECT_ITEM_GEN) {
			hiliteCell(x, y, yellow, 50, true);
		}
		rogue.goldGenerated += theItem.quantity;
	}

	if (D_INSPECT_ITEM_GEN) {
		await temporaryMessage("Added gold.", true);
	}

	scrollTable[SCROLL_ENCHANTING].frequency		= 0;	// No enchant scrolls or strength/life potions can spawn except via initial
	potionTable[POTION_STRENGTH].frequency      = 0;	// item population or blueprints that create them specifically.
  potionTable[POTION_LIFE].frequency          = 0;

	if (D_MESSAGE_ITEM_GENERATION) printf("\n---- Depth %i: %lu gold generated so far.", rogue.depthLevel, rogue.goldGenerated);


	if (D_INSPECT_LEVELGEN && !D_INSPECT_ITEM_GEN) {
		dumpLevelToScreen();
		theItem = floorItems.nextItem;
		while(theItem) {
			hiliteCell(theItem.xLoc, theItem.yLoc, teal, 50, true);
			theItem = theItem.nextItem;
		}
		await temporaryMessage('Items placed here.', true);
	}
}

// Name of this function is a bit misleading -- basically returns true iff the item will stack without consuming an extra slot
// i.e. if it's a throwing weapon with a sibling already in your pack. False for potions and scrolls.
function itemWillStackWithPack( /* item */ theItem) {
	let tempItem;		// item *
	if (theItem.category & GEM) {
			for (tempItem = packItems.nextItem;
					 tempItem != NULL && !((tempItem.category & GEM) && theItem.originDepth == tempItem.originDepth);
					 tempItem = tempItem.nextItem);
			return (tempItem ? true : false);
	} else if (!(theItem.quiverNumber)) {
		return false;
	} else {
		for (tempItem = packItems.nextItem;
			 tempItem != NULL && tempItem.quiverNumber != theItem.quiverNumber;
			 tempItem = tempItem.nextItem);
		return (tempItem ? true : false);
	}
}


async function removeItemFrom(x, y) {
	let layer;

	pmap[x][y].flags &= ~HAS_ITEM;

	if (cellHasTMFlag(x, y, TM_PROMOTES_ON_ITEM_PICKUP)) {
		for (layer = 0; layer < NUMBER_TERRAIN_LAYERS; layer++) {
			if (tileCatalog[pmap[x][y].layers[layer]].mechFlags & TM_PROMOTES_ON_ITEM_PICKUP) {
				await promoteTile(x, y, layer, false);
			}
		}
	}
}

// adds the item at (x,y) to the pack
async function pickUpItemAt(x, y) {
	let theItem;	// item *
  let monst;		// creature *
	const buf = STRING(), buf2 = STRING(); // char[COLS * 3];
  let guardianX, guardianY;

	rogue.disturbed = true;

	// find the item
	theItem = itemAtLoc(x, y);

	if (!theItem) {
		ERROR("Error: Expected item; item not found.", true);
		return;
	}

	if ((theItem.flags & ITEM_KIND_AUTO_ID)
    && tableForItemCategory(theItem.category, NULL)
		&& !(tableForItemCategory(theItem.category, NULL)[theItem.kind].identified))
	{
    identifyItemKind(theItem);
	}

  if ((theItem.category & WAND)
      && wandTable[theItem.kind].identified
      && wandTable[theItem.kind].range.lowerBound == wandTable[theItem.kind].range.upperBound)
	{
      theItem.flags |= ITEM_IDENTIFIED;
  }

	if (numberOfItemsInPack() < MAX_PACK_ITEMS || (theItem.category & GOLD) || itemWillStackWithPack(theItem)) {
		// remove from floor chain
		pmap[x][y].flags &= ~ITEM_DETECTED;

		if (!removeItemFromChain(theItem, floorItems)) {
        brogueAssert(false);
    }

		if (theItem.category & GOLD) {
			rogue.gold += theItem.quantity;
			sprintf(buf, "you found %i pieces of gold.", theItem.quantity);
			message(buf, itemMessageColor, false);
			deleteItem(theItem);
			await removeItemFrom(x, y); // triggers tiles with T_PROMOTES_ON_ITEM_PICKUP
			return;
		}

		if ((theItem.category & AMULET) && numberOfMatchingPackItems(AMULET, 0, 0, false)) {
			message("you already have the Amulet of Yendor.", false);
			deleteItem(theItem);
			return;
		}

		theItem = addItemToPack(theItem);

		itemName(theItem, buf2, true, true, NULL); // include suffix, article

		sprintf(buf, "you now have %s (%c).", buf2, theItem.inventoryLetter);
		message(buf, itemMessageColor, false);

		await removeItemFrom(x, y); // triggers tiles with T_PROMOTES_ON_ITEM_PICKUP

    if ((theItem.category & AMULET)
        && !(rogue.yendorWarden)) {
        // Identify the amulet guardian, or generate one if there isn't one.
        for (monst = monsters.nextCreature; monst != NULL; monst = monst.nextCreature) {
            if (monst.info.monsterID == MK_WARDEN_OF_YENDOR) {
                rogue.yendorWarden = monst;
                break;
            }
        }
        if (!rogue.yendorWarden) {
            const loc = getRandomMonsterSpawnLocation();
            monst = generateMonster(MK_WARDEN_OF_YENDOR, false, false);
            monst.xLoc = loc[0];
            monst.yLoc = loc[1];
            pmap[loc[0]][loc[1]].flags |= HAS_MONSTER;
            rogue.yendorWarden = monst;
        }
    }
	} else {
		theItem.flags |= ITEM_PLAYER_AVOIDS; // explore shouldn't try to pick it up more than once.
		itemName(theItem, buf2, false, true, NULL); // include article
		sprintf(buf, "Your pack is too full to pick up %s.", buf2);
		message(buf, false);
	}
}


function conflateItemCharacteristics(/* item */ newItem, /* item */ oldItem) {

    // let magic detection and other flags propagate to the new stack...
    newItem.flags |= (oldItem.flags & (ITEM_MAGIC_DETECTED | ITEM_IDENTIFIED | ITEM_PROTECTED | ITEM_RUNIC
                                         | ITEM_RUNIC_HINTED | ITEM_CAN_BE_IDENTIFIED | ITEM_MAX_CHARGES_KNOWN));

    // keep the higher enchantment and lower strength requirement...
    if (oldItem.enchant1 > newItem.enchant1) {
        newItem.enchant1 = oldItem.enchant1;
    }
    if (oldItem.strengthRequired < newItem.strengthRequired) {
        newItem.strengthRequired = oldItem.strengthRequired;
    }
    // Copy the inscription.
    if (oldItem.inscription && !newItem.inscription) {
        newItem.inscription = oldItem.inscription;
    }
    // Keep track of origin depth only if every item in the stack has the same origin depth.
    if (oldItem.originDepth <= 0 || newItem.originDepth != oldItem.originDepth) {
        newItem.originDepth = 0;
    }
}

function stackItems( /* item */ newItem, /* item */ oldItem) {
    //Increment the quantity of the old item...
    newItem.quantity += oldItem.quantity;

    // ...conflate attributes...
    conflateItemCharacteristics(newItem, oldItem);

    // ...and delete the new item.
    deleteItem(oldItem);
}

function inventoryLetterAvailable(proposedLetter) {
    let theItem;		// item *
    if (proposedLetter >= 'a'
        && proposedLetter <= 'z')
		{
        for (theItem = packItems.nextItem; theItem != NULL; theItem = theItem.nextItem) {
            if (theItem.inventoryLetter == proposedLetter) {
                return false;
            }
        }
        return true;
    }
    return false;
}


function addItemToPack(/* item */ theItem) {
	let previousItem, tempItem; // item *
	let itemLetter;	// char

	// Can the item stack with another in the inventory?
	if (theItem.category & (FOOD|POTION|SCROLL|GEM)) {
		for (tempItem = packItems.nextItem; tempItem != NULL; tempItem = tempItem.nextItem) {
			if (theItem.category == tempItem.category
          && theItem.kind == tempItem.kind
          && (!(theItem.category & GEM) || theItem.originDepth == tempItem.originDepth)) 	// We found a match!
			{
        stackItems(tempItem, theItem);

				// Pass back the incremented (old) item. No need to add it to the pack since it's already there.
				return tempItem;
			}
		}
	} else if (theItem.category & WEAPON && theItem.quiverNumber > 0) {
		for (tempItem = packItems.nextItem; tempItem != NULL; tempItem = tempItem.nextItem) {
			if (theItem.category == tempItem.category && theItem.kind == tempItem.kind
				&& theItem.quiverNumber == tempItem.quiverNumber)
			{
				// We found a match!
        stackItems(tempItem, theItem);

				// Pass back the incremented (old) item. No need to add it to the pack since it's already there.
				return tempItem;
			}
		}
	}

	// assign a reference letter to the item
	if (!inventoryLetterAvailable(theItem.inventoryLetter)) {
		itemLetter = nextAvailableInventoryCharacter();
		if (itemLetter) {
			theItem.inventoryLetter = itemLetter;
		}
	}

	// insert at proper place in pack chain
	for (previousItem = packItems;
		 previousItem.nextItem != NULL && previousItem.nextItem.category <= theItem.category;
		 previousItem = previousItem.nextItem);
	theItem.nextItem = previousItem.nextItem;
	previousItem.nextItem = theItem;

	return theItem;
}


function numberOfItemsInPack() {
	let theCount = 0;
	let theItem;	// item *
	for(theItem = packItems.nextItem; theItem != NULL; theItem = theItem.nextItem) {
		theCount += (theItem.category & (WEAPON | GEM) ? 1 : theItem.quantity);
	}
	return theCount;
}

function nextAvailableInventoryCharacter() {
	const charTaken = []; // boolean[26];
	let i;
	let theItem;	// item *
	let c;
	for(i=0; i<26; i++) {
		charTaken[i] = false;
	}
	for (theItem = packItems.nextItem; theItem != NULL; theItem = theItem.nextItem) {
		c = theItem.inventoryLetter;
		if (c >= 'a' && c <= 'z') {
			charTaken[c.charCodeAt(0) - 'a'.charCodeAt(0)] = true;
		}
	}
	for(i=0; i<26; i++) {
		if (!charTaken[i]) {
			return String.fromCharCode('a'.charCodeAt(0) + i);
		}
	}
	return null;
}

function checkForDisenchantment(/* item */ theItem) {
	const buf = STRING(), buf2 = STRING();

  if ((theItem.flags & ITEM_RUNIC)
			&& (((theItem.category & WEAPON) && theItem.enchant2 < NUMBER_GOOD_WEAPON_ENCHANT_KINDS) || ((theItem.category & ARMOR) && theItem.enchant2 < NUMBER_GOOD_ARMOR_ENCHANT_KINDS))
      && theItem.enchant1 <= 0)
	{
      theItem.enchant2 = 0;
      theItem.flags &= ~(ITEM_RUNIC | ITEM_RUNIC_HINTED | ITEM_RUNIC_IDENTIFIED);

      if (theItem.flags & ITEM_IDENTIFIED) {
        identify(theItem);
				itemName(theItem, buf2, false, false, NULL);
        sprintf(buf, "the runes fade from your %s!", buf2);
				message(buf, itemMessageColor, false);
      }
  }
	if (theItem.flags & ITEM_CURSED
			&& theItem.enchant1 >= 0)
	{
			theItem.flags &= ~ITEM_CURSED;
	}
}

function itemIsSwappable(/* item */ theItem) {
  if ((theItem.category & CAN_BE_SWAPPED)
      && theItem.quiverNumber == 0)
	{
      return true;
  } else {
      return false;
  }
}

function swapItemToEnchantLevel(/* item */ theItem, newEnchant, enchantmentKnown) {
    let x, y, charmPercent;
    const buf1 = STRING(), buf2 = STRING(); // char[COLS * 3];

    if ((theItem.category & STAFF) && newEnchant < 2
        || (theItem.category & CHARM) && newEnchant < 1
        || (theItem.category & WAND) && newEnchant < 0)
		{
        itemName(theItem, buf1, false, true, NULL);
        sprintf(buf2, "%s shatter%s from the strain!",
                buf1,
                theItem.quantity == 1 ? "s" : "");
        x = theItem.xLoc;
        y = theItem.yLoc;
        removeItemFromChain(theItem, floorItems);
        pmap[x][y].flags &= ~(HAS_ITEM | ITEM_DETECTED);
        if (pmap[x][y].flags & (ANY_KIND_OF_VISIBLE | DISCOVERED | ITEM_DETECTED)) {
            refreshDungeonCell(x, y);
        }
        if (playerCanSee(x, y)) {
            message(buf2, itemMessageColor, false);
        }
    } else {
        if ((theItem.category & STAFF)
            && theItem.charges > newEnchant)
				{
            theItem.charges = newEnchant;
        }
        if (theItem.category & CHARM) {
            charmPercent = Math.floor(theItem.charges * 100 / charmRechargeDelay(theItem.kind, theItem.enchant1));
            theItem.charges = Math.floor(charmPercent * charmRechargeDelay(theItem.kind, newEnchant) / 100);
        }
        if (enchantmentKnown) {
            if (theItem.category & STAFF) {
                theItem.flags |= ITEM_MAX_CHARGES_KNOWN;
            }
            theItem.flags |= ITEM_IDENTIFIED;
        } else {
            theItem.flags &= ~(ITEM_MAX_CHARGES_KNOWN | ITEM_IDENTIFIED);
            theItem.flags |= ITEM_CAN_BE_IDENTIFIED;
            if (theItem.category & WEAPON) {
                theItem.charges = WEAPON_KILLS_TO_AUTO_ID; // kill this many enemies to auto-identify
            } else if (theItem.category & ARMOR) {
                theItem.charges = ARMOR_DELAY_TO_AUTO_ID; // this many turns until it reveals its enchants and whether runic
            } else if (theItem.category & RING) {
                theItem.charges = RING_DELAY_TO_AUTO_ID; // how many turns of being worn until it auto-identifies
            }
        }
        if (theItem.category & WAND) {
            theItem.charges = newEnchant;
        } else {
            theItem.enchant1 = newEnchant;
        }
				checkForDisenchantment(theItem);
    }
}

function enchantLevelKnown(/* item */ theItem) {
  if ((theItem.category & STAFF)
      && (theItem.flags & ITEM_MAX_CHARGES_KNOWN))
	{
      return true;
  } else {
      return (theItem.flags & ITEM_IDENTIFIED);
  }
}

function effectiveEnchantLevel(/* item */ theItem) {
  if (theItem.category & WAND) {
      return theItem.charges;
  } else {
      return theItem.enchant1;
  }
}

function swapItemEnchants(machineNumber) {
    let lockedItem, tempItem;	// item *
    let i, j, oldEnchant;
    let enchantmentKnown;

    lockedItem = NULL;
    for (i = 0; i < DCOLS; i++) {
        for (j = 0; j < DROWS; j++) {
            tempItem = itemAtLoc(i, j);
            if (tempItem
                && pmap[i][j].machineNumber == machineNumber
								&& cellHasTMFlag(i, j, TM_SWAP_ENCHANTS_ACTIVATION)
                && itemIsSwappable(tempItem))
						{
                if (lockedItem) {
                    if (effectiveEnchantLevel(lockedItem) != effectiveEnchantLevel(tempItem)) {
                        // Presto change-o!
                        oldEnchant = effectiveEnchantLevel(lockedItem);
                        enchantmentKnown = enchantLevelKnown(lockedItem);
                        swapItemToEnchantLevel(lockedItem, effectiveEnchantLevel(tempItem), enchantLevelKnown(tempItem));
                        swapItemToEnchantLevel(tempItem, oldEnchant, enchantmentKnown);
                        return true;
                    }
                } else {
                    lockedItem = tempItem;
                }
            }
        }
    }
    return false;
}

async function updateFloorItems() {
  let x, y;
	let loc;
  const buf = STRING(), buf2 = STRING(); // char[DCOLS*3];
  let layer;	// enum dungeonLayers
  let theItem, nextItem;	// item *

	for (theItem=floorItems.nextItem; theItem != NULL; theItem = nextItem) {
		nextItem = theItem.nextItem;
    x = theItem.xLoc;
    y = theItem.yLoc;
    if (cellHasTerrainFlag(x, y, T_AUTO_DESCENT)) {
        if (playerCanSeeOrSense(x, y)) {
            itemName(theItem, buf, false, false, NULL);
            sprintf(buf2, "The %s plunge%s out of sight!", buf, (theItem.quantity > 1 ? "" : "s"));
            message(buf2, itemMessageColor, false);
        }
        if (playerCanSee(x, y)) {
            await discover(x, y);
        }
        theItem.flags |= ITEM_PREPLACED;

        // Remove from item chain.
        removeItemFromChain(theItem, floorItems);

        pmap[x][y].flags &= ~(HAS_ITEM | ITEM_DETECTED);

        if (theItem.category == POTION || rogue.depthLevel == DEEPEST_LEVEL) {
            // Potions don't survive the fall.
            deleteItem(theItem);
        } else {
            // Add to next level's chain.
            theItem.nextItem = levels[rogue.depthLevel-1 + 1].items;
            levels[rogue.depthLevel-1 + 1].items = theItem;
        }
        refreshDungeonCell(x, y);
        continue;
    }
		if ((cellHasTerrainFlag(x, y, T_IS_FIRE) && (theItem.flags & ITEM_FLAMMABLE))
        || (cellHasTerrainFlag(x, y, T_LAVA_INSTA_DEATH) && !(theItem.category & AMULET)))
		{
      await burnItem(theItem);
      continue;
    }
    if (cellHasTerrainFlag(x, y, T_MOVES_ITEMS)) {
      loc = getQualifyingLocNear(x, y, true, 0, (T_OBSTRUCTS_ITEMS | T_OBSTRUCTS_PASSABILITY), (HAS_ITEM), false, false);
      removeItemFrom(x, y);
      pmap[loc[0]][loc[1]].flags |= HAS_ITEM;
      if (pmap[x][y].flags & ITEM_DETECTED) {
          pmap[x][y].flags &= ~ITEM_DETECTED;
          pmap[loc[0]][loc[1]].flags |= ITEM_DETECTED;
      }
      theItem.xLoc = loc[0];
      theItem.yLoc = loc[1];
      refreshDungeonCell(x, y);
      refreshDungeonCell(loc[0], loc[1]);
      continue;
    }
    if (cellHasTMFlag(x, y, TM_PROMOTES_ON_STEP)) {
        for (layer = 0; layer < NUMBER_TERRAIN_LAYERS; layer++) {
            if (tileCatalog[pmap[x][y].layers[layer]].mechFlags & TM_PROMOTES_ON_STEP) {
                await promoteTile(x, y, layer, false);
            }
        }
        continue;
    }
    if (pmap[x][y].machineNumber
        && pmap[x][y].machineNumber == pmap[player.xLoc][player.yLoc].machineNumber
        && (theItem.flags & ITEM_KIND_AUTO_ID))
		{
        identifyItemKind(theItem);
    }
    if (cellHasTMFlag(x, y, TM_SWAP_ENCHANTS_ACTIVATION)
        && pmap[x][y].machineNumber)
		{
        while (nextItem != NULL
               && pmap[x][y].machineNumber == pmap[nextItem.xLoc][nextItem.yLoc].machineNumber
               && cellHasTMFlag(nextItem.xLoc, nextItem.yLoc, TM_SWAP_ENCHANTS_ACTIVATION))
			 {
            // Skip future items that are also swappable, so that we don't inadvertently
            // destroy the next item and then try to update it.
            nextItem = nextItem.nextItem;
        }

        if (!circuitBreakersPreventActivation(pmap[x][y].machineNumber)
            && swapItemEnchants(pmap[x][y].machineNumber))
				{
            await activateMachine(pmap[x][y].machineNumber);
        }
    }
  }
}

async function inscribeItem( /* item */ theItem) {
	const itemText = STRING(), buf = STRING(), nameOfItem = STRING(), oldInscription = STRING();

	strcpy(oldInscription, theItem.inscription);
	strcpy(theItem.inscription, ''); // [0] = '\0';
	itemName(theItem, nameOfItem, true, true, NULL);
	strcpy(theItem.inscription, oldInscription);

	sprintf(buf, "inscribe: %s \"", nameOfItem);
 	const ok = await getInputTextString(itemText, buf, min(29, DCOLS - strLenWithoutEscapes(buf) - 1), "", "\"", TEXT_INPUT_NORMAL, false);
	if (ok && strlen(itemText)) {
		strcpy(theItem.inscription, itemText);
		confirmMessages();
		itemName(theItem, nameOfItem, true, true, NULL);
		sprintf(buf, "%s %s.", (theItem.quantity > 1 ? "they're" : "it's"), nameOfItem);
		message(buf, itemMessageColor, false);
		return true;
	} else {
		confirmMessages();
		return false;
	}
}

function itemCanBeCalled( /* item */ theItem) {
    if (theItem.category & (WEAPON|ARMOR|SCROLL|RING|POTION|STAFF|WAND|CHARM)) {
        return true;
    } else if ((theItem.category & (POTION | SCROLL))
               && !tableForItemCategory(theItem.category, NULL)[theItem.kind].identified)
		{
        return true;
    } else {
        return false;
    }
}

async function call( /* item */ theItem) {
	const itemText = STRING(), buf = STRING(); // char[COLS * 3];
	let c;
	const command = []; // char[100];
  let tempItem;	// item *

	c = 0;
	command[c++] = CALL_KEY;
	if (theItem == NULL) {
    // Need to gray out known potions and scrolls from inventory selection.
    // Hijack the "item can be identified" flag for this purpose,
    // and then reset it immediately afterward.
    for (tempItem = packItems.nextItem; tempItem != NULL; tempItem = tempItem.nextItem) {
        if ((tempItem.category & (POTION | SCROLL))
            && tableForItemCategory(tempItem.category, NULL)[tempItem.kind].identified) {

            tempItem.flags &= ~ITEM_CAN_BE_IDENTIFIED;
        } else {
            tempItem.flags |= ITEM_CAN_BE_IDENTIFIED;
        }
    }
		theItem = await promptForItemOfType((WEAPON|ARMOR|SCROLL|RING|POTION|STAFF|WAND|CHARM), ITEM_CAN_BE_IDENTIFIED, 0,
									  KEYBOARD_LABELS ? "Call what? (a-z, shift for more info; or <esc> to cancel)" : "Call what?",
                                      true);
    updateIdentifiableItems(); // Reset the flags.
	}
	if (theItem == NULL) {
		return;
	}

	command[c++] = theItem.inventoryLetter;

	confirmMessages();

	if ((theItem.flags & ITEM_IDENTIFIED) || theItem.category & (WEAPON|ARMOR|CHARM|FOOD|GOLD|AMULET|GEM)) {
		if (theItem.category & (WEAPON | ARMOR | CHARM | STAFF | WAND | RING)) {
			if (await inscribeItem(theItem)) {
				command[c++] = null;	// '\0';
				// strcat((char *) command, theItem.inscription);
				// recordKeystrokeSequence(command);
				// recordKeystroke(RETURN_KEY, false, false);
			}
		} else {
			message("you already know what that is.", false);
		}
		return;
	}

	if (theItem.category & (WEAPON | ARMOR | STAFF | WAND | RING)) {
    if (tableForItemCategory(theItem.category, NULL)[theItem.kind].identified) {
			if (await inscribeItem(theItem)) {
				command[c++] = null; // '\0';
				// strcat((char *) command, theItem.inscription);
				// recordKeystrokeSequence(command);
				// recordKeystroke(RETURN_KEY, false, false);
			}
      return;
    } else if (await confirm("Inscribe this particular item instead of all similar items?", true)) {
			command[c++] = 'y'; // y means yes, since the recording also needs to negotiate the above confirmation prompt.
			if (await inscribeItem(theItem)) {
				command[c++] = null; // '\0';
				// strcat((char *) command, theItem.inscription);
				// recordKeystrokeSequence(command);
				// recordKeystroke(RETURN_KEY, false, false);
			}
			return;
		} else {
			command[c++] = 'n'; // n means no
		}
	}

	if (tableForItemCategory(theItem.category, NULL)
        && !(tableForItemCategory(theItem.category, NULL)[theItem.kind].identified))
	{
    await getInputTextString(itemText, "call them: \"", 29, "", "\"", TEXT_INPUT_NORMAL, false);
    if (itemText && strlen(itemText)) {
        command[c++] = null; // '\0';
        // strcat((char *) command, itemText);
        // recordKeystrokeSequence(command);
        // recordKeystroke(RETURN_KEY, false, false);
        if (strlen(itemText)) {
            strcpy(tableForItemCategory(theItem.category, NULL)[theItem.kind].callTitle, itemText);
            tableForItemCategory(theItem.category, NULL)[theItem.kind].called = true;
        } else {
            strcpy(tableForItemCategory(theItem.category, NULL)[theItem.kind].callTitle, ''); // [0] = '\0';
            tableForItemCategory(theItem.category, NULL)[theItem.kind].called = false;
        }
        confirmMessages();
        itemName(theItem, buf, false, true, NULL);
        message(buf, itemMessageColor, false);
    }
	} else {
        message("you already know what that is.", false);
	}
}


// Generates the item name and returns it.
// IncludeDetails governs things such as enchantment, charges, strength requirement, times used, etc.
// IncludeArticle governs the article -- e.g. "some" food, "5" darts, "a" pink potion.
// If baseColor is provided, then the suffix will be in gray, flavor portions of the item name (e.g. a "pink" potion,
//	a "sandalwood" staff, a "ruby" ring) will be in dark purple, and the Amulet of Yendor and lumenstones will be in yellow.
//  BaseColor itself will be the color that the name reverts to outside of these colored portions.
function itemName(/* item */ theItem, /* char */ root, includeDetails, includeArticle, /* color */ baseColor) {
	const buf = STRING();
	const grayEscapeSequence = STRING(), purpleEscapeSequence = STRING(), yellowEscapeSequence = STRING(), baseEscapeSequence = STRING();
	const pluralization = STRING();

	const article = STRING();
	const tempColor = color();

	strcpy(pluralization, (theItem.quantity > 1 ? "s" : ""));

	if (baseColor) {
		tempColor.copy(backgroundMessageColor);
		applyColorMultiplier(tempColor, baseColor); // To gray out the purple if necessary.
		encodeMessageColor(purpleEscapeSequence, 0, tempColor);

		tempColor.copy(gray);
		//applyColorMultiplier(&tempColor, baseColor);
		encodeMessageColor(grayEscapeSequence, 0, tempColor);

		tempColor.copy(itemMessageColor);
		applyColorMultiplier(tempColor, baseColor);
		encodeMessageColor(yellowEscapeSequence, 0, tempColor);

		encodeMessageColor(baseEscapeSequence, 0, baseColor);
	}

	switch (theItem.category) {
		case FOOD:
			if (theItem.kind == FRUIT) {
				sprintf(root, "mango%s", pluralization);
			} else {
				if (theItem.quantity == 1) {
					sprintf(article, "some ");
					sprintf(root, "food");
				} else {
					sprintf(root, "ration%s of food", pluralization);
				}
			}
			break;
		case WEAPON:
			sprintf(root, "%s%s", weaponTable[theItem.kind].name, pluralization);
			if (includeDetails) {
				if ((theItem.flags & ITEM_IDENTIFIED) || rogue.playbackOmniscience) {
					sprintf(buf, "%s%i %s", (theItem.enchant1 < 0 ? "" : "+"), theItem.enchant1, root);
					strcpy(root, buf);
				}

				if (theItem.flags & ITEM_RUNIC) {
					if ((theItem.flags & ITEM_RUNIC_IDENTIFIED) || rogue.playbackOmniscience) {
						if (theItem.enchant2 == W_SLAYING) {
							sprintf(root, "%s of %s slaying%s",
									root,
                  monsterClassCatalog[theItem.vorpalEnemy].name,
									grayEscapeSequence);
						} else {
							sprintf(root, "%s of %s%s",
									root,
									weaponRunicNames[theItem.enchant2],
									grayEscapeSequence);
						}
					} else if (theItem.flags & (ITEM_IDENTIFIED | ITEM_RUNIC_HINTED)) {
						if ( strlen(grayEscapeSequence) ) {
							strcat(root, grayEscapeSequence);
						}
						strcat(root, " (unknown runic)");
					}
				}
				sprintf(root, "%s%s <%i>", root, grayEscapeSequence, theItem.strengthRequired);
			}
			break;
		case ARMOR:
			sprintf(root, "%s", armorTable[theItem.kind].name);
			if (includeDetails) {
				if ((theItem.flags & ITEM_RUNIC)
					&& ((theItem.flags & ITEM_RUNIC_IDENTIFIED)
						|| rogue.playbackOmniscience))
        {
					if (theItem.enchant2 == A_IMMUNITY) {
						sprintf(root, "%s of %s immunity", root, monsterClassCatalog[theItem.vorpalEnemy].name);
					} else {
						sprintf(root, "%s of %s", root, armorRunicNames[theItem.enchant2]);
					}
				}

				if ((theItem.flags & ITEM_IDENTIFIED) || rogue.playbackOmniscience) {
					if (theItem.enchant1 == 0) {
						sprintf(buf, "%s%s [%i]<%i>", root, grayEscapeSequence, Math.floor(theItem.armor/10), theItem.strengthRequired);
					} else {
						sprintf(buf, "%s%i %s%s [%i]<%i>",
								(theItem.enchant1 < 0 ? "" : "+"),
								theItem.enchant1,
								root,
								grayEscapeSequence,
								Math.floor(theItem.armor/10) + theItem.enchant1,
								theItem.strengthRequired);
					}
					strcpy(root, buf);
				} else {
					sprintf(root, "%s%s <%i>", root, grayEscapeSequence, theItem.strengthRequired);
				}

				if ((theItem.flags & ITEM_RUNIC)
					&& (theItem.flags & (ITEM_IDENTIFIED | ITEM_RUNIC_HINTED))
					&& !(theItem.flags & ITEM_RUNIC_IDENTIFIED)
					&& !rogue.playbackOmniscience)
        {
					strcat(root, " (unknown runic)");
				}
			}
			break;
		case SCROLL:
			if (scrollTable[theItem.kind].identified || rogue.playbackOmniscience) {
				sprintf(root, "scroll%s of %s", pluralization, scrollTable[theItem.kind].name);
			} else if (scrollTable[theItem.kind].called) {
				sprintf(root, "scroll%s called %s%s%s",
						pluralization,
						purpleEscapeSequence,
						scrollTable[theItem.kind].callTitle,
						baseEscapeSequence);
			} else {
				sprintf(root, "scroll%s entitled %s\"%s\"%s",
						pluralization,
						purpleEscapeSequence,
						scrollTable[theItem.kind].flavor,
						baseEscapeSequence);
			}
			break;
		case POTION:
			if (potionTable[theItem.kind].identified || rogue.playbackOmniscience) {
				sprintf(root, "potion%s of %s", pluralization, potionTable[theItem.kind].name);
			} else if (potionTable[theItem.kind].called) {
				sprintf(root, "potion%s called %s%s%s",
						pluralization,
						purpleEscapeSequence,
						potionTable[theItem.kind].callTitle,
						baseEscapeSequence);
			} else {
				sprintf(root, "%s%s%s potion%s",
						purpleEscapeSequence,
						potionTable[theItem.kind].flavor,
						baseEscapeSequence,
						pluralization);
			}
			break;
		case WAND:
			if (wandTable[theItem.kind].identified || rogue.playbackOmniscience) {
				sprintf(root, "wand%s of %s",
						pluralization,
						wandTable[theItem.kind].name);
			} else if (wandTable[theItem.kind].called) {
				sprintf(root, "wand%s called %s%s%s",
						pluralization,
						purpleEscapeSequence,
						wandTable[theItem.kind].callTitle,
						baseEscapeSequence);
			} else {
				sprintf(root, "%s%s%s wand%s",
						purpleEscapeSequence,
						wandTable[theItem.kind].flavor,
						baseEscapeSequence,
						pluralization);
			}
			if (includeDetails) {
				if (theItem.flags & (ITEM_IDENTIFIED | ITEM_MAX_CHARGES_KNOWN) || rogue.playbackOmniscience) {
					sprintf(root, "%s%s [%i]",
							root,
							grayEscapeSequence,
							theItem.charges);
				} else if (theItem.enchant2 > 2) {
					sprintf(root, "%s%s (used %i times)",
							root,
							grayEscapeSequence,
							theItem.enchant2);
				} else if (theItem.enchant2) {
					sprintf(root, "%s%s (used %s)",
							root,
							grayEscapeSequence,
							(theItem.enchant2 == 2 ? "twice" : "once"));
				}
			}
			break;
		case STAFF:
			if (staffTable[theItem.kind].identified || rogue.playbackOmniscience) {
				sprintf(root, "staff%s of %s", pluralization, staffTable[theItem.kind].name);
			} else if (staffTable[theItem.kind].called) {
				sprintf(root, "staff%s called %s%s%s",
						pluralization,
						purpleEscapeSequence,
						staffTable[theItem.kind].callTitle,
						baseEscapeSequence);
			} else {
				sprintf(root, "%s%s%s staff%s",
						purpleEscapeSequence,
						staffTable[theItem.kind].flavor,
						baseEscapeSequence,
						pluralization);
			}
			if (includeDetails) {
				if ((theItem.flags & ITEM_IDENTIFIED) || rogue.playbackOmniscience) {
					sprintf(root, "%s%s [%i/%i]", root, grayEscapeSequence, theItem.charges, theItem.enchant1);
				} else if (theItem.flags & ITEM_MAX_CHARGES_KNOWN) {
					sprintf(root, "%s%s [?/%i]", root, grayEscapeSequence, theItem.enchant1);
				}
			}
			break;
		case RING:
			if (ringTable[theItem.kind].identified || rogue.playbackOmniscience) {
				sprintf(root, "ring%s of %s", pluralization, ringTable[theItem.kind].name);
			} else if (ringTable[theItem.kind].called) {
				sprintf(root, "ring%s called %s%s%s",
						pluralization,
						purpleEscapeSequence,
						ringTable[theItem.kind].callTitle,
						baseEscapeSequence);
			} else {
				sprintf(root, "%s%s%s ring%s",
						purpleEscapeSequence,
						ringTable[theItem.kind].flavor,
						baseEscapeSequence,
						pluralization);
			}
			if (includeDetails && ((theItem.flags & ITEM_IDENTIFIED) || rogue.playbackOmniscience)) {
				sprintf(buf, "%s%i %s", (theItem.enchant1 < 0 ? "" : "+"), theItem.enchant1, root);
				strcpy(root, buf);
			}
			break;
		case CHARM:
			sprintf(root, "%s charm%s", charmTable[theItem.kind].name, pluralization);

			if (includeDetails) {
				sprintf(buf, "%s%i %s", (theItem.enchant1 < 0 ? "" : "+"), theItem.enchant1, root);
				strcpy(root, buf);
        if (theItem.charges) {
          const delay = Math.floor((charmRechargeDelay(theItem.kind, theItem.enchant1) - theItem.charges) * 100 / charmRechargeDelay(theItem.kind, theItem.enchant1));
					sprintf(buf, "%s %s(%i%)",
									root,
									grayEscapeSequence,
									delay);
					strcpy(root, buf);
        } else {
					strcat(root, grayEscapeSequence);
					strcat(root, " (ready)");
        }
			}
			break;
		case GOLD:
			sprintf(root, "gold piece%s", pluralization);
			break;
		case AMULET:
			sprintf(root, "%sAmulet%s of Yendor%s", yellowEscapeSequence, pluralization, baseEscapeSequence);
			break;
		case GEM:
			sprintf(root, "%slumenstone%s%s from depth %i", yellowEscapeSequence, pluralization, baseEscapeSequence, theItem.originDepth);
			break;
		case KEY:
			if (includeDetails && theItem.originDepth > 0 && theItem.originDepth != rogue.depthLevel) {
				sprintf(root, "%s%s%s from depth %i",
						keyTable[theItem.kind].name,
						pluralization,
						grayEscapeSequence,
						theItem.originDepth);
			} else {
				sprintf(root,
						keyTable[theItem.kind].name,
						"%s%s",
						pluralization);
			}
			break;
		default:
			sprintf(root, "unknown item%s", pluralization);
			break;
	}

	if (includeArticle && !strlen(article)) {
		// prepend number if quantity is over 1
		if (theItem.quantity > 1) {
			sprintf(article, "%i ", theItem.quantity);
		} else if (theItem.category & AMULET) {
			sprintf(article, "the ");
		} else if (!(theItem.category & ARMOR) && !(theItem.category & FOOD && theItem.kind == RATION)) {
			// otherwise prepend a/an if the item is not armor and not a ration of food;
			// armor gets no article, and "some food" was taken care of above.
			sprintf(article, "a%s ", (isVowelish(root) ? "n" : ""));
		}
	}
	// strcat(buf, suffixID);
	if (includeArticle) {
		sprintf(buf, "%s%s", article, root);
		strcpy(root, buf);
	}

	if (includeDetails && theItem.inscription[0]) {
		sprintf(buf, "%s \"%s\"", root, theItem.inscription);
		strcpy(root, buf);
	}
	return;
}


// kindCount is optional
function tableForItemCategory(/* enum itemCategory */ theCat) {	// itemTable *
  let returnedTable;	// itemTable *
	switch (theCat) {
		case FOOD:
			returnedTable = foodTable;
      break;
		case WEAPON:
			returnedTable = weaponTable;
      break;
		case ARMOR:
			returnedTable = armorTable;
      break;
		case POTION:
			returnedTable = potionTable;
      break;
		case SCROLL:
			returnedTable = scrollTable;
      break;
		case RING:
			returnedTable = ringTable;
      break;
		case WAND:
			returnedTable = wandTable;
      break;
		case STAFF:
			returnedTable = staffTable;
      break;
		case CHARM:
			returnedTable = charmTable;
      break;
		default:
			returnedTable = null;
      break;
	}
  return returnedTable;
}

function isVowelish(str) {
	str = STRING(str);

	if (stringsMatch(str, "uni")) return false;  // Words that start with "uni" aren't treated like vowels; e.g., "a" unicorn.
	if (stringsMatch(str, "eu"))  return false;  // Words that start with "eu" aren't treated like vowels; e.g., "a" eucalpytus staff.

	let i = 0;
	while( str.charCodeAt(i) == COLOR_ESCAPE ) {
		i += 4;
	}

	// TODO - Get rid of 'charAt'
	const ch = str.charAt(i).toLowerCase();
	return ['a', 'e', 'i', 'o', 'u'].includes(ch);
}
//
// function charmEffectDuration(charmKind, enchant) {
//     const duration = [
//         3,  // Health
//         20, // Protection
//         7,  // Haste
//         10, // Fire immunity
//         5,  // Invisibility
//         25, // Telepathy
//         10, // Levitation
//         0,  // Shattering
//         18, // Guardian
//         0,  // Teleportation
//         0,  // Recharging
//         0,  // Negation
//     ];
//     const increment = [
//         0,  // Health
//         0,  // Protection
//         20, // Haste
//         25, // Fire immunity
//         20, // Invisibility
//         25, // Telepathy
//         25, // Levitation
//         0,  // Shattering
//         0,  // Guardian
//         0,  // Teleportation
//         0,  // Recharging
//         0,  // Negation
//     ];
//
//     return Math.floor(duration[charmKind] * (pow((100 + (increment[charmKind])) / 100, enchant) + FLOAT_FUDGE));
// }
//
// function charmRechargeDelay(charmKind, enchant) {
//     const duration = [
//         2500,   // Health
//         1000,   // Protection
//         800,    // Haste
//         800,    // Fire immunity
//         800,    // Invisibility
//         800,    // Telepathy
//         800,    // Levitation
//         2500,   // Shattering
//         700,    // Guardian
//         1000,   // Teleportation
//         10000,  // Recharging
//         2500,   // Negation
//     ];
//     const increment = [
//         45, // Health
//         40, // Protection
//         35, // Haste
//         40, // Fire immunity
//         35, // Invisibility
//         35, // Telepathy
//         35, // Levitation
//         40, // Shattering
//         30, // Guardian
//         45, // Teleportation
//         45, // Recharging
//         40, // Negation
//     ];
//
//     return charmEffectDuration(charmKind, enchant) + Math.floor(duration[charmKind] * (pow((100 - (increment[charmKind])) / 100, enchant) + FLOAT_FUDGE));
// }

function fp_enchantIncrement(/* item */ theItem) {
	if (theItem.category & (WEAPON | ARMOR)) {
		if (theItem.strengthRequired == 0) {
			return (1 + 0) << FP_BASE;
		} else if (rogue.strength - player.weaknessAmount < theItem.strengthRequired) {
			return Math.floor((35 << FP_BASE) / 10);
		} else {
			return Math.floor((125 << FP_BASE) / 100);
		}
	} else {
		return (1 + 0) << FP_BASE;
	}
}

function itemIsCarried( /* item */ theItem) {
	let tempItem;  // item *

	for (tempItem = packItems.nextItem; tempItem != NULL; tempItem = tempItem.nextItem) {
		if (tempItem === theItem) {
			return true;
		}
	}
	return false;
}

function effectiveRingEnchant( /* item */ theItem) {
    if (theItem.category != RING) {
        return 0;
    }
    if (!(theItem.flags & ITEM_IDENTIFIED)
        && theItem.enchant1 > 0)
		{
        return theItem.timesEnchanted + 1; // Unidentified positive rings act as +1 until identified.
    }
    return theItem.enchant1;
}

function apparentRingBonus(/* ringKind */ kind) {
    const rings = [rogue.ringLeft, rogue.ringRight];
		let ring;
    let retval = 0;
    let i;

    if (ringTable[kind].identified) {
      for (i = 0; i < 2; i++) {
        ring = rings[i];
        if (ring && ring.kind == kind) {
            retval += effectiveRingEnchant(ring);
        }
      }
    }
    return retval;
}

const weaponRunicEffectDescriptions = [
	"time will stop while you take an extra turn",
	"the enemy will die instantly",
	"the enemy will be paralyzed",
	"[multiplicity]", // never used
	"the enemy will be slowed",
	"the enemy will be confused",
			"the enemy will be flung",
	"[slaying]", // never used
	"the enemy will be healed",
	"the enemy will be cloned"
];


// returns a string with the item description details
function itemDetails( buf, /* item */ theItem) {
	const buf2 = STRING(), buf3 = STRING(), theName = STRING(), goodColorEscape = STRING(), badColorEscape = STRING(), whiteColorEscape = STRING();
	let singular, carried;
	let enchant;
	let nextLevelState = 0, newValue;
	let accuracyChange, damageChange, current, currentDamage, newDamage;

	encodeMessageColor(goodColorEscape, 0, goodMessageColor);
	encodeMessageColor(badColorEscape, 0, badMessageColor);
	encodeMessageColor(whiteColorEscape, 0, white);

	singular = (theItem.quantity == 1 ? true : false);
	carried = itemIsCarried(theItem);

	// Name
	itemName(theItem, theName, true, true, NULL);
	encodeMessageColor(buf, 0, itemMessageColor);
	capitalize(theName);
	strcat(buf, theName);
	if (carried) {
		sprintf(buf2, " (%c)", theItem.inventoryLetter);
		strcat(buf, buf2);
	}
	encodeMessageColor(buf2, 0, white);
	strcat(buf, buf2);
	strcat(buf, "\n\n");

	enchant = fp_netEnchant(theItem);
	itemName(theItem, theName, false, false, NULL);

	// introductory text
  const itemTable = tableForItemCategory(theItem.category, NULL);
	if (itemTable && (itemTable[theItem.kind].identified || rogue.playbackOmniscience))
  {
		strcat(buf, tableForItemCategory(theItem.category, NULL)[theItem.kind].description);

    if (theItem.category == POTION && theItem.kind == POTION_LIFE) {
			sprintf(buf2, "\n\nIt will increase your maximum health by %s%i%%s.",
							goodColorEscape,
							Math.floor((player.info.maxHP + 10) * 100 / player.info.maxHP - 100),
							whiteColorEscape);
			strcat(buf, buf2);
    }
	} else {
		switch (theItem.category) {
			case POTION:
				sprintf(buf2, "%s flask%s contain%s a swirling %s liquid. Who knows what %s will do when drunk or thrown?",
						(singular ? "This" : "These"),
						(singular ? "" : "s"),
						(singular ? "s" : ""),
						itemTable[theItem.kind].flavor,
						(singular ? "it" : "they"));
				break;
			case SCROLL:
				sprintf(buf2, "%s parchment%s %s covered with indecipherable writing, and bear%s a title of \"%s.\" Who knows what %s will do when read aloud?",
						(singular ? "This" : "These"),
						(singular ? "" : "s"),
						(singular ? "is" : "are"),
						(singular ? "s" : ""),
						itemTable[theItem.kind].flavor,
						(singular ? "it" : "they"));
				break;
			case STAFF:
				sprintf(buf2, "This gnarled %s staff is warm to the touch. Who knows what it will do when used?",
						itemTable[theItem.kind].flavor);
				break;
			case WAND:
				sprintf(buf2, "This thin %s wand is warm to the touch. Who knows what it will do when used?",
						itemTable[theItem.kind].flavor);
				break;
			case RING:
				sprintf(buf2, "This metal band is adorned with a%s %s gem that glitters in the darkness. Who knows what effect it has when worn? ",
            isVowelish(itemTable[theItem.kind].flavor) ? "n" : "",
						itemTable[theItem.kind].flavor);
				break;
			case CHARM: // Should never be displayed.
				strcat(buf2, "What a perplexing charm!");
				break;
			case AMULET:
				strcpy(buf2, "Legends are told about this mysterious golden amulet, and legions of adventurers have perished in its pursuit. Unfathomable riches await anyone with the skill and ambition to carry it into the light of day.");
				break;
			case GEM:
				sprintf(buf2, "Faint golden lights swirl and fluoresce beneath the stone%s surface. Lumenstones are said to contain mysterious properties of untold power, but for you, they mean one thing: riches.",
						(singular ? "'s" : "s'"));
				break;
			case KEY:
				strcpy(buf2, keyTable[theItem.kind].description);
				break;
			case GOLD:
				sprintf(buf2, "A pile of %i shining gold coins.", theItem.quantity);
				break;
			default:
				break;
		}
		strcat(buf, buf2);
	}

  if (carried && theItem.originDepth > 0) {
      sprintf(buf2, " (You found %s on depth %i.) ",
              singular ? "it" : "them",
              theItem.originDepth);
			strcat(buf, buf2);
  }

	// detailed description
	switch (theItem.category) {

		case FOOD:
			sprintf(buf2, "\n\nYou are %shungry enough to fully enjoy a %s.",
					((STOMACH_SIZE - player.status[STATUS_NUTRITION]) >= foodTable[theItem.kind].strengthRequired ? "" : "not yet "),
					foodTable[theItem.kind].name);
			strcat(buf, buf2);
			break;

		case WEAPON:
		case ARMOR:
			// enchanted? strength modifier?
			if ((theItem.flags & ITEM_IDENTIFIED) || rogue.playbackOmniscience) {
				if (theItem.enchant1) {
                    if (theItem.enchant1 > 0) {
                        sprintf(buf2, "\n\nThe %s bear%s an intrinsic enchantment of %s+%i%s",
                                theName,
                                (singular ? "s" : ""),
                                goodColorEscape,
                                theItem.enchant1,
                                whiteColorEscape);
                    } else {
                        sprintf(buf2, "\n\nThe %s bear%s an intrinsic penalty of %s%i%s",
                                theName,
                                (singular ? "s" : ""),
                                badColorEscape,
                                theItem.enchant1,
                                whiteColorEscape);
                    }
				} else {
					sprintf(buf2, "\n\nThe %s bear%s no intrinsic enchantment",
							theName,
							(singular ? "s" : ""));
				}
				strcat(buf, buf2);
				if (fp_strengthModifier(theItem)) {
					sprintf(buf2, ", %s %s %s %s%s%{f,2}%s because of your %s strength. ",
							(theItem.enchant1 ? "and" : "but"),
							(singular ? "carries" : "carry"),
							(theItem.enchant1 && (theItem.enchant1 > 0) == (fp_strengthModifier(theItem) > 0) ? "an additional" : "a"),
							(fp_strengthModifier(theItem) > 0 ? "bonus of +" : "penalty of "),
              (fp_strengthModifier(theItem) > 0 ? goodColorEscape : badColorEscape),
							Math.floor(fp_strengthModifier(theItem) / FP_FACTOR),
              whiteColorEscape,
							(fp_strengthModifier(theItem) > 0 ? "excess" : "inadequate"));
					strcat(buf, buf2);
				} else {
					strcat(buf, ". ");
				}
			} else {
				if ((theItem.enchant1 > 0) && (theItem.flags & ITEM_MAGIC_DETECTED)) {
					sprintf(buf2, "\n\nYou can feel an %saura of benevolent magic%s radiating from the %s. ",
              goodColorEscape,
              whiteColorEscape,
							theName);
					strcat(buf, buf2);
				}
				if (fp_strengthModifier(theItem)) {
					sprintf(buf2, "\n\nThe %s %s%s a %s%s%{f,2}%s because of your %s strength. ",
							theName,
							((theItem.enchant1 > 0) && (theItem.flags & ITEM_MAGIC_DETECTED) ? "also " : ""),
							(singular ? "carries" : "carry"),
							(fp_strengthModifier(theItem) > 0 ? "bonus of +" : "penalty of "),
              (fp_strengthModifier(theItem) > 0 ? goodColorEscape : badColorEscape),
							Math.floor(fp_strengthModifier(theItem) / FP_FACTOR),
              whiteColorEscape,
							(fp_strengthModifier(theItem) > 0 ? "excess" : "inadequate"));
					strcat(buf, buf2);
				}

				if (theItem.category & WEAPON) {
					sprintf(buf2, "It will reveal its secrets if you defeat %i%s %s with it. ",
							theItem.charges,
							(theItem.charges == WEAPON_KILLS_TO_AUTO_ID ? "" : " more"),
							(theItem.charges == 1 ? "enemy" : "enemies"));
				} else {
					sprintf(buf2, "It will reveal its secrets if worn for %i%s turn%s. ",
							theItem.charges,
							(theItem.charges == ARMOR_DELAY_TO_AUTO_ID ? "" : " more"),
							(theItem.charges == 1 ? "" : "s"));
				}
				strcat(buf, buf2);
			}

			// Display the known percentage by which the armor/weapon will increase/decrease accuracy/damage/defense if not already equipped.
			if (!(theItem.flags & ITEM_EQUIPPED)) {
				if (theItem.category & WEAPON) {
					current = player.info.accuracy;
					if (rogue.weapon) {
            currentDamage = Math.floor((rogue.weapon.damage.lowerBound + rogue.weapon.damage.upperBound << FP_BASE) / 2);
						if ((rogue.weapon.flags & ITEM_IDENTIFIED) || rogue.playbackOmniscience) {
							current = current * fp_accuracyFraction(fp_netEnchant(rogue.weapon)) >> FP_BASE;
							currentDamage = currentDamage * fp_damageFraction(fp_netEnchant(rogue.weapon)) >> FP_BASE;
						} else {
							current = current * fp_accuracyFraction(fp_strengthModifier(rogue.weapon)) >> FP_BASE;
							currentDamage = currentDamage * fp_damageFraction(fp_strengthModifier(rogue.weapon)) >> FP_BASE;
						}
					} else {
              currentDamage = Math.floor((player.info.damage.lowerBound + player.info.damage.upperBound << FP_BASE) / 2);
          }

					newValue = player.info.accuracy;
					newDamage = Math.floor((theItem.damage.lowerBound + theItem.damage.upperBound << FP_BASE) / 2);
					if ((theItem.flags & ITEM_IDENTIFIED) || rogue.playbackOmniscience) {
						newValue = newValue * fp_accuracyFraction(fp_netEnchant(theItem)) >> FP_BASE;
						newDamage = newDamage * fp_damageFraction(fp_netEnchant(theItem)) >> FP_BASE;
					} else {
						newValue = newValue * fp_accuracyFraction(fp_strengthModifier(theItem)) >> FP_BASE;
						newDamage = newDamage * fp_damageFraction(fp_strengthModifier(theItem)) >> FP_BASE;
					}
					accuracyChange	= Math.floor(newValue * 100 / current) - 100;
					damageChange	= Math.floor(newDamage * 100 / currentDamage) - 100;
					sprintf(buf2, "Wielding the %s%s will %s your current accuracy by %s%i%%s, and will %s your current damage by %s%i%%s. ",
							theName,
							((theItem.flags & ITEM_IDENTIFIED) || rogue.playbackOmniscience) ? "" : ", assuming it has no hidden properties,",
							((accuracyChange) < 0) ? "decrease" : "increase",
              ((accuracyChange) < 0) ? badColorEscape : (accuracyChange > 0 ? goodColorEscape : ""),
							abs(accuracyChange),
              whiteColorEscape,
							((damageChange) < 0) ? "decrease" : "increase",
              ((damageChange) < 0) ? badColorEscape : (damageChange > 0 ? goodColorEscape : ""),
							abs(damageChange),
              whiteColorEscape);
				} else {
					newValue = theItem.armor;
					if ((theItem.flags & ITEM_IDENTIFIED) || rogue.playbackOmniscience) {
						newValue += 10 * fp_netEnchant(theItem) >> FP_BASE;
					} else {
						newValue += 10 * fp_strengthModifier(theItem) >> FP_BASE;
					}
					newValue = max(0, newValue);
          newValue = Math.floor(newValue / 10);
					sprintf(buf2, "Wearing the %s%s will result in an armor rating of %s%i%s. ",
							theName,
							((theItem.flags & ITEM_IDENTIFIED) || rogue.playbackOmniscience) ? "" : ", assuming it has no hidden properties,",
              (newValue > displayedArmorValue() ? goodColorEscape : (newValue < displayedArmorValue() ? badColorEscape : whiteColorEscape)),
							Math.floor(newValue),
              whiteColorEscape);
				}
				strcat(buf, buf2);
			}

			// protected?
			if (theItem.flags & ITEM_PROTECTED) {
				sprintf(buf2, "%sThe %s cannot be corroded by acid.%s ",
            goodColorEscape,
						theName,
            whiteColorEscape);
				strcat(buf, buf2);
			}

			// heavy armor?
      current = armorAggroAdjustment(rogue.armor);
			if ((theItem.category & ARMOR)
                && !(theItem.flags & ITEM_EQUIPPED)
                && (current != armorAggroAdjustment(theItem)))
      {
        newValue = armorAggroAdjustment(theItem);
        if (rogue.armor) {
            newValue -= armorAggroAdjustment(rogue.armor);
        }
				sprintf(buf2, "Equipping the %s will %s%s your stealth range by %i%s. ",
						theName,
            newValue > 0 ? badColorEscape : goodColorEscape,
            newValue > 0 ? "increase" : "decrease",
            abs(newValue),
            whiteColorEscape);
				strcat(buf, buf2);
			}

			if (theItem.category & WEAPON) {

				// runic?
				if (theItem.flags & ITEM_RUNIC) {
					if ((theItem.flags & ITEM_RUNIC_IDENTIFIED) || rogue.playbackOmniscience) {
						sprintf(buf2, "\n\nGlowing runes of %s adorn the %s. ",
								weaponRunicNames[theItem.enchant2],
								theName);
						strcat(buf, buf2);
						if (theItem.enchant2 == W_SLAYING) {
              describeMonsterClass(buf3, theItem.vorpalEnemy, false);
							sprintf(buf2, "It will never fail to slay a%s %s in a single stroke. ",
                  (isVowelish(buf3) ? "n" : ""),
									buf3);
							strcat(buf, buf2);
						} else if (theItem.enchant2 == W_MULTIPLICITY) {
							if ((theItem.flags & ITEM_IDENTIFIED) || rogue.playbackOmniscience) {
								sprintf(buf2, "%i% of the time that it hits an enemy, %i spectral %s%s will spring into being with accuracy and attack power equal to your own, and will dissipate %i turns later. (If the %s is enchanted, %i image%s will appear %i% of the time, and will last %i turns.)",
										runicWeaponChance(theItem, false, 0),
										fp_weaponImageCount(enchant),
										theName,
										(fp_weaponImageCount(enchant) > 1 ? "s" : ""),
										fp_weaponImageDuration(enchant),
										theName,
										fp_weaponImageCount(enchant + fp_enchantIncrement(theItem)),
										(fp_weaponImageCount(enchant + fp_enchantIncrement(theItem)) > 1 ? "s" : ""),
										runicWeaponChance(theItem, true, enchant + fp_enchantIncrement(theItem)),
										fp_weaponImageDuration(enchant + fp_enchantIncrement(theItem)));
							} else {
								sprintf(buf2, "Sometimes, when it hits an enemy, spectral %ss will spring into being with accuracy and attack power equal to your own, and will dissipate shortly thereafter.",
										theName);
							}
							strcat(buf, buf2);
						} else {
							if ((theItem.flags & ITEM_IDENTIFIED) || rogue.playbackOmniscience) {
                if (runicWeaponChance(theItem, false, 0) < 2
                    && rogue.strength - player.weaknessAmount < theItem.strengthRequired)
                {
									strcpy(buf2, "Its runic effect will almost never activate because of your inadequate strength, but sometimes, when");
                } else {
									sprintf(buf2, "%i% of the time that",
													runicWeaponChance(theItem, false, 0));
                }
								strcat(buf, buf2);
							} else {
								strcat(buf, "Sometimes, when");
							}
							sprintf(buf2, " it hits an enemy, %s",
									weaponRunicEffectDescriptions[theItem.enchant2]);
							strcat(buf, buf2);

							if ((theItem.flags & ITEM_IDENTIFIED) || rogue.playbackOmniscience) {
								switch (theItem.enchant2) {
									case W_SPEED:
										strcat(buf, ". ");
										break;
									case W_PARALYSIS:
										sprintf(buf2, " for %i turns. ",
												(fp_weaponParalysisDuration(enchant)));
										strcat(buf, buf2);
										nextLevelState = Math.floor(fp_weaponParalysisDuration(enchant + fp_enchantIncrement(theItem)));
										break;
									case W_SLOWING:
										sprintf(buf2, " for %i turns. ",
												fp_weaponSlowDuration(enchant));
										strcat(buf, buf2);
										nextLevelState = fp_weaponSlowDuration(enchant + fp_enchantIncrement(theItem));
										break;
									case W_CONFUSION:
										sprintf(buf2, " for %i turns. ",
												fp_weaponConfusionDuration(enchant));
										strcat(buf, buf2);
										nextLevelState = fp_weaponConfusionDuration(enchant + fp_enchantIncrement(theItem));
										break;
									case W_FORCE:
										sprintf(buf2, " up to %i spaces backward. If the enemy hits an obstruction, it (and any monster it hits) will take damage in proportion to the distance it flew. ",
												fp_weaponForceDistance(enchant));
										strcat(buf, buf2);
										nextLevelState = fp_weaponForceDistance(enchant + fp_enchantIncrement(theItem));
										break;
									case W_MERCY:
										strcpy(buf2, " by 50% of its maximum health. ");
										strcat(buf, buf2);
										break;
									default:
										strcpy(buf2, ". ");
										strcat(buf, buf2);
										break;
								}

								if (((theItem.flags & ITEM_IDENTIFIED) || rogue.playbackOmniscience)
									&& runicWeaponChance(theItem, false, 0) < runicWeaponChance(theItem, true, (enchant + fp_enchantIncrement(theItem))))
                {
									sprintf(buf2, "(If the %s is enchanted, the chance will increase to %i%",
											theName,
											runicWeaponChance(theItem, true, (enchant + fp_enchantIncrement(theItem))));
									strcat(buf, buf2);
									if (nextLevelState) {
                      if (theItem.enchant2 == W_FORCE) {
                          sprintf(buf2, " and the distance will increase to %i.)",
                                  nextLevelState);
                      } else {
                          sprintf(buf2, " and the duration will increase to %i turns.)",
                                  nextLevelState);
                      }
									} else {
										strcpy(buf2, ".)");
									}
									strcat(buf, buf2);
								}
							} else {
								strcat(buf, ". ");
							}
						}

					} else if (theItem.flags & ITEM_IDENTIFIED) {
						sprintf(buf2, "\n\nGlowing runes of an indecipherable language run down the length of the %s. ",
								theName);
						strcat(buf, buf2);
					}
				}

				// equipped? cursed?
				if (theItem.flags & ITEM_EQUIPPED) {
					sprintf(buf2, "\n\nYou hold the %s at the ready%s. ",
							theName,
							((theItem.flags & ITEM_CURSED) ? ", and because it is cursed, you are powerless to let go" : ""));
					strcat(buf, buf2);
				} else if (((theItem.flags & (ITEM_IDENTIFIED | ITEM_MAGIC_DETECTED)) || rogue.playbackOmniscience)
						   && (theItem.flags & ITEM_CURSED))
        {
					sprintf(buf2, "\n\n%sYou can feel a malevolent magic lurking within the %s.%s ",
                            badColorEscape,
                            theName,
                            whiteColorEscape);
					strcat(buf, buf2);
				}

			} else if (theItem.category & ARMOR) {

				// runic?
				if (theItem.flags & ITEM_RUNIC) {
					if ((theItem.flags & ITEM_RUNIC_IDENTIFIED) || rogue.playbackOmniscience) {
						sprintf(buf2, "\n\nGlowing runes of %s adorn the %s. ",
								armorRunicNames[theItem.enchant2],
								theName);
						strcat(buf, buf2);

						// A_MULTIPLICITY, A_MUTUALITY, A_ABSORPTION, A_REPRISAL, A_IMMUNITY, A_REFLECTION, A_BURDEN, A_VULNERABILITY, A_IMMOLATION
						switch (theItem.enchant2) {
							case A_MULTIPLICITY:
								sprintf(buf2, "When worn, 33% of the time that an enemy's attack connects, %i allied spectral duplicate%s of your attacker will appear for 3 turns. ",
										fp_armorImageCount(enchant),
										(fp_armorImageCount(enchant) == 1 ? "" : "s"));
								if (fp_armorImageCount(enchant + fp_enchantIncrement(theItem)) > fp_armorImageCount(enchant)) {
									sprintf(buf3, "(If the %s is enchanted, the number of duplicates will increase to %i.) ",
											theName,
											(fp_armorImageCount(enchant + fp_enchantIncrement(theItem))));
									strcat(buf2, buf3);
								}
								break;
							case A_MUTUALITY:
								strcpy(buf2, "When worn, the damage that you incur from physical attacks will be split evenly among yourself and all other adjacent enemies. ");
								break;
							case A_ABSORPTION:
                if (theItem.flags & ITEM_IDENTIFIED) {
                    sprintf(buf2, "It will reduce the damage of inbound attacks by a random amount between 0 and %i, which is %i% of your current maximum health. (If the %s is enchanted, this maximum amount will %s %i.) ",
                            fp_armorAbsorptionMax(enchant),
                            Math.floor(100 * fp_armorAbsorptionMax(enchant) / player.info.maxHP),
                            theName,
                            (fp_armorAbsorptionMax(enchant) == fp_armorAbsorptionMax((enchant + fp_enchantIncrement(theItem))) ? "remain at" : "increase to"),
                            fp_armorAbsorptionMax((enchant + fp_enchantIncrement(theItem))));
                } else {
									strcpy(buf2, "It will reduce the damage of inbound attacks by a random amount determined by its enchantment level. ");
                }
								break;
							case A_REPRISAL:
                if (theItem.flags & ITEM_IDENTIFIED) {
                    sprintf(buf2, "Any enemy that attacks you will itself be wounded by %i% of the damage that it inflicts. (If the %s is enchanted, this percentage will increase to %i%.) ",
                            fp_armorReprisalPercent(enchant),
                            theName,
                            fp_armorReprisalPercent((enchant + fp_enchantIncrement(theItem))));
                } else {
                    strcpy(buf2, "Any enemy that attacks you will itself be wounded by a percentage (determined by enchantment level) of the damage that it inflicts. ");
                }
								break;
							case A_IMMUNITY:
                describeMonsterClass(buf3, theItem.vorpalEnemy, false);
								sprintf(buf2, "It offers complete protection from any attacking %s. ",
										buf3);
								break;
							case A_REFLECTION:
                if (theItem.flags & ITEM_IDENTIFIED) {
                    if (theItem.enchant1 > 0) {
                        const reflectChance = fp_reflectionChance(enchant);
                        const reflectChance2 = fp_reflectionChance(enchant + fp_enchantIncrement(theItem));
                        sprintf(buf2, "When worn, you will deflect %i% of incoming spells -- including directly back at their source %i% of the time. (If the armor is enchanted, these will increase to %i% and %i%.) ",
                                reflectChance,
                                Math.floor(reflectChance * reflectChance / 100),
                                reflectChance2,
                                Math.floor(reflectChance2 * reflectChance2 / 100));
                    } else if (theItem.enchant1 < 0) {
                        const reflectChance = fp_reflectionChance(enchant);
                        const reflectChance2 = fp_reflectionChance(enchant + fp_enchantIncrement(theItem));
                        sprintf(buf2, "When worn, %i% of your own spells will deflect from their target -- including directly back at you %i% of the time. (If the armor is enchanted, these will decrease to %i% and %i%.) ",
                                reflectChance,
                                Math.floor(reflectChance * reflectChance / 100),
                                reflectChance2,
                                Math.floor(reflectChance2 * reflectChance2 / 100));
                    }
                } else {
									strcpy(buf2, "When worn, you will deflect some percentage of incoming spells, determined by enchantment level. ");
                }
								break;
              case A_RESPIRATION:
									strcpy(buf2, "When worn, it will maintain a pocket of fresh air around you, rendering you immune to the effects of steam and all toxic gases. ");
                  break;
              case A_DAMPENING:
									strcpy(buf2, "When worn, it will safely absorb the concussive impact of any explosions (though you may still be burned). ");
                  break;
							case A_BURDEN:
								strcpy(buf2, "10% of the time it absorbs a blow, its strength requirement will permanently increase. ");
								break;
							case A_VULNERABILITY:
								strcpy(buf2, "While it is worn, inbound attacks will inflict twice as much damage. ");
								break;
              case A_IMMOLATION:
								strcpy(buf2, "10% of the time it absorbs a blow, it will explode in flames. ");
								break;
							default:
								break;
						}
						strcat(buf, buf2);
					} else if (theItem.flags & ITEM_IDENTIFIED) {
						sprintf(buf2, "\n\nGlowing runes of an indecipherable language spiral around the %s. ",
								theName);
						strcat(buf, buf2);
					}
				}

				// equipped? cursed?
				if (theItem.flags & ITEM_EQUIPPED) {
					sprintf(buf2, "\n\nYou are wearing the %s%s. ",
							theName,
							((theItem.flags & ITEM_CURSED) ? ", and because it is cursed, you are powerless to remove it" : ""));
					strcat(buf, buf2);
				} else if (((theItem.flags & (ITEM_IDENTIFIED | ITEM_MAGIC_DETECTED)) || rogue.playbackOmniscience)
						   && (theItem.flags & ITEM_CURSED))
        {
					sprintf(buf2, "\n\n%sYou can feel a malevolent magic lurking within the %s.%s ",
                            badColorEscape,
                            theName,
                            whiteColorEscape);
					strcat(buf, buf2);
				}
			}
			break;

		case STAFF:
			// charges

			newValue = apparentRingBonus(RING_WISDOM);
			if ((theItem.flags & ITEM_IDENTIFIED)  || rogue.playbackOmniscience) {
				sprintf(buf2, "\n\nThe %s has %i charges remaining out of a maximum of %i charges, and%s recovers a charge in approximately %i turns. ",
						theName,
						theItem.charges,
						theItem.enchant1,
            newValue == 0 ? "" : ", with your current rings,",
            Math.floor(staffChargeDuration(theItem) / fp_ringWisdomMultiplier(newValue << FP_BASE)));
				strcat(buf, buf2);
			} else if (theItem.flags & ITEM_MAX_CHARGES_KNOWN) {
				sprintf(buf2, "\n\nThe %s has a maximum of %i charges, and%s recovers a charge in approximately %i turns. ",
							theName,
              theItem.enchant1,
              newValue == 0 ? "" : ", with your current rings,",
              Math.floor(staffChargeDuration(theItem) / fp_ringWisdomMultiplier(newValue << FP_BASE)));
				strcat(buf, buf2);
			}

			// effect description
			if (((theItem.flags & (ITEM_IDENTIFIED | ITEM_MAX_CHARGES_KNOWN)) && staffTable[theItem.kind].identified)
				|| rogue.playbackOmniscience)
      {
				switch (theItem.kind) {
					case STAFF_LIGHTNING:
						sprintf(buf2, "This staff deals damage to every creature in its line of fire; nothing is immune. (If the staff is enchanted, its average damage will increase by %i%.)",
								Math.floor(100 * (fp_staffDamageLow(enchant + FP_FACTOR) + fp_staffDamageHigh(enchant + FP_FACTOR)) / (fp_staffDamageLow(enchant) + fp_staffDamageHigh(enchant)) - 100));
						break;
					case STAFF_FIRE:
						sprintf(buf2, "This staff deals damage to any creature that it hits, unless the creature is immune to fire. (If the staff is enchanted, its average damage will increase by %i%.) It also sets creatures and flammable terrain on fire.",
								Math.floor(100 * (fp_staffDamageLow(enchant + FP_FACTOR) + fp_staffDamageHigh(enchant + FP_FACTOR)) / (fp_staffDamageLow(enchant) + fp_staffDamageHigh(enchant)) - 100));
            break;
					case STAFF_POISON:
						sprintf(buf2, "The bolt from this staff will poison any creature that it hits for %i turns. (If the staff is enchanted, this will increase to %i turns.)",
								fp_staffPoison(enchant),
								fp_staffPoison(enchant + FP_FACTOR));
						break;
					case STAFF_TUNNELING:
						sprintf(buf2, "The bolt from this staff will dissolve %i layers of obstruction. (If the staff is enchanted, this will increase to %i layers.)",
								theItem.enchant1,
								theItem.enchant1 + 1);
						break;
					case STAFF_BLINKING:
						sprintf(buf2, "This staff enables you to teleport up to %i spaces. (If the staff is enchanted, this will increase to %i spaces.)",
								fp_staffBlinkDistance(enchant),
								fp_staffBlinkDistance(enchant + FP_FACTOR));
						break;
					case STAFF_ENTRANCEMENT:
						sprintf(buf2, "This staff will compel its target to mirror your movements for %i turns. (If the staff is enchanted, this will increase to %i turns.)",
								fp_staffEntrancementDuration(enchant),
								fp_staffEntrancementDuration(enchant + FP_FACTOR));
						break;
					case STAFF_HEALING:
						if (enchant < 10) {
							sprintf(buf2, "This staff will heal its target by %i% of its maximum health. (If the staff is enchanted, this will increase to %i%.)",
									theItem.enchant1 * 10,
									(theItem.enchant1 + 1) * 10);
						} else {
							strcpy(buf2, "This staff will completely heal its target.");
						}
						break;
					case STAFF_HASTE:
						sprintf(buf2, "This staff will cause its target to move twice as fast for %i turns. (If the staff is enchanted, this will increase to %i turns.)",
								fp_staffHasteDuration(enchant),
								fp_staffHasteDuration(enchant + FP_FACTOR));
						break;
					case STAFF_OBSTRUCTION:
						strcpy(buf2, "");
						break;
					case STAFF_DISCORD:
						sprintf(buf2, "This staff will cause discord for %i turns. (If the staff is enchanted, this will increase to %i turns.)",
								fp_staffDiscordDuration(enchant),
								fp_staffDiscordDuration(enchant + FP_FACTOR));
						break;
					case STAFF_CONJURATION:
						sprintf(buf2, "%i phantom blades will be called into service. (If the staff is enchanted, this will increase to %i blades.)",
								fp_staffBladeCount(enchant),
								fp_staffBladeCount(enchant + FP_FACTOR));
						break;
					case STAFF_PROTECTION:
						sprintf(buf2, "This staff will shield a creature for up to 20 turns against up to %i damage. (If the staff is enchanted, this will increase to %i damage.)",
								Math.floor(fp_staffProtection(enchant) / 10),
								Math.floor(fp_staffProtection(enchant + FP_FACTOR) / 10));
						break;

					default:
						strcpy(buf2, "No one knows what this staff does.");
						break;
				}
        if (strlen(buf2)) {
            strcat(buf, "\n\n");
            strcat(buf, buf2);
        }
			}
			break;

		case WAND:
			strcat(buf, "\n\n");
			if ((theItem.flags & (ITEM_IDENTIFIED | ITEM_MAX_CHARGES_KNOWN)) || rogue.playbackOmniscience) {
				if (theItem.charges) {
					sprintf(buf2, "%i charge%s remain%s. Enchanting this wand will add %i charge%s.",
							theItem.charges,
							(theItem.charges == 1 ? "" : "s"),
							(theItem.charges == 1 ? "s" : ""),
              wandTable[theItem.kind].range.lowerBound,
              (wandTable[theItem.kind].range.lowerBound == 1 ? "" : "s"));
				} else {
					sprintf(buf2, "No charges remain.  Enchanting this wand will add %i charge%s.",
                            wandTable[theItem.kind].range.lowerBound,
                            (wandTable[theItem.kind].range.lowerBound == 1 ? "" : "s"));
				}
			} else {
				if (theItem.enchant2) {
					sprintf(buf2, "You have used this wand %i time%s, but do not know how many charges, if any, remain.",
							theItem.enchant2,
							(theItem.enchant2 == 1 ? "" : "s"));
				} else {
					strcpy(buf2, "You have not yet used this wand.");
				}

				if (wandTable[theItem.kind].identified) {
					strcat(buf, buf2);
					sprintf(buf2, " Wands of this type can be found with %i to %i charges. Enchanting this wand will add %i charge%s.",
							wandTable[theItem.kind].range.lowerBound,
							wandTable[theItem.kind].range.upperBound,
              wandTable[theItem.kind].range.lowerBound,
              (wandTable[theItem.kind].range.lowerBound == 1 ? "" : "s"));
				}
			}
			strcat(buf, buf2);
			break;

		case RING:
			if (((theItem.flags & ITEM_IDENTIFIED) && ringTable[theItem.kind].identified) || rogue.playbackOmniscience) {
        if (theItem.enchant1) {
            switch (theItem.kind) {
                case RING_CLAIRVOYANCE:
                    if (theItem.enchant1 > 0) {
                        sprintf(buf2, "\n\nThis ring provides magical sight with a radius of %i. (If the ring is enchanted, this will increase to %i.)",
                                theItem.enchant1 + 1,
                                theItem.enchant1 + 2);
                    } else {
                        sprintf(buf2, "\n\nThis ring magically blinds you to a radius of %i. (If the ring is enchanted, this will decrease to %i.)",
                                (theItem.enchant1 * -1) + 1,
                                (theItem.enchant1 * -1));
                    }
                    strcat(buf, buf2);
                    break;
                case RING_REGENERATION:
                    sprintf(buf2, "\n\nWith this ring equipped, you will regenerate all of your health in %li turns (instead of %li). (If the ring is enchanted, this will decrease to %li turns.)",
                            Math.floor(fp_turnsForFullRegenInThousandths(theItem.enchant1) / 1000),
                            TURNS_FOR_FULL_REGEN,
                            Math.floor(fp_turnsForFullRegenInThousandths(theItem.enchant1 + 1) / 1000));
                    strcat(buf, buf2);
                    break;
                case RING_TRANSFERENCE:
                    sprintf(buf2, "\n\nDealing direct damage to a creature (whether in melee or otherwise) will %s you by %i% of the damage dealt. (If the ring is enchanted, this will %s to %i%.)",
                            (theItem.enchant1 >= 0 ? "heal" : "harm"),
                            abs(theItem.enchant1) * 5,
                            (theItem.enchant1 >= 0 ? "increase" : "decrease"),
                            abs(theItem.enchant1 + 1) * 5);
                    strcat(buf, buf2);
                    break;
                case RING_WISDOM:
                    sprintf(buf2, "\n\nWhen worn, your staffs will recharge at %i% of their normal rate. (If the ring is enchanted, the rate will increase to %i% of the normal rate.)",
											Math.floor(100 * fp_ringWisdomMultiplier(enchant) >> FP_BASE),
											Math.floor(100 * fp_ringWisdomMultiplier(enchant + FP_FACTOR) >> FP_BASE));
                    strcat(buf, buf2);
                    break;
                case RING_REAPING:
                    sprintf(buf2, "\n\nEach blow that you land with a weapon will %s your staffs and charms by 0-%i turns per point of damage dealt. (If the ring is enchanted, this will %s to 0-%i turns per point of damage.)",
                            (theItem.enchant1 >= 0 ? "recharge" : "drain"),
                            abs(theItem.enchant1),
                            (theItem.enchant1 >= 0 ? "increase" : "decrease"),
                            abs(theItem.enchant1 + 1));
                    strcat(buf, buf2);
                    break;
                default:
                    break;
            }
        }
			} else {
				sprintf(buf2, "\n\nIt will reveal its secrets if worn for %i%s turn%s",
						theItem.charges,
						(theItem.charges == RING_DELAY_TO_AUTO_ID ? "" : " more"),
						(theItem.charges == 1 ? "" : "s"));
				strcat(buf, buf2);

        if ((theItem.charges < RING_DELAY_TO_AUTO_ID || (theItem.flags & (ITEM_MAGIC_DETECTED | ITEM_IDENTIFIED)))
            && theItem.enchant1 > 0) // Mention the unknown-positive-ring footnote only if it's good magic and you know it.
        {
            sprintf(buf2, ", and until you understand its secrets, it will function as a +%i ring.", theItem.timesEnchanted + 1);
            strcat(buf, buf2);
        } else {
						strcat(buf, ".");
        }
			}

			// equipped? cursed?
			if (theItem.flags & ITEM_EQUIPPED) {
				sprintf(buf2, "\n\nThe %s is on your finger%s. ",
						theName,
						((theItem.flags & ITEM_CURSED) ? ", and because it is cursed, you are powerless to remove it" : ""));
				strcat(buf, buf2);
			} else if (((theItem.flags & (ITEM_IDENTIFIED | ITEM_MAGIC_DETECTED)) || rogue.playbackOmniscience)
					   && (theItem.flags & ITEM_CURSED))
      {
				sprintf(buf2, "\n\n%sYou can feel a malevolent magic lurking within the %s.%s ",
                        badColorEscape,
                        theName,
                        whiteColorEscape);
				strcat(buf, buf2);
			}
			break;
  case CHARM:
      switch (theItem.kind) {
          case CHARM_HEALTH:
              sprintf(buf2, "\n\nWhen used, the charm will heal %i% of your health and recharge in %i turns. (If the charm is enchanted, it will heal %i% of your health and recharge in %i turns.)",
											fp_charmHealing(enchant),
											charmRechargeDelay(theItem.kind, theItem.enchant1),
											fp_charmHealing(enchant + FP_FACTOR),
											charmRechargeDelay(theItem.kind, theItem.enchant1 + 1));
              break;
          case CHARM_PROTECTION:
							sprintf(buf2, "\n\nWhen used, the charm will shield you for up to 20 turns for up to %i% of your total health and recharge in %i turns. (If the charm is enchanted, it will shield up to %i% of your total health and recharge in %i turns.)",
											Math.floor(100 * fp_charmProtection(enchant) / 10 / player.info.maxHP),
											charmRechargeDelay(theItem.kind, theItem.enchant1),
											Math.floor(100 * fp_charmProtection(enchant + FP_FACTOR) / 10 / player.info.maxHP),
											charmRechargeDelay(theItem.kind, theItem.enchant1 + 1));
              break;
          case CHARM_HASTE:
              sprintf(buf2, "\n\nWhen used, the charm will haste you for %i turns and recharge in %i turns. (If the charm is enchanted, the haste will last %i turns and it will recharge in %i turns.)",
                      charmEffectDuration(theItem.kind, theItem.enchant1),
                      charmRechargeDelay(theItem.kind, theItem.enchant1),
                      charmEffectDuration(theItem.kind, theItem.enchant1 + 1),
                      charmRechargeDelay(theItem.kind, theItem.enchant1 + 1));
              break;
          case CHARM_FIRE_IMMUNITY:
              sprintf(buf2, "\n\nWhen used, the charm will grant you immunity to fire for %i turns and recharge in %i turns. (If the charm is enchanted, the immunity will last %i turns and it will recharge in %i turns.)",
                      charmEffectDuration(theItem.kind, theItem.enchant1),
                      charmRechargeDelay(theItem.kind, theItem.enchant1),
                      charmEffectDuration(theItem.kind, theItem.enchant1 + 1),
                      charmRechargeDelay(theItem.kind, theItem.enchant1 + 1));
              break;
          case CHARM_INVISIBILITY:
              sprintf(buf2, "\n\nWhen used, the charm will turn you invisible for %i turns and recharge in %i turns. While invisible, monsters more than two spaces away cannot track you. (If the charm is enchanted, the invisibility will last %i turns and it will recharge in %i turns.)",
                      charmEffectDuration(theItem.kind, theItem.enchant1),
                      charmRechargeDelay(theItem.kind, theItem.enchant1),
                      charmEffectDuration(theItem.kind, theItem.enchant1 + 1),
                      charmRechargeDelay(theItem.kind, theItem.enchant1 + 1));
              break;
          case CHARM_TELEPATHY:
              sprintf(buf2, "\n\nWhen used, the charm will grant you telepathy for %i turns and recharge in %i turns. (If the charm is enchanted, the telepathy will last %i turns and it will recharge in %i turns.)",
                      charmEffectDuration(theItem.kind, theItem.enchant1),
                      charmRechargeDelay(theItem.kind, theItem.enchant1),
                      charmEffectDuration(theItem.kind, theItem.enchant1 + 1),
                      charmRechargeDelay(theItem.kind, theItem.enchant1 + 1));
              break;
          case CHARM_LEVITATION:
              sprintf(buf2, "\n\nWhen used, the charm will lift you off the ground for %i turns and recharge in %i turns. (If the charm is enchanted, the levitation will last %i turns and it will recharge in %i turns.)",
                      charmEffectDuration(theItem.kind, theItem.enchant1),
                      charmRechargeDelay(theItem.kind, theItem.enchant1),
                      charmEffectDuration(theItem.kind, theItem.enchant1 + 1),
                      charmRechargeDelay(theItem.kind, theItem.enchant1 + 1));
              break;
          case CHARM_SHATTERING:
							sprintf(buf2, "\n\nWhen used, the charm will dissolve the nearby walls up to %i spaces away, and recharge in %i turns. (If the charm is enchanted, it will reach up to %i spaces and recharge in %i turns.)",
											fp_charmShattering(enchant),
											charmRechargeDelay(theItem.kind, theItem.enchant1),
											fp_charmShattering(enchant + FP_FACTOR),
											charmRechargeDelay(theItem.kind, theItem.enchant1 + 1));
              break;
          case CHARM_GUARDIAN:
              sprintf(buf2, "\n\nWhen used, a guardian will materialize for %i turns, and the charm will recharge in %i turns. (If the charm is enchanted, the guardian will last for %i turns and the charm will recharge in %i turns.)",
											fp_charmGuardianLifespan(enchant),
											charmRechargeDelay(theItem.kind, theItem.enchant1),
											fp_charmGuardianLifespan(enchant + FP_FACTOR),
											charmRechargeDelay(theItem.kind, theItem.enchant1 + 1));
              break;
          case CHARM_TELEPORTATION:
              sprintf(buf2, "\n\nWhen used, the charm will teleport you elsewhere in the dungeon and recharge in %i turns. (If the charm is enchanted, it will recharge in %i turns.)",
                      charmRechargeDelay(theItem.kind, theItem.enchant1),
                      charmRechargeDelay(theItem.kind, theItem.enchant1 + 1));
              break;
          case CHARM_RECHARGING:
              sprintf(buf2, "\n\nWhen used, the charm will recharge your staffs (though not your wands or charms), after which it will recharge in %i turns. (If the charm is enchanted, it will recharge in %i turns.)",
                      charmRechargeDelay(theItem.kind, theItem.enchant1),
                      charmRechargeDelay(theItem.kind, theItem.enchant1 + 1));
              break;
          case CHARM_NEGATION:
              sprintf(buf2, "\n\nWhen used, the charm will negate all magical effects on the creatures in your field of view and the items on the ground up to %i spaces away, and recharge in %i turns. (If the charm is enchanted, it will reach up to %i spaces and recharge in %i turns.)",
											fp_charmNegationRadius(enchant),
											charmRechargeDelay(theItem.kind, theItem.enchant1),
											fp_charmNegationRadius(enchant + FP_FACTOR),
											charmRechargeDelay(theItem.kind, theItem.enchant1 + 1));
              break;
          default:
              break;
      }
      strcat(buf, buf2);
      break;
		default:
			break;
	}

  return buf;
}

function displayMagicCharForItem( /* item */ theItem) {
	if (!(theItem.flags & ITEM_MAGIC_DETECTED)
		|| (theItem.category & PRENAMED_CATEGORY)) {
		return false;
	}
  return true;
}

async function displayInventory(categoryMask,
					  requiredFlags,
					  forbiddenFlags,
					  waitForAcknowledge,
					  includeButtons)
{
	let theItem;		// item *
	let i, j, m, maxLength = 0, itemNumber, itemCount, equippedItemCount;
	let extraLineCount = 0;
	let itemList = []; // item *[DROWS];
	const buf = STRING(); // char[COLS*3];
	let theKey;
	let theEvent = rogueEvent();
	let magicDetected, repeatDisplay;
	let highlightItemLine, itemSpaceRemaining;
	const dbuf = GRID(COLS, ROWS, cellDisplayBuffer); // cellDisplayBuffer[COLS][ROWS];
	const rbuf = GRID(COLS, ROWS, cellDisplayBuffer); // cellDisplayBuffer[COLS][ROWS];
	const buttons = ARRAY(50, brogueButton); // brogueButton[50] = {{{0}}};
	let actionKey;
	let darkItemColor = color();

	const whiteColorEscapeSequence = STRING(),
				grayColorEscapeSequence = STRING(),
				yellowColorEscapeSequence = STRING(),
				darkYellowColorEscapeSequence = STRING(),
				goodColorEscapeSequence = STRING(),
				badColorEscapeSequence = STRING();
	let magicEscapePtr;	// char *

	// assureCosmeticRNG();

	clearCursorPath();
	clearDisplayBuffer(dbuf);

	encodeMessageColor(whiteColorEscapeSequence, 0, white);
	encodeMessageColor(grayColorEscapeSequence, 0, gray);
	encodeMessageColor(yellowColorEscapeSequence, 0, itemColor);
	darkItemColor.copy(itemColor);
	applyColorAverage(darkItemColor, black, 50);
	encodeMessageColor(darkYellowColorEscapeSequence, 0, darkItemColor);
	encodeMessageColor(goodColorEscapeSequence, 0, goodMessageColor);
	encodeMessageColor(badColorEscapeSequence, 0, badMessageColor);

	if (packItems.nextItem == NULL) {
		confirmMessages();
		message("Your pack is empty!", false);
		// restoreRNG();
		return 0;
	}

	magicDetected = false;
	for (theItem = packItems.nextItem; theItem != NULL; theItem = theItem.nextItem) {
		if (displayMagicCharForItem(theItem) && (theItem.flags & ITEM_MAGIC_DETECTED)) {
			magicDetected = true;
		}
	}

	// List the items in the order we want to display them, with equipped items at the top.
	itemNumber = 0;
	equippedItemCount = 0;
	// First, the equipped weapon if any.
	if (rogue.weapon) {
		itemList[itemNumber] = rogue.weapon;
		itemNumber++;
		equippedItemCount++;
	}
	// Now, the equipped armor if any.
	if (rogue.armor) {
		itemList[itemNumber] = rogue.armor;
		itemNumber++;
		equippedItemCount++;
	}
	// Now, the equipped rings, if any.
	if (rogue.ringLeft) {
		itemList[itemNumber] = rogue.ringLeft;
		itemNumber++;
		equippedItemCount++;
	}
	if (rogue.ringRight) {
		itemList[itemNumber] = rogue.ringRight;
		itemNumber++;
		equippedItemCount++;
	}
	// Now all of the non-equipped items.
	for (theItem = packItems.nextItem; theItem != NULL; theItem = theItem.nextItem) {
		if (!(theItem.flags & ITEM_EQUIPPED)) {
			itemList[itemNumber] = theItem;
			itemNumber++;
		}
	}

	// Initialize the buttons:
	for (i=0; i < max(MAX_PACK_ITEMS, ROWS); i++) {
		buttons[i].y = mapToWindowY(i + (equippedItemCount && i >= equippedItemCount ? 1 : 0));
		buttons[i].buttonColor.copy(black);
		buttons[i].opacity = INTERFACE_OPACITY;
		buttons[i].flags |= B_DRAW;
	}
	// Now prepare the buttons.
	//for (theItem = packItems.nextItem; theItem != NULL; theItem = theItem.nextItem) {

  const closeParen = KEYBOARD_LABELS ? ')' : ' ';
	for (i=0; i<itemNumber; i++) {
		theItem = itemList[i];
		// Set button parameters for the item:
		buttons[i].flags |= (B_DRAW | B_GRADIENT | B_ENABLED);
		if (!waitForAcknowledge) {
			buttons[i].flags |= B_KEYPRESS_HIGHLIGHT;
		}
		buttons[i].hotkey[0] = theItem.inventoryLetter;
		buttons[i].hotkey[1] = theItem.inventoryLetter.toUpperCase();

		if ((theItem.category & categoryMask) &&
			!(~(theItem.flags) & requiredFlags) &&
			!(theItem.flags & forbiddenFlags))
		{
			buttons[i].flags |= (B_HOVER_ENABLED);
		}

		// Set the text for the button:
		itemName(theItem, buf, true, true, (buttons[i].flags & B_HOVER_ENABLED) ? white : gray);
		capitalize(buf);

		if ((theItem.flags & ITEM_MAGIC_DETECTED) && !(theItem.category & AMULET)) { // Won't include food, keys, lumenstones or amulet.

			buttons[i].symbol[0] = (itemMagicChar(theItem) ? itemMagicChar(theItem) : '-');
			if (buttons[i].symbol[0] == '-') {
				magicEscapePtr = yellowColorEscapeSequence;
			} else if (buttons[i].symbol[0] == GOOD_MAGIC_CHAR) {
				magicEscapePtr = goodColorEscapeSequence;
			} else {
				magicEscapePtr = badColorEscapeSequence;
			}

			// The first '*' is the magic detection symbol, e.g. '-' for non-magical.
			// The second '*' is the item character, e.g. ':' for food.
			sprintf(buttons[i].text, " %c%c %s* %s* %s%s%s",
					KEYBOARD_LABELS ? theItem.inventoryLetter : ' ',
					(theItem.flags & ITEM_PROTECTED ? '}' : closeParen),
					magicEscapePtr,
					(buttons[i].flags & B_HOVER_ENABLED) ? yellowColorEscapeSequence : darkYellowColorEscapeSequence,
					(buttons[i].flags & B_HOVER_ENABLED) ? whiteColorEscapeSequence : grayColorEscapeSequence,
					buf,
					// grayColorEscapeSequence,
					(theItem.flags & ITEM_EQUIPPED ? ((theItem.category & WEAPON) ? " (in hand) " : " (worn) ") : ""));
			buttons[i].symbol[1] = theItem.displayChar;
		} else {
			sprintf(buttons[i].text, " %c%c %s%s* %s%s%s", // The '*' is the item character, e.g. ':' for food.
					KEYBOARD_LABELS ? theItem.inventoryLetter : ' ',
					(theItem.flags & ITEM_PROTECTED ? '}' : closeParen),
					(magicDetected ? "  " : ""), // For proper spacing when this item is not detected but another is.
					(buttons[i].flags & B_HOVER_ENABLED) ? yellowColorEscapeSequence : darkYellowColorEscapeSequence,
					(buttons[i].flags & B_HOVER_ENABLED) ? whiteColorEscapeSequence : grayColorEscapeSequence,
					buf,
					// grayColorEscapeSequence,
					(theItem.flags & ITEM_EQUIPPED ? ((theItem.category & WEAPON) ? " (in hand) " : " (worn) ") : ""));
			buttons[i].symbol[0] = theItem.displayChar;
		}

		// Keep track of the maximum width needed:
		maxLength = max(maxLength, strLenWithoutEscapes(buttons[i].text));

        //		itemList[itemNumber] = theItem;
        //
        //		itemNumber++;
	}
	//printf("\nMaxlength: %i", maxLength);
	itemCount = itemNumber;
	if (!itemNumber) {
		confirmMessages();
		message("Nothing of that type!", false);
		// restoreRNG();
		return 0;
	}
	if (waitForAcknowledge) {
		// Add the two extra lines as disabled buttons.
		itemSpaceRemaining = MAX_PACK_ITEMS - numberOfItemsInPack();
		if (itemSpaceRemaining) {
			sprintf(buttons[itemNumber + extraLineCount].text, "%s%s    You have room for %i more item%s.",
					grayColorEscapeSequence,
					(magicDetected ? "  " : ""),
					itemSpaceRemaining,
					(itemSpaceRemaining == 1 ? "" : "s"));
		} else {
			sprintf(buttons[itemNumber + extraLineCount].text, "%s%s    Your pack is full.",
					grayColorEscapeSequence,
					(magicDetected ? "  " : ""));
		}
		maxLength = max(maxLength, (strLenWithoutEscapes(buttons[itemNumber + extraLineCount].text)));
		extraLineCount++;

		sprintf(buttons[itemNumber + extraLineCount].text, KEYBOARD_LABELS ? "%s%s -- press (a-z) for more info -- " : "%s%s -- touch an item for more info -- ",
				grayColorEscapeSequence,
				(magicDetected ? "  " : ""));
		maxLength = max(maxLength, (strLenWithoutEscapes(buttons[itemNumber + extraLineCount].text)));
		extraLineCount++;
	}
	if (equippedItemCount) {
		// Add a separator button to fill in the blank line between equipped and unequipped items.
		sprintf(buttons[itemNumber + extraLineCount].text, "      %s%s---",
				(magicDetected ? "  " : ""),
				grayColorEscapeSequence);
		buttons[itemNumber + extraLineCount].y = mapToWindowY(equippedItemCount);
		extraLineCount++;
	}

	for (i=0; i < itemNumber + extraLineCount; i++) {

		// Position the button.
		buttons[i].x = COLS - maxLength;

		// Pad the button label with space, so the button reaches to the right edge of the screen.
		m = strlen(buttons[i].text);
		for (j=buttons[i].x + strLenWithoutEscapes(buttons[i].text); j < COLS; j++) {
			buttons[i].text.append(' ');
		}

		// Display the button. This would be redundant with the button loop,
		// except that we want the display to stick around until we get rid of it.
		drawButton(buttons[i], BUTTON_NORMAL, dbuf);
	}

	// Add invisible previous and next buttons, so up and down arrows can select items.
	// Previous
	buttons[itemNumber + extraLineCount + 0].flags = B_ENABLED; // clear everything else
	buttons[itemNumber + extraLineCount + 0].hotkey[0] = NUMPAD_8;
	buttons[itemNumber + extraLineCount + 0].hotkey[1] = UP_ARROW;
	// Next
	buttons[itemNumber + extraLineCount + 1].flags = B_ENABLED; // clear everything else
	buttons[itemNumber + extraLineCount + 1].hotkey[0] = NUMPAD_2;
	buttons[itemNumber + extraLineCount + 1].hotkey[1] = DOWN_ARROW;

	overlayDisplayBuffer(dbuf, rbuf);

	do {
		repeatDisplay = false;

		// Do the button loop.
		highlightItemLine = -1;
		overlayDisplayBuffer(rbuf, NULL);	// Remove the inventory display while the buttons are active,
											// since they look the same and we don't want their opacities to stack.

		highlightItemLine = await buttonInputLoop(buttons,
											itemCount + extraLineCount + 2, // the 2 is for up/down hotkeys
											COLS - maxLength,
											mapToWindowY(0),
											maxLength,
											itemNumber + extraLineCount,
											theEvent);
		if (highlightItemLine == itemNumber + extraLineCount + 0) {
			// Up key
			highlightItemLine = itemNumber - 1;
			theEvent.shiftKey = true;
		} else if (highlightItemLine == itemNumber + extraLineCount + 1) {
			// Down key
			highlightItemLine = 0;
			theEvent.shiftKey = true;
		}

		if (highlightItemLine >= 0) {
			theKey = itemList[highlightItemLine].inventoryLetter;
			theItem = itemList[highlightItemLine];
		} else {
			theKey = ESCAPE_KEY;
		}

		// Was an item selected?
		if (highlightItemLine > -1 && (waitForAcknowledge || theEvent.shiftKey || theEvent.controlKey)) {

			do {
				// Yes. Highlight the selected item. Do this by changing the button color and re-displaying it.
				overlayDisplayBuffer(dbuf, NULL);

				//buttons[highlightItemLine].buttonColor = interfaceBoxColor;
				drawButton(buttons[highlightItemLine], BUTTON_PRESSED, NULL);
				//buttons[highlightItemLine].buttonColor = black;

				if (theEvent.shiftKey || theEvent.controlKey || waitForAcknowledge) {
					// Display an information window about the item.
					actionKey = await printCarriedItemDetails(theItem, max(2, mapToWindowX(DCOLS - maxLength - 42)), mapToWindowY(2), 40, includeButtons, NULL);

					overlayDisplayBuffer(rbuf, NULL); // remove the item info window

					if (actionKey == -1) {
						repeatDisplay = true;
						overlayDisplayBuffer(dbuf, NULL); // redisplay the inventory
					} else {
						// restoreRNG();
						repeatDisplay = false;
						overlayDisplayBuffer(rbuf, NULL); // restore the original screen
					}

					switch (actionKey) {
						case APPLY_KEY:
							await apply(theItem, true);
							break;
						case EQUIP_KEY:
							await equip(theItem);
							break;
						case UNEQUIP_KEY:
							await unequip(theItem);
							break;
						case DROP_KEY:
							await drop(theItem);
							break;
						case THROW_KEY:
							await throwCommand(theItem);
							break;
						case RELABEL_KEY:
							await relabel(theItem);
							break;
						case CALL_KEY:
							await call(theItem);
							break;
						case UP_KEY:
							highlightItemLine = highlightItemLine - 1;
							if (highlightItemLine < 0) {
								highlightItemLine = itemNumber - 1;
							}
							break;
						case DOWN_KEY:
							highlightItemLine = highlightItemLine + 1;
							if (highlightItemLine >= itemNumber) {
								highlightItemLine = 0;
							}
							break;
						default:
							break;
					}

					if (actionKey == UP_KEY || actionKey == DOWN_KEY) {
						theKey = itemList[highlightItemLine].inventoryLetter;
						theItem = itemList[highlightItemLine];
					} else if (actionKey != -1) {	// cannot use > -1 b/c we have a string
						// Player took an action directly from the item screen; we're done here.
						// restoreRNG();
						return 0;
					}
				}
			} while (actionKey == UP_KEY || actionKey == DOWN_KEY);
		}
	} while (repeatDisplay); // so you can get info on multiple items sequentially

	overlayDisplayBuffer(rbuf, NULL); // restore the original screen

	// restoreRNG();
	return theKey;
}


function numberOfMatchingPackItems( categoryMask, requiredFlags,  forbiddenFlags, displayErrors) {
	let theItem;		// item *
	let matchingItemCount = 0;

	if (packItems.nextItem == NULL) {
		if (displayErrors) {
			confirmMessages();
			message("Your pack is empty!", false);
		}
		return 0;
	}

	for (theItem = packItems.nextItem; theItem != NULL; theItem = theItem.nextItem) {

		if (theItem.category & categoryMask &&
			!(~(theItem.flags) & requiredFlags) &&
			!(theItem.flags & forbiddenFlags))
		{
			matchingItemCount++;
		}
	}

	if (matchingItemCount == 0) {
		if (displayErrors) {
			confirmMessages();
			message("You have nothing suitable.", false);
		}
		return 0;
	}

	return matchingItemCount;
}

function updateEncumbrance() {
	let moveSpeed, attackSpeed;

	moveSpeed = player.info.movementSpeed;
	attackSpeed = player.info.attackSpeed;

	if (player.status[STATUS_HASTED]) {
		moveSpeed = Math.floor(moveSpeed/2);
		attackSpeed = Math.floor(attackSpeed/2);
	} else if (player.status[STATUS_SLOWED]) {
		moveSpeed *= 2;
		attackSpeed *= 2;
	}

	player.movementSpeed = moveSpeed;
	player.attackSpeed = attackSpeed;

	recalculateEquipmentBonuses();
}

function displayedArmorValue() {
    if (!rogue.armor || (rogue.armor.flags & ITEM_IDENTIFIED)) {
        return Math.floor(player.info.defense / 10);
    } else {
			return Math.floor(((armorTable[rogue.armor.kind].range.upperBound + armorTable[rogue.armor.kind].range.lowerBound << FP_BASE) / 2 / 10
											 + fp_strengthModifier(rogue.armor)) >> FP_BASE);
    }
}

function strengthCheck( /* item */ theItem) {
	const buf1 = STRING(), buf2 = STRING(); // char[COLS*2];
	let strengthDeficiency;

	updateEncumbrance();
	if (theItem) {
		if (theItem.category & WEAPON && theItem.strengthRequired > rogue.strength - player.weaknessAmount) {
			strengthDeficiency = theItem.strengthRequired - max(0, rogue.strength - player.weaknessAmount);
			strcpy(buf1, "");
			itemName(theItem, buf1, false, false, NULL);
			sprintf(buf2, "You can barely lift the %s; %i more strength would be ideal.", buf1, strengthDeficiency);
			message(buf2, false);
		}

		if (theItem.category & ARMOR && theItem.strengthRequired > rogue.strength - player.weaknessAmount) {
			strengthDeficiency = theItem.strengthRequired - max(0, rogue.strength - player.weaknessAmount);
			strcpy(buf1, "");
			itemName(theItem, buf1, false, false, NULL);
			sprintf(buf2, "You stagger under the weight of the %s; %i more strength would be ideal.",
					buf1, strengthDeficiency);
			message(buf2, false);
		}
	}
}

function canEquip(/* item */ theItem) {
	let previouslyEquippedItem = NULL;	// item *

	if (theItem.category & WEAPON) {
		previouslyEquippedItem = rogue.weapon;
	} else if (theItem.category & ARMOR) {
		previouslyEquippedItem = rogue.armor;
	}
	if (previouslyEquippedItem && (previouslyEquippedItem.flags & ITEM_CURSED)) {
		return false; // already using a cursed item
	}

	if ((theItem.category & RING) && rogue.ringLeft && rogue.ringRight) {
		return false;
	}
	return true;
}

// Will prompt for an item if none is given.
// Equips the item and records input if successful.
// Player's failure to select an item will result in failure.
// Failure does not record input.
async function equip( /* item */ theItem) {
	const buf1 = STRING(), buf2 = STRING();
	const command = []; // cahr[10];
	let c = 0;
	let theItem2;	// item *

	command[c++] = EQUIP_KEY;
	if (!theItem) {
		theItem = await promptForItemOfType((WEAPON|ARMOR|RING), 0, ITEM_EQUIPPED,
                                      KEYBOARD_LABELS ? "Equip what? (a-z, shift for more info; or <esc> to cancel)" : "Equip what?", true);
	}
	if (theItem == NULL) {
		return;
	}

	command[c++] = theItem.inventoryLetter;

	if (theItem.category & (WEAPON|ARMOR|RING)) {

		if (theItem.category & RING) {
			if (theItem.flags & ITEM_EQUIPPED) {
				confirmMessages();
				message("you are already wearing that ring.", false);
				return;
			} else if (rogue.ringLeft && rogue.ringRight) {
				confirmMessages();
				theItem2 = await promptForItemOfType((RING), ITEM_EQUIPPED, 0,
											   "You are already wearing two rings; remove which first?", true);
				if (!theItem2 || theItem2.category != RING || !(theItem2.flags & ITEM_EQUIPPED)) {
					if (theItem2) { // No message if canceled or did an inventory action instead.
						message("Invalid entry.", false);
					}
					return;
				} else {
					if (theItem2.flags & ITEM_CURSED) {
						itemName(theItem2, buf1, false, false, NULL);
						sprintf(buf2, "You can't remove your %s: it appears to be cursed.", buf1);
						confirmMessages();
						message(buf2, itemMessageColor, false);
						return;
					}
					unequipItem(theItem2, false);
					command[c++] = theItem2.inventoryLetter;
				}
			}
		}

		if (theItem.flags & ITEM_EQUIPPED) {
			confirmMessages();
			message("already equipped.", false);
			return;
		}

		if (!canEquip(theItem)) {
			// equip failed because current item is cursed
			if (theItem.category & WEAPON) {
				itemName(rogue.weapon, buf1, false, false, NULL);
			} else if (theItem.category & ARMOR) {
				itemName(rogue.armor, buf1, false, false, NULL);
			} else {
				sprintf(buf1, "one");
			}
			sprintf(buf2, "You can't; the %s you are using appears to be cursed.", buf1);
			confirmMessages();
			message(buf2, itemMessageColor, false);
			return;
		}
		command[c] = null;
		recordKeystrokeSequence(command);

		equipItem(theItem, false);

		itemName(theItem, buf2, true, true, NULL);
		sprintf(buf1, "Now %s %s.", (theItem.category & WEAPON ? "wielding" : "wearing"), buf2);
		confirmMessages();
		message(buf1, itemMessageColor, false);

		strengthCheck(theItem);

		if (theItem.flags & ITEM_CURSED) {
			itemName(theItem, buf2, false, false, NULL);
			switch(theItem.category) {
				case WEAPON:
					sprintf(buf1, "you wince as your grip involuntarily tightens around your %s.", buf2);
					break;
				case ARMOR:
					sprintf(buf1, "your %s constricts around you painfully.", buf2);
					break;
				case RING:
					sprintf(buf1, "your %s tightens around your finger painfully.", buf2);
					break;
				default:
					sprintf(buf1, "your %s seizes you with a malevolent force.", buf2);
					break;
			}
			message(buf1, itemMessageColor, false);
		}
		await playerTurnEnded();
	} else {
		confirmMessages();
		message("You can't equip that.", false);
	}
}


// Returns whether the given item is a key that can unlock the given location.
// An item qualifies if:
// (1) it's a key (has ITEM_IS_KEY flag),
// (2) its originDepth matches the depth, and
// (3) either its key (x, y) location matches (x, y), or its machine number matches the machine number at (x, y).
function keyMatchesLocation( /* item */ theItem, x, y) {
	let i;

	if ((theItem.flags & ITEM_IS_KEY)
		&& theItem.originDepth == rogue.depthLevel)
	{
		for (i=0; i < KEY_ID_MAXIMUM && (theItem.keyLoc[i].x || theItem.keyLoc[i].machine); i++) {
			if (theItem.keyLoc[i].x == x && theItem.keyLoc[i].y == y) {
				return true;
			} else if (theItem.keyLoc[i].machine == pmap[x][y].machineNumber) {
				return true;
			}
		}
	}
	return false;
}


function keyInPackFor(x, y) {
	let theItem;		// item *

	for (theItem = packItems.nextItem; theItem != NULL; theItem = theItem.nextItem) {
		if (keyMatchesLocation(theItem, x, y)) {
			return theItem;
		}
	}
	return NULL;
}

function keyOnTileAt(x, y) {
	let theItem;		// item *
	let monst;			// creature *

	if ((pmap[x][y].flags & HAS_PLAYER)
		&& player.xLoc == x
		&& player.yLoc == y
		&& keyInPackFor(x, y))
	{
		return keyInPackFor(x, y);
	}
	if (pmap[x][y].flags & HAS_ITEM) {
		theItem = itemAtLoc(x, y);
		if (keyMatchesLocation(theItem, x, y)) {
			return theItem;
		}
	}
	if (pmap[x][y].flags & HAS_MONSTER) {
		monst = monsterAtLoc(x, y);
		if (monst.carriedItem) {
			theItem = monst.carriedItem;
			if (keyMatchesLocation(theItem, x, y)) {
				return theItem;
			}
		}
	}
	return NULL;
}

// Aggroes out to the given distance.
async function aggravateMonsters(distance, x, y, /* color */ flashColor) {
	let monst;	// creature *
	let i, j, grid;

  rogue.wpCoordinates[0][0] = x;
  rogue.wpCoordinates[0][1] = y;
  refreshWaypoint(0);

	grid = allocGrid();
	fillGrid(grid, 0);
	calculateDistances(grid, x, y, T_PATHING_BLOCKER, NULL, true, false);

	for (monst=monsters.nextCreature; monst != NULL; monst = monst.nextCreature) {
    if (grid[monst.xLoc][monst.yLoc] <= distance) {
      if (monst.creatureState == MONSTER_SLEEPING) {
        wakeUp(monst);
      }
      if (monst.creatureState != MONSTER_ALLY && monst.leader !== player) {
        alertMonster(monst);
				monst.info.flags &= ~MONST_MAINTAINS_DISTANCE;
				monst.info.abilityFlags &= ~MA_AVOID_CORRIDORS;
      }
    }
	}
	for (i=0; i<DCOLS; i++) {
		for (j=0; j<DROWS; j++) {
			if (grid[i][j] >= 0 && grid[i][j] <= distance) {
				scentMap[i][j] = 0;
				addScentToCell(i, j, 2 * grid[i][j]);
			}
		}
	}
	freeGrid(grid);

  if (player.xLoc == x && player.yLoc == y) {
    player.status[STATUS_AGGRAVATING] = player.maxStatus[STATUS_AGGRAVATING] = distance;
    rogue.aggroRange = currentAggroValue();
  }

  if (grid[player.xLoc][player.yLoc] >= 0 && grid[player.xLoc][player.yLoc] <= distance) {
      await discover(x, y);
      discoverCell(x, y);
      await colorFlash(flashColor, 0, (DISCOVERED | MAGIC_MAPPED), 10, distance, x, y);
      if (!playerCanSee(x, y)) {
          message("You hear a piercing shriek; something must have triggered a nearby alarm.", false);
      }
  }
}

// Simple line algorithm (maybe this is Bresenham?) that returns a list of coordinates
// that extends all the way to the edge of the map based on an originLoc (which is not included
// in the list of coordinates) and a targetLoc.
// Returns the number of entries in the list, and includes (-1, -1) as an additional
// terminus indicator after the end of the list.
function getLineCoordinates( listOfCoordinates /* short[][2] */, originLoc /* short[2] */, targetLoc /* short[2] */) {
	let targetVector = [], error = [], currentVector = [], previousVector = [], quadrantTransform = [];
	let largerTargetComponent, i;
	let currentLoc = [], previousLoc = [];
	let cellNumber = 0;

	if (originLoc[0] == targetLoc[0] && originLoc[1] == targetLoc[1]) {
		return 0;
	}

	// Neither vector is negative. We keep track of negatives with quadrantTransform.
	for (i=0; i<= 1; i++) {
		targetVector[i] = targetLoc[i] - originLoc[i] << FP_BASE;	// FIXME: should use parens?
		if (targetVector[i] < 0) {
			targetVector[i] *= -1;
			quadrantTransform[i] = -1;
		} else {
			quadrantTransform[i] = 1;
		}
		currentVector[i] = previousVector[i] = error[i] = 0;
		currentLoc[i] = originLoc[i];
	}

	// normalize target vector such that one dimension equals 1 and the other is in [0, 1].
	largerTargetComponent = max(targetVector[0], targetVector[1]);
	// targetVector[0] = Math.floor( (targetVector[0] << FP_BASE) / largerTargetComponent);
	// targetVector[1] = Math.floor( (targetVector[1] << FP_BASE) / largerTargetComponent);
	targetVector[0] = Math.floor(targetVector[0] * FP_FACTOR / largerTargetComponent);
	targetVector[1] = Math.floor(targetVector[1] * FP_FACTOR / largerTargetComponent);

	do {
		for (i=0; i<= 1; i++) {

			previousLoc[i] = currentLoc[i];

			currentVector[i] += targetVector[i] >> FP_BASE;
			error[i] += (targetVector[i] == FP_FACTOR ? 0 : targetVector[i]);

			if (error[i] >= Math.floor(FP_FACTOR / 2) ) {
				currentVector[i]++;
				error[i] -= FP_FACTOR;
			}

			currentLoc[i] = Math.floor(quadrantTransform[i]*currentVector[i] + originLoc[i]);

			listOfCoordinates[cellNumber][i] = currentLoc[i];
		}

		//DEBUG printf("\ncell %i: (%i, %i)", cellNumber, listOfCoordinates[cellNumber][0], listOfCoordinates[cellNumber][1]);
		cellNumber++;

	} while (coordinatesAreInMap(currentLoc[0], currentLoc[1]));

	cellNumber--;

	listOfCoordinates[cellNumber][0] = listOfCoordinates[cellNumber][1] = -1; // demarcates the end of the list
	return cellNumber;
}

// If a hypothetical bolt were launched from originLoc toward targetLoc,
// with a given max distance and a toggle as to whether it halts at its impact location
// or one space prior, where would it stop?
// Takes into account the caster's knowledge; i.e. won't be blocked by monsters
// that the caster is not aware of.
function getImpactLoc(returnLoc /* short[2] */, originLoc /* short[2] */, targetLoc /* short[2] */,
				  maxDistance, returnLastEmptySpace)
{
  let coords = ARRAY(DCOLS + 1, () => [-1, -1] ); /// short[DCOLS + 1][2];
  let i, n;
	let monst;	// creature *

  n = getLineCoordinates(coords, originLoc, targetLoc);
  n = min(n, maxDistance);
	for (i=0; i<n; i++) {
    monst = monsterAtLoc(coords[i][0], coords[i][1]);
    if (monst
        && !monsterIsHidden(monst, monsterAtLoc(originLoc[0], originLoc[1]))
        && !(monst.bookkeepingFlags & MB_SUBMERGED))
		{
        // Imaginary bolt hit the player or a monster.
        break;
    }
		if (cellHasTerrainFlag(coords[i][0], coords[i][1], (T_OBSTRUCTS_VISION | T_OBSTRUCTS_PASSABILITY))) {
        break;
    }
	}
  if (i == maxDistance) {
      returnLoc[0] = coords[i-1][0];
      returnLoc[1] = coords[i-1][1];
  } else if (returnLastEmptySpace) {
      if (i == 0) {
          returnLoc[0] = originLoc[0];
          returnLoc[1] = originLoc[1];
      } else {
          returnLoc[0] = coords[i-1][0];
          returnLoc[1] = coords[i-1][1];
      }
	} else {
		returnLoc[0] = coords[i][0];
		returnLoc[1] = coords[i][1];
	}
  brogueAssert(coordinatesAreInMap(returnLoc[0], returnLoc[1]));

	return returnLoc;
}

// Returns true if the two coordinates are unobstructed and diagonally adjacent,
// but their two common neighbors are obstructed and at least one blocks diagonal movement.
function impermissibleKinkBetween(x1, y1, x2, y2) {
    brogueAssert(coordinatesAreInMap(x1, y1));
    brogueAssert(coordinatesAreInMap(x2, y2));
    if (cellHasTerrainFlag(x1, y1, T_OBSTRUCTS_PASSABILITY)
        || cellHasTerrainFlag(x2, y2, T_OBSTRUCTS_PASSABILITY))
		{
        // One of the two locations is obstructed.
        return false;
    }
    if (abs(x1 - x2) != 1 || abs(y1 - y2) != 1) {
        // Not diagonally adjacent.
        return false;
    }
    if (!cellHasTerrainFlag(x2, y1, T_OBSTRUCTS_PASSABILITY)
        || !cellHasTerrainFlag(x1, y2, T_OBSTRUCTS_PASSABILITY))
		{
        // At least one of the common neighbors isn't obstructed.
        return false;
    }
    if (!cellHasTerrainFlag(x2, y1, T_OBSTRUCTS_DIAGONAL_MOVEMENT)
        && !cellHasTerrainFlag(x1, y2, T_OBSTRUCTS_DIAGONAL_MOVEMENT))
		{
        // Neither of the common neighbors obstructs diagonal movement.
        return false;
    }
    return true;
}


async function tunnelize(x, y) {
	let layer;		// enum dungeonLayers
	let didSomething = false;
	let monst;		// creature *
  let x2, y2;
  let dir;			// enum directions

	if (pmap[x][y].flags & IMPREGNABLE) {
		return false;
	}

	await freeCaptivesEmbeddedAt(x, y);

  if (x == 0 || x == DCOLS - 1 || y == 0 || y == DROWS - 1) {
      pmap[x][y].layers[DUNGEON] = CRYSTAL_WALL; // don't dissolve the boundary walls
      didSomething = true;
  } else {
      for (layer = 0; layer < NUMBER_TERRAIN_LAYERS; layer++) {
          if (tileCatalog[pmap[x][y].layers[layer]].flags & (T_OBSTRUCTS_PASSABILITY | T_OBSTRUCTS_VISION)) {
              pmap[x][y].layers[layer] = (layer == DUNGEON ? FLOOR : NOTHING);
              didSomething = true;
          }
      }
  }
  if (didSomething) {
      await spawnDungeonFeature(x, y, dungeonFeatureCatalog[DF_TUNNELIZE], true, false);
      if (pmap[x][y].flags & HAS_MONSTER) {
          // Kill turrets and sentinels if you tunnelize them.
          monst = monsterAtLoc(x, y);
          if (monst.info.flags & MONST_ATTACKABLE_THRU_WALLS) {
              await inflictLethalDamage(NULL, monst);
          }
      }
  }
  if (!cellHasTerrainFlag(x, y, T_OBSTRUCTS_DIAGONAL_MOVEMENT)
      && didSomething)
	{
      // Tunnel out any diagonal kinks between walls.
      for (dir = 0; dir < DIRECTION_COUNT; dir++) {
          x2 = x + nbDirs[dir][0];
          y2 = y + nbDirs[dir][1];
          if (coordinatesAreInMap(x2, y2) && impermissibleKinkBetween(x, y, x2, y2))
					{
              if ((pmap[x][y2].flags & IMPREGNABLE)
                  || (!(pmap[x2][y].flags & IMPREGNABLE) && rand_percent(50)))
							{
                  await tunnelize(x2, y);
              } else {
                  await tunnelize(x, y2);
              }
          }
      }
  }
	return didSomething;
}


async function negate( /* creature */ monst) {
    let i, j;
    let backupBolts = []; // boltType[20];
    monst.info.abilityFlags &= MA_NON_NEGATABLE_ABILITIES; // negated monsters lose all special abilities
    monst.bookkeepingFlags &= ~MB_SEIZING;

	if (monst.info.flags & MONST_DIES_IF_NEGATED) {
		let buf, monstName; // char [DCOLS];
		monsterName(monstName, monst, true);
		if (monst.status[STATUS_LEVITATING]) {
			sprintf(buf, "%s dissipates into thin air", monstName);
		} else if (monst.info.flags & MONST_INANIMATE) {
            sprintf(buf, "%s shatters into tiny pieces", monstName);
        } else {
			sprintf(buf, "%s falls to the ground, lifeless", monstName);
		}
		await killCreature(monst, false);
		combatMessage(buf, messageColorFromVictim(monst));
	} else if (!(monst.info.flags & MONST_INVULNERABLE)) {
		// works on inanimates
		monst.status[STATUS_IMMUNE_TO_FIRE] = 0;
		monst.status[STATUS_SLOWED] = 0;
		monst.status[STATUS_HASTED] = 0;
		monst.status[STATUS_CONFUSED] = 0;
		monst.status[STATUS_ENTRANCED] = 0;
		monst.status[STATUS_DISCORDANT] = 0;
		monst.status[STATUS_SHIELDED] = 0;
		monst.status[STATUS_INVISIBLE] = 0;
		if (monst === player) {
			monst.status[STATUS_TELEPATHIC] = min(monst.status[STATUS_TELEPATHIC], 1);
			monst.status[STATUS_MAGICAL_FEAR] = min(monst.status[STATUS_MAGICAL_FEAR], 1);
			monst.status[STATUS_LEVITATING] = min(monst.status[STATUS_LEVITATING], 1);
			if (monst.status[STATUS_DARKNESS]) {
				monst.status[STATUS_DARKNESS] = 0;
				updateMinersLightRadius();
				updateVision(true);
			}
		} else {
			monst.status[STATUS_TELEPATHIC] = 0;
			monst.status[STATUS_MAGICAL_FEAR] = 0;
			monst.status[STATUS_LEVITATING] = 0;
		}
		monst.info.flags &= ~MONST_IMMUNE_TO_FIRE;
		monst.movementSpeed = monst.info.movementSpeed;
		monst.attackSpeed = monst.info.attackSpeed;
		if (monst !== player && (monst.info.flags & NEGATABLE_TRAITS)) {
			if ((monst.info.flags & MONST_FIERY) && monst.status[STATUS_BURNING]) {
				extinguishFireOnCreature(monst);
			}
			monst.info.flags &= ~NEGATABLE_TRAITS;
			refreshDungeonCell(monst.xLoc, monst.yLoc);
			refreshSideBar(-1, -1, false);
		}
    for (i = 0; i < 20; i++) {
        backupBolts[i] = monst.info.bolts[i];
        monst.info.bolts[i] = BOLT_NONE;
    }
    for (i = 0, j = 0; i < 20 && backupBolts[i]; i++) {
        if (boltCatalog[backupBolts[i]].flags & BF_NOT_NEGATABLE) {
            monst.info.bolts[j] = backupBolts[i];
            j++;
        }
    }
    monst.newPowerCount = monst.totalPowerCount; // Allies can re-learn lost ability slots.
		await applyInstantTileEffectsToCreature(monst); // in case it should immediately die or fall into a chasm
	}
}

// function monsterAccuracyAdjusted( /* creature */ monst) {
//     let retval = Math.floor(monst.info.accuracy * (pow(WEAPON_ENCHANT_ACCURACY_FACTOR, -2.5 * monst.weaknessAmount) + FLOAT_FUDGE));
//     return max(retval, 0);
// }
//
// function monsterDamageAdjustmentAmount( /* creature */ monst) {
//     if (monst === player) {
//         // Handled through player strength routines elsewhere.
//         return Math.floor(1.0 + FLOAT_FUDGE);
//     } else {
//         return Math.floor(pow(WEAPON_ENCHANT_DAMAGE_FACTOR, -2.5 * monst.weaknessAmount) + FLOAT_FUDGE);
//     }
// }
//
// function monsterDefenseAdjusted(/* creature */ monst) {
//     let retval;
//     if (monst === player) {
//         // Weakness is already taken into account in recalculateEquipmentBonuses() for the player.
//         retval = monst.info.defense;
//     } else {
//         retval = Math.floor(monst.info.defense - 25 * monst.weaknessAmount);
//     }
//     return max(retval, 0);
// }

// Adds one to the creature's weakness, sets the weakness status duration to maxDuration.
function weaken(/* creature */ monst, maxDuration) {
    if (monst.weaknessAmount < 10) {
        monst.weaknessAmount++;
    }
	monst.status[STATUS_WEAKENED] = max(monst.status[STATUS_WEAKENED], maxDuration);
	monst.maxStatus[STATUS_WEAKENED] = max(monst.maxStatus[STATUS_WEAKENED], maxDuration);
	if (monst === player) {
    message("your muscles weaken as an enervating toxin fills your veins.", badMessageColor, false);
		strengthCheck(rogue.weapon);
		strengthCheck(rogue.armor);
	}
}

// True if the creature polymorphed; false if not.
function polymorph( /* creature */ monst) {
	let previousDamageTaken, healthFraction, newMonsterIndex;

	if (monst === player || (monst.info.flags & (MONST_INANIMATE | MONST_INVULNERABLE))) {
		return false; // Sorry, this is not Nethack.
	}

  if (monst.creatureState == MONSTER_FLEEING
      && (monst.info.flags & (MONST_MAINTAINS_DISTANCE | MONST_FLEES_NEAR_DEATH)) || (monst.info.abilityFlags & MA_HIT_STEAL_FLEE))
	{
      monst.creatureState = MONSTER_TRACKING_SCENT;
      monst.creatureMode = MODE_NORMAL;
  }

	unAlly(monst); // Sorry, no cheap dragon allies.
  monst.mutationIndex = -1; // Polymorph cures mutation -- basic science.
	healthFraction = Math.floor(monst.currentHP * 1000 / monst.info.maxHP);
	previousDamageTaken = monst.info.maxHP - monst.currentHP;

	do {
        newMonsterIndex = rand_range(1, NUMBER_MONSTER_KINDS - 1);
	} while (monsterCatalog[newMonsterIndex].flags & (MONST_INANIMATE | MONST_NO_POLYMORPH) // Can't turn something into an inanimate object or lich/phoenix/warden.
             || newMonsterIndex == monst.info.monsterID); // Can't stay the same monster.

  monst.info = monsterCatalog[newMonsterIndex]; // Presto change-o!

  monst.info.turnsBetweenRegen *= 1000;
	monst.currentHP = max(1, max( Math.floor(healthFraction * monst.info.maxHP / 1000), monst.info.maxHP - previousDamageTaken));

	monst.movementSpeed = monst.info.movementSpeed;
	monst.attackSpeed = monst.info.attackSpeed;
	if (monst.status[STATUS_HASTED]) {
		monst.movementSpeed = Math.floor(monst.movementSpeed / 2);
		monst.attackSpeed = Math.floor(monst.attackSpeed / 2);
	}
	if (monst.status[STATUS_SLOWED]) {
		monst.movementSpeed *= 2;
		monst.attackSpeed *= 2;
	}

	clearStatus(monst);

	if (monst.info.flags & MONST_FIERY) {
		monst.status[STATUS_BURNING] = monst.maxStatus[STATUS_BURNING] = 1000; // won't decrease
	}
	if (monst.info.flags & MONST_FLIES) {
		monst.status[STATUS_LEVITATING] = monst.maxStatus[STATUS_LEVITATING] = 1000; // won't decrease
	}
	if (monst.info.flags & MONST_IMMUNE_TO_FIRE) {
		monst.status[STATUS_IMMUNE_TO_FIRE] = monst.maxStatus[STATUS_IMMUNE_TO_FIRE] = 1000; // won't decrease
	}
	if (monst.info.flags & MONST_INVISIBLE) {
		monst.status[STATUS_INVISIBLE] = monst.maxStatus[STATUS_INVISIBLE] = 1000; // won't decrease
	}
	monst.status[STATUS_NUTRITION] = monst.maxStatus[STATUS_NUTRITION] = 1000;

	if (monst.bookkeepingFlags & MB_CAPTIVE) {
		demoteMonsterFromLeadership(monst);
		monst.creatureState = MONSTER_TRACKING_SCENT;
		monst.bookkeepingFlags &= ~MB_CAPTIVE;
	}
  monst.bookkeepingFlags &= ~(MB_SEIZING | MB_SEIZED);

	monst.ticksUntilTurn = max(monst.ticksUntilTurn, 101);

	refreshDungeonCell(monst.xLoc, monst.yLoc);
  if (boltCatalog[BOLT_POLYMORPH].backColor) {
      flashMonster(monst, boltCatalog[BOLT_POLYMORPH].backColor, 100);
  }
	return true;
}


function slow( /* creature */ monst, turns) {
	if (!(monst.info.flags & (MONST_INANIMATE | MONST_INVULNERABLE))) {
		monst.status[STATUS_SLOWED] = monst.maxStatus[STATUS_SLOWED] = turns;
		monst.status[STATUS_HASTED] = 0;
		if (monst === player) {
			updateEncumbrance();
			message("you feel yourself slow down.", false);
		} else {
			monst.movementSpeed = monst.info.movementSpeed * 2;
			monst.attackSpeed = monst.info.attackSpeed * 2;
		}
	}
}

function haste( /* creature */ monst, turns) {
	if (monst && !(monst.info.flags & (MONST_INANIMATE | MONST_INVULNERABLE))) {
		monst.status[STATUS_SLOWED] = 0;
		monst.status[STATUS_HASTED] = monst.maxStatus[STATUS_HASTED] = turns;
		if (monst === player) {
			updateEncumbrance();
			message("you feel yourself speed up.", false);
		} else {
			monst.movementSpeed = Math.floor(monst.info.movementSpeed / 2);
			monst.attackSpeed = Math.floor(monst.info.attackSpeed / 2);
		}
	}
}

function heal( /* creature */ monst, percent, panacea) {
	const buf = STRING(), monstName = STRING(); // char[COLS];
	monst.currentHP = min(monst.info.maxHP, monst.currentHP + Math.floor(percent * monst.info.maxHP / 100));
  if (panacea) {
      if (monst.status[STATUS_HALLUCINATING] > 1) {
          monst.status[STATUS_HALLUCINATING] = 1;
      }
      if (monst.status[STATUS_CONFUSED] > 1) {
          monst.status[STATUS_CONFUSED] = 1;
      }
      if (monst.status[STATUS_NAUSEOUS] > 1) {
          monst.status[STATUS_NAUSEOUS] = 1;
      }
      if (monst.status[STATUS_SLOWED] > 1) {
          monst.status[STATUS_SLOWED] = 1;
      }
      if (monst.status[STATUS_WEAKENED] > 1) {
          monst.weaknessAmount = 0;
          monst.status[STATUS_WEAKENED] = 0;
          updateEncumbrance();
      }
      if (monst.status[STATUS_POISONED]) {
          monst.poisonAmount = 0;
          monst.status[STATUS_POISONED] = 0;
      }
      if (monst.status[STATUS_DARKNESS] > 0) {
          monst.status[STATUS_DARKNESS] = 0;
          if (monst === player) {
              updateMinersLightRadius();
              updateVision(true);
          }
      }
  }
	if (canDirectlySeeMonster(monst)
        && monst !== player
        && !panacea)
	{
		monsterName(monstName, monst, true);
		sprintf(buf, "%s looks healthier", monstName);
		combatMessage(buf, NULL);
	}
}

function makePlayerTelepathic(duration) {
    let monst;	// creature *

    player.status[STATUS_TELEPATHIC] = player.maxStatus[STATUS_TELEPATHIC] = duration;
    for (monst=monsters.nextCreature; monst != NULL; monst = monst.nextCreature) {
        refreshDungeonCell(monst.xLoc, monst.yLoc);
    }
    if (monsters.nextCreature == NULL) {
        message("you can somehow tell that you are alone on this depth at the moment.", false);
    } else {
        message("you can somehow feel the presence of other creatures' minds!", false);
    }
}

function rechargeItems( categories) {
  let tempItem;	// item *
  let x, y, z, i, categoryCount;
  const buf = STRING(); // char[DCOLS * 3];

  x = y = z = 0; // x counts staffs, y counts wands, z counts charms
  for (tempItem = packItems.nextItem; tempItem != NULL; tempItem = tempItem.nextItem) {
      if (tempItem.category & categories & STAFF) {
          x++;
          tempItem.charges = tempItem.enchant1;
          tempItem.enchant2 = Math.floor((tempItem.kind == STAFF_BLINKING || tempItem.kind == STAFF_OBSTRUCTION ? 10000 : 5000) / tempItem.enchant1);
      }
      if (tempItem.category & categories & WAND) {
          y++;
          tempItem.charges++;
      }
      if (tempItem.category & categories & CHARM) {
          z++;
          tempItem.charges = 0;
      }
  }

  categoryCount = (x ? 1 : 0) + (y ? 1 : 0) + (z ? 1 : 0);

  if (categoryCount) {
      i = 0;
      strcpy(buf, "a surge of energy courses through your pack, recharging your ");
      if (x) {
          i++;
          strcat(buf, x == 1 ? "staff" : "staffs");
          if (i == categoryCount - 1) {
              strcat(buf, " and ");
          } else if (i <= categoryCount - 2) {
              strcat(buf, ", ");
          }
      }
      if (y) {
          i++;
          strcat(buf, y == 1 ? "wand" : "wands");
          if (i == categoryCount - 1) {
              strcat(buf, " and ");
          } else if (i <= categoryCount - 2) {
              strcat(buf, ", ");
          }
      }
      if (z) {
          strcat(buf, z == 1 ? "charm" : "charms");
      }
      strcat(buf, ".");
      message(buf, false);
  } else {
      message("a surge of energy courses through your pack, but nothing happens.", false);
  }
}

// //async void causeFear(const char *emitterName) {
// //    creature *monst;
// //    short numberOfMonsters = 0;
// //    char buf[DCOLS*3], mName[DCOLS];
// //
// //    for (monst = monsters->nextCreature; monst != NULL; monst = monst->nextCreature) {
// //        if (pmap[monst->xLoc][monst->yLoc].flags & IN_FIELD_OF_VIEW
// //            && monst->creatureState != MONSTER_FLEEING
// //            && !(monst->info.flags & (MONST_INANIMATE | MONST_INVULNERABLE))) {
// //
// //            monst->status[STATUS_MAGICAL_FEAR] = monst->maxStatus[STATUS_MAGICAL_FEAR] = rand_range(150, 225);
// //            monst->creatureState = MONSTER_FLEEING;
// //            if (canSeeMonster(monst)) {
// //                numberOfMonsters++;
// //                monsterName(mName, monst, true);
// //            }
// //        }
// //    }
// //    if (numberOfMonsters > 1) {
// //        sprintf(buf, "%s emits a brilliant flash of red light, and the monsters flee!", emitterName);
// //    } else if (numberOfMonsters == 1) {
// //        sprintf(buf, "%s emits a brilliant flash of red light, and %s flees!", emitterName, mName);
// //    } else {
// //        sprintf(buf, "%s emits a brilliant flash of red light!", emitterName);
// //    }
// //    message(buf, false);
// //    await colorFlash(&redFlashColor, 0, IN_FIELD_OF_VIEW, 15, DCOLS, player.xLoc, player.yLoc);
// //}

async function negationBlast( /* char */ emitterName, distance) {
    let monst, nextMonst;		// creature *
    let theItem;						// item *
    const buf = STRING(); 	// char[DCOLS];

    sprintf(buf, "%s emits a numbing torrent of anti-magic!", emitterName);
    message(buf, itemMessageColor, false);
    await colorFlash(pink, 0, IN_FIELD_OF_VIEW, 3 + Math.floor(distance / 5), distance, player.xLoc, player.yLoc);
    await negate(player);
    flashMonster(player, pink, 100);
    for (monst = monsters.nextCreature; monst != NULL;) {
        nextMonst = monst.nextCreature;
        if ((pmap[monst.xLoc][monst.yLoc].flags & IN_FIELD_OF_VIEW)
            && (player.xLoc - monst.xLoc) * (player.xLoc - monst.xLoc) + (player.yLoc - monst.yLoc) * (player.yLoc - monst.yLoc) <= distance * distance)
				{
            if (canSeeMonster(monst)) {
                flashMonster(monst, pink, 100);
            }
            await negate(monst); // This can be fatal.
        }
        monst = nextMonst;
    }
    for (theItem = floorItems; theItem != NULL; theItem = theItem.nextItem) {
        if ((pmap[theItem.xLoc][theItem.yLoc].flags & IN_FIELD_OF_VIEW)
            && (player.xLoc - theItem.xLoc) * (player.xLoc - theItem.xLoc) + (player.yLoc - theItem.yLoc) * (player.yLoc - theItem.yLoc) <= distance * distance)
				{
            theItem.flags &= ~(ITEM_MAGIC_DETECTED | ITEM_CURSED);
            switch (theItem.category) {
                case WEAPON:
                case ARMOR:
                    theItem.enchant1 = theItem.enchant2 = theItem.charges = 0;
                    theItem.flags &= ~(ITEM_RUNIC | ITEM_RUNIC_HINTED | ITEM_RUNIC_IDENTIFIED | ITEM_PROTECTED);
                    identify(theItem);
                    break;
                case STAFF:
                    theItem.charges = 0;
                    break;
                case WAND:
                    theItem.charges = 0;
                    theItem.flags |= ITEM_MAX_CHARGES_KNOWN;
                    break;
                case RING:
                    theItem.enchant1 = 0;
                    theItem.flags |= ITEM_IDENTIFIED; // Reveal that it is (now) +0, but not necessarily which kind of ring it is.
                    updateIdentifiableItems();
                    break;
                case CHARM:
                    theItem.charges = charmRechargeDelay(theItem.kind, theItem.enchant1);
                    break;
                default:
                    break;
            }
        }
    }
}

async function discordBlast(/* char */emitterName, distance) {
    let monst, nextMonst;	// creature *
    const buf = STRING(); // char[DCOLS];

    sprintf(buf, "%s emits a wave of unsettling purple radiation!", emitterName);
    message(buf, itemMessageColor, false);
    await colorFlash(discordColor, 0, IN_FIELD_OF_VIEW, 3 + Math.floor(distance / 5), distance, player.xLoc, player.yLoc);
    for (monst = monsters.nextCreature; monst != NULL;) {
        nextMonst = monst.nextCreature;
        if ((pmap[monst.xLoc][monst.yLoc].flags & IN_FIELD_OF_VIEW)
            && (player.xLoc - monst.xLoc) * (player.xLoc - monst.xLoc) + (player.yLoc - monst.yLoc) * (player.yLoc - monst.yLoc) <= distance * distance)
				{
            if (!(monst.info.flags & (MONST_INANIMATE | MONST_INVULNERABLE))) {
                if (canSeeMonster(monst)) {
                    flashMonster(monst, discordColor, 100);
                }
                monst.status[STATUS_DISCORDANT] = monst.maxStatus[STATUS_DISCORDANT] = 30;
            }
        }
        monst = nextMonst;
    }
}

async function crystalize(radius) {
	let i, j;
	let monst;	// creature *

	for (i=0; i<DCOLS; i++) {
		for (j=0; j < DROWS; j++) {
			if ((player.xLoc - i) * (player.xLoc - i) + (player.yLoc - j) * (player.yLoc - j) <= radius * radius
				&& !(pmap[i][j].flags & IMPREGNABLE))
			{
				if (i == 0 || i == DCOLS - 1 || j == 0 || j == DROWS - 1) {
					pmap[i][j].layers[DUNGEON] = CRYSTAL_WALL; // don't dissolve the boundary walls
				} else if (tileCatalog[pmap[i][j].layers[DUNGEON]].flags & (T_OBSTRUCTS_PASSABILITY | T_OBSTRUCTS_VISION)) {

					pmap[i][j].layers[DUNGEON] = FORCEFIELD;
          await spawnDungeonFeature(i, j, dungeonFeatureCatalog[DF_SHATTERING_SPELL], true, false);

					if (pmap[i][j].flags & HAS_MONSTER) {
						monst = monsterAtLoc(i, j);
						if (monst.info.flags & MONST_ATTACKABLE_THRU_WALLS) {
              await inflictLethalDamage(NULL, monst);
						} else {
							await freeCaptivesEmbeddedAt(i, j);
						}
					}
				}
			}
		}
	}
	updateVision(false);
	await colorFlash(forceFieldColor, 0, 0, radius, radius, player.xLoc, player.yLoc);
	displayLevel();
	refreshSideBar(-1, -1, false);
}

function imbueInvisibility( /* creature */ monst, duration) {
    let autoID = false;

    if (monst && !(monst.info.flags & (MONST_INANIMATE | MONST_INVISIBLE | MONST_INVULNERABLE))) {
        if (monst === player || monst.creatureState == MONSTER_ALLY) {
            autoID = true;
        }
        monst.status[STATUS_INVISIBLE] = monst.maxStatus[STATUS_INVISIBLE] = duration;
        refreshDungeonCell(monst.xLoc, monst.yLoc);
        refreshSideBar(-1, -1, false);
        if (boltCatalog[BOLT_POLYMORPH].backColor) {
            flashMonster(monst, boltCatalog[BOLT_INVISIBILITY].backColor, 100);
        }
    }
    return autoID;
}

function projectileReflects( /* creature */ attacker, /* creature */ defender) {
	let prob;
  let netReflectionLevel;

	// immunity armor always reflects its vorpal enemy's projectiles
	if (defender === player && rogue.armor && (rogue.armor.flags & ITEM_RUNIC) && rogue.armor.enchant2 == A_IMMUNITY
		&& monsterIsInClass(attacker, rogue.armor.vorpalEnemy)
    && monstersAreEnemies(attacker, defender))
	{
		return true;
	}

	if (defender === player && rogue.armor && (rogue.armor.flags & ITEM_RUNIC) && rogue.armor.enchant2 == A_REFLECTION) {
		netReflectionLevel = fp_netEnchant(rogue.armor);
	} else {
		netReflectionLevel = 0;
	}

	if (defender && (defender.info.flags & MONST_REFLECT_4)) {
    if (defender.info.flags & MONST_ALWAYS_USE_ABILITY) {
        return true;
    }
		netReflectionLevel += 4 << FP_BASE;
	}

	if (netReflectionLevel <= 0) {
		return false;
	}

	prob = fp_reflectionChance(netReflectionLevel);

	return rand_percent(prob);
}


// Alters listOfCoordinates to describe reflected path,
// which diverges from the existing path at kinkCell,
// and then returns the path length of the reflected path.
function reflectBolt(targetX, targetY, listOfCoordinates /* short[][2] */, kinkCell, retracePath) {
	let k, target = [-1, -1], origin = [-1, -1], newPathLength, failsafe, finalLength;
	let newPath = ARRAY(DCOLS, () => [-1, -1] ); // short[DCOLS][2],
	let needRandomTarget;

	needRandomTarget = (targetX < 0 || targetY < 0
						|| (targetX == listOfCoordinates[kinkCell][0] && targetY == listOfCoordinates[kinkCell][1]));

	if (retracePath) {
		// if reflecting back at caster, follow precise trajectory until we reach the caster
		for (k = 1; k <= kinkCell && kinkCell + k < MAX_BOLT_LENGTH; k++) {
			listOfCoordinates[kinkCell + k][0] = listOfCoordinates[kinkCell - k][0];
			listOfCoordinates[kinkCell + k][1] = listOfCoordinates[kinkCell - k][1];
		}

		// Calculate a new "extension" path, with an origin at the caster, and a destination at
		// the caster's location translated by the vector from the reflection point to the caster.
		//
		// For example, if the player is at (0,0), and the caster is at (2,3), then the newpath
		// is from (2,3) to (4,6):
		// (2,3) + ((2,3) - (0,0)) = (4,6).

		origin[0] = listOfCoordinates[2 * kinkCell][0];
		origin[1] = listOfCoordinates[2 * kinkCell][1];
		target[0] = targetX + (targetX - listOfCoordinates[kinkCell][0]);
		target[1] = targetY + (targetY - listOfCoordinates[kinkCell][1]);
		newPathLength = getLineCoordinates(newPath, origin, target);
		for (k=0; k<=newPathLength; k++) {
			listOfCoordinates[2 * kinkCell + k + 1][0] = newPath[k][0];
			listOfCoordinates[2 * kinkCell + k + 1][1] = newPath[k][1];
		}
		finalLength = 2 * kinkCell + newPathLength + 1;
	} else {
		failsafe = 50;
		do {
			if (needRandomTarget) {
				// pick random target
				perimeterCoords(target, rand_range(0, 39));
				target[0] += listOfCoordinates[kinkCell][0];
				target[1] += listOfCoordinates[kinkCell][1];
			} else {
				target[0] = targetX;
				target[1] = targetY;
			}
			newPathLength = getLineCoordinates(newPath, listOfCoordinates[kinkCell], target);
			if (newPathLength > 0
                && !cellHasTerrainFlag(newPath[0][0], newPath[0][1], (T_OBSTRUCTS_VISION | T_OBSTRUCTS_PASSABILITY))) {

				needRandomTarget = false;
			}
		} while (needRandomTarget && --failsafe);

		for (k = 0; k < newPathLength; k++) {
			listOfCoordinates[kinkCell + k + 1][0] = newPath[k][0];
			listOfCoordinates[kinkCell + k + 1][1] = newPath[k][1];
		}

		finalLength = kinkCell + newPathLength + 1;
	}

	listOfCoordinates[finalLength][0] = -1;
	listOfCoordinates[finalLength][1] = -1;
	return finalLength;
}


// Update stuff that promotes without keys so players can't abuse item libraries with blinking/haste shenanigans
async function checkForMissingKeys(x, y) {
	let layer;

	if (cellHasTMFlag(x, y, TM_PROMOTES_WITHOUT_KEY) && !keyOnTileAt(x, y)) {
		for (layer = 0; layer < NUMBER_TERRAIN_LAYERS; layer++) {
			if (tileCatalog[pmap[x][y].layers[layer]].mechFlags & TM_PROMOTES_WITHOUT_KEY) {
				await promoteTile(x, y, layer, false);
			}
		}
	}
}

async function beckonMonster( /* creature */ monst, x, y) {
    let from = [-1, -1], to = [-1, -1];
    const theBolt = boltCatalog[BOLT_BLINKING];

    if (monst.bookkeepingFlags & MB_CAPTIVE) {
        await freeCaptive(monst);
    }
    from[0] = monst.xLoc;
    from[1] = monst.yLoc;
    to[0] = x;
    to[1] = y;
    theBolt.magnitude = max(1, Math.floor((distanceBetween(x, y, monst.xLoc, monst.yLoc) - 2) / 2));
    await zap(from, to, theBolt, false);
    if (monst.ticksUntilTurn < player.attackSpeed+1) {
        monst.ticksUntilTurn = player.attackSpeed+1;
    }
}

function boltEffectForItem( /* item */ theItem) {		// enum boltEffects
    if (theItem.category & (STAFF | WAND)) {
        return boltCatalog[tableForItemCategory(theItem.category, NULL)[theItem.kind].strengthRequired].boltEffect;
    } else {
        return BE_NONE;
    }
}

function boltForItem( /* item */ theItem) {		// enum boltType
    if (theItem.category & (STAFF | WAND)) {
        return tableForItemCategory(theItem.category, NULL)[theItem.kind].strengthRequired;
    } else {
        return 0;
    }
}


// Called on each space of the bolt's flight.
// Returns true if the bolt terminates here.
// Caster can be null.
// Pass in true for boltInView if any part of the bolt is currently visible to the player.
// Pass in true for alreadyReflected if the bolt has already reflected off of something.
// If the effect is visible enough for the player to identify the shooting item,
// *autoID will be set to true. (AutoID can be null.)
// If the effect causes the level's lighting or vision to change, *lightingChanged
// will be set to true. (LightingChanged can be null.)
async function updateBolt( /* bolt */ theBolt, /* creature */ caster, x, y,
                   boltInView, alreadyReflected)
{
	let autoID = false;
	let lightingChanged = false;

	const buf = STRING(), monstName = STRING(); // char[COLS];
  let monst; // Creature being hit by the bolt, if any.
  let newMonst; // Utility variable for plenty
  let terminateBolt = false;

  // Handle collisions with monsters.

  monst = monsterAtLoc(x, y);
  if (monst && !(monst.bookkeepingFlags & MB_SUBMERGED)) {
      monsterName(monstName, monst, true);

      switch(theBolt.boltEffect) {
          case BE_ATTACK:
            if (!cellHasTerrainFlag(x, y, T_OBSTRUCTS_PASSABILITY)
                || (monst.info.flags & MONST_ATTACKABLE_THRU_WALLS))
						{
                await attack(caster, monst, false);
								autoID = true;
            }
            break;
          case BE_DAMAGE:
							autoID = true;
              if (((theBolt.flags & BF_FIERY) && monst.status[STATUS_IMMUNE_TO_FIRE] > 0)
                  || (monst.info.flags & MONST_INVULNERABLE))
							{
                  if (canSeeMonster(monst)) {
                      sprintf(buf, "%s ignore%s %s %s",
                              monstName,
                              (monst === player ? "" : "s"),
                              canSeeMonster(caster) ? "the" : "a",
                              theBolt.name);
                      combatMessage(buf, 0);
                  }
              } else if (await inflictDamage(caster, monst, fp_staffDamage(theBolt.magnitude << FP_BASE), theBolt.backColor, false)) {
                  // killed monster
                  if (player.currentHP <= 0) {
                      if (caster === player) {
                          sprintf(buf, "Killed by a reflected %s", theBolt.name);
                          await gameOver(buf, true);
                      }
                      terminateBolt = true;
                      return true;
                  }
                  if (boltInView || canSeeMonster(monst)) {
                      sprintf(buf, "%s %s %s %s",
                              canSeeMonster(caster) ? "the" : "a",
                              theBolt.name,
                              ((monst.info.flags & MONST_INANIMATE) ? "destroys" : "kills"),
                              monstName);
                      combatMessage(buf, messageColorFromVictim(monst));
                  } else {
                      sprintf(buf, "you hear %s %s", monstName, ((monst.info.flags & MONST_INANIMATE) ? "get destroyed" : "die"));
                      combatMessage(buf, 0);
                  }
              } else {
                  // monster lives
                  if (monst.creatureMode != MODE_PERM_FLEEING
                      && monst.creatureState != MONSTER_ALLY
                      && (monst.creatureState != MONSTER_FLEEING || monst.status[STATUS_MAGICAL_FEAR]))
									{
                      monst.creatureState = MONSTER_TRACKING_SCENT;
                      monst.status[STATUS_MAGICAL_FEAR] = 0;
                  }
                  if (boltInView) {
                      sprintf(buf, "%s %s hits %s",
                              canSeeMonster(caster) ? "the" : "a",
                              theBolt.name,
                              monstName);
                      combatMessage(buf, messageColorFromVictim(monst));
                  }
                  if (theBolt.flags & BF_FIERY) {
                      await exposeCreatureToFire(monst);
                  }
                  if (!alreadyReflected
                      || caster !== player)
									{
                      await moralAttack(caster, monst);
                  }
              }
              if (theBolt.flags & BF_FIERY) {
                  await exposeTileToFire(x, y, true); // burninate
              }
              break;
          case BE_TELEPORT:
              if (!(monst.info.flags & MONST_IMMOBILE)) {
                  if (monst.bookkeepingFlags & MB_CAPTIVE) {
                      await freeCaptive(monst);
                  }
                  await teleport(monst, -1, -1, false);
              }
              break;
          case BE_BECKONING:
              if (!(monst.info.flags & MONST_IMMOBILE)
                  && caster
                  && distanceBetween(caster.xLoc, caster.yLoc, monst.xLoc, monst.yLoc) > 1)
							{
                  if (canSeeMonster(monst)) {
										autoID = true;
                  }
                  await beckonMonster(monst, caster.xLoc, caster.yLoc);
                  if (canSeeMonster(monst)) {
										autoID = true;
                  }
              }
              break;
          case BE_SLOW:
              slow(monst, theBolt.magnitude * 5);
              if (boltCatalog[BOLT_SLOW].backColor) {
                  await flashMonster(monst, boltCatalog[BOLT_SLOW].backColor, 100);
              }
							autoID = true;
              break;
          case BE_HASTE:
              haste(monst, fp_staffHasteDuration(theBolt.magnitude << FP_BASE));
              if (boltCatalog[BOLT_HASTE].backColor) {
                  await flashMonster(monst, boltCatalog[BOLT_HASTE].backColor, 100);
              }
							autoID = true;
              break;
          case BE_POLYMORPH:
              if (polymorph(monst)) {
                  if (!monst.status[STATUS_INVISIBLE]) {
										autoID = true;
                  }
              }
              break;
          case BE_INVISIBILITY:
              if (imbueInvisibility(monst, 150)) {
								autoID = true;
              }
              break;
          case BE_DOMINATION:
              if (monst !== player && !(monst.info.flags & (MONST_INANIMATE | MONST_INVULNERABLE))) {
                  if (rand_percent(wandDominate(monst))) {
                      // domination succeeded
                      monst.status[STATUS_DISCORDANT] = 0;
                      await becomeAllyWith(monst);
                      //refreshSideBar(-1, -1, false);
                      refreshDungeonCell(monst.xLoc, monst.yLoc);
                      if (canSeeMonster(monst)) {
												autoID = true;
                          sprintf(buf, "%s is bound to your will!", monstName);
                          message(buf, false);
                          if (boltCatalog[BOLT_DOMINATION].backColor) {
                              flashMonster(monst, boltCatalog[BOLT_DOMINATION].backColor, 100);
                          }
                      }
                  } else if (canSeeMonster(monst)) {
										autoID = true;
                      sprintf(buf, "%s resists the bolt of domination.", monstName);
                      message(buf, false);
                  }
              }
              break;
          case BE_NEGATION:
              await negate(monst);
              if (boltCatalog[BOLT_NEGATION].backColor) {
                  flashMonster(monst, boltCatalog[BOLT_NEGATION].backColor, 100);
              }
              break;
          case BE_EMPOWERMENT:
              if (monst !== player
                  && !(monst.info.flags & (MONST_INANIMATE | MONST_INVULNERABLE)))
							{
                  empowerMonster(monst);
                  createFlare(monst.xLoc, monst.yLoc, EMPOWERMENT_LIGHT);
                  if (canSeeMonster(monst)) {
										autoID = true;
                  }
              }
              break;
          case BE_POISON:
              if (!(monst.info.flags & (MONST_INANIMATE | MONST_INVULNERABLE))) {
                  addPoison(monst, fp_staffPoison(theBolt.magnitude << FP_BASE), 1);
                  if (canSeeMonster(monst)) {
                      if (boltCatalog[BOLT_POISON].backColor) {
                          flashMonster(monst, boltCatalog[BOLT_POISON].backColor, 100);
                      }
											autoID = true;
                      if (monst !== player) {
                          sprintf(buf, "%s %s %s sick",
                                  monstName,
                                  (monst === player ? "feel" : "looks"),
                                  (monst.status[STATUS_POISONED] * monst.poisonAmount >= monst.currentHP && !player.status[STATUS_HALLUCINATING] ? "fatally" : "very"));
                          combatMessage(buf, messageColorFromVictim(monst));
                      }
                  }
              }
              break;
          case BE_ENTRANCEMENT:
              if (monst === player) {
                  flashMonster(monst, confusionGasColor, 100);
                  monst.status[STATUS_CONFUSED] = fp_staffEntrancementDuration(theBolt.magnitude << FP_BASE);
                  monst.maxStatus[STATUS_CONFUSED] = max(monst.status[STATUS_CONFUSED], monst.maxStatus[STATUS_CONFUSED]);
                  await messageWithAck("the bolt hits you and you suddently feel disoriented.");
									autoID = true;
              } else if (!(monst.info.flags & (MONST_INANIMATE | MONST_INVULNERABLE))) {
                  monst.status[STATUS_ENTRANCED] = monst.maxStatus[STATUS_ENTRANCED] = fp_staffEntrancementDuration(theBolt.magnitude << FP_BASE);
                  wakeUp(monst);
                  if (canSeeMonster(monst)) {
                      if (boltCatalog[BOLT_ENTRANCEMENT].backColor) {
                          flashMonster(monst, boltCatalog[BOLT_ENTRANCEMENT].backColor, 100);
                      }
											autoID = true;
                      sprintf(buf, "%s is entranced!", monstName);
                      message(buf, false);
                  }
              }
              break;
          case BE_HEALING:
              heal(monst, theBolt.magnitude * 10, false);
              if (canSeeMonster(monst)) {
								autoID = true;
              }
              break;
          case BE_PLENTY:
              if (!(monst.info.flags & (MONST_INANIMATE | MONST_INVULNERABLE))) {
                  newMonst = await cloneMonster(monst, true, true);
                  if (newMonst) {
                      newMonst.currentHP = Math.floor((newMonst.currentHP + 1) / 2);
                      monst.currentHP = Math.floor((monst.currentHP + 1) / 2);
                      if (boltCatalog[BOLT_PLENTY].backColor) {
                          flashMonster(monst, boltCatalog[BOLT_PLENTY].backColor, 100);
                          flashMonster(newMonst, boltCatalog[BOLT_PLENTY].backColor, 100);
                      }
											autoID = true;
                  }
              }
              break;
          case BE_DISCORD:
              if (!(monst.info.flags & (MONST_INANIMATE | MONST_INVULNERABLE))) {
                  monst.status[STATUS_DISCORDANT] = monst.maxStatus[STATUS_DISCORDANT] = max(fp_staffDiscordDuration(theBolt.magnitude << FP_BASE), monst.status[STATUS_DISCORDANT]);
                  if (canSeeMonster(monst)) {
                      if (boltCatalog[BOLT_DISCORD].backColor) {
                          flashMonster(monst, boltCatalog[BOLT_DISCORD].backColor, 100);
                      }
											autoID = true;
                  }
              }
              break;
          case BE_SHIELDING:
              if (staffProtection(theBolt.magnitude) > monst.status[STATUS_SHIELDED]) {
                  monst.status[STATUS_SHIELDED] = fp_staffProtection(theBolt.magnitude << FP_BASE);
              }
              monst.maxStatus[STATUS_SHIELDED] = monst.status[STATUS_SHIELDED];
              if (boltCatalog[BOLT_SHIELDING].backColor) {
                  flashMonster(monst, boltCatalog[BOLT_SHIELDING].backColor, 100);
              }
							autoID = true;
              break;
          default:
              break;
      }

      if (!(theBolt.flags & BF_PASSES_THRU_CREATURES)) {
          terminateBolt = true;
      }
  }

  // Handle ordinary bolt updates that aren't dependent on hitting a creature.
  switch (theBolt.boltEffect) {
      case BE_BLINKING:
          if (caster === player) {
              player.xLoc = x;
              player.yLoc = y;
              lightingChanged = true;
          }
          break;
      default:
          break;
  }

  if (theBolt.pathDF) {
      await spawnDungeonFeature(x, y, dungeonFeatureCatalog[theBolt.pathDF], true, false);
  }

  if ((theBolt.flags & BF_FIERY)
      && await exposeTileToFire(x, y, true))
	{
		lightingChanged = true;
		autoID = true;
  }

  if ((theBolt.flags & BF_ELECTRIC)
      && await exposeTileToElectricity(x, y))
	{
		lightingChanged = true;
		autoID = true;
  }

	let result = BR_CONTINUES;
	if (terminateBolt) 		{ result |= BR_DONE; }
	if (autoID) 					{ result |= BR_AUTO_ID; }
	if (lightingChanged) 	{ result |= BR_LIGHTING_CHANGED; }

  return result;
}


const POW_OBSTRUCTION = [
		// 0.8^x << FP_BASE, with x from 2 to 40:
		41943, 33554, 26843, 21474, 17179, 13743, 10995, 8796, 7036, 5629, 4503, 3602,
		2882, 2305, 1844, 1475, 1180, 944, 755, 604, 483, 386, 309, 247, 198, 158, 126,
		101, 81, 64, 51, 41, 33, 26, 21, 17, 13, 10, 8, 6, 5];

// Called when the bolt hits something.
// Caster can be null.
// Pass in true for alreadyReflected if the bolt has already reflected off of something.
// If the effect is visible enough for the player to identify the shooting item,
// *autoID will be set to true. (AutoID can be null.)
async function detonateBolt( /* bolt */ theBolt, /* creature */ caster, x, y) {
	let autoID = false;
	let feat;	// dungeonFeature
  let i, x2, y2;
  let monst;	// creature *

  switch(theBolt.boltEffect) {
      case BE_OBSTRUCTION:
          feat = dungeonFeatureCatalog[DF_FORCEFIELD];
					feat.probabilityDecrement = max(1, 75 * POW_OBSTRUCTION[min(40, theBolt.magnitude) - 2] >> FP_BASE);
          await spawnDungeonFeature(x, y, feat, true, false);
          autoID = true;
          break;
      case BE_CONJURATION:
          for (i = 0; i < (fp_staffBladeCount(theBolt.magnitude << FP_BASE)); i++) {
              monst = generateMonster(MK_SPECTRAL_BLADE, true, false);
              const loc = getQualifyingPathLocNear(x, y, true,
                                       T_DIVIDES_LEVEL & avoidedFlagsForMonster(monst.info) & ~T_SPONTANEOUSLY_IGNITES, HAS_PLAYER,
                                       avoidedFlagsForMonster(monst.info) & ~T_SPONTANEOUSLY_IGNITES, (HAS_PLAYER | HAS_MONSTER | HAS_STAIRS), false);
							if (!loc) ERROR('EXPECTED LOCATION');
							monst.xLoc = loc[0];
							monst.yLoc = loc[1];
              monst.bookkeepingFlags |= (MB_FOLLOWER | MB_BOUND_TO_LEADER | MB_DOES_NOT_TRACK_LEADER);
              monst.bookkeepingFlags &= ~MB_JUST_SUMMONED;
              monst.leader = player;
              monst.creatureState = MONSTER_ALLY;
              monst.ticksUntilTurn = monst.info.attackSpeed + 1; // So they don't move before the player's next turn.
              pmap[monst.xLoc][monst.yLoc].flags |= HAS_MONSTER;
              //refreshDungeonCell(monst.xLoc, monst.yLoc);
              fadeInMonster(monst);
          }
          updateVision(true);
          //refreshSideBar(-1, -1, false);
          monst = NULL;
					autoID = true;
          break;
      case BE_BLINKING:
          if (pmap[x][y].flags & HAS_MONSTER) { // We're blinking onto an area already occupied by a submerged monster.
                                                // Make sure we don't get the shooting monster by accident.
              caster.xLoc = caster.yLoc = -1; // Will be set back to the destination in a moment.
              monst = monsterAtLoc(x, y);
              const loc = findAlternativeHomeFor(monst, x2, y2, true);
							x2 = loc[0];
							y2 = loc[1];
              if (x2 >= 0) {
                  // Found an alternative location.
                  monst.xLoc = x2;
                  monst.yLoc = y2;
                  pmap[x][y].flags &= ~HAS_MONSTER;
                  pmap[x2][y2].flags |= HAS_MONSTER;
              } else {
                  // No alternative location?? Hard to imagine how this could happen.
                  // Just bury the monster and never speak of this incident again.
                  await killCreature(monst, true);
                  pmap[x][y].flags &= ~HAS_MONSTER;
                  monst = NULL;
              }
          }
          caster.bookkeepingFlags &= ~MB_SUBMERGED;
          pmap[x][y].flags |= (caster === player ? HAS_PLAYER : HAS_MONSTER);
          caster.xLoc = x;
          caster.yLoc = y;
          await applyInstantTileEffectsToCreature(caster);
          if (caster === player) {
              // increase scent turn number so monsters don't sniff around at the old cell like idiots
              rogue.scentTurnNumber += 30;
              // get any items at the destination location
              if (pmap[player.xLoc][player.yLoc].flags & HAS_ITEM) {
                  await pickUpItemAt(player.xLoc, player.yLoc);
              }
              updateVision(true);
          }
					autoID = true;
          break;
      case BE_TUNNELING:
          setUpWaypoints(); // Recompute waypoints based on the new situation.
          break;
  }

  if (theBolt.targetDF) {
      await spawnDungeonFeature(x, y, dungeonFeatureCatalog[theBolt.targetDF], true, false);
  }

	return autoID;
}

// returns whether the bolt effect should autoID any staff or wand it came from, if it came from a staff or wand

async function zap(originLoc /* short[2] */, targetLoc /* short[2] */, /* bolt */ theBolt, hideDetails) {
	let listOfCoordinates = ARRAY(MAX_BOLT_LENGTH, () => [-1, -1] ); // short [MAX_BOLT_LENGTH][2];
	let i, j, k, x, y, x2, y2, numCells, blinkDistance, boltLength, initialBoltLength;
	const lights = GRID(DCOLS, DROWS, () => [0, 0, 0] ); 	// char [DCOLS][DROWS][3];
	let monst = NULL, shootingMonst;	// creature *
	const buf = STRING(), monstName = STRING(); 	// char[COLS];
	let autoID = false;
  let lightingChanged = false;
	let fastForward = false;
	let alreadyReflected = false;
	let boltInView;
	let boltColor;
	let boltLightRadius;

  let theChar;
  const foreColor = color(), backColor = color(), multColor = color();

	const boltLights = ARRAY(500, lightSource);
	const boltLightColors = ARRAY(500, color);

  brogueAssert(originLoc[0] != targetLoc[0] || originLoc[1] != targetLoc[1]);
	if (originLoc[0] == targetLoc[0] && originLoc[1] == targetLoc[1]) {
		return false;
	}

	x = originLoc[0];
	y = originLoc[1];

	initialBoltLength = boltLength = 5 * theBolt.magnitude;
	numCells = getLineCoordinates(listOfCoordinates, originLoc, targetLoc);
	shootingMonst = monsterAtLoc(originLoc[0], originLoc[1]);

	if (hideDetails) {
		boltColor = gray;
	} else {
		boltColor = theBolt.backColor;
	}

	refreshSideBar(-1, -1, false);
  displayCombatText(); // To announce who fired the bolt while the animation plays.

	if (theBolt.boltEffect == BE_BLINKING) {
		if (cellHasTerrainFlag(listOfCoordinates[0][0], listOfCoordinates[0][1], (T_OBSTRUCTS_PASSABILITY | T_OBSTRUCTS_VISION))
			|| ((pmap[listOfCoordinates[0][0]][listOfCoordinates[0][1]].flags & (HAS_PLAYER | HAS_MONSTER))
				&& !(monsterAtLoc(listOfCoordinates[0][0], listOfCoordinates[0][1]).bookkeepingFlags & MB_SUBMERGED)))
		{
			// shooting blink point-blank into an obstruction does nothing.
			return false;
		}
    theBolt.foreColor = black;
    theBolt.theChar = shootingMonst.info.displayChar;
		pmap[originLoc[0]][originLoc[1]].flags &= ~(HAS_PLAYER | HAS_MONSTER);
		refreshDungeonCell(originLoc[0], originLoc[1]);
		blinkDistance = theBolt.magnitude * 2 + 1;
		await checkForMissingKeys(originLoc[0], originLoc[1]);
	}

  if (boltColor) {
      for (i=0; i<initialBoltLength; i++) {
          boltLightColors[i].copy(boltColor);
          boltLights[i] = lightCatalog[BOLT_LIGHT_SOURCE];
          boltLights[i].lightColor = boltLightColors[i];
					boltLightRadius = 50 * ((3 << FP_BASE) + (theBolt.magnitude << FP_BASE) * 4/3) * (initialBoltLength - i) / initialBoltLength >> FP_BASE;
					boltLights[i].lightRadius.lowerBound = boltLights[i].lightRadius.upperBound = boltLightRadius;
      }
  }

	if (theBolt.boltEffect == BE_TUNNELING) {
		await tunnelize(originLoc[0], originLoc[1]);
	}

	backUpLighting(lights);
	boltInView = true;
	for (i=0; i<numCells; i++) {

		x = listOfCoordinates[i][0];
		y = listOfCoordinates[i][1];

		monst = monsterAtLoc(x, y);

    // Handle bolt reflection off of creatures (reflection off of terrain is handled further down).
		if (monst
            && !(theBolt.flags & BF_NEVER_REFLECTS)
            && projectileReflects(shootingMonst, monst)
            && i < MAX_BOLT_LENGTH - max(DCOLS, DROWS))
		{
			if (projectileReflects(shootingMonst, monst)) { // if it scores another reflection roll, reflect at caster
				numCells = reflectBolt(originLoc[0], originLoc[1], listOfCoordinates, i, !alreadyReflected);
			} else {
				numCells = reflectBolt(-1, -1, listOfCoordinates, i, false); // otherwise reflect randomly
			}

			alreadyReflected = true;

			if (boltInView) {
				monsterName(monstName, monst, true);
				sprintf(buf, "%s deflect%s the %s",
                        monstName,
                        (monst === player ? "" : "s"),
                        theBolt.name);
				combatMessage(buf, 0);
			}
      if (monst === player
          && rogue.armor
          && rogue.armor.enchant2 == A_REFLECTION
          && !(rogue.armor.flags & ITEM_RUNIC_IDENTIFIED))
			{
          autoIdentify(rogue.armor);
      }
			continue;
		}

		const boltResult = await updateBolt(theBolt, shootingMonst, x, y, boltInView, alreadyReflected);
		autoID = boltResult & BR_AUTO_ID;
		lightingChanged = boltResult & BR_LIGHTING_CHANGED;
    if (boltResult & BR_DONE) {
        break;
    }

    if (lightingChanged) {
        updateVision(true);
        backUpLighting(lights);
    }

		// Update the visual effect of the bolt.
        // First do lighting. This lighting effect is expensive; do it only if the player can see the bolt.
		if (boltInView && boltColor) {
			demoteVisibility();
			restoreLighting(lights);
			for (k = min(i, boltLength + 2); k >= 0; k--) {
				if (k < initialBoltLength) {
					paintLight(boltLights[k], listOfCoordinates[i-k][0], listOfCoordinates[i-k][1], false, false);
				}
			}
		}
		boltInView = false;
		updateFieldOfViewDisplay(false, true);
    // Now draw the bolt itself.
		for (k = min(i, boltLength + 2); k >= 0; k--) {
            x2 = listOfCoordinates[i-k][0];
            y2 = listOfCoordinates[i-k][1];
            if (playerCanSeeOrSense(x2, y2)) {
                if (!fastForward) {
                    const app = getCellAppearance(x2, y2);
                    if (boltColor) {
                        applyColorAugment(app.foreColor, boltColor, max(0, 100 - k * 100 / (boltLength)));
                        applyColorAugment(app.backColor, boltColor, max(0, 100 - k * 100 / (boltLength)));
                    }
                    const displayChar = (k == 0 || (theBolt.flags & BF_DISPLAY_CHAR_ALONG_LENGTH));
                    if (displayChar) {
                        if (theBolt.foreColor) {
                            app.foreColor.copy(theBolt.foreColor);
                        }
                        if (theBolt.theChar) {
                            app.char = theBolt.theChar;
                        }
                    }
                    if (displayChar
                        && theBolt.foreColor
                        && theBolt.theChar)
										{
                        colorMultiplierFromDungeonLight(x2, y2, multColor);
                        applyColorMultiplier(app.foreColor, multColor);
                        plotCharWithColor(app.char, mapToWindowX(x2), mapToWindowY(y2), app.foreColor, app.backColor);
                    } else if (boltColor) {
                        plotCharWithColor(app.char, mapToWindowX(x2), mapToWindowY(y2), app.foreColor, app.backColor);
                    } else if (k == 1
                               && theBolt.foreColor
                               && theBolt.theChar)
										 {
                        refreshDungeonCell(x2, y2); // Clean up the contrail so it doesn't leave a trail of characters.
                    }
                }
                if (playerCanSee(x2, y2)) {
                    // Don't want to let omniscience mode affect boltInView; causes OOS.
                    boltInView = true;
                }
            }
		}
		if (!fastForward && (boltInView || rogue.playbackOmniscience)) {
			fastForward = rogue.playbackFastForward || await pauseBrogue(16);
		}

		if (theBolt.boltEffect == BE_BLINKING) {
			theBolt.magnitude = Math.floor((blinkDistance - i) / 2) + 1;
			boltLength = theBolt.magnitude * 5;
			for (j=0; j<i; j++) {
				refreshDungeonCell(listOfCoordinates[j][0], listOfCoordinates[j][1]);
			}
			if (i >= blinkDistance) {
				break;
			}
		}

		// Some bolts halt at the square before they hit something.
		if ((theBolt.flags & BF_HALTS_BEFORE_OBSTRUCTION) && i + 1 < numCells)
		{
      x2 = listOfCoordinates[i+1][0];
      y2 = listOfCoordinates[i+1][1];

			if (cellHasTerrainFlag(x2, y2, (T_OBSTRUCTS_VISION | T_OBSTRUCTS_PASSABILITY))) {
          break;
      }

      if (!(theBolt.flags & BF_PASSES_THRU_CREATURES)) {
          monst = monsterAtLoc(listOfCoordinates[i+1][0], listOfCoordinates[i+1][1]);
          if (monst && !(monst.bookkeepingFlags & MB_SUBMERGED)) {
              break;
          }
      }
  	}

    // Tunnel if we hit a wall.
    if (cellHasTerrainFlag(x, y, (T_OBSTRUCTS_PASSABILITY | T_OBSTRUCTS_VISION))
        && theBolt.boltEffect == BE_TUNNELING
        && await tunnelize(x, y))
		{
        updateVision(true);
        backUpLighting(lights);
        autoID = true;
        theBolt.magnitude--;
        boltLength = theBolt.magnitude * 5;
        for (j=0; j<i; j++) {
            refreshDungeonCell(listOfCoordinates[j][0], listOfCoordinates[j][1]);
        }
        if (theBolt.magnitude <= 0) {
            refreshDungeonCell(listOfCoordinates[i-1][0], listOfCoordinates[i-1][1]);
            refreshDungeonCell(x, y);
            break;
        }
    }

    // Stop when we hit a wall.
		if (cellHasTerrainFlag(x, y, (T_OBSTRUCTS_PASSABILITY | T_OBSTRUCTS_VISION))) {
        break;
		}

		// Does the bolt bounce before hitting a wall?
		// Can happen with a cursed deflection ring or a reflective terrain target, or when shooting a tunneling bolt into an impregnable wall.
		if (i + 1 < numCells && !(theBolt.flags & BF_NEVER_REFLECTS))
		{
      x2 = listOfCoordinates[i+1][0];
      y2 = listOfCoordinates[i+1][1];
			if (cellHasTerrainFlag(x2, y2, (T_OBSTRUCTS_VISION | T_OBSTRUCTS_PASSABILITY))
          && (projectileReflects(shootingMonst, NULL)
              || cellHasTMFlag(x2, y2, TM_REFLECTS_BOLTS)
              || (theBolt.boltEffect == BE_TUNNELING && (pmap[x2][y2].flags & IMPREGNABLE)))
          && i < MAX_BOLT_LENGTH - max(DCOLS, DROWS))
			{
        sprintf(buf, "the bolt reflects off of %s", tileText(x2, y2));
        if (projectileReflects(shootingMonst, NULL)) {
            // If it scores another reflection roll, reflect at caster, unless it's already reflected.
            numCells = reflectBolt(originLoc[0], originLoc[1], listOfCoordinates, i, !alreadyReflected);
        } else {
            numCells = reflectBolt(-1, -1, listOfCoordinates, i, false); // Otherwise reflect randomly.
        }
        alreadyReflected = true;
        if (boltInView) {
            combatMessage(buf, 0);
        }
      }
    }
	}

  if (!fastForward) {
      refreshDungeonCell(x, y);
      if (i > 0) {
          refreshDungeonCell(listOfCoordinates[i-1][0], listOfCoordinates[i-1][1]);
      }
  }

	if (pmap[x][y].flags & (HAS_MONSTER | HAS_PLAYER)) {
		monst = monsterAtLoc(x, y);
		monsterName(monstName, monst, true);
	} else {
		monst = NULL;
	}

  autoID = await detonateBolt(theBolt, shootingMonst, x, y);

	updateLighting();
	backUpLighting(lights);
	boltInView = true;
	refreshSideBar(-1, -1, false);
	if (boltLength > 0) {
        if (boltColor) {
            // j is where the front tip of the bolt would be if it hadn't collided at i
            for (j=i; j < i + boltLength + 2; j++) { // j can imply a bolt tip position that is off the map

                // dynamic lighting
                if (boltInView) {
                    demoteVisibility();
                    restoreLighting(lights);

                    // k = j-i;
                    // boltLights[k].lightRadius.lowerBound *= 2;
                    // boltLights[k].lightRadius.upperBound *= 2;
                    // boltLights[k].lightColor = &boltImpactColor;

                    for (k = min(j, boltLength + 2); k >= j-i; k--) {
                        if (k < initialBoltLength) {
                            paintLight(boltLights[k], listOfCoordinates[j-k][0], listOfCoordinates[j-k][1], false, false);
                        }
                    }
                    updateFieldOfViewDisplay(false, true);
                }

                boltInView = false;

                // beam graphic
                // k iterates from the tail tip of the visible portion of the bolt to the head
                for (k = min(j, boltLength + 2); k >= j-i; k--) {
                    if (playerCanSee(listOfCoordinates[j-k][0], listOfCoordinates[j-k][1])) {
                        if (boltColor) {
                            hiliteCell(listOfCoordinates[j-k][0], listOfCoordinates[j-k][1], boltColor, max(0, 100 - k * 100 / (boltLength)), false);
                        }
                        boltInView = true;
                    }
                }

                if (!fastForward && boltInView) {
                    fastForward = rogue.playbackFastForward || await pauseBrogue(16);
                }
            }
        } else if (theBolt.flags & BF_DISPLAY_CHAR_ALONG_LENGTH) {
            for (j = 0; j < i; j++) {
                x2 = listOfCoordinates[j][0];
                y2 = listOfCoordinates[j][1];
                if (playerCanSeeOrSense(x2, y2)) {
                    refreshDungeonCell(x2, y2);
                }
            }
        }
    }
    return autoID;
}

// Relies on the sidebar entity list. If one is already selected, select the next qualifying. Otherwise, target the first qualifying.
function nextTargetAfter(
                        targetX,
                        targetY,
                        targetEnemies,
                        targetAllies,
                        targetItems,
                        targetTerrain,
                        requireOpenPath,
                        reverseDirection)
{
	let returnX = -1, returnY = -1;
  let i, n, targetCount, newX, newY;
  let selectedIndex = 0;
  let monst;		// creature *
  let theItem;	// item *
  const deduplicatedTargetList = ARRAY(ROWS, () => [-1, -1]); // short[ROWS][2];

  targetCount = 0;
  for (i=0; i<ROWS; i++) {
      if (rogue.sidebarLocationList[i][0] != -1) {
          if (targetCount == 0
              || deduplicatedTargetList[targetCount-1][0] != rogue.sidebarLocationList[i][0]
              || deduplicatedTargetList[targetCount-1][1] != rogue.sidebarLocationList[i][1])
					{
              deduplicatedTargetList[targetCount][0] = rogue.sidebarLocationList[i][0];
              deduplicatedTargetList[targetCount][1] = rogue.sidebarLocationList[i][1];
              if (rogue.sidebarLocationList[i][0] == targetX
                  && rogue.sidebarLocationList[i][1] == targetY)
							{
                  selectedIndex = targetCount;
              }
              targetCount++;
          }
      }
  }

  for (i = reverseDirection ? targetCount - 1 : 0; reverseDirection ? i >= 0 : i < targetCount; reverseDirection ? i-- : i++) {
      n = (selectedIndex + i) % targetCount;
      newX = deduplicatedTargetList[n][0];
      newY = deduplicatedTargetList[n][1];
      if ((newX != player.xLoc || newY != player.yLoc)
          && (newX != targetX || newY != targetY)
          && (!requireOpenPath || openPathBetween(player.xLoc, player.yLoc, newX, newY)))
			{
          brogueAssert(coordinatesAreInMap(newX, newY));
          brogueAssert(n >= 0 && n < targetCount);
          monst = monsterAtLoc(newX, newY);
          if (monst) {
              if (monstersAreEnemies(player, monst)) {
                  if (targetEnemies) {
                      return [newX, newY];
                  }
              } else {
                  if (targetAllies) {
                      return [newX, newY];
                  }
              }
          }
          theItem = itemAtLoc(newX, newY);
          if (!monst && theItem && targetItems) {
              return [newX, newY];
          }
          if (!monst && !theItem && targetTerrain) {
              return [newX, newY];
          }
      }
  }
  return null;
}

// Returns how far it went before hitting something.
function hiliteTrajectory( coordinateList /* short[DCOLS][2] */, numCells, eraseHiliting, passThroughMonsters, /* color */ hiliteColor)
{
	let x, y, i;
	let monst;	// creature *

	for (i=0; i<numCells; i++) {
		x = coordinateList[i][0];
		y = coordinateList[i][1];
		if (eraseHiliting) {
			refreshDungeonCell(x, y);
		} else {
			hiliteCell(x, y, hiliteColor, 20, true);
		}

		if (cellHasTerrainFlag(x, y, (T_OBSTRUCTS_VISION | T_OBSTRUCTS_PASSABILITY))
			|| pmap[x][y].flags & (HAS_PLAYER))
		{
			i++;
			break;
		} else if (!(pmap[x][y].flags & DISCOVERED)) {
			break;
		} else if (!passThroughMonsters && pmap[x][y].flags & (HAS_MONSTER)
				   && (playerCanSee(x, y) || player.status[STATUS_TELEPATHIC]))
	  {
			monst = monsterAtLoc(x, y);
			if (!(monst.bookkeepingFlags & MB_SUBMERGED)
				&& !monsterIsHidden(monst, player))
			{
				i++;
				break;
			}
		}
	}
	return i;
}

// Event is optional. Returns true if the event should be executed by the parent function.
async function moveCursor(
				   targetLoc, // short[2],
				   returnEvent,	// rogueEvent *
				   state,			// buttonState *
				   colorsDance,
				   keysMoveCursor,
				   targetCanLeaveMap)
{
	let keystroke;
	let moveIncrement;
	let buttonInput;
	let cursorMovementCommand, again, movementKeystroke, sidebarHighlighted;
	const theEvent = rogueEvent();

	const cursor = rogue.cursorLoc; // shorthand
	cursor[0] = targetLoc[0];
	cursor[1] = targetLoc[1];

	const result = {
		targetConfirmed: false,
		canceled: false,
		tabKey: false,
		executeEvent: false,
		targetLoc: targetLoc, // reference same one so it is in the results
	};

	sidebarHighlighted = false;

	do {
		again = false;
		cursorMovementCommand = false;
		movementKeystroke = false;

    // oldRNG = rogue.RNG;
    // rogue.RNG = RNG_COSMETIC;
		// assureCosmeticRNG();

		if (state) { // Also running a button loop.

			// Update the display.
			overlayDisplayBuffer(state.dbuf, NULL);

			// Get input.
			await nextBrogueEvent(theEvent, false, colorsDance, true);

			// Process the input.
			buttonInput = await processButtonInput(state, theEvent);

			if (buttonInput != -1) {
				state.buttonDepressed = state.buttonFocused = -1;
				drawButtonsInState(state);
			}

			// Revert the display.
			overlayDisplayBuffer(state.rbuf, NULL);

		} else { // No buttons to worry about.
			await nextBrogueEvent(theEvent, false, colorsDance, true);
		}
		// restoreRNG();

		if (theEvent.eventType == MOUSE_UP || theEvent.eventType == MOUSE_ENTERED_CELL) {
			if (theEvent.param1 >= 0
				&& theEvent.param1 < mapToWindowX(0)
				&& theEvent.param2 >= 0
				&& theEvent.param2 < ROWS - 1
				&& rogue.sidebarLocationList[theEvent.param2][0] > -1) {

				// If the cursor is on an entity in the sidebar.
				cursor[0] = rogue.sidebarLocationList[theEvent.param2][0];
				cursor[1] = rogue.sidebarLocationList[theEvent.param2][1];
				sidebarHighlighted = true;
				cursorMovementCommand = true;
				refreshSideBar(cursor[0], cursor[1], false);
				if (theEvent.eventType == MOUSE_UP) {
					result.targetConfirmed = true;
				}
			} else if (coordinatesAreInMap(windowToMapX(theEvent.param1), windowToMapY(theEvent.param2))
                       || targetCanLeaveMap && theEvent.eventType != MOUSE_UP)
			{
				// If the cursor is in the map area, or is allowed to leave the map and it isn't a click.
				if (theEvent.eventType == MOUSE_UP
					&& !theEvent.shiftKey
					&& (theEvent.controlKey || (cursor[0] == windowToMapX(theEvent.param1) && cursor[1] == windowToMapY(theEvent.param2))))
				{
					result.targetConfirmed = true;
				}
				cursor[0] = windowToMapX(theEvent.param1);
				cursor[1] = windowToMapY(theEvent.param2);
				cursorMovementCommand = true;
			} else {
				cursorMovementCommand = false;
				again = theEvent.eventType != MOUSE_UP;
			}
		} else if (theEvent.eventType == KEYSTROKE) {
			keystroke = theEvent.param1;
			moveIncrement = ( (theEvent.controlKey || theEvent.shiftKey) ? 5 : 1 );
			keystroke = stripShiftFromMovementKeystroke(keystroke);
			switch(keystroke) {
				case LEFT_ARROW:
				case LEFT_KEY:
				case NUMPAD_4:
					if (keysMoveCursor && cursor[0] > 0) {
						cursor[0] -= moveIncrement;
					}
					cursorMovementCommand = movementKeystroke = keysMoveCursor;
					break;
				case RIGHT_ARROW:
				case RIGHT_KEY:
				case NUMPAD_6:
					if (keysMoveCursor && cursor[0] < DCOLS - 1) {
						cursor[0] += moveIncrement;
					}
					cursorMovementCommand = movementKeystroke = keysMoveCursor;
					break;
				case UP_ARROW:
				case UP_KEY:
				case NUMPAD_8:
					if (keysMoveCursor && cursor[1] > 0) {
						cursor[1] -= moveIncrement;
					}
					cursorMovementCommand = movementKeystroke = keysMoveCursor;
					break;
				case DOWN_ARROW:
				case DOWN_KEY:
				case NUMPAD_2:
					if (keysMoveCursor && cursor[1] < DROWS - 1) {
						cursor[1] += moveIncrement;
					}
					cursorMovementCommand = movementKeystroke = keysMoveCursor;
					break;
				case UPLEFT_KEY:
				case NUMPAD_7:
					if (keysMoveCursor && cursor[0] > 0 && cursor[1] > 0) {
						cursor[0] -= moveIncrement;
						cursor[1] -= moveIncrement;
					}
					cursorMovementCommand = movementKeystroke = keysMoveCursor;
					break;
				case UPRIGHT_KEY:
				case NUMPAD_9:
					if (keysMoveCursor && cursor[0] < DCOLS - 1 && cursor[1] > 0) {
						cursor[0] += moveIncrement;
						cursor[1] -= moveIncrement;
					}
					cursorMovementCommand = movementKeystroke = keysMoveCursor;
					break;
				case DOWNLEFT_KEY:
				case NUMPAD_1:
					if (keysMoveCursor && cursor[0] > 0 && cursor[1] < DROWS - 1) {
						cursor[0] -= moveIncrement;
						cursor[1] += moveIncrement;
					}
					cursorMovementCommand = movementKeystroke = keysMoveCursor;
					break;
				case DOWNRIGHT_KEY:
				case NUMPAD_3:
					if (keysMoveCursor && cursor[0] < DCOLS - 1 && cursor[1] < DROWS - 1) {
						cursor[0] += moveIncrement;
						cursor[1] += moveIncrement;
					}
					cursorMovementCommand = movementKeystroke = keysMoveCursor;
					break;
				case TAB_KEY:
        case SHIFT_TAB_KEY:
				case NUMPAD_0:
					result.tabKey = true;
					break;
				case RETURN_KEY:
				case ENTER_KEY:
					result.targetConfirmed = true;
					break;
				case ESCAPE_KEY:
				case ACKNOWLEDGE_KEY:
					result.canceled = true;
					break;
				default:
					break;
			}
		} else if (theEvent.eventType == RIGHT_MOUSE_UP) {
			// do nothing
		} else {
			again = true;
		}

		if (sidebarHighlighted
			&& (!(pmap[cursor[0]][cursor[1]].flags & (HAS_PLAYER | HAS_MONSTER))
                || !canSeeMonster(monsterAtLoc(cursor[0], cursor[1])))
			&& (!(pmap[cursor[0]][cursor[1]].flags & HAS_ITEM) || !playerCanSeeOrSense(cursor[0], cursor[1]))
			&& (!cellHasTMFlag(cursor[0], cursor[1], TM_LIST_IN_SIDEBAR) || !playerCanSeeOrSense(cursor[0], cursor[1])))
		{
			// The sidebar is highlighted but the cursor is not on a visible item, monster or terrain. Un-highlight the sidebar.
			refreshSideBar(-1, -1, false);
			sidebarHighlighted = false;
		}

		if (targetCanLeaveMap && !movementKeystroke) {
			// permit it to leave the map by up to 1 space in any direction if mouse controlled.
			cursor[0] = clamp(cursor[0], -1, DCOLS);
			cursor[1] = clamp(cursor[1], -1, DROWS);
		} else {
			cursor[0] = clamp(cursor[0], 0, DCOLS - 1);
			cursor[1] = clamp(cursor[1], 0, DROWS - 1);
		}
	} while (again && (!event || !cursorMovementCommand));

	if (returnEvent) {
		returnEvent.copy(theEvent);
	}

	if (sidebarHighlighted) {
		// Don't leave the sidebar highlighted when we exit.
		refreshSideBar(-1, -1, false);
		sidebarHighlighted = false;
	}

	targetLoc[0] = cursor[0];
	targetLoc[1] = cursor[1];

	result.executeEvent = !cursorMovementCommand;
	return result; // !cursorMovementCommand;
}

async function pullMouseClickDuringPlayback( loc /* short[2] */) {
	const theEvent = rogueEvent();

  brogueAssert(rogue.playbackMode);
	await nextBrogueEvent(theEvent, false, false, false);
	loc[0] = windowToMapX(theEvent.param1);
	loc[1] = windowToMapY(theEvent.param2);
}

// Return true if a target is chosen, or false if canceled.
async function chooseTarget( returnLoc,	// short[2]
					 maxDistance,
					 stopAtTarget,
					 autoTarget,
					 targetAllies,
					 passThroughCreatures,
           trajectoryColor /* color */)
{
	const originLoc = [-1, -1], targetLoc = [-1, -1], oldTargetLoc = [-1, -1], coordinates = ARRAY(DCOLS, () => [-1, -1] ); // short[DCOLS][2],
	let numCells, i, distance, newX, newY;
	let monst;		// creature *
	let canceled, targetConfirmed, tabKey, cursorInTrajectory, focusedOnSomething = false;
	let moveResult;
	const event = rogueEvent();
    // short oldRNG;
  const trajColor = color(); // *trajectoryColor;
	trajColor.copy(trajectoryColor);

  normColor(trajColor, 100, 10);

	if (rogue.playbackMode) {
		// In playback, pull the next event (a mouseclick) and use that location as the target.
		await pullMouseClickDuringPlayback(returnLoc);
		rogue.cursorLoc[0] = rogue.cursorLoc[1] = -1;
		return true;
	}

  // oldRNG = rogue.RNG;
  // rogue.RNG = RNG_COSMETIC;
	// assureCosmeticRNG();

	originLoc[0] = player.xLoc;
	originLoc[1] = player.yLoc;

	targetLoc[0] = oldTargetLoc[0] = player.xLoc;
	targetLoc[1] = oldTargetLoc[1] = player.yLoc;

	if (autoTarget) {
		if (rogue.lastTarget
			&& canSeeMonster(rogue.lastTarget)
			&& (targetAllies == (rogue.lastTarget.creatureState == MONSTER_ALLY))
			&& rogue.lastTarget.depth == rogue.depthLevel
			&& !(rogue.lastTarget.bookkeepingFlags & MB_IS_DYING)
			&& openPathBetween(player.xLoc, player.yLoc, rogue.lastTarget.xLoc, rogue.lastTarget.yLoc))
		{
			monst = rogue.lastTarget;
		} else {
			//rogue.lastTarget = NULL;
			const loc = nextTargetAfter(targetLoc[0], targetLoc[1], !targetAllies, targetAllies, false, false, true, false);
			if (loc) {
				newX = loc[0];
				newY = loc[1];
        targetLoc[0] = newX;
        targetLoc[1] = newY;
      }
      monst = monsterAtLoc(targetLoc[0], targetLoc[1]);
		}
		if (monst) {
			targetLoc[0] = monst.xLoc;
			targetLoc[1] = monst.yLoc;
			refreshSideBar(monst.xLoc, monst.yLoc, false);
			focusedOnSomething = true;
		}
	}

	numCells = getLineCoordinates(coordinates, originLoc, targetLoc);
	if (maxDistance > 0) {
		numCells = min(numCells, maxDistance);
	}
	if (stopAtTarget) {
		numCells = min(numCells, distanceBetween(player.xLoc, player.yLoc, targetLoc[0], targetLoc[1]));
	}

	targetConfirmed = canceled = tabKey = false;

	do {
		printLocationDescription(targetLoc[0], targetLoc[1]);

		if (canceled) {
			refreshDungeonCell(oldTargetLoc[0], oldTargetLoc[1]);
			hiliteTrajectory(coordinates, numCells, true, passThroughCreatures, trajectoryColor);
			confirmMessages();
			rogue.cursorLoc[0] = rogue.cursorLoc[1] = -1;
			// restoreRNG();
			return false;
		}

		if (tabKey) {
			const loc = nextTargetAfter(targetLoc[0], targetLoc[1], !targetAllies, targetAllies, false, false, true, event.shiftKey);
			if (loc) {
				newX = loc[0];
				newY = loc[1];
        targetLoc[0] = newX;
        targetLoc[1] = newY;
      }
		}

		monst = monsterAtLoc(targetLoc[0], targetLoc[1]);
		if (monst != NULL && monst !== player && canSeeMonster(monst)) {
			focusedOnSomething = true;
    } else if (playerCanSeeOrSense(targetLoc[0], targetLoc[1])
               && (pmap[targetLoc[0]][targetLoc[1]].flags & HAS_ITEM) || cellHasTMFlag(targetLoc[0], targetLoc[1], TM_LIST_IN_SIDEBAR))
	  {
        focusedOnSomething = true;
		} else if (focusedOnSomething) {
			refreshSideBar(-1, -1, false);
			focusedOnSomething = false;
		}
    if (focusedOnSomething) {
			refreshSideBar(targetLoc[0], targetLoc[1], false);
    }

		refreshDungeonCell(oldTargetLoc[0], oldTargetLoc[1]);
		hiliteTrajectory(coordinates, numCells, true, passThroughCreatures, trajColor);

		if (!targetConfirmed) {
			numCells = getLineCoordinates(coordinates, originLoc, targetLoc);
			if (maxDistance > 0) {
				numCells = min(numCells, maxDistance);
			}

			if (stopAtTarget) {
				numCells = min(numCells, distanceBetween(player.xLoc, player.yLoc, targetLoc[0], targetLoc[1]));
			}
			distance = hiliteTrajectory(coordinates, numCells, false, passThroughCreatures, trajColor);
			cursorInTrajectory = false;
			for (i=0; i<distance; i++) {
				if (coordinates[i][0] == targetLoc[0] && coordinates[i][1] == targetLoc[1]) {
					cursorInTrajectory = true;
					break;
				}
			}
			hiliteCell(targetLoc[0], targetLoc[1], white, (cursorInTrajectory ? 100 : 35), true);
		}

		oldTargetLoc[0] = targetLoc[0];
		oldTargetLoc[1] = targetLoc[1];
		// restoreRNG();
		moveResult = await moveCursor( /* &targetConfirmed, &canceled, &tabKey, */ targetLoc, event, NULL, false, true, false);
		targetConfirmed = moveResult.targetConfirmed;
		canceled = moveResult.canceled;
		tabKey = moveResult.tabKey;
		// assureCosmeticRNG();
		if (event.eventType == RIGHT_MOUSE_UP) { // Right mouse cancels.
			canceled = true;
		}
	} while (!moveResult || !moveResult.targetConfirmed);

	if (maxDistance > 0) {
		numCells = min(numCells, maxDistance);
	}
	hiliteTrajectory(coordinates, numCells, true, passThroughCreatures, trajectoryColor);
	refreshDungeonCell(oldTargetLoc[0], oldTargetLoc[1]);

	if (originLoc[0] == targetLoc[0] && originLoc[1] == targetLoc[1]) {
		confirmMessages();
		// restoreRNG();
		rogue.cursorLoc[0] = rogue.cursorLoc[1] = -1;
		return false;
	}

	monst = monsterAtLoc(targetLoc[0], targetLoc[1]);
	if (monst && monst !== player && canSeeMonster(monst)) {
		rogue.lastTarget = monst;
	}

	returnLoc[0] = targetLoc[0];
	returnLoc[1] = targetLoc[1];
	// restoreRNG();
	rogue.cursorLoc[0] = rogue.cursorLoc[1] = -1;
	return true;
}


function identifyItemKind( /* item */ theItem) {
  let theTable;	// itemTable *
	let tableCount, i, lastItem;

    theTable = tableForItemCategory(theItem.category, NULL);
    if (theTable) {
			theItem.flags &= ~ITEM_KIND_AUTO_ID;

	    tableCount = 0;
	    lastItem = -1;

	    switch (theItem.category) {
	        case SCROLL:
	            tableCount = NUMBER_SCROLL_KINDS;
	            break;
	        case POTION:
	            tableCount = NUMBER_POTION_KINDS;
	            break;
	        case WAND:
	            tableCount = NUMBER_WAND_KINDS;
	            break;
	        case STAFF:
	            tableCount = NUMBER_STAFF_KINDS;
	            break;
	        case RING:
	            tableCount = NUMBER_RING_KINDS;
	            break;
	        default:
	            break;
	    }
	    if ((theItem.category & RING)
	        && theItem.enchant1 <= 0)
			{
	        theItem.flags |= ITEM_IDENTIFIED;
	    }

	    if ((theItem.category & WAND)
	        && theTable[theItem.kind].range.lowerBound == theTable[theItem.kind].range.upperBound)
			{
	        theItem.flags |= ITEM_IDENTIFIED;
	    }
	    if (tableCount) {
	        theTable[theItem.kind].identified = true;
	        for (i=0; i<tableCount; i++) {
	            if (!(theTable[i].identified)) {
	                if (lastItem != -1) {
	                    return; // At least two unidentified items remain.
	                }
	                lastItem = i;
	            }
	        }
	        if (lastItem != -1) {
	            // Exactly one unidentified item remains; identify it.
	            theTable[lastItem].identified = true;
	        }
	    }
    }
}

function autoIdentify(/* item */ theItem) {
	let quantityBackup;
	const buf = STRING(), oldName = STRING(), newName = STRING();

    if (tableForItemCategory(theItem.category, NULL)
        && !tableForItemCategory(theItem.category, NULL)[theItem.kind].identified)
		{
        identifyItemKind(theItem);
        quantityBackup = theItem.quantity;
        theItem.quantity = 1;
        itemName(theItem, newName, false, true, NULL);
        theItem.quantity = quantityBackup;
        sprintf(buf, "(It must %s %s.)",
                ((theItem.category & (POTION | SCROLL)) ? "have been" : "be"),
                newName);
        message(buf, itemMessageColor, false);
    }

    if ((theItem.category & (WEAPON | ARMOR))
        && (theItem.flags & ITEM_RUNIC)
        && !(theItem.flags & ITEM_RUNIC_IDENTIFIED))
		{
        itemName(theItem, oldName, false, false, NULL);
        theItem.flags |= (ITEM_RUNIC_IDENTIFIED | ITEM_RUNIC_HINTED);
        itemName(theItem, newName, true, true, NULL);
        sprintf(buf, "(Your %s must be %s.)", oldName, newName);
        message(buf, itemMessageColor, false);
    }
}

// returns whether the item disappeared
async function hitMonsterWithProjectileWeapon( /* creature */ thrower, /* creature */ monst, /* item */ theItem) {
	const buf = STRING(), theItemName = STRING(), targetName = STRING(), armorRunicString = STRING(); // char[DCOLS]
	let thrownWeaponHit;
	let equippedWeapon;		// item *
	let damage;

	if (!(theItem.category & WEAPON)) {
		return false;
	}

	// armorRunicString[0] = '\0';

	itemName(theItem, theItemName, false, false, NULL);
	monsterName(targetName, monst, true);

	monst.status[STATUS_ENTRANCED] = 0;

	if (monst !== player
		&& monst.creatureMode != MODE_PERM_FLEEING
		&& (monst.creatureState != MONSTER_FLEEING || monst.status[STATUS_MAGICAL_FEAR])
		&& !(monst.bookkeepingFlags & MB_CAPTIVE)
        && monst.creatureState != MONSTER_ALLY)
	{
		monst.creatureState = MONSTER_TRACKING_SCENT;
		if (monst.status[STATUS_MAGICAL_FEAR]) {
			monst.status[STATUS_MAGICAL_FEAR] = 1;
		}
	}

	if (thrower === player) {
		equippedWeapon = rogue.weapon;
		equipItem(theItem, true);
		thrownWeaponHit = attackHit(player, monst);
		if (equippedWeapon) {
			equipItem(equippedWeapon, true);
		} else {
			unequipItem(theItem, true);
		}
	} else {
		thrownWeaponHit = attackHit(thrower, monst);
	}

	if (thrownWeaponHit) {
		damage = monst.info.flags & (MONST_IMMUNE_TO_WEAPONS | MONST_INVULNERABLE) ? 0 :
				  (randClump(theItem.damage) * fp_damageFraction(fp_netEnchant(theItem)) >> FP_BASE);

		if (monst === player) {
			const runicResult = await applyArmorRunicEffect(thrower, damage, false);
     armorRunicString = runicResult.message;
     damage = runicResult.damage;
		}

		if (await inflictDamage(thrower, monst, damage, red, false)) { // monster killed
			sprintf(buf, "the %s %s %s.",
                    theItemName,
                    (monst.info.flags & MONST_INANIMATE) ? "destroyed" : "killed",
                    targetName);
			message(buf, messageColorFromVictim(monst), false);
		} else {
			sprintf(buf, "the %s hit %s.", theItemName, targetName);
			if (theItem.flags & ITEM_RUNIC) {
				await magicWeaponHit(monst, theItem, false);
			}
			message(buf, messageColorFromVictim(monst), false);
		}
    await moralAttack(thrower, monst);
		if ( strlen(armorRunicString) ) {
			message(armorRunicString, false);
		}
		return true;
	} else {
		theItem.flags &= ~ITEM_PLAYER_AVOIDS; // Don't avoid thrown weapons that missed.
		sprintf(buf, "the %s missed %s.", theItemName, targetName);
		message(buf, false);
		return false;
	}
}


async function throwItem(/* item */ theItem, /* creature */ thrower, targetLoc /* short[2] */, maxDistance) {
	const listOfCoordinates = ARRAY(MAX_BOLT_LENGTH, () => [-1, -1] );
	const originLoc = [-1, -1];
	let i, x, y, numCells;
	let monst = NULL;		// creature *
	const buf = STRING(), buf2 = STRING(), buf3 = STRING(); // char[COLS*3];
	let displayChar;
	const multColor = color();
	let dropLoc = [-1, -1];
	let hitSomethingSolid = false, fastForward = false;
  let layer;	// enum dungeonLayers

	theItem.flags |= ITEM_PLAYER_AVOIDS; // Avoid thrown items, unless it's a weapon that misses a monster.

	x = originLoc[0] = thrower.xLoc;
	y = originLoc[1] = thrower.yLoc;

	numCells = getLineCoordinates(listOfCoordinates, originLoc, targetLoc);

	thrower.ticksUntilTurn = thrower.attackSpeed;

	if (thrower !== player
        && (pmap[originLoc[0]][originLoc[1]].flags & IN_FIELD_OF_VIEW))
	{
		monsterName(buf2, thrower, true);
		itemName(theItem, buf3, false, true, NULL);
		sprintf(buf, "%s hurls %s.", buf2, buf3);
		message(buf, false);
	}

	for (i=0; i<numCells && i < maxDistance; i++) {
		x = listOfCoordinates[i][0];
		y = listOfCoordinates[i][1];

		if (pmap[x][y].flags & (HAS_MONSTER | HAS_PLAYER)) {
			monst = monsterAtLoc(x, y);
      if (!(monst.bookkeepingFlags & MB_SUBMERGED)) {
//			if (projectileReflects(thrower, monst) && i < DCOLS*2) {
//				if (projectileReflects(thrower, monst)) { // if it scores another reflection roll, reflect at caster
//					numCells = reflectBolt(originLoc[0], originLoc[1], listOfCoordinates, i, true);
//				} else {
//					numCells = reflectBolt(-1, -1, listOfCoordinates, i, false); // otherwise reflect randomly
//				}
//
//				monsterName(buf2, monst, true);
//				itemName(theItem, buf3, false, false, NULL);
//				sprintf(buf, "%s deflect%s the %s", buf2, (monst === player ? "" : "s"), buf3);
//				combatMessage(buf, 0);
//				continue;
//			}
        if ((theItem.category & WEAPON)
            && theItem.kind != INCENDIARY_DART
            && await hitMonsterWithProjectileWeapon(thrower, monst, theItem))
				{
            return;
        }
        break;
      }
  	}

    // We hit something!
    if (cellHasTerrainFlag(x, y, (T_OBSTRUCTS_PASSABILITY | T_OBSTRUCTS_VISION))) {
        if ((theItem.category & WEAPON)
            && (theItem.kind == INCENDIARY_DART)
            && (cellHasTerrainFlag(x, y, T_IS_FLAMMABLE) || (pmap[x][y].flags & (HAS_MONSTER | HAS_PLAYER))))
				{
            // Incendiary darts thrown at flammable obstructions (foliage, wooden barricades, doors) will hit the obstruction
            // instead of bursting a cell earlier.
        } else if (cellHasTerrainFlag(x, y, T_OBSTRUCTS_PASSABILITY)
                   && cellHasTMFlag(x, y, TM_PROMOTES_ON_PLAYER_ENTRY)
                   && tileCatalog[pmap[x][y].layers[layerWithTMFlag(x, y, TM_PROMOTES_ON_PLAYER_ENTRY)]].flags & T_OBSTRUCTS_PASSABILITY)
			  {
            layer = layerWithTMFlag(x, y, TM_PROMOTES_ON_PLAYER_ENTRY);
            if (tileCatalog[pmap[x][y].layers[layer]].flags & T_OBSTRUCTS_PASSABILITY) {
                message(tileCatalog[pmap[x][y].layers[layer]].flavorText, false);
                await promoteTile(x, y, layer, false);
            }
        } else {
            i--;
            if (i >= 0) {
                x = listOfCoordinates[i][0];
                y = listOfCoordinates[i][1];
            } else { // it was aimed point-blank into an obstruction
                x = thrower.xLoc;
                y = thrower.yLoc;
            }
        }
        hitSomethingSolid = true;
        break;
    }

		if (playerCanSee(x, y)) { // show the graphic
			const app = getCellAppearance(x, y);
			app.foreColor.copy(theItem.foreColor);
			if (playerCanDirectlySee(x, y)) {
				colorMultiplierFromDungeonLight(x, y, multColor);
				applyColorMultiplier(app.foreColor, multColor);
			} else { // clairvoyant visible
				applyColorMultiplier(app.foreColor, clairvoyanceColor);
			}
			plotCharWithColor(theItem.displayChar, mapToWindowX(x), mapToWindowY(y), app.foreColor, app.backColor);

			if (!fastForward) {
				fastForward = rogue.playbackFastForward || await pauseBrogue(25);
			}

			refreshDungeonCell(x, y);
		}

		if (x == targetLoc[0] && y == targetLoc[1]) { // reached its target
			break;
		}
	}

	if ((theItem.category & POTION) && (hitSomethingSolid || !cellHasTerrainFlag(x, y, T_AUTO_DESCENT))) {
		if (theItem.kind == POTION_CONFUSION || theItem.kind == POTION_POISON
			|| theItem.kind == POTION_PARALYSIS || theItem.kind == POTION_INCINERATION
			|| theItem.kind == POTION_DARKNESS || theItem.kind == POTION_LICHEN
			|| theItem.kind == POTION_DESCENT)
		{
			switch (theItem.kind) {
				case POTION_POISON:
					strcpy(buf, "the flask shatters and a deadly purple cloud billows out!");
					await spawnDungeonFeature(x, y, dungeonFeatureCatalog[DF_POISON_GAS_CLOUD_POTION], true, false);
					message(buf, false);
					break;
				case POTION_CONFUSION:
					strcpy(buf, "the flask shatters and a multi-hued cloud billows out!");
					await spawnDungeonFeature(x, y, dungeonFeatureCatalog[DF_CONFUSION_GAS_CLOUD_POTION], true, false);
					message(buf, false);
					break;
				case POTION_PARALYSIS:
					strcpy(buf, "the flask shatters and a cloud of pink gas billows out!");
					await spawnDungeonFeature(x, y, dungeonFeatureCatalog[DF_PARALYSIS_GAS_CLOUD_POTION], true, false);
					message(buf, false);
					break;
				case POTION_INCINERATION:
					strcpy(buf, "the flask shatters and its contents burst violently into flame!");
					message(buf, false);
					await spawnDungeonFeature(x, y, dungeonFeatureCatalog[DF_INCINERATION_POTION], true, false);
					break;
				case POTION_DARKNESS:
					strcpy(buf, "the flask shatters and the lights in the area start fading.");
					await spawnDungeonFeature(x, y, dungeonFeatureCatalog[DF_DARKNESS_POTION], true, false);
					message(buf, false);
					break;
				case POTION_DESCENT:
					strcpy(buf, "as the flask shatters, the ground vanishes!");
					message(buf, false);
					await spawnDungeonFeature(x, y, dungeonFeatureCatalog[DF_HOLE_POTION], true, false);
					break;
				case POTION_LICHEN:
					strcpy(buf, "the flask shatters and deadly spores spill out!");
					message(buf, false);
					await spawnDungeonFeature(x, y, dungeonFeatureCatalog[DF_LICHEN_PLANTED], true, false);
					break;
			}

			autoIdentify(theItem);

			refreshDungeonCell(x, y);

			//if (pmap[x][y].flags & (HAS_MONSTER | HAS_PLAYER)) {
			//	monst = monsterAtLoc(x, y);
			//	applyInstantTileEffectsToCreature(monst);
			//}
		} else {
			if (cellHasTerrainFlag(x, y, T_OBSTRUCTS_PASSABILITY)) {
				strcpy(buf2, "against");
			} else if (tileCatalog[pmap[x][y].layers[highestPriorityLayer(x, y, false)]].mechFlags & TM_STAND_IN_TILE) {
				strcpy(buf2, "into");
			} else {
				strcpy(buf2, "on");
			}
			sprintf(buf, "the flask shatters and %s liquid splashes harmlessly %s %s.",
					potionTable[theItem.kind].flavor, buf2, tileText(x, y));
			message(buf, false);
			if (theItem.kind == POTION_HALLUCINATION && (theItem.flags & ITEM_MAGIC_DETECTED)) {
				autoIdentify(theItem);
			}
		}
		return; // potions disappear when they break
	}
	if ((theItem.category & WEAPON) && theItem.kind == INCENDIARY_DART) {
		await spawnDungeonFeature(x, y, dungeonFeatureCatalog[DF_DART_EXPLOSION], true, false);
		if (pmap[x][y].flags & (HAS_MONSTER | HAS_PLAYER)) {
			await exposeCreatureToFire(monsterAtLoc(x, y));
		}
		return;
	}
	dropLoc = getQualifyingLocNear(x, y, true, 0, (T_OBSTRUCTS_ITEMS | T_OBSTRUCTS_PASSABILITY), (HAS_ITEM), false, false);
	await placeItem(theItem, dropLoc[0], dropLoc[1]);
	refreshDungeonCell(dropLoc[0], dropLoc[1]);
}


async function throwCommand( /* item */ theItem) {
	let thrownItem; // item *
	const buf = STRING(), theName = STRING(); // char[COLS];
	const command = []; // unsigned char[10];
	let maxDistance, zapTarget = [-1, -1], originLoc = [-1, -1], quantity;
	let autoTarget;

	command[0] = THROW_KEY;
	if (theItem == NULL) {
		theItem = await promptForItemOfType((ALL_ITEMS), 0, 0,
                                      KEYBOARD_LABELS ? "Throw what? (a-z, shift for more info; or <esc> to cancel)" : "Throw what?", true);
	}
	if (theItem == NULL) {
		return;
	}

	quantity = theItem.quantity;
	theItem.quantity = 1;
	itemName(theItem, theName, false, false, NULL);
	theItem.quantity = quantity;

	command[1] = theItem.inventoryLetter;
	confirmMessages();

	if (((theItem.flags & ITEM_EQUIPPED) || theItem.timesEnchanted > 0)
        && theItem.quantity <= 1)
	{
		sprintf(buf, "Are you sure you want to throw your %s?", theName);
		if (!await confirm(buf, false)) {
			return;
		}
    if (theItem.flags & ITEM_CURSED) {
        sprintf(buf, "You cannot unequip your %s; it appears to be cursed.", theName);
        message(buf, itemMessageColor, false);
        return;
    }
	}

	sprintf(buf, "Throw %s %s where? (<hjklyubn>, mouse, or <tab>)",
			(theItem.quantity > 1 ? "a" : "your"),
			theName);
	await temporaryMessage(buf, false);
	maxDistance = (12 + 2 * max(rogue.strength - player.weaknessAmount - 12, 2));
	autoTarget = (theItem.category & (WEAPON | POTION)) ? true : false;
	if (await chooseTarget(zapTarget, maxDistance, true, autoTarget, false, false, red)) {
    if ((theItem.flags & ITEM_EQUIPPED) && theItem.quantity <= 1) {
        unequipItem(theItem, false);
    }
		// command[2] = '\0';
		recordKeystrokeSequence(command);
		recordMouseClick(mapToWindowX(zapTarget[0]), mapToWindowY(zapTarget[1]), true, false);

		confirmMessages();

		thrownItem = generateItem(ALL_ITEMS, -1);
		copyItem(thrownItem, theItem); // clone the item
		thrownItem.flags &= ~ITEM_EQUIPPED;
		thrownItem.quantity = 1;

		itemName(thrownItem, theName, false, false, NULL);
		originLoc[0] = player.xLoc;
		originLoc[1] = player.yLoc;

		await throwItem(thrownItem, player, zapTarget, maxDistance);
	} else {
		return;
	}

	// Now decrement or delete the thrown item out of the inventory.
	if (theItem.quantity > 1) {
		theItem.quantity--;
	} else {
		removeItemFromChain(theItem, packItems);
		deleteItem(theItem);
	}
	await playerTurnEnded();
}

async function relabel(/* item */ theItem) {
  let oldItem;	// item *
	const buf = STRING(), theName = STRING();
	let newLabel;
	const command = []; // char[10];

  if (!KEYBOARD_LABELS && !rogue.playbackMode) {
      return;
  }
	if (theItem == NULL) {
 		theItem = await promptForItemOfType((ALL_ITEMS), 0, 0,
                                    KEYBOARD_LABELS ? "Relabel what? (a-z, shift for more info; or <esc> to cancel)" : "Relabel what?", true);
 	}
	if (theItem == NULL) {
 		return;
 	}
  await temporaryMessage("New letter? (a-z)", false);
  newLabel = '';
  do {
      newLabel = await nextKeyPress(true);
  } while (!strlen(newLabel));

  if (newLabel >= 'A' && newLabel <= 'Z') {
      newLabel = newLabel.toLowerCase(); // += 'a' - 'A'; // lower-case.
  }
  if (newLabel >= 'a' && newLabel <= 'z') {
      if (newLabel != theItem.inventoryLetter) {
          command[0] = RELABEL_KEY;
          command[1] = theItem.inventoryLetter;
          command[2] = newLabel;
          command[3] = '';
          recordKeystrokeSequence(command);

          oldItem = itemOfPackLetter(newLabel);
          if (oldItem) {
              oldItem.inventoryLetter = theItem.inventoryLetter;
              itemName(oldItem, theName, true, true, NULL);
              sprintf(buf, "Relabeled %s as (%c);", theName, oldItem.inventoryLetter);
              message(buf, itemMessageColor, false);
          }
          theItem.inventoryLetter = newLabel;
          itemName(theItem, theName, true, true, NULL);
          sprintf(buf, "%{s}elabeled %s as (%c).", oldItem ? " r" : "R", theName, newLabel);
          message(buf, itemMessageColor, false);
      } else {
          itemName(theItem, theName, true, true, NULL);
          sprintf(buf, "%s %s already labeled (%c).",
                  theName,
                  theItem.quantity == 1 ? "is" : "are",
                  theItem.inventoryLetter);
          message(buf, itemMessageColor, false);
      }
  }
}

// If the blink trajectory lands in lava based on the player's knowledge, abort.
// If the blink trajectory might land in lava based on the player's knowledge,
// prompt for confirmation.
async function playerCancelsBlinking(originLoc /* short[2] */, targetLoc /* short[2] */, maxDistance) {
  const coordinates = ARRAY(DCOLS, () => [-1, -1] ), impactLoc = [-1, -1];
  let numCells, i, x, y;
  let certainDeath = false;
  let possibleDeath = false;
  let flags, tFlags, tmFlags;

  if (rogue.playbackMode) {
      return false;
  }

  if (player.status[STATUS_IMMUNE_TO_FIRE]
      || player.status[STATUS_LEVITATING])
	{
      return false;
  }

  getImpactLoc(impactLoc, originLoc, targetLoc, maxDistance > 0 ? maxDistance : DCOLS, true);
  flags = getLocationFlags(impactLoc[0], impactLoc[1], true);
	tFlags = flags.terrainFlags;
	tmFlags = flags.TMFlags;

	if (maxDistance > 0) {
    if ((pmap[impactLoc[0]][impactLoc[1]].flags & DISCOVERED)
        && (tFlags & T_LAVA_INSTA_DEATH)
        && !(tFlags & (T_ENTANGLES | T_AUTO_DESCENT))
				&& !(tmFlags & TM_EXTINGUISHES_FIRE))
		{
        certainDeath = possibleDeath = true;
    }
	} else {
    certainDeath = true;
    numCells = getLineCoordinates(coordinates, originLoc, targetLoc);
    for (i = 0; i < numCells; i++) {
        x = coordinates[i][0];
        y = coordinates[i][1];
        if (pmap[x][y].flags & DISCOVERED) {
            flags = getLocationFlags(x, y, true);
						tFlags = flags.terrainFlags;
            if ((tFlags & (T_LAVA_INSTA_DEATH | T_AUTO_DESCENT))
                && !(tmFlags & TM_EXTINGUISHES_FIRE))
						{
                possibleDeath = true;
            } else if (i >= fp_staffBlinkDistance(2 << FP_BASE) - 1) {
                // Found at least one possible safe landing spot.
                certainDeath = false;
            }
        }
        if (x == impactLoc[0] && y == impactLoc[1]) {
            break;
        }
    }
  }
  if (possibleDeath && certainDeath) {
      message("that would be certain death!", false);
      return true;
  }
  if (possibleDeath
      && ! await confirm("Blink across lava with unknown range?", false))
	{
      return true;
  }
  return false;
}

async function useStaffOrWand(/* item */theItem, /* boolean * */commandsRecorded) {
	const buf = STRING(), buf2 = STRING();
	const command = []; // char[10];
	const zapTarget = [-1, -1], originLoc = [-1, -1];
	let maxDistance, c;
	let autoTarget, targetAllies, autoID, boltKnown, passThroughCreatures, confirmedTarget;
  const theBolt = bolt();
  const trajectoryHiliteColor = color();

	c = 0;
	command[c++] = APPLY_KEY;
	command[c++] = theItem.inventoryLetter;

  if (theItem.charges <= 0 && (theItem.flags & ITEM_IDENTIFIED)) {
      itemName(theItem, buf2, false, false, NULL);
      sprintf(buf, "Your %s has no charges.", buf2);
      message(buf, itemMessageColor, false);
      return false;
  }
  await temporaryMessage("Direction? (<hjklyubn>, mouse, or <tab>; <return> to confirm)", false);
  itemName(theItem, buf2, false, false, NULL);
  sprintf(buf, "Zapping your %s:", buf2);
  printString(buf, mapToWindowX(0), 1, itemMessageColor, black, NULL);

  theBolt.copy(boltCatalog[tableForItemCategory(theItem.category, NULL)[theItem.kind].strengthRequired]);
  if (theItem.category == STAFF) {
      theBolt.magnitude = theItem.enchant1;
  }

  if ((theItem.category & STAFF) && theItem.kind == STAFF_BLINKING
      && theItem.flags & (ITEM_IDENTIFIED | ITEM_MAX_CHARGES_KNOWN))
	{
		maxDistance = fp_staffBlinkDistance(fp_netEnchant(theItem));
  } else {
      maxDistance = -1;
  }
  if (tableForItemCategory(theItem.category, NULL)[theItem.kind].identified) {
      autoTarget = targetAllies = passThroughCreatures = false;
      if (!player.status[STATUS_HALLUCINATING]) {
          if (theBolt.flags & (BF_TARGET_ALLIES | BF_TARGET_ENEMIES)) {
              autoTarget = true;
          }
          if (theBolt.flags & BF_TARGET_ALLIES) {
              targetAllies = true;
          }
      }
      if (theBolt.flags & BF_PASSES_THRU_CREATURES) {
          passThroughCreatures = true;
      }
  } else {
      autoTarget = true;
      targetAllies = false;
      passThroughCreatures = false;
  }
  boltKnown = (((theItem.category & WAND) && wandTable[theItem.kind].identified)
               || ((theItem.category & STAFF) && staffTable[theItem.kind].identified));
  if (!boltKnown) {
      trajectoryHiliteColor.copy(gray);
  } else if (theBolt.backColor == NULL) {
      trajectoryHiliteColor.copy(red);
  } else {
      trajectoryHiliteColor.copy(theBolt.backColor);
  }

  originLoc[0] = player.xLoc;
  originLoc[1] = player.yLoc;
  confirmedTarget = await chooseTarget(zapTarget, maxDistance, false, autoTarget, targetAllies, passThroughCreatures, trajectoryHiliteColor);
  if (confirmedTarget
      && boltKnown
      && theBolt.boltEffect == BE_BLINKING
      && await playerCancelsBlinking(originLoc, zapTarget, maxDistance))
	{
      confirmedTarget = false;
  }
  if (confirmedTarget) {
      command[c] = null;
      if (!(commandsRecorded)) {
          recordKeystrokeSequence(command);
          recordMouseClick(mapToWindowX(zapTarget[0]), mapToWindowY(zapTarget[1]), true, false);
          commandsRecorded = true;
      }
      confirmMessages();

      rogue.featRecord[FEAT_PURE_WARRIOR] = false;

      if (theItem.charges > 0) {
          autoID = await zap(originLoc, zapTarget,
                       theBolt,
                       !boltKnown);	// hide bolt details
          if (autoID) {
              if (!tableForItemCategory(theItem.category, NULL)[theItem.kind].identified) {
                  itemName(theItem, buf2, false, false, NULL);
                  sprintf(buf, "(Your %s must be ", buf2);
                  identifyItemKind(theItem);
                  itemName(theItem, buf2, false, true, NULL);
                  strcat(buf, buf2);
                  strcat(buf, ".)");
                  message(buf, itemMessageColor, false);
              }
          }
      } else {
          itemName(theItem, buf2, false, false, NULL);
          if (theItem.category == STAFF) {
              sprintf(buf, "Your %s fizzles; it must be out of charges for now.", buf2);
          } else {
              sprintf(buf, "Your %s fizzles; it must be depleted.", buf2);
          }
          message(buf, itemMessageColor, false);
          theItem.flags |= ITEM_MAX_CHARGES_KNOWN;
          await playerTurnEnded();
          return false;
      }
  } else {
      return false;
  }
  return true;
}

function summonGuardian( /* item */ theItem) {
    let x = player.xLoc, y = player.yLoc;
    let monst;	// creature *

    monst = generateMonster(MK_CHARM_GUARDIAN, false, false);
    const loc = getQualifyingPathLocNear(x, y, true,
                             T_DIVIDES_LEVEL & avoidedFlagsForMonster((monst.info)) & ~T_SPONTANEOUSLY_IGNITES, HAS_PLAYER,
                             avoidedFlagsForMonster((monst.info)) & ~T_SPONTANEOUSLY_IGNITES, (HAS_PLAYER | HAS_MONSTER | HAS_STAIRS), false);
		monst.xLoc = loc[0];
		monst.yLoc = loc[1];
    monst.bookkeepingFlags |= (MB_FOLLOWER | MB_BOUND_TO_LEADER | MB_DOES_NOT_TRACK_LEADER);
    monst.bookkeepingFlags &= ~MB_JUST_SUMMONED;
    monst.leader = player;
    monst.creatureState = MONSTER_ALLY;
    monst.ticksUntilTurn = monst.info.attackSpeed + 1; // So they don't move before the player's next turn.
    monst.status[STATUS_LIFESPAN_REMAINING] = monst.maxStatus[STATUS_LIFESPAN_REMAINING] = fp_charmGuardianLifespan(fp_netEnchant(theItem));
    pmap[monst.xLoc][monst.yLoc].flags |= HAS_MONSTER;
    fadeInMonster(monst);
}

async function useCharm(/* item */ theItem) {
	let enchant = fp_netEnchant(theItem);

    rogue.featRecord[FEAT_PURE_WARRIOR] = false;

    switch (theItem.kind) {
        case CHARM_HEALTH:
            heal(player, fp_charmHealing(enchant), false);
            message("You feel much healthier.", false);
            break;
        case CHARM_PROTECTION:
            if (fp_charmProtection(enchant) > player.status[STATUS_SHIELDED]) {
                player.status[STATUS_SHIELDED] = fp_charmProtection(enchant);
            }
            player.maxStatus[STATUS_SHIELDED] = player.status[STATUS_SHIELDED];
            if (boltCatalog[BOLT_SHIELDING].backColor) {
                flashMonster(player, boltCatalog[BOLT_SHIELDING].backColor, 100);
            }
            message("A shimmering shield coalesces around you.", false);
            break;
        case CHARM_HASTE:
            haste(player, charmEffectDuration(theItem.kind, theItem.enchant1));
            break;
        case CHARM_FIRE_IMMUNITY:
            player.status[STATUS_IMMUNE_TO_FIRE] = player.maxStatus[STATUS_IMMUNE_TO_FIRE] = charmEffectDuration(theItem.kind, theItem.enchant1);
            if (player.status[STATUS_BURNING]) {
                extinguishFireOnCreature(player);
            }
            message("you no longer fear fire.", false);
            break;
        case CHARM_INVISIBILITY:
            imbueInvisibility(player, charmEffectDuration(theItem.kind, theItem.enchant1));
            message("You shiver as a chill runs up your spine.", false);
            break;
        case CHARM_TELEPATHY:
            makePlayerTelepathic(charmEffectDuration(theItem.kind, theItem.enchant1));
            break;
        case CHARM_LEVITATION:
            player.status[STATUS_LEVITATING] = player.maxStatus[STATUS_LEVITATING] = charmEffectDuration(theItem.kind, theItem.enchant1);
            player.bookkeepingFlags &= ~MB_SEIZED; // break free of holding monsters
            message("you float into the air!", false);
            break;
        case CHARM_SHATTERING:
            message("your charm emits a wave of turquoise light that pierces the nearby walls!", itemMessageColor, false);
            crystalize(fp_charmShattering(enchant));
            break;
        case CHARM_GUARDIAN:
            message("your charm flashes and the form of a mythical guardian coalesces!", itemMessageColor, false);
            summonGuardian(theItem);
            break;
        case CHARM_TELEPORTATION:
            await teleport(player, -1, -1, true);
            break;
        case CHARM_RECHARGING:
            rechargeItems(STAFF);
            break;
        case CHARM_NEGATION:
            await negationBlast("your charm", fp_charmNegationRadius(enchant) + 1); // Add 1 because otherwise radius 1 would affect only the player.
            break;
        default:
            break;
    }
}

async function apply( /* item */theItem, recordCommands) {
	const buf = STRING(), buf2 = STRING();
	let commandsRecorded, revealItemType;
	const command = []; // char[10] = "";
	let c;

	commandsRecorded = !recordCommands;
	c = 0;
	command[c++] = APPLY_KEY;

	revealItemType = false;

	if (!theItem) {
		theItem = await promptForItemOfType((SCROLL|FOOD|POTION|STAFF|WAND|CHARM), 0, 0,
									  KEYBOARD_LABELS ? "Apply what? (a-z, shift for more info; or <esc> to cancel)" : "Apply what?",
                                      true);
	}

	if (theItem == NULL) {
		return;
	}

  if ((theItem.category == SCROLL || theItem.category == POTION)
      && magicCharDiscoverySuffix(theItem.category, theItem.kind) == -1
      && ((theItem.flags & ITEM_MAGIC_DETECTED) || tableForItemCategory(theItem.category, NULL)[theItem.kind].identified))
	{
      if (tableForItemCategory(theItem.category, NULL)[theItem.kind].identified) {
          sprintf(buf,
                  "Really %s a %s of %s?",
                  theItem.category == SCROLL ? "read" : "drink",
                  theItem.category == SCROLL ? "scroll" : "potion",
                  tableForItemCategory(theItem.category, NULL)[theItem.kind].name);
      } else {
          sprintf(buf,
                  "Really %s a cursed %s?",
                  theItem.category == SCROLL ? "read" : "drink",
                  theItem.category == SCROLL ? "scroll" : "potion");
      }
      if (! await confirm(buf, false)) {
          return;
      }
  }

	command[c++] = theItem.inventoryLetter;
	confirmMessages();
	switch (theItem.category) {
		case FOOD:
			if (STOMACH_SIZE - player.status[STATUS_NUTRITION] < foodTable[theItem.kind].strengthRequired) { // Not hungry enough.
				sprintf(buf, "You're not hungry enough to fully enjoy the %s. Eat it anyway?",
						(theItem.kind == RATION ? "food" : "mango"));
				if (!await confirm(buf, false)) {
					return;
				}
			}
			player.status[STATUS_NUTRITION] = min(foodTable[theItem.kind].strengthRequired + player.status[STATUS_NUTRITION], STOMACH_SIZE);
			if (theItem.kind == RATION) {
				message("That food tasted delicious!", itemMessageColor, false);
			} else {
				message("My, what a yummy mango!", itemMessageColor, false);
			}
      rogue.featRecord[FEAT_MYSTIC] = false;
			break;
		case POTION:
			command[c] = null;
      if (!commandsRecorded) {
          recordKeystrokeSequence(command);
          commandsRecorded = true;
      }
			if (!potionTable[theItem.kind].identified) {
				revealItemType = true;
			}
			await drinkPotion(theItem);
			break;
		case SCROLL:
			command[c] = null;
      if (!commandsRecorded) {
          recordKeystrokeSequence(command);
          commandsRecorded = true; // have to record in case further keystrokes are necessary (e.g. enchant scroll)
      }
			if (!scrollTable[theItem.kind].identified
				&& theItem.kind != SCROLL_ENCHANTING
				&& theItem.kind != SCROLL_IDENTIFY)
			{
				revealItemType = true;
			}
			await readScroll(theItem);
			break;
		case STAFF:
		case WAND:
      if (! await useStaffOrWand(theItem, commandsRecorded)) {
          return;
      }
			break;
    case CHARM:
			if (theItem.charges > 0) {
				itemName(theItem, buf2, false, false, NULL);
				sprintf(buf, "Your %s hasn't finished recharging.", buf2);
				message(buf, itemMessageColor, false);
				return;
			}
      if (!commandsRecorded) {
          command[c] = null;
          recordKeystrokeSequence(command);
          commandsRecorded = true;
      }
      await useCharm(theItem);
      break;
		default:
			itemName(theItem, buf2, false, true, NULL);
			sprintf(buf, "you can't apply %s.", buf2);
			message(buf, false);
			return;
	}

	if (!commandsRecorded) { // to make sure we didn't already record the keystrokes above with staff/wand targeting
		command[c] = null;
		recordKeystrokeSequence(command);
    commandsRecorded = true;
	}

	// Reveal the item type if appropriate.
	if (revealItemType) {
		autoIdentify(theItem);
	}

	if (theItem.category & CHARM) {
    theItem.charges = charmRechargeDelay(theItem.kind, theItem.enchant1);
  } else if (theItem.charges > 0) {
		theItem.charges--;
		if (theItem.category == WAND) {
			theItem.enchant2++; // keeps track of how many times the wand has been discharged for the player's convenience
		}
	} else if (theItem.quantity > 1) {
		theItem.quantity--;
	} else {
		removeItemFromChain(theItem, packItems);
		deleteItem(theItem);
	}
	await playerTurnEnded();
}


function identify(/* item */ theItem) {
	theItem.flags |= ITEM_IDENTIFIED;
	theItem.flags &= ~ITEM_CAN_BE_IDENTIFIED;
	if (theItem.flags & ITEM_RUNIC) {
		theItem.flags |= (ITEM_RUNIC_IDENTIFIED | ITEM_RUNIC_HINTED);
	}
    if (theItem.category & RING) {
        updateRingBonuses();
    }
	identifyItemKind(theItem);
}

// /*
// enum monsterTypes chooseVorpalEnemy() {
// 	short i, index, possCount = 0, deepestLevel = 0, deepestHorde, chosenHorde, failsafe = 25;
// 	enum monsterTypes candidate;
//
//     for (i=0; i<NUMBER_HORDES; i++) {
//         if (hordeCatalog[i].minLevel >= rogue.depthLevel && !hordeCatalog[i].flags) {
//             possCount += hordeCatalog[i].frequency;
//         }
//         if (hordeCatalog[i].minLevel > deepestLevel) {
//             deepestHorde = i;
//             deepestLevel = hordeCatalog[i].minLevel;
//         }
//     }
//
// 	do {
// 		if (possCount == 0) {
// 			chosenHorde = deepestHorde;
// 		} else {
// 			index = rand_range(1, possCount);
// 			for (i=0; i<NUMBER_HORDES; i++) {
// 				if (hordeCatalog[i].minLevel >= rogue.depthLevel && !hordeCatalog[i].flags) {
// 					if (index <= hordeCatalog[i].frequency) {
// 						chosenHorde = i;
// 						break;
// 					}
// 					index -= hordeCatalog[i].frequency;
// 				}
// 			}
// 		}
//
// 		index = rand_range(-1, hordeCatalog[chosenHorde].numberOfMemberTypes - 1);
// 		if (index == -1) {
// 			candidate = hordeCatalog[chosenHorde].leaderType;
// 		} else {
// 			candidate = hordeCatalog[chosenHorde].memberType[index];
// 		}
// 	} while (((monsterCatalog[candidate].flags & MONST_NEVER_VORPAL_ENEMY)
//               || (monsterCatalog[candidate].abilityFlags & MA_NEVER_VORPAL_ENEMY))
//              && --failsafe > 0);
// 	return candidate;
// }*/

function lotteryDraw(/* short */frequencies, itemCount) {
    let i, maxFreq, randIndex;
    maxFreq = 0;
    for (i = 0; i < itemCount; i++) {
        maxFreq += frequencies[i];
    }
    brogueAssert(maxFreq > 0);
    randIndex = rand_range(0, maxFreq - 1);
    for (i = 0; i < itemCount; i++) {
      if (frequencies[i] > randIndex) {
          return i;
      } else {
          randIndex -= frequencies[i];
      }
    }
    brogueAssert(false);
    return 0;
}

function chooseVorpalEnemy() {
    let i, frequencies = []; // short[MONSTER_CLASS_COUNT];
    for (i = 0; i < MONSTER_CLASS_COUNT; i++) {
        if (monsterClassCatalog[i].maxDepth <= 0
            || rogue.depthLevel <= monsterClassCatalog[i].maxDepth)
				{
            frequencies[i] = monsterClassCatalog[i].frequency;
        } else {
            frequencies[i] = 0;
        }
    }
    return lotteryDraw(frequencies, MONSTER_CLASS_COUNT);
}

function describeMonsterClass(buf, lassID, conjunctionAnd) {
    let i;
    const buf2 = STRING(); // char[50];

    for (i = 0; monsterClassCatalog[classID].memberList[i] != 0; i++) {
        strcpy(buf2, monsterCatalog[monsterClassCatalog[classID].memberList[i]].monsterName);
        if (monsterClassCatalog[classID].memberList[i + 1] != 0) {
            if (monsterClassCatalog[classID].memberList[i + 2] == 0) {
                strcat(buf2, (conjunctionAnd ? " and " : " or "));
            } else {
                strcat(buf2, ", ");
            }
        }
				strcat(buf, buf2);
    }
    return buf;
}

function updateIdentifiableItem( /* item */ theItem) {
	if ((theItem.category & SCROLL) && scrollTable[theItem.kind].identified) {
  	theItem.flags &= ~ITEM_CAN_BE_IDENTIFIED;
  }
	else if ((theItem.category & POTION) && potionTable[theItem.kind].identified)
	{
		theItem.flags &= ~ITEM_CAN_BE_IDENTIFIED;
	} else if ((theItem.category & (RING | STAFF | WAND))
			   && (theItem.flags & ITEM_IDENTIFIED)
			   && tableForItemCategory(theItem.category, NULL)[theItem.kind].identified)
  {
		theItem.flags &= ~ITEM_CAN_BE_IDENTIFIED;
	} else if ((theItem.category & (WEAPON | ARMOR))
			   && (theItem.flags & ITEM_IDENTIFIED)
			   && (!(theItem.flags & ITEM_RUNIC) || (theItem.flags & ITEM_RUNIC_IDENTIFIED)))
  {
		theItem.flags &= ~ITEM_CAN_BE_IDENTIFIED;
	} else if (theItem.category & NEVER_IDENTIFIABLE) {
      theItem.flags &= ~ITEM_CAN_BE_IDENTIFIED;
  }
}

function updateIdentifiableItems() {
	let theItem;	// item *
	for (theItem = packItems.nextItem; theItem != NULL; theItem = theItem.nextItem) {
		updateIdentifiableItem(theItem);
	}
	for (theItem = floorItems; theItem != NULL; theItem = theItem.nextItem) {
		updateIdentifiableItem(theItem);
	}
}


function magicMapCell(x, y) {
    pmap[x][y].flags |= MAGIC_MAPPED;
    pmap[x][y].rememberedTerrainFlags = tileCatalog[pmap[x][y].layers[DUNGEON]].flags | tileCatalog[pmap[x][y].layers[LIQUID]].flags;
    pmap[x][y].rememberedTMFlags = tileCatalog[pmap[x][y].layers[DUNGEON]].mechFlags | tileCatalog[pmap[x][y].layers[LIQUID]].mechFlags;
    if (pmap[x][y].layers[LIQUID] && tileCatalog[pmap[x][y].layers[LIQUID]].drawPriority < tileCatalog[pmap[x][y].layers[DUNGEON]].drawPriority) {
        pmap[x][y].rememberedTerrain = pmap[x][y].layers[LIQUID];
    } else {
        pmap[x][y].rememberedTerrain = pmap[x][y].layers[DUNGEON];
    }
}



async function readIdentifyScroll(theItem) {
  const buf = STRING(), buf2 = STRING();

  identify(theItem);
  updateIdentifiableItems();
  await messageWithAck("this is a scroll of identify.", itemMessageColor);
  if (numberOfMatchingPackItems(ALL_ITEMS, ITEM_CAN_BE_IDENTIFIED, 0, false) == 0) {
  	message("everything in your pack is already identified.", false);
  	return;
  }
  do {
  	theItem = await promptForItemOfType((ALL_ITEMS), ITEM_CAN_BE_IDENTIFIED, 0,
  								  KEYBOARD_LABELS ? "Identify what? (a-z; shift for more info)" : "Identify what?",
                    false);
  	if (rogue.gameHasEnded) {
  		return;
  	}
  	if (theItem && !(theItem.flags & ITEM_CAN_BE_IDENTIFIED)) {
  		confirmMessages();
  		itemName(theItem, buf2, true, true, NULL);
  		sprintf(buf, "you already know %s %s.", (theItem.quantity > 1 ? "they're" : "it's"), buf2);
  		message(buf, itemMessageColor, false);
  	}
  } while (theItem == NULL || !(theItem.flags & ITEM_CAN_BE_IDENTIFIED));

  recordKeystroke(theItem.inventoryLetter, false, false);
  confirmMessages();
  identify(theItem);
  itemName(theItem, buf, true, true, NULL);
  sprintf(buf2, "%s %s.", (theItem.quantity == 1 ? "this is" : "these are"), buf);
  message(buf2, itemMessageColor, false);
}


async function readScrollOfEnchanting(theItem) {

	const buf = STRING(), buf2 = STRING();

	identify(theItem);
	await messageWithAck("this is a scroll of enchanting.", itemMessageColor, true);
	if (!numberOfMatchingPackItems((WEAPON | ARMOR | RING | STAFF | WAND | CHARM), 0, 0, false)) {
		confirmMessages();
		message("you have nothing that can be enchanted.", false);
		return;
	}
	do {
		theItem = await promptForItemOfType((WEAPON | ARMOR | RING | STAFF | WAND | CHARM), 0, 0,
									  KEYBOARD_LABELS ? "Enchant what? (a-z; shift for more info)" : "Enchant what?",
                    false);
		confirmMessages();
		if (theItem == NULL || !(theItem.category & (WEAPON | ARMOR | RING | STAFF | WAND | CHARM))) {
			await messageWithAck("Can't enchant that.");
		}
		if (rogue.gameHasEnded) {
			return;
		}
	} while (theItem == NULL || !(theItem.category & (WEAPON | ARMOR | RING | STAFF | WAND | CHARM)));

	recordKeystroke(theItem.inventoryLetter, false, false);
	confirmMessages();

	switch (theItem.category) {
		case WEAPON:
			theItem.strengthRequired = max(0, theItem.strengthRequired - 1);
			theItem.enchant1++;
      if (theItem.quiverNumber) {
          theItem.quiverNumber = rand_range(1, 60000);
      }
			break;
		case ARMOR:
			theItem.strengthRequired = max(0, theItem.strengthRequired - 1);
			theItem.enchant1++;
			break;
		case RING:
			theItem.enchant1++;
			updateRingBonuses();
			if (theItem.kind == RING_CLAIRVOYANCE) {
				updateClairvoyance();
				displayLevel();
			}
			break;
		case STAFF:
			theItem.enchant1++;
			theItem.charges++;
			theItem.enchant2 = Math.floor(500 / theItem.enchant1);
			break;
		case WAND:
      theItem.charges += wandTable[theItem.kind].range.lowerBound;
			break;
		case CHARM:
      theItem.enchant1++;
      theItem.charges = min(0, theItem.charges); // Enchanting instantly recharges charms.
      // theItem.charges = theItem.charges * charmRechargeDelay(theItem.kind, theItem.enchant1) / charmRechargeDelay(theItem.kind, theItem.enchant1 - 1);
			break;
		default:
			break;
	}
  theItem.timesEnchanted++;
  if ((theItem.category & (WEAPON | ARMOR | STAFF | RING | CHARM))
      && theItem.enchant1 >= 16)
  {
      rogue.featRecord[FEAT_SPECIALIST] = true;
  }
	if (theItem.flags & ITEM_EQUIPPED) {
		equipItem(theItem, true);
	}
	itemName(theItem, buf, false, false, NULL);
	sprintf(buf2, "your %s gleam%s briefly in the darkness.", buf, (theItem.quantity == 1 ? "s" : ""));
	message(buf2, itemMessageColor, false);
	if (theItem.flags & ITEM_CURSED) {
		sprintf(buf2, "a malevolent force leaves your %s.", buf);
		message(buf2, itemMessageColor, false);
		theItem.flags &= ~ITEM_CURSED;
	}
  createFlare(player.xLoc, player.yLoc, SCROLL_ENCHANTMENT_LIGHT);

}



async function readScroll(/* item */ theItem) {
	let i, j, x, y, numberOfMonsters = 0;
	let tempItem;		// item *
	let monst;			// creature *
	let hadEffect = false;
	const buf = STRING(), buf2 = STRING();

  rogue.featRecord[FEAT_ARCHIVIST] = false;

	switch (theItem.kind) {
		case SCROLL_IDENTIFY:
    	await readIdentifyScroll(theItem);
			break;
		case SCROLL_TELEPORT:
			await teleport(player, -1, -1, true);
			break;
		case SCROLL_REMOVE_CURSE:
			for (tempItem = packItems.nextItem; tempItem != NULL; tempItem = tempItem.nextItem) {
				if (tempItem.flags & ITEM_CURSED) {
					hadEffect = true;
					tempItem.flags &= ~ITEM_CURSED;
				}
			}
			if (hadEffect) {
				message("your pack glows with a cleansing light, and a malevolent energy disperses.", false);
			} else {
				message("your pack glows with a cleansing light, but nothing happens.", false);
			}
			break;
		case SCROLL_ENCHANTING:
    	await readScrollOfEnchanting(theItem);
			break;
		case SCROLL_RECHARGING:
      rechargeItems(STAFF | CHARM);
			break;
		case SCROLL_PROTECT_ARMOR:
			if (rogue.armor) {
				tempItem = rogue.armor;
				tempItem.flags |= ITEM_PROTECTED;
				itemName(tempItem, buf2, false, false, NULL);
				sprintf(buf, "a protective golden light covers your %s.", buf2);
				message(buf, itemMessageColor, false);
				if (tempItem.flags & ITEM_CURSED) {
					sprintf(buf, "a malevolent force leaves your %s.", buf2);
					message(buf, itemMessageColor, false);
					tempItem.flags &= ~ITEM_CURSED;
				}
			} else {
				message("a protective golden light surrounds you, but it quickly disperses.", false);
			}
      createFlare(player.xLoc, player.yLoc, SCROLL_PROTECTION_LIGHT);
			break;
		case SCROLL_PROTECT_WEAPON:
			if (rogue.weapon) {
				tempItem = rogue.weapon;
				tempItem.flags |= ITEM_PROTECTED;
				itemName(tempItem, buf2, false, false, NULL);
				sprintf(buf, "a protective golden light covers your %s.", buf2);
				message(buf, itemMessageColor, false);
				if (tempItem.flags & ITEM_CURSED) {
					sprintf(buf, "a malevolent force leaves your %s.", buf2);
					message(buf, itemMessageColor, false);
					tempItem.flags &= ~ITEM_CURSED;
				}
        if (rogue.weapon.quiverNumber) {
            rogue.weapon.quiverNumber = rand_range(1, 60000);
        }
			} else {
				message("a protective golden light covers your empty hands, but it quickly disperses.", false);
			}
      createFlare(player.xLoc, player.yLoc, SCROLL_PROTECTION_LIGHT);
			break;
		case SCROLL_SANCTUARY:
			await spawnDungeonFeature(player.xLoc, player.yLoc, dungeonFeatureCatalog[DF_SACRED_GLYPHS], true, false);
      message("sprays of color arc to the ground, forming glyphs where they alight.", itemMessageColor, false);
			break;
		case SCROLL_MAGIC_MAPPING:
			confirmMessages();
			message("this scroll has a map on it!",itemMessageColor, false);
			for (i=0; i<DCOLS; i++) {
				for (j=0; j<DROWS; j++) {
					if (cellHasTMFlag(i, j, TM_IS_SECRET)) {
						discover(i, j);
            magicMapCell(i, j);
						pmap[i][j].flags &= ~(STABLE_MEMORY | DISCOVERED);
					}
				}
			}
			for (i=0; i<DCOLS; i++) {
				for (j=0; j<DROWS; j++) {
					if (!(pmap[i][j].flags & DISCOVERED) && pmap[i][j].layers[DUNGEON] != GRANITE) {
            magicMapCell(i, j);
					}
				}
			}
			await colorFlash(magicMapFlashColor, 0, MAGIC_MAPPED, 15, DCOLS + DROWS, player.xLoc, player.yLoc);
			break;
		case SCROLL_AGGRAVATE_MONSTER:
			await aggravateMonsters(DCOLS + DROWS, player.xLoc, player.yLoc, gray);
			message("the scroll emits a piercing shriek that echoes throughout the dungeon!", false);
			break;
		case SCROLL_SUMMON_MONSTER:
			for (j=0; j<25 && numberOfMonsters < 3; j++) {
				for (i=0; i<8; i++) {
					x = player.xLoc + nbDirs[i][0];
					y = player.yLoc + nbDirs[i][1];
					if (!cellHasTerrainFlag(x, y, T_OBSTRUCTS_PASSABILITY) && !(pmap[x][y].flags & HAS_MONSTER)
						&& rand_percent(10) && (numberOfMonsters < 3))
					{
						monst = await spawnHorde(0, x, y, (HORDE_LEADER_CAPTIVE | HORDE_NO_PERIODIC_SPAWN | HORDE_IS_SUMMONED | HORDE_MACHINE_ONLY), 0);
						if (monst) {
							// refreshDungeonCell(x, y);
							// monst.creatureState = MONSTER_TRACKING_SCENT;
							// monst.ticksUntilTurn = player.movementSpeed;
							wakeUp(monst);
							fadeInMonster(monst);
							numberOfMonsters++;
						}
					}
				}
			}
			if (numberOfMonsters > 1) {
				message("the fabric of space ripples, and monsters appear!", false);
			} else if (numberOfMonsters == 1) {
				message("the fabric of space ripples, and a monster appears!", false);
			} else {
				message("the fabric of space boils violently around you, but nothing happens.", false);
			}
			break;
		case SCROLL_NEGATION:
      await negationBlast("the scroll", DCOLS);
			break;
		case SCROLL_SHATTERING:
			message("the scroll emits a wave of turquoise light that pierces the nearby walls!", itemMessageColor, false);
			await crystalize(9);
			break;
    case SCROLL_DISCORD:
      await discordBlast("the scroll", DCOLS);
      break;
	}
}

function detectMagicOnItem( /* item */ theItem) {
    theItem.flags |= ITEM_MAGIC_DETECTED;
    if ((theItem.category & (WEAPON | ARMOR))
        && theItem.enchant1 == 0
        && !(theItem.flags & ITEM_RUNIC))
		{
        identify(theItem);
    }
}

async function drinkPotion(/* item */ theItem) {
	let tempItem = NULL;		// item *
	let monst = NULL;				// creature *
	let hadEffect = false;
	let hadEffect2 = false;
  const buf = STRING(); 	// char[1000] = "";

  brogueAssert(rogue.RNG == RNG_SUBSTANTIVE);

  rogue.featRecord[FEAT_ARCHIVIST] = false;

	switch (theItem.kind) {
		case POTION_LIFE:
      sprintf(buf, "%{s}your maximum health increases by %{i}%.",
              ((player.currentHP < player.info.maxHP) ? "you heal completely and " : ""),
              Math.floor((player.info.maxHP + 10) * 100 / player.info.maxHP) - 100);

      player.info.maxHP += 10;
      heal(player, 100, true);
      updatePlayerRegenerationDelay();
      message(buf, advancementMessageColor, false);
			break;
		case POTION_HALLUCINATION:
			player.status[STATUS_HALLUCINATING] = player.maxStatus[STATUS_HALLUCINATING] = 300;
			message("colors are everywhere! The walls are singing!", false);
			break;
		case POTION_INCINERATION:
			//await colorFlash(&darkOrange, 0, IN_FIELD_OF_VIEW, 4, 4, player.xLoc, player.yLoc);
			message("as you uncork the flask, it explodes in flame!", false);
			await spawnDungeonFeature(player.xLoc, player.yLoc, dungeonFeatureCatalog[DF_INCINERATION_POTION], true, false);
			await exposeCreatureToFire(player);
			break;
		case POTION_DARKNESS:
			player.status[STATUS_DARKNESS] = max(400, player.status[STATUS_DARKNESS]);
			player.maxStatus[STATUS_DARKNESS] = max(400, player.maxStatus[STATUS_DARKNESS]);
			updateMinersLightRadius();
			updateVision(true);
			message("your vision flickers as a cloak of darkness settles around you!", false);
			break;
		case POTION_DESCENT:
			await colorFlash(darkBlue, 0, IN_FIELD_OF_VIEW, 3, 3, player.xLoc, player.yLoc);
			message("vapor pours out of the flask and causes the floor to disappear!", false);
			await spawnDungeonFeature(player.xLoc, player.yLoc, dungeonFeatureCatalog[DF_HOLE_POTION], true, false);
      if (!player.status[STATUS_LEVITATING]) {
          player.bookkeepingFlags |= MB_IS_FALLING;
      }
			break;
		case POTION_STRENGTH:
			rogue.strength++;
			if (player.status[STATUS_WEAKENED]) {
				player.status[STATUS_WEAKENED] = 1;
			}
			updateEncumbrance();
			message("newfound strength surges through your body.", advancementMessageColor, false);
      createFlare(player.xLoc, player.yLoc, POTION_STRENGTH_LIGHT);
			break;
		case POTION_POISON:
			await spawnDungeonFeature(player.xLoc, player.yLoc, dungeonFeatureCatalog[DF_POISON_GAS_CLOUD_POTION], true, false);
			message("caustic gas billows out of the open flask!", false);
			break;
		case POTION_PARALYSIS:
			await spawnDungeonFeature(player.xLoc, player.yLoc, dungeonFeatureCatalog[DF_PARALYSIS_GAS_CLOUD_POTION], true, false);
			message("your muscles stiffen as a cloud of pink gas bursts from the open flask!", false);
			break;
		case POTION_TELEPATHY:
      makePlayerTelepathic(300);
			break;
		case POTION_LEVITATION:
			player.status[STATUS_LEVITATING] = player.maxStatus[STATUS_LEVITATING] = 100;
			player.bookkeepingFlags &= ~MB_SEIZED; // break free of holding monsters
			message("you float into the air!", false);
			break;
		case POTION_CONFUSION:
			await spawnDungeonFeature(player.xLoc, player.yLoc, dungeonFeatureCatalog[DF_CONFUSION_GAS_CLOUD_POTION], true, false);
			message("a shimmering cloud of rainbow-colored gas billows out of the open flask!", false);
			break;
		case POTION_LICHEN:
			message("a handful of tiny spores burst out of the open flask!", false);
			await spawnDungeonFeature(player.xLoc, player.yLoc, dungeonFeatureCatalog[DF_LICHEN_PLANTED], true, false);
			break;
		case POTION_DETECT_MAGIC:
			hadEffect = false;
			hadEffect2 = false;
			for (tempItem = floorItems.nextItem; tempItem != NULL; tempItem = tempItem.nextItem) {
				if (tempItem.category & CAN_BE_DETECTED) {
          detectMagicOnItem(tempItem);
					if (itemMagicChar(tempItem)) {
						pmap[tempItem.xLoc][tempItem.yLoc].flags |= ITEM_DETECTED;
						hadEffect = true;
						refreshDungeonCell(tempItem.xLoc, tempItem.yLoc);
					}
				}
			}
			for (monst = monsters.nextCreature; monst != NULL; monst = monst.nextCreature) {
				if (monst.carriedItem && (monst.carriedItem.category & CAN_BE_DETECTED)) {
          detectMagicOnItem(monst.carriedItem);
					if (itemMagicChar(monst.carriedItem)) {
						hadEffect = true;
						refreshDungeonCell(monst.xLoc, monst.yLoc);
					}
				}
			}
			for (tempItem = packItems.nextItem; tempItem != NULL; tempItem = tempItem.nextItem) {
				if (tempItem.category & CAN_BE_DETECTED) {
          detectMagicOnItem(tempItem);
					if (itemMagicChar(tempItem)) {
						if (tempItem.flags & ITEM_MAGIC_DETECTED) {
							hadEffect2 = true;
						}
					}
				}
			}
			if (hadEffect || hadEffect2) {
				if (hadEffect && hadEffect2) {
					message("you can somehow feel the presence of magic on the level and in your pack.", false);
				} else if (hadEffect) {
					message("you can somehow feel the presence of magic on the level.", false);
				} else {
					message("you can somehow feel the presence of magic in your pack.", false);
				}
			} else {
				message("you can somehow feel the absence of magic on the level and in your pack.", false);
			}
			break;
		case POTION_HASTE_SELF:
			haste(player, 25);
			break;
		case POTION_FIRE_IMMUNITY:
			player.status[STATUS_IMMUNE_TO_FIRE] = player.maxStatus[STATUS_IMMUNE_TO_FIRE] = 150;
			if (player.status[STATUS_BURNING]) {
				extinguishFireOnCreature(player);
			}
			message("a comforting breeze envelops you, and you no longer fear fire.", false);
			break;
		case POTION_INVISIBILITY:
			player.status[STATUS_INVISIBLE] = player.maxStatus[STATUS_INVISIBLE] = 75;
			message("you shiver as a chill runs up your spine.", false);
			break;
		default:
			ERROR("you feel very strange, as though your body doesn't know how to react!", true);
	}
}

// Used for the Discoveries screen. Returns a number: 1 == good, -1 == bad, 0 == could go either way.
function magicCharDiscoverySuffix(category, kind) {
	let result = 0;

	switch (category) {
		case SCROLL:
			switch (kind) {
				case SCROLL_AGGRAVATE_MONSTER:
				case SCROLL_SUMMON_MONSTER:
					result = -1;
					break;
				default:
					result = 1;
					break;
			}
			break;
		case POTION:
			switch (kind) {
				case POTION_HALLUCINATION:
				case POTION_INCINERATION:
				case POTION_DESCENT:
				case POTION_POISON:
				case POTION_PARALYSIS:
				case POTION_CONFUSION:
				case POTION_LICHEN:
				case POTION_DARKNESS:
					result = -1;
					break;
				default:
					result = 1;
					break;
			}
			break;
		case WAND:
        case STAFF:
            if (boltCatalog[tableForItemCategory(category, NULL)[kind].strengthRequired].flags & (BF_TARGET_ALLIES)) {
                result = -1;
            } else {
                result = 1;
            }
            break;
		case RING:
			result = 0;
            break;
		case CHARM:
			result = 1;
			break;
	}
	return result;
}


function itemMagicChar(theItem) {
	switch (theItem.category) {
		case WEAPON:
		case ARMOR:
			if ((theItem.flags & ITEM_CURSED) || theItem.enchant1 < 0) {
				return BAD_MAGIC_CHAR;
			} else if (theItem.enchant1 > 0) {
				return GOOD_MAGIC_CHAR;
			}
			return 0;
			break;
		case SCROLL:
			switch (theItem.kind) {
				case SCROLL_AGGRAVATE_MONSTER:
				case SCROLL_SUMMON_MONSTER:
					return BAD_MAGIC_CHAR;
				default:
					return GOOD_MAGIC_CHAR;
			}
		case POTION:
			switch (theItem.kind) {
				case POTION_HALLUCINATION:
				case POTION_INCINERATION:
				case POTION_DESCENT:
				case POTION_POISON:
				case POTION_PARALYSIS:
				case POTION_CONFUSION:
				case POTION_LICHEN:
				case POTION_DARKNESS:
					return BAD_MAGIC_CHAR;
				default:
					return GOOD_MAGIC_CHAR;
			}
		case WAND:
			if (theItem.charges == 0) {
				return 0;
			}
		case STAFF:
            if (boltCatalog[tableForItemCategory(theItem.category)[theItem.kind].strengthRequired].flags & (BF_TARGET_ALLIES)) {
                return BAD_MAGIC_CHAR;
            } else {
                return GOOD_MAGIC_CHAR;
            }
		case RING:
			if (theItem.flags & ITEM_CURSED || theItem.enchant1 < 0) {
				return BAD_MAGIC_CHAR;
			} else if (theItem.enchant1 > 0) {
				return GOOD_MAGIC_CHAR;
			} else {
				return 0;
			}
        case CHARM:
            return GOOD_MAGIC_CHAR;
            break;
		case AMULET:
			return AMULET_CHAR;
	}
	return 0;
}

async function unequip(/* item */ theItem) {
	const buf = STRING(), buf2 = STRING();
	const command = []; // char[3];

	command[0] = UNEQUIP_KEY;
	if (theItem == NULL) {
		theItem = await promptForItemOfType(ALL_ITEMS, ITEM_EQUIPPED, 0,
									  KEYBOARD_LABELS ? "Remove (unequip) what? (a-z or <esc> to cancel)" : "Remove (unequip) what?",
                                      true);
	}
	if (theItem == NULL) {
		return;
	}

	command[1] = theItem.inventoryLetter;
	command[2] = null;

	if (!(theItem.flags & ITEM_EQUIPPED)) {
		itemName(theItem, buf2, false, false, NULL);
		sprintf(buf, "your %s %s not equipped.",
                buf2,
                theItem.quantity == 1 ? "was" : "were");
		confirmMessages();
		message(buf, itemMessageColor, false);
		return;
	} else if (theItem.flags & ITEM_CURSED) { // this is where the item gets unequipped
		itemName(theItem, buf2, false, false, NULL);
		sprintf(buf, "you can't; your %s appear%s to be cursed.",
                buf2,
                theItem.quantity == 1 ? "s" : "");
		confirmMessages();
		message(buf, itemMessageColor, false);
		return;
	} else {
		recordKeystrokeSequence(command);
		unequipItem(theItem, false);
		if (theItem.category & RING) {
			updateRingBonuses();
		}
		itemName(theItem, buf2, true, true, NULL);
		if (strLenWithoutEscapes(buf2) > 52) {
			itemName(theItem, buf2, false, true, NULL);
		}
		confirmMessages();
		updateEncumbrance();
		sprintf(buf, "you are no longer %s %s.", (theItem.category & WEAPON ? "wielding" : "wearing"), buf2);
		message(buf, itemMessageColor, false);
	}
	await playerTurnEnded();
}

function canDrop() {
	if (cellHasTerrainFlag(player.xLoc, player.yLoc, T_OBSTRUCTS_ITEMS)) {
		return false;
	}
	return true;
}

async function drop(/* item */ theItem) {
	const buf = STRING(), buf2 = STRING();
	const command = []; // char[3];

	command[0] = DROP_KEY;
	if (theItem == NULL) {
		theItem = await promptForItemOfType(ALL_ITEMS, 0, 0,
									  KEYBOARD_LABELS ? "Drop what? (a-z, shift for more info; or <esc> to cancel)" : "Drop what?",
                                      true);
	}
	if (theItem == NULL) {
		return;
	}
	command[1] = theItem.inventoryLetter;
	command[2] = null;

	if ((theItem.flags & ITEM_EQUIPPED) && (theItem.flags & ITEM_CURSED)) {
		itemName(theItem, buf2, false, false, NULL);
		sprintf(buf, "you can't; your %s appears to be cursed.", buf2);
		confirmMessages();
		message(buf, itemMessageColor, false);
	} else if (canDrop()) {
		recordKeystrokeSequence(command);
		if (theItem.flags & ITEM_EQUIPPED) {
			unequipItem(theItem, false);
		}
		theItem = await dropItem(theItem); // This is where it gets dropped.
		theItem.flags |= ITEM_PLAYER_AVOIDS; // Try not to pick up stuff you've already dropped.
		itemName(theItem, buf2, true, true, NULL);
		sprintf(buf, "You dropped %s.", buf2);
		message(buf, itemMessageColor, false);
		await playerTurnEnded();
	} else {
		confirmMessages();
		message("There is already something there.", false);
	}
}

async function promptForItemOfType(category,
						  requiredFlags,
						  forbiddenFlags,
						  prompt,
						  allowInventoryActions)
{
	let keystroke;
	let theItem;	// item *

	if (!numberOfMatchingPackItems(ALL_ITEMS, requiredFlags, forbiddenFlags, true)) {
		return NULL;
	}

	await temporaryMessage(prompt, false);

	keystroke = await displayInventory(category, requiredFlags, forbiddenFlags, false, allowInventoryActions);

	if (!keystroke) {
		// This can happen if the player does an action with an item directly from the inventory screen via a button.
		return NULL;
	}

	if (keystroke < 'a' || keystroke > 'z') {
		confirmMessages();
		if (keystroke != ESCAPE_KEY && keystroke != ACKNOWLEDGE_KEY) {
			message("Invalid entry.", false);
		}
		return NULL;
	}

	theItem = itemOfPackLetter(keystroke);
	if (theItem == NULL) {
		confirmMessages();
		message("No such item.", false);
		return NULL;
	}

	return theItem;
}


function itemOfPackLetter(letter) {
	let theItem;		// item *
	for (theItem = packItems.nextItem; theItem != NULL; theItem = theItem.nextItem) {
		if (theItem.inventoryLetter == letter) {
			return theItem;
		}
	}
	return NULL;
}

function itemAtLoc(x, y) {  // item *
	let theItem; // item *

	if (!(pmap[x][y].flags & HAS_ITEM)) {
		return NULL; // easy optimization
	}
	for (theItem = floorItems.nextItem; theItem != NULL && (theItem.xLoc != x || theItem.yLoc != y); theItem = theItem.nextItem);
	if (theItem == NULL) {
		pmap[x][y].flags &= ~HAS_ITEM;
		hiliteCell(x, y, white, 75, true);
		rogue.automationActive = false;
		ERROR("ERROR: An item was supposed to be @ " + x + ", " + y + ", but I couldn't find it.", true);
		refreshDungeonCell(x, y);
	}
	return theItem;
}

async function dropItem( /* item */ theItem) {
	let itemFromTopOfStack, itemOnFloor;		// item *

	if (cellHasTerrainFlag(player.xLoc, player.yLoc, T_OBSTRUCTS_ITEMS)) {
		return NULL;
	}

	itemOnFloor = itemAtLoc(player.xLoc, player.yLoc);

	if (theItem.quantity > 1 && !(theItem.category & (WEAPON | GEM))) { // peel off the top item and drop it
		itemFromTopOfStack = generateItem(ALL_ITEMS, -1);
		copyItem(itemFromTopOfStack, theItem); // clone the item
		theItem.quantity--;
		itemFromTopOfStack.quantity = 1;
		if (itemOnFloor) {
			itemOnFloor.inventoryLetter = theItem.inventoryLetter; // just in case all letters are taken
			await pickUpItemAt(player.xLoc, player.yLoc);
		}
		await placeItem(itemFromTopOfStack, player.xLoc, player.yLoc);
		return itemFromTopOfStack;
	} else { // drop the entire item
		removeItemFromChain(theItem, packItems);
		if (itemOnFloor) {
			itemOnFloor.inventoryLetter = theItem.inventoryLetter;
			await pickUpItemAt(player.xLoc, player.yLoc);
		}
		await placeItem(theItem, player.xLoc, player.yLoc);
		return theItem;
	}
}

function recalculateEquipmentBonuses() {
	let enchant;
	let theItem;	// item *

	if (rogue.weapon) {
		theItem = rogue.weapon;
		enchant = fp_netEnchant(theItem);
		player.info.damage.copy(theItem.damage);
		player.info.damage.lowerBound = player.info.damage.lowerBound * fp_damageFraction(enchant) >> FP_BASE;
		player.info.damage.upperBound = player.info.damage.upperBound * fp_damageFraction(enchant) >> FP_BASE;
		if (player.info.damage.lowerBound < 1) {
			player.info.damage.lowerBound = 1;
		}
		if (player.info.damage.upperBound < 1) {
			player.info.damage.upperBound = 1;
		}
	}

	if (rogue.armor) {
		theItem = rogue.armor;
		enchant = fp_netEnchant(theItem);
    enchant -= player.status[STATUS_DONNING] << FP_BASE;
		player.info.defense = (theItem.armor << FP_BASE) + enchant * 10 >> FP_BASE;
		if (player.info.defense < 0) {
			player.info.defense = 0;
		}
	}
}


function equipItem( /*item */ theItem, force)
{
	let previouslyEquippedItem = NULL;	// item *

	if ((theItem.category & RING) && (theItem.flags & ITEM_EQUIPPED)) {
		return;
	}

	if (theItem.category & WEAPON) {
		previouslyEquippedItem = rogue.weapon;
	} else if (theItem.category & ARMOR) {
		previouslyEquippedItem = rogue.armor;
	}
	if (previouslyEquippedItem) {
		if (!force && (previouslyEquippedItem.flags & ITEM_CURSED)) {
			return; // already using a cursed item
		} else {
			unequipItem(previouslyEquippedItem, force);
		}
	}
	if (theItem.category & WEAPON) {
		rogue.weapon = theItem;
		recalculateEquipmentBonuses();
	} else if (theItem.category & ARMOR) {
        if (!force) {
            player.status[STATUS_DONNING] = player.maxStatus[STATUS_DONNING] = Math.floor(theItem.armor / 10);
        }
		rogue.armor = theItem;
		recalculateEquipmentBonuses();
	} else if (theItem.category & RING) {
		if (rogue.ringLeft && rogue.ringRight) {
			return;
		}
		if (rogue.ringLeft) {
			rogue.ringRight = theItem;
		} else {
			rogue.ringLeft = theItem;
		}
		updateRingBonuses();
		if (theItem.kind == RING_CLAIRVOYANCE) {
			updateClairvoyance();
			displayLevel();
            identifyItemKind(theItem);
		} else if (theItem.kind == RING_LIGHT
                   || theItem.kind == RING_STEALTH) {
            identifyItemKind(theItem);
		}
	}
	theItem.flags |= ITEM_EQUIPPED;
	return;
}

function unequipItem( /* item */ theItem, force)
{
	if (theItem == NULL || !(theItem.flags & ITEM_EQUIPPED)) {
		return;
	}
	if ((theItem.flags & ITEM_CURSED) && !force) {
		return;
	}
	theItem.flags &= ~ITEM_EQUIPPED;
	if (theItem.category & WEAPON) {
		player.info.damage.lowerBound = 1;
		player.info.damage.upperBound = 2;
		player.info.damage.clumpFactor = 1;
		rogue.weapon = NULL;
	}
	if (theItem.category & ARMOR) {
		player.info.defense = 0;
		rogue.armor = NULL;
    player.status[STATUS_DONNING] = 0;
	}
	if (theItem.category & RING) {
		if (rogue.ringLeft == theItem) {
			rogue.ringLeft = NULL;
		} else if (rogue.ringRight == theItem) {
			rogue.ringRight = NULL;
		}
		updateRingBonuses();
		if (theItem.kind == RING_CLAIRVOYANCE) {
			updateClairvoyance();
      updateFieldOfViewDisplay(false, false);
			updateClairvoyance(); // Yes, we have to call this a second time.
			displayLevel();
		}
	}
	updateEncumbrance();
	return;
}

function updateRingBonuses() {
	let i;
	let rings = [rogue.ringLeft, rogue.ringRight];

	rogue.clairvoyance = rogue.stealthBonus = rogue.transference = rogue.awarenessBonus = rogue.regenerationBonus = rogue.wisdomBonus = rogue.reaping = 0;
	rogue.lightMultiplier = 1;

	for (i=0; i<= 1; i++) {
		if (rings[i]) {
			switch (rings[i].kind) {
				case RING_CLAIRVOYANCE:
					rogue.clairvoyance += effectiveRingEnchant(rings[i]);
					break;
				case RING_STEALTH:
					rogue.stealthBonus += effectiveRingEnchant(rings[i]);
					break;
				case RING_REGENERATION:
					rogue.regenerationBonus += effectiveRingEnchant(rings[i]);
					break;
				case RING_TRANSFERENCE:
					rogue.transference += effectiveRingEnchant(rings[i]);
					break;
				case RING_LIGHT:
					rogue.lightMultiplier += effectiveRingEnchant(rings[i]);
					break;
				case RING_AWARENESS:
					rogue.awarenessBonus += 20 * effectiveRingEnchant(rings[i]);
					break;
				case RING_WISDOM:
					rogue.wisdomBonus += effectiveRingEnchant(rings[i]);
          break;
      case RING_REAPING:
          rogue.reaping += effectiveRingEnchant(rings[i]);
					break;
			}
		}
	}

	if (rogue.lightMultiplier <= 0) {
		rogue.lightMultiplier--; // because it starts at positive 1 instead of 0
	}

	updateMinersLightRadius();
	updatePlayerRegenerationDelay();

	if (rogue.stealthBonus < 0) {
		rogue.stealthBonus *= 4;
	}
}

function updatePlayerRegenerationDelay() {
	let maxHP;
	let turnsForFull; // In thousandths of a turn.
	maxHP = player.info.maxHP;
	turnsForFull = fp_turnsForFullRegenInThousandths(rogue.regenerationBonus << FP_BASE);

	player.regenPerTurn = 0;
	while (maxHP > Math.floor(turnsForFull / 1000) ) {
		player.regenPerTurn++;
		maxHP -= Math.floor(turnsForFull / 1000);
	}

	player.info.turnsBetweenRegen = Math.floor(turnsForFull / maxHP);
	// DEBUG printf("\nTurnsForFull: %i; regenPerTurn: %i; (thousandths of) turnsBetweenRegen: %i", turnsForFull, player.regenPerTurn, player.info.turnsBetweenRegen);
}


function removeItemFromChain(/* item */ theItem, /* item */ theChain) {
	let previousItem; // item *

	for (previousItem = theChain;
		 previousItem.nextItem;
		 previousItem = previousItem.nextItem) {
		if (previousItem.nextItem == theItem) {
			previousItem.nextItem = theItem.nextItem;
			return true;
		}
	}
	return false;
}

function addItemToChain( /* item */ theItem, /* item */ theChain) {
    theItem.nextItem = theChain.nextItem;
    theChain.nextItem = theItem;
}

function deleteItem( /* item */ theItem) {
	// free(theItem);
  theItem.nextItem = null;
	// TODO - Put on free list
}

function resetItemTableEntry(/* itemTable */ theEntry) {
	theEntry.identified = false;
	theEntry.called = false;
	strcpy(theEntry.callTitle, '');
}

function shuffleFlavors() {
	let i, j, randIndex, randNumber;
	const buf = STRING(); // char[COLS];

	for (i=0; i<NUMBER_POTION_KINDS; i++) {
		resetItemTableEntry(potionTable[i]);
	}
	for (i=0; i<NUMBER_STAFF_KINDS; i++) {
		resetItemTableEntry(staffTable[i]);
	}
	for (i=0; i<NUMBER_WAND_KINDS; i++) {
		resetItemTableEntry(wandTable[i]);
	}
	for (i=0; i<NUMBER_SCROLL_KINDS; i++) {
		resetItemTableEntry(scrollTable[i]);
	}
	for (i=0; i<NUMBER_RING_KINDS; i++) {
		resetItemTableEntry(ringTable[i]);
	}

	for (i=0; i<NUMBER_ITEM_COLORS; i++) {
		itemColors[i] = itemColorsRef[i];
	}
	for (i=0; i<NUMBER_ITEM_COLORS; i++) {
		randIndex = rand_range(0, NUMBER_ITEM_COLORS - 1);
    if (randIndex != i) {
        const temp = itemColors[i];
        itemColors[i] = itemColors[randIndex];
        itemColors[randIndex] = temp;
				// printf("Color %i -> %s\n", i, itemColors[i]);
				// printf("Color %i -> %s\n", randIndex, itemColors[randIndex]);
    }
	}

	if (NUMBER_ITEM_COLORS < NUMBER_POTION_KINDS) {
		throw new Error('Need more colors to cover the number of potions! HAVE:', NUMBER_ITEM_COLORS, 'NEED:', NUMBER_POTION_KINDS);
	}

	for( i = 0; i < NUMBER_POTION_KINDS; i++) {
		potionTable[i].flavor = itemColors[i + 1];
		// console.log('Potion', potionTable[i].name, potionTable[i].flavor);
	}

	for (i=0; i<NUMBER_ITEM_WOODS; i++) {
		itemWoods[i] = itemWoodsRef[i];
	}
	for (i=0; i<NUMBER_ITEM_WOODS; i++) {
		randIndex = rand_range(0, NUMBER_ITEM_WOODS - 1);
    if (randIndex != i) {
        const temp = itemWoods[i];
        itemWoods[i] = itemWoods[randIndex];
        itemWoods[randIndex] = temp;
    }
		// printf("Wood %i -> %s\n", i, itemWoods[i]);
	}

	if (NUMBER_ITEM_WOODS < NUMBER_STAFF_KINDS) {
		throw new Error('Need more woods to cover the number of staffs! HAVE:', NUMBER_ITEM_WOODS, 'NEED:', NUMBER_STAFF_KINDS);
	}

	for (i=0; i<NUMBER_STAFF_KINDS; i++) {
		staffTable[i].flavor = itemWoods[i];
	}

	for (i=0; i<NUMBER_ITEM_GEMS; i++) {
		itemGems[i] = itemGemsRef[i];
	}
	for (i=0; i<NUMBER_ITEM_GEMS; i++) {
		randIndex = rand_range(0, NUMBER_ITEM_GEMS - 1);
    if (randIndex != i) {
        const temp = itemGems[i];
        itemGems[i] = itemGems[randIndex];
        itemGems[randIndex] = temp;
    }
		// printf("Gem %i -> %s\n", i, itemGems[i]);
	}

	if (NUMBER_ITEM_GEMS < NUMBER_RING_KINDS) {
		throw new Error('Need more gems to cover the number of rings! HAVE:', NUMBER_ITEM_GEMS, 'NEED:', NUMBER_RING_KINDS);
	}

	for (i=0; i<NUMBER_RING_KINDS; i++) {
		ringTable[i].flavor = itemGems[i];
	}


	for (i=0; i<NUMBER_ITEM_METALS; i++) {
		itemMetals[i] = itemMetalsRef[i];
	}
	for (i=0; i<NUMBER_ITEM_METALS; i++) {
      randIndex = rand_range(0, NUMBER_ITEM_METALS - 1);
      if (randIndex != i) {
          const temp = itemMetals[i];
          itemMetals[i] = itemMetals[randIndex];
          itemMetals[randIndex] = temp;
      }
			// printf("Metal %i -> %s\n", i, itemMetals[i]);
	}

	if (NUMBER_ITEM_METALS < NUMBER_WAND_KINDS) {
		throw new Error('Need more metals to cover the number of wands! HAVE:', NUMBER_ITEM_METALS, 'NEED:', NUMBER_WAND_KINDS);
	}

	for (i=0; i<NUMBER_WAND_KINDS; i++) {
		wandTable[i].flavor = itemMetals[i];
	}

	for (i=0; i<NUMBER_SCROLL_KINDS; i++) {
		itemTitles[i] = STRING();
		randNumber = rand_range(3, 4);
		for (j=0; j<randNumber; j++) {
			randIndex = rand_range(0, NUMBER_TITLE_PHONEMES - 1);
			strcpy(buf, itemTitles[i]);
			sprintf(itemTitles[i], "%s%s%s", buf, ((rand_percent(50) && j>0) ? " " : ""), titlePhonemes[randIndex]);
		}
		scrollTable[i].flavor = itemTitles[i];
		// console.log(scrollTable[i].name, '->', itemTitles[i].text);
	}
}

function itemValue(/* item */ theItem) {
	switch (theItem.category) {
		case AMULET:
			return 35000;
			break;
		case GEM:
			return 5000 * theItem.quantity;
			break;
		default:
			return 0;
			break;
	}
}
/*
 *  Monsters.c
 *  Brogue
 *
 *  Created by Brian Walker on 1/13/09.
 *  Copyright 2012. All rights reserved.
 *
 *  This file is part of Brogue.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

// #include <math.h>
// #include "Rogue.h"
// #include "IncludeGlobals.h"

function mutateMonster( /* creature */ monst, mutationIndex) {
    brogueAssert(mutationIndex >= 0 && mutationIndex < NUMBER_MUTATORS);
    monst.mutationIndex = mutationIndex;
    const theMut = mutationCatalog[mutationIndex];

    monst.info.flags |= theMut.monsterFlags;
    monst.info.abilityFlags |= theMut.monsterAbilityFlags;
    monst.info.maxHP = Math.floor(monst.info.maxHP * theMut.healthFactor / 100);
    monst.info.movementSpeed = Math.floor(monst.info.movementSpeed * theMut.moveSpeedFactor / 100);
    monst.info.attackSpeed = Math.floor(monst.info.attackSpeed * theMut.attackSpeedFactor / 100);
    monst.info.defense = Math.floor(monst.info.defense * theMut.defenseFactor / 100);
    if (monst.info.damage.lowerBound > 0) {
        monst.info.damage.lowerBound = Math.floor(monst.info.damage.lowerBound * theMut.damageFactor / 100);
        monst.info.damage.lowerBound = max(monst.info.damage.lowerBound, 1);
    }
    if (monst.info.damage.upperBound > 0) {
        monst.info.damage.upperBound = Math.floor(monst.info.damage.upperBound * theMut.damageFactor / 100);
        monst.info.damage.upperBound = max(monst.info.damage.upperBound, (monst.info.abilityFlags & MA_POISONS) ? 2 : 1);
    }
    if (theMut.DFChance >= 0) {
        monst.info.DFChance = theMut.DFChance;
    }
    if (theMut.DFType > 0) {
        monst.info.DFType = theMut.DFType;
    }
}

function copyCreatureType(dest, source) {
  dest.monsterID = source.monsterID;
  dest.monsterName.copy(source.monsterName);
  dest.displayChar = source.displayChar;
  dest.foreColor = source.foreColor;
  dest.maxHP = source.maxHP;
  dest.defense = source.defense;
  dest.accuracy = source.accuracy;
  dest.damage = randomRange(source.damage);
  dest.turnsBetweenRegen = source.turnsBetweenRegen;
  dest.movementSpeed = source.movementSpeed;
  dest.attackSpeed = source.attackSpeed;
  dest.bloodType = source.bloodType;
  dest.ntrinsicLightType = source.ntrinsicLightType;
  dest.DFChance = source.DFChance;
  dest.DFType = source.DFType;
  dest.bolts = source.bolts.slice();
  dest.flags = source.flags;
  dest.abilityFlags = source.abilityFlags;

}

// 1.17^x * 10, with x from 1 to 13:
const POW_DEEP_MUTATION = [11, 13, 16, 18, 21, 25, 30, 35, 41, 48, 56, 65, 76];

// Allocates space, generates a creature of the given type,
// prepends it to the list of creatures, and returns a pointer to that creature. Note that the creature
// is not given a map location here!
function generateMonster(monsterID, itemPossible, mutationPossible) {
	let itemChance, mutationChance, i, mutationAttempt;
	let monst; // creature *

	monst = creature(); // (creature *) malloc(sizeof(creature));
	// memset(monst, '\0', sizeof(creature));
	clearStatus(monst);
	copyCreatureType(monst.info, monsterCatalog[monsterID]);

  monst.mutationIndex = -1;
  if (mutationPossible
      && !(monst.info.flags & MONST_NEVER_MUTATED)
      && !(monst.info.abilityFlags & MA_NEVER_MUTATED)
      && rogue.depthLevel > 10)
  {
      if (rogue.depthLevel <= AMULET_LEVEL) {
          mutationChance = clamp(rogue.depthLevel - 10, 1, 10);
      } else {
          mutationChance = POW_DEEP_MUTATION[min(rogue.depthLevel - AMULET_LEVEL, 12)];
          mutationChance = min(mutationChance, 75);
      }

      if (rand_percent(mutationChance)) {
          mutationAttempt = rand_range(0, NUMBER_MUTATORS - 1);
          if (!(monst.info.flags & mutationCatalog[mutationAttempt].forbiddenFlags)
              && !(monst.info.abilityFlags & mutationCatalog[mutationAttempt].forbiddenAbilityFlags))
          {
              mutateMonster(monst, mutationAttempt);
          }
      }
  }

	monst.nextCreature = monsters.nextCreature;
	monsters.nextCreature = monst;
	monst.xLoc = monst.yLoc = 0;
	monst.depth = rogue.depthLevel;
	monst.bookkeepingFlags = 0;
	monst.mapToMe = NULL;
	monst.safetyMap = NULL;
	monst.leader = NULL;
	monst.carriedMonster = NULL;
	monst.creatureState = (((monst.info.flags & MONST_NEVER_SLEEPS) || rand_percent(25))
							? MONSTER_TRACKING_SCENT : MONSTER_SLEEPING);
	monst.creatureMode = MODE_NORMAL;
	monst.currentHP = monst.info.maxHP;
	monst.spawnDepth = rogue.depthLevel;
	monst.ticksUntilTurn = monst.info.movementSpeed;
	monst.info.turnsBetweenRegen *= 1000; // tracked as thousandths to prevent rounding errors
	monst.turnsUntilRegen = monst.info.turnsBetweenRegen;
	monst.regenPerTurn = 0;
	monst.movementSpeed = monst.info.movementSpeed;
	monst.attackSpeed = monst.info.attackSpeed;
	monst.turnsSpentStationary = 0;
	monst.xpxp = 0;
  monst.machineHome = 0;
	monst.newPowerCount = monst.totalPowerCount = 0;
	monst.targetCorpseLoc[0] = monst.targetCorpseLoc[1] = 0;
  monst.lastSeenPlayerAt[0] = monst.lastSeenPlayerAt[1] = -1;
  monst.targetWaypointIndex = -1;
  for (i=0; i < MAX_WAYPOINT_COUNT; i++) {
      monst.waypointAlreadyVisited[i] = rand_range(0, 1);
  }

	if (monst.info.flags & MONST_FIERY) {
		monst.status[STATUS_BURNING] = monst.maxStatus[STATUS_BURNING] = 1000; // won't decrease
	}
	if (monst.info.flags & MONST_FLIES) {
		monst.status[STATUS_LEVITATING] = monst.maxStatus[STATUS_LEVITATING] = 1000; // won't decrease
	}
	if (monst.info.flags & MONST_IMMUNE_TO_FIRE) {
		monst.status[STATUS_IMMUNE_TO_FIRE] = monst.maxStatus[STATUS_IMMUNE_TO_FIRE] = 1000; // won't decrease
	}
	if (monst.info.flags & MONST_INVISIBLE) {
		monst.status[STATUS_INVISIBLE] = monst.maxStatus[STATUS_INVISIBLE] = 1000; // won't decrease
	}
	monst.status[STATUS_NUTRITION] = monst.maxStatus[STATUS_NUTRITION] = 1000;

	if (monst.info.flags & MONST_CARRY_ITEM_100) {
		itemChance = 100;
	} else if (monst.info.flags & MONST_CARRY_ITEM_25) {
		itemChance = 25;
	} else {
		itemChance = 0;
	}

  if (ITEMS_ENABLED
      && itemPossible
      && (rogue.depthLevel <= AMULET_LEVEL)
      && monsterItemsHopper.nextItem
      && rand_percent(itemChance))
  {
      monst.carriedItem = monsterItemsHopper.nextItem;
      monsterItemsHopper.nextItem = monsterItemsHopper.nextItem.nextItem;
      monst.carriedItem.nextItem = NULL;
      monst.carriedItem.originDepth = rogue.depthLevel;
  } else {
      monst.carriedItem = NULL;
  }

	initializeGender(monst);

  if (!(monst.info.flags & MONST_INANIMATE) && !monst.status[STATUS_LIFESPAN_REMAINING]) {
      monst.bookkeepingFlags |= MB_HAS_SOUL;
  }

	return monst;
}


function monsterRevealed(/* creature */ monst) {
    if (monst === player) {
        return false;
    } else if (D_MONSTER_OMNISCIENCE) {
      return true;
    } else if (monst.bookkeepingFlags & MB_TELEPATHICALLY_REVEALED) {
        return true;
    } else if (monst.status[STATUS_ENTRANCED]) {
        return true;
    } else if (player.status[STATUS_TELEPATHIC] && !(monst.info.flags & MONST_INANIMATE)) {
        return true;
    }
    return false;
}

function monsterHiddenBySubmersion(/* creature */ monst, /* creature */ observer) {
    if (monst.bookkeepingFlags & MB_SUBMERGED) {
        if (observer
            && (terrainFlags(observer.xLoc, observer.yLoc) & T_IS_DEEP_WATER)
            && !observer.status[STATUS_LEVITATING])
        {
            // observer is in deep water, so target is not hidden by water
            return false;
        } else {
            // submerged and the observer is not in deep water.
            return true;
        }
    }
    return false;
}

function monsterIsHidden(/* creature */ monst, /* creature */ observer) {
    if (monst.bookkeepingFlags & MB_IS_DORMANT) {
        return true;
    }
    if (observer && monstersAreTeammates(monst, observer)) {
        // Teammates can always see each other.
        return false;
    }
    if ((monst.status[STATUS_INVISIBLE] && !pmap[monst.xLoc][monst.yLoc].layers[GAS])) {
        // invisible and not in gas
        return true;
    }
    if (monsterHiddenBySubmersion(monst, observer)) {
        return true;
    }
    return false;
}

function canSeeMonster(/* creature */ monst) {
	if (monst === player) {
		return true;
	}
	if (!monsterIsHidden(monst, player)
        && (playerCanSee(monst.xLoc, monst.yLoc) || monsterRevealed(monst))) {
		return true;
	}
	return false;
}

// This is different from canSeeMonster() in that it counts only physical sight -- not clairvoyance or telepathy.
function canDirectlySeeMonster( /* creature */ monst) {
	if (monst === player) {
		return true;
	}
	if (playerCanDirectlySee(monst.xLoc, monst.yLoc) && !monsterIsHidden(monst, player)) {
		return true;
	}
	return false;
}

function monsterName(buf, /* creature */ monst, includeArticle, omniscience) {

  omniscience = omniscience || rogue.playbackOmniscience;

	if (monst === player) {
    strcpy(buf, "you");
    return;
	}
	if (canSeeMonster(monst) || omniscience) {
		if (player.status[STATUS_HALLUCINATING] && !omniscience)
    {
			// assureCosmeticRNG();
      sprintf(buf, "%s%s", (includeArticle ? "the " : ""),
					monsterCatalog[cosmetic_range(1, NUMBER_MONSTER_KINDS - 1)].monsterName);
			// restoreRNG();
			return buf;
		}
    sprintf(buf, "%s%s", (includeArticle ? (monst.creatureState == MONSTER_ALLY ? "your " : "the ") : ""),
				monst.info.monsterName);
		return;
	} else {
    strcpy(buf, "something");
		return;
	}
}

function monsterIsInClass( /* creature */ monst, monsterClass) {
  let i;
  for (i = 0; monsterClassCatalog[monsterClass].memberList[i] != 0; i++) {
      if (monsterClassCatalog[monsterClass].memberList[i] == monst.info.monsterID) {
          return true;
      }
  }
  return false;
}

// Don't attack a revenant if you're not magical.
// Don't attack a monster embedded in obstruction crystal.
// Etc.
function attackWouldBeFutile(/* creature */ attacker, /* creature */ defender)
{
    if (cellHasTerrainFlag(defender.xLoc, defender.yLoc, T_OBSTRUCTS_PASSABILITY)
        && !(defender.info.flags & MONST_ATTACKABLE_THRU_WALLS))
    {
        return true;
    }
    if (attacker === player) {
        // Let the player do what she wants, if it's possible.
        return false;
    }
    if ((attacker.info.flags & MONST_RESTRICTED_TO_LIQUID)
        && !(attacker.status[STATUS_LEVITATING])
        && defender.status[STATUS_LEVITATING])
    {
        return true;
    }
    if (defender.info.flags & MONST_INVULNERABLE) {
        return true;
    }
    if (defender.info.flags & MONST_IMMUNE_TO_WEAPONS
        && !(attacker.info.abilityFlags & MA_POISONS))
    {
        return true;
    }
    return false;
}

// This is a specific kind of willingness, bordering on ability.
// Intuition: if it swung an axe from that position, should it
// hit the defender? Or silently pass through it, as it does for
// allies?
function monsterWillAttackTarget( /* creature */ attacker, /* creature */ defender) {
    if (attacker === defender || (defender.bookkeepingFlags & MB_IS_DYING)) {
        return false;
    }
    if (attacker === player
        && defender.creatureState == MONSTER_ALLY)
    {
        return false;
    }
    if (attacker.status[STATUS_ENTRANCED]
        && defender.creatureState != MONSTER_ALLY)
    {
        return true;
    }
    if (attacker.creatureState == MONSTER_ALLY
        && attacker !== player
        && defender.status[STATUS_ENTRANCED])
    {
        return false;
    }
    if (defender.bookkeepingFlags & MB_CAPTIVE) {
        return false;
    }
    if (attacker.status[STATUS_DISCORDANT]
        || defender.status[STATUS_DISCORDANT]
        || attacker.status[STATUS_CONFUSED])
    {
        return true;
    }
    if (monstersAreEnemies(attacker, defender)
      && !monstersAreTeammates(attacker, defender))
    {
        return true;
    }
    return false;
}

function monstersAreTeammates(/* creature */ monst1, /* creature */ monst2) {
	// if one follows the other, or the other follows the one, or they both follow the same
	return ((((monst1.bookkeepingFlags & MB_FOLLOWER) && monst1.leader == monst2)
			 || ((monst2.bookkeepingFlags & MB_FOLLOWER) && monst2.leader == monst1)
			 || (monst1.creatureState == MONSTER_ALLY && monst2 === player)
			 || (monst1 === player && monst2.creatureState == MONSTER_ALLY)
			 || (monst1.creatureState == MONSTER_ALLY && monst2.creatureState == MONSTER_ALLY)
			 || ((monst1.bookkeepingFlags & MB_FOLLOWER) && (monst2.bookkeepingFlags & MB_FOLLOWER)
				 && monst1.leader == monst2.leader)) ? true : false);
}


function monstersAreEnemies(/* creature */ monst1, /* creature */ monst2) {
	if ((monst1.bookkeepingFlags | monst2.bookkeepingFlags) & MB_CAPTIVE) {
		return false;
	}
	if (monst1 === monst2) {
		return false; // Can't be enemies with yourself, even if discordant.
	}
	if (monst1.status[STATUS_DISCORDANT] || monst2.status[STATUS_DISCORDANT]) {
		return true;
	}
	// eels and krakens attack anything in deep water
	if (((monst1.info.flags & MONST_RESTRICTED_TO_LIQUID)
		 && !(monst2.info.flags & MONST_IMMUNE_TO_WATER)
		 && !(monst2.status[STATUS_LEVITATING])
		 && cellHasTerrainFlag(monst2.xLoc, monst2.yLoc, T_IS_DEEP_WATER))

		|| ((monst2.info.flags & MONST_RESTRICTED_TO_LIQUID)
			&& !(monst1.info.flags & MONST_IMMUNE_TO_WATER)
			&& !(monst1.status[STATUS_LEVITATING])
			&& cellHasTerrainFlag(monst1.xLoc, monst1.yLoc, T_IS_DEEP_WATER)))
  {
		return true;
	}
	return ((monst1.creatureState == MONSTER_ALLY || monst1 === player)
			!= (monst2.creatureState == MONSTER_ALLY || monst2 === player));
}


function initializeGender(/* creature */ monst) {
	if ((monst.info.flags & MONST_MALE) && (monst.info.flags & MONST_FEMALE)) {
		monst.info.flags &= ~(rand_percent(50) ? MONST_MALE : MONST_FEMALE);
	}
}

// Returns true if either string has a null terminator before they otherwise disagree.
function stringsMatch(str1, str2) {
	let i, j;

  str1 = STRING(str1);
  str2 = STRING(str2);

  let limit = min( strlen(str1) , strlen(str2) );

	for (i=0, j=0; limit > 0; --limit) {

    // TODO - Handle COLOR_END also
    while (str1.text.charCodeAt(i) === COLOR_ESCAPE) {
      i += 4;
    }
    while(str2.text.charCodeAt(j) === COLOR_ESCAPE) {
      j += 4;
    }

		if (str1.text.charAt(i).toLowerCase() != str2.text.charAt(j).toLowerCase()) {
			return false;
		}
	}
	return true;
}

// Genders:
//	0 = [character escape sequence]
//	1 = you
//	2 = male
//	3 = female
//	4 = neuter
function resolvePronounEscapes(text, /* creature */ monst) {
	let pronounType, gender, i;
	let insert, scan;
	let capitalize;

  if (!(text instanceof BrogueString)) throw new Error('Must use BrogueString.');

	// Note: Escape sequences MUST be longer than EACH of the possible replacements.
	// That way, the string only contracts, and we don't need a buffer.
	const pronouns = [
		["$HESHE", "you", "he", "she", "it"],
		["$HIMHER", "you", "him", "her", "it"],
		["$HISHER", "your", "his", "her", "its"],
		["$HIMSELFHERSELF", "yourself", "himself", "herself", "itself"]
  ];

	if (monst === player) {
		gender = 1;
  } else if (!canSeeMonster(monst) && !rogue.playbackOmniscience) {
      gender = 4;
	} else if (monst.info.flags & MONST_MALE) {
		gender = 2;
	} else if (monst.info.flags & MONST_FEMALE) {
		gender = 3;
	} else {
		gender = 4;
	}

	capitalize = false;

  for(i = 0; i < strlen(text); ++i) {
    const ch = text.text.charCodeAt(i);
    if (ch === COLOR_ESCAPE) {
      i += 4;
    }
    else if (ch === COLOR_END) {
      // skip
    }
    else if (ch === '.'.charCodeAt(0)) {
      capitalize = true;
    }
    else if (ch === '$'.charCodeAt(0)) {
      for( let p = 0; p < pronouns.length; ++p) {
        if (text.text.startsWith(pronouns[p][0], i)) {
          const pronoun = STRING(pronouns[p][gender]);
          if (capitalize) {
            pronoun.capitalize();
          }
          text.splice(i, strlen(pronouns[p][0]), pronoun);
        }
      }
    }
    else if (ch !== ' '.charCodeAt(0) ) {
      capitalize = false;
    }
  }

  return text;
}


// Pass 0 for summonerType for an ordinary selection.
function pickHordeType(depth, /* monsterTypes */ summonerType, forbiddenFlags, requiredFlags) {
	let i, index, possCount = 0;

	if (depth <= 0) {
		depth = rogue.depthLevel;
	}

	for (i=0; i<NUMBER_HORDES; i++) {
		if (!(hordeCatalog[i].flags & forbiddenFlags)
			&& !(~(hordeCatalog[i].flags) & requiredFlags)
			&& ((!summonerType && hordeCatalog[i].minLevel <= depth && hordeCatalog[i].maxLevel >= depth)
				|| (summonerType && (hordeCatalog[i].flags & HORDE_IS_SUMMONED) && hordeCatalog[i].leaderType == summonerType)))
    {
			possCount += hordeCatalog[i].frequency;
		}
	}

	if (possCount == 0) {
		return -1;
	}

	index = rand_range(1, possCount);

	for (i=0; i<NUMBER_HORDES; i++) {
		if (!(hordeCatalog[i].flags & forbiddenFlags)
			&& !(~(hordeCatalog[i].flags) & requiredFlags)
			&& ((!summonerType && hordeCatalog[i].minLevel <= depth && hordeCatalog[i].maxLevel >= depth)
				|| (summonerType && (hordeCatalog[i].flags & HORDE_IS_SUMMONED) && hordeCatalog[i].leaderType == summonerType)))
    {
			if (index <= hordeCatalog[i].frequency) {
				return i;
			}
			index -= hordeCatalog[i].frequency;
		}
	}
	return 0; // should never happen
}

function empowerMonster( /* creature */ monst) {
    const theMonsterName = STRING(), buf = STRING(); // char[200];
    monst.info.maxHP += 5;
    monst.currentHP += Math.floor(5 * monst.currentHP / (monst.info.maxHP - 5));
    monst.info.defense += 5;
    monst.info.accuracy += 5;
    monst.info.damage.lowerBound += max(1, Math.floor(monst.info.damage.lowerBound / 20));
    monst.info.damage.upperBound += max(1, Math.floor(monst.info.damage.upperBound / 20));
    monst.newPowerCount++;
    monst.totalPowerCount++;
    heal(monst, 100, true);
    if (monst.info.turnsBetweenRegen > 0) {
        monst.info.turnsBetweenRegen = Math.floor((monst.info.turnsBetweenRegen * 2 + 2) / 3);
    }

    if (canSeeMonster(monst)) {
        monsterName(theMonsterName, monst, true);
        sprintf(bif, "%s looks stronger", theMonsterName);
        combatMessage(buf, advancementMessageColor);
    }
}


function copyCreature(dest, source) {
  copyCreatureType(dest.info, source.info);
  dest.xLoc = source.xLoc;
  dest.yLoc = source.yLoc;
  dest.depth = source.depth;
  dest.currentHP = source.currentHP;
  dest.turnsUntilRegen = source.turnsUntilRegen;
  dest.regenPerTurn = source.regenPerTurn;		 // number of HP to regenerate every single turn
  dest.weaknessAmount = source.weaknessAmount; // number of points of weakness that are inflicted by the weakness status
  dest.poisonAmount = source.poisonAmount;     // number of points of damage per turn from poison
  dest.creatureState = source.creatureState;	 // current behavioral state
  dest.creatureMode = source.creatureMode;	   // current behavioral mode (higher-level than state)

  dest.mutationIndex = source.mutationIndex;   // what mutation the monster has (or -1 for none)

  // Waypoints:
  dest.targetWaypointIndex = source.targetWaypointIndex;               // the index number of the waypoint we're pathing toward
  dest.waypointAlreadyVisited = source.waypointAlreadyVisited.slice(); // [MAX_WAYPOINT_COUNT]; // checklist of waypoints
  dest.lastSeenPlayerAt = source.lastSeenPlayerAt.slice();             // last location at which the monster hunted the player

  dest.targetCorpseLoc = source.targetCorpseLoc.slice();  // [2];			// location of the corpse that the monster is approaching to gain its abilities
  strcpy(dest.targetCorpseName,source.targetCorpseName); // [30];			// name of the deceased monster that we're approaching to gain its abilities
  dest.absorptionFlags = source.absorptionFlags;		// ability/behavior flags that the monster will gain when absorption is complete
  dest.absorbBehavior = source.absorbBehavior;				// above flag is behavior instead of ability (ignored if absorptionBolt is set)
  dest.absorptionBolt = source.absorptionBolt;               // bolt index that the monster will learn to cast when absorption is complete
  dest.corpseAbsorptionCounter = source.corpseAbsorptionCounter;		// used to measure both the time until the monster stops being interested in the corpse,
                    // and, later, the time until the monster finishes absorbing the corpse.
  dest.mapToMe = source.mapToMe; 					// if a pack leader, this is a periodically updated pathing map to get to the leader
  dest.safetyMap = source.safetyMap; 					// fleeing monsters store their own safety map when out of player FOV to avoid omniscience
  dest.ticksUntilTurn = source.ticksUntilTurn; 				// how long before the creature gets its next move

  // Locally cached statistics that may be temporarily modified:
  dest.movementSpeed = source.movementSpeed;
  dest.attackSpeed = source.attackSpeed;

  dest.turnsSpentStationary = source.turnsSpentStationary; 		// how many (subjective) turns it's been since the creature moved between tiles
  dest.flashStrength = source.flashStrength;				// monster will flash soon; this indicates the percent strength of flash
  dest.flashColor.copy(source.flashColor),					// the color that the monster will flash
  dest.status = source.status.slice(); // [NUMBER_OF_STATUS_EFFECTS];
  dest.maxStatus = source.maxStatus.slice(); // [NUMBER_OF_STATUS_EFFECTS]; // used to set the max point on the status bars
  dest.bookkeepingFlags = source.bookkeepingFlags;
  dest.spawnDepth = source.spawnDepth;					// keep track of the depth of the machine to which they relate (for activation monsters)
  dest.machineHome = source.machineHome;                  // monsters that spawn in a machine keep track of the machine number here (for activation monsters)
  dest.xpxp = source.xpxp;							// exploration experience (used to time telepathic bonding for allies)
  dest.newPowerCount = source.newPowerCount;                // how many more times this monster can absorb a fallen monster
  dest.totalPowerCount = source.totalPowerCount;              // how many times has the monster been empowered? Used to recover abilities when negated.
  dest.leader = source.leader;			// only if monster is a follower
  dest.carriedMonster = source.carriedMonster;	// when vampires turn into bats, one of the bats restores the vampire when it dies
  dest.nextCreature = source.nextCreature;
  dest.carriedItem = source.carriedItem;			// only used for monsters

}

// If placeClone is false, the clone won't get a location
// and won't set any HAS_MONSTER flags or cause any refreshes;
// it's just generated and inserted into the chains.
async function cloneMonster( /* creature */ monst, announce, placeClone) {
	let newMonst, nextMonst, parentMonst;  // creature *
	const buf = STRING(), monstName = STRING(); // char[DCOLS];
  let jellyCount;

	newMonst = generateMonster(monst.info.monsterID, false, false);
	nextMonst = newMonst.nextCreature;
  copyCreature(newMonst, monst);   // *newMonst = *monst; // boink!
	newMonst.nextCreature = nextMonst;

	if (monst.carriedMonster) {
		parentMonst = await cloneMonster(monst.carriedMonster, false, false); // Also clone the carriedMonster
		removeMonsterFromChain(parentMonst, monsters);
		removeMonsterFromChain(parentMonst, dormantMonsters);
	} else {
		parentMonst = NULL;
	}

	initializeGender(newMonst);
	newMonst.bookkeepingFlags &= ~(MB_LEADER | MB_CAPTIVE | MB_HAS_SOUL);
	newMonst.bookkeepingFlags |= MB_FOLLOWER;
	newMonst.mapToMe = NULL;
	newMonst.safetyMap = NULL;
	newMonst.carriedItem = NULL;
	newMonst.carriedMonster = parentMonst;
	newMonst.ticksUntilTurn = 101;
  if (!(monst.creatureState == MONSTER_ALLY)) {
      newMonst.bookkeepingFlags &= ~MB_TELEPATHICALLY_REVEALED;
  }
	if (monst.leader) {
		newMonst.leader = monst.leader;
	} else {
		newMonst.leader = monst;
		monst.bookkeepingFlags |= MB_LEADER;
	}

  if (monst.bookkeepingFlags & MB_CAPTIVE) {
      // If you clone a captive, the clone will be your ally.
      await becomeAllyWith(newMonst);
  }

	if (placeClone) {
//		getQualifyingLocNear(loc, monst.xLoc, monst.yLoc, true, 0, forbiddenFlagsForMonster(&(monst.info)), (HAS_PLAYER | HAS_MONSTER), false, false);
//		newMonst.xLoc = loc[0];
//		newMonst.yLoc = loc[1];
    const loc = getQualifyingPathLocNear(monst.xLoc, monst.yLoc, true,
                                 T_DIVIDES_LEVEL & avoidedFlagsForMonster(newMonst.info), HAS_PLAYER,
                                 avoidedFlagsForMonster(newMonst.info), (HAS_PLAYER | HAS_MONSTER | HAS_STAIRS), false);
    if (!loc) ERROR('EXPECTED LOCATION');
    newMonst.xLoc = loc[0];
    newMonst.yLoc = loc[1];
		pmap[newMonst.xLoc][newMonst.yLoc].flags |= HAS_MONSTER;
		refreshDungeonCell(newMonst.xLoc, newMonst.yLoc);
		if (announce && canSeeMonster(newMonst)) {
			monsterName(monstName, newMonst, false);
			sprintf(buf, "another %s appears!", monstName);
			message(buf, false);
		}
	}

	if (monst === player) { // Player managed to clone himself.
		newMonst.info.foreColor = gray;
		newMonst.info.damage.lowerBound = 1;
		newMonst.info.damage.upperBound = 2;
		newMonst.info.damage.clumpFactor = 1;
		newMonst.info.defense = 0;
		newMonst.info.monsterName = "clone";
		newMonst.creatureState = MONSTER_ALLY;
	}

  if (monst.creatureState == MONSTER_ALLY
      && (monst.info.abilityFlags & MA_CLONE_SELF_ON_DEFEND)
      && !rogue.featRecord[FEAT_JELLYMANCER])
  {
      jellyCount = 0;
      for (nextMonst = monsters.nextCreature; nextMonst != NULL; nextMonst = nextMonst.nextCreature) {
          if (nextMonst.creatureState == MONSTER_ALLY
              && (nextMonst.info.abilityFlags & MA_CLONE_SELF_ON_DEFEND))
          {
              jellyCount++;
          }
      }
      if (jellyCount >= 90) {
          rogue.featRecord[FEAT_JELLYMANCER] = true;
      }
  }
	return newMonst;
}


function forbiddenFlagsForMonster( /* creatureType */ monsterType) {
	let flags;

	flags = T_PATHING_BLOCKER;
  if (monsterType.flags & MONST_INVULNERABLE) {
      flags &= ~(T_LAVA_INSTA_DEATH | T_SPONTANEOUSLY_IGNITES | T_IS_FIRE);
  }
	if (monsterType.flags & (MONST_IMMUNE_TO_FIRE | MONST_FLIES)) {
		flags &= ~T_LAVA_INSTA_DEATH;
	}
	if (monsterType.flags & MONST_IMMUNE_TO_FIRE) {
		flags &= ~(T_SPONTANEOUSLY_IGNITES | T_IS_FIRE);
	}
	if (monsterType.flags & (MONST_IMMUNE_TO_WATER | MONST_FLIES)) {
		flags &= ~T_IS_DEEP_WATER;
	}
	if (monsterType.flags & (MONST_FLIES)) {
		flags &= ~(T_AUTO_DESCENT | T_IS_DF_TRAP);
	}
	return flags;
}


function avoidedFlagsForMonster( /* creatureType */ monsterType) {
	let flags;

	flags = forbiddenFlagsForMonster(monsterType) | T_HARMFUL_TERRAIN | T_SACRED;

  if (monsterType.flags & MONST_INVULNERABLE) {
      flags &= ~(T_HARMFUL_TERRAIN | T_IS_DF_TRAP);
  }
	if (monsterType.flags & MONST_INANIMATE) {
		flags &= ~(T_CAUSES_POISON | T_CAUSES_DAMAGE | T_CAUSES_PARALYSIS | T_CAUSES_CONFUSION);
	}
	if (monsterType.flags & MONST_IMMUNE_TO_FIRE) {
		flags &= ~T_IS_FIRE;
	}
	if (monsterType.flags & MONST_FLIES) {
		flags &= ~T_CAUSES_POISON;
	}
	return flags;
}

function monsterCanSubmergeNow(/* creature */ monst) {
	return ((monst.info.flags & MONST_SUBMERGES)
			&& cellHasTMFlag(monst.xLoc, monst.yLoc, TM_ALLOWS_SUBMERGING)
			&& !cellHasTerrainFlag(monst.xLoc, monst.yLoc, T_OBSTRUCTS_PASSABILITY)
			&& !(monst.bookkeepingFlags & (MB_SEIZING | MB_SEIZED | MB_CAPTIVE))
			&& ((monst.info.flags & (MONST_IMMUNE_TO_FIRE | MONST_INVULNERABLE))
				|| monst.status[STATUS_IMMUNE_TO_FIRE]
				|| !cellHasTerrainFlag(monst.xLoc, monst.yLoc, T_LAVA_INSTA_DEATH)));
}

// Returns true if at least one minion spawned.
async function spawnMinions(hordeID, /* creature */ leader, summoned) {
	let iSpecies, iMember, count;
	let forbiddenTerrainFlags;
	let theHorde;  // hordeType *
	let monst; // creature *
	let x, y, loc;
	let failsafe;
	let atLeastOneMinion = false;
  const buf = STRING(), buf2 = STRING();

	x = leader.xLoc;
	y = leader.yLoc;

	theHorde = hordeCatalog[hordeID];

	for (iSpecies = 0; iSpecies < theHorde.numberOfMemberTypes; iSpecies++) {
		count = randClump(theHorde.memberCount[iSpecies]);

		forbiddenTerrainFlags = forbiddenFlagsForMonster(monsterCatalog[theHorde.memberType[iSpecies]]);
		if (hordeCatalog[hordeID].spawnsIn) {
			forbiddenTerrainFlags &= ~(tileCatalog[hordeCatalog[hordeID].spawnsIn].flags);
		}

		for (iMember = 0; iMember < count; iMember++) {
			monst = generateMonster(theHorde.memberType[iSpecies], true, !summoned);
			failsafe = 0;
			do {
        loc = getQualifyingPathLocNear(x, y, summoned,
                                 T_DIVIDES_LEVEL & forbiddenTerrainFlags, (HAS_PLAYER | HAS_STAIRS),
                                 forbiddenTerrainFlags, HAS_MONSTER, false);
			} while (!loc || (theHorde.spawnsIn && !cellHasTerrainType(monst.xLoc, monst.yLoc, theHorde.spawnsIn) && failsafe++ < 20));
			if (failsafe >= 20) {
				// abort
				killCreature(monst, true);
				break;
			}
      monst.xLoc = loc[0];
      monst.yLoc = loc[1];

			if (monsterCanSubmergeNow(monst)) {
				monst.bookkeepingFlags |= MB_SUBMERGED;
			}
      brogueAssert(!(pmap[monst.xLoc][monst.yLoc].flags & HAS_MONSTER));
			pmap[monst.xLoc][monst.yLoc].flags |= HAS_MONSTER;
			monst.bookkeepingFlags |= (MB_FOLLOWER | MB_JUST_SUMMONED);
			monst.leader = leader;
			monst.creatureState = leader.creatureState;
			monst.mapToMe = NULL;
			if (theHorde.flags & HORDE_DIES_ON_LEADER_DEATH) {
				monst.bookkeepingFlags |= MB_BOUND_TO_LEADER;
			}
			if (hordeCatalog[hordeID].flags & HORDE_ALLIED_WITH_PLAYER) {
				await becomeAllyWith(monst);
			}
			atLeastOneMinion = true;

      if (D_MESSAGE_MONSTER_GENERATION) {
        monsterName(buf, monst, false, true);
        sprintf(buf2, "Added minion: %s @ %i,%i", buf, monst.xLoc, monst.yLoc);
        message(buf2, false);
      }

		}
	}

	if (atLeastOneMinion && !(theHorde.flags & HORDE_DIES_ON_LEADER_DEATH)) {
		leader.bookkeepingFlags |= MB_LEADER;
	}

	return atLeastOneMinion;
}

function drawManacle(x, y, dir) {
	const manacles = [MANACLE_T, MANACLE_B, MANACLE_L, MANACLE_R, MANACLE_TL, MANACLE_BL, MANACLE_TR, MANACLE_BR];
	let newX = x + nbDirs[dir][0];
	let newY = y + nbDirs[dir][1];
	if (coordinatesAreInMap(newX, newY)
		&& pmap[newX][newY].layers[DUNGEON] == FLOOR
		&& pmap[newX][newY].layers[LIQUID] == NOTHING)
  {
		pmap[x + nbDirs[dir][0]][y + nbDirs[dir][1]].layers[SURFACE] = manacles[dir];
		return true;
	}
	return false;
}

function drawManacles( x, y) {
	const fallback = [[UPLEFT, UP, LEFT], [DOWNLEFT, DOWN, LEFT], [UPRIGHT, UP, RIGHT], [DOWNRIGHT, DOWN, RIGHT]];
	let i, j;
	for (i = 0; i < 4; i++) {
		for (j = 0; j < 3 && !drawManacle(x, y, fallback[i][j]); j++);
	}
}


// If hordeID is 0, it's randomly assigned based on the depth, with a 10% chance of an out-of-depth spawn from 1-5 levels deeper.
// If x is negative, location is random.
// Returns a pointer to the leader.
async function spawnHorde(hordeID, x, y, forbiddenFlags, requiredFlags) {
	let loc; // short[2];
	let i, failsafe, depth;
	let theHorde;  // hordeType *
	let leader, preexistingMonst;  // creature *
  let tryAgain;
  const buf = STRING(), buf2 = STRING();

	if (rogue.depthLevel > 1 && rand_percent(10)) {
		depth = rogue.depthLevel + rand_range(1, min(5, Math.floor(rogue.depthLevel / 2)));
		if (depth > AMULET_LEVEL) {
			depth = max(rogue.depthLevel, AMULET_LEVEL);
		}
    forbiddenFlags |= HORDE_NEVER_OOD;
	} else {
		depth = rogue.depthLevel;
	}

	if (hordeID <= 0) {
		failsafe = 50;
		do {
      tryAgain = false;
			hordeID = pickHordeType(depth, 0, forbiddenFlags, requiredFlags);
			if (hordeID < 0) {
				return NULL;
			}
      if (x >= 0 && y >= 0) {
        if (cellHasTerrainFlag(x, y, T_PATHING_BLOCKER)
            && (!hordeCatalog[hordeID].spawnsIn || !cellHasTerrainType(x, y, hordeCatalog[hordeID].spawnsIn)))
        {
            // don't spawn a horde in special terrain unless it's meant to spawn there
            tryAgain = true;
        }
        if (hordeCatalog[hordeID].spawnsIn && !cellHasTerrainType(x, y, hordeCatalog[hordeID].spawnsIn)) {
            // don't spawn a horde on normal terrain if it's meant for special terrain
            tryAgain = true;
        }
      }
		} while (--failsafe && tryAgain);
	}

	failsafe = 50;

	if (x < 0 || y < 0) {
		i = 0;
		do {

      loc = randomMatchingLocation(FLOOR, NOTHING, (hordeCatalog[hordeID].spawnsIn ? hordeCatalog[hordeID].spawnsIn : -1));

			while (!loc || passableArcCount(loc[0], loc[1]) > 1)
      {
				if (!--failsafe) {
					return NULL;
				}
				hordeID = pickHordeType(depth, 0, forbiddenFlags, 0);

				if (hordeID < 0) {
					return NULL;
				}

        loc = randomMatchingLocation(FLOOR, NOTHING, (hordeCatalog[hordeID].spawnsIn ? hordeCatalog[hordeID].spawnsIn : -1));
			}

			x = loc[0];
			y = loc[1];
			i++;

			// This "while" condition should contain IN_FIELD_OF_VIEW, since that is specifically
			// calculated from the entry stairs when the level is generated, and will prevent monsters
			// from spawning within FOV of the entry stairs.
		} while (i < 25 && (pmap[x][y].flags & (ANY_KIND_OF_VISIBLE | IN_FIELD_OF_VIEW)));
	}

//	if (hordeCatalog[hordeID].spawnsIn == DEEP_WATER && pmap[x][y].layers[LIQUID] != DEEP_WATER) {
//		ERROR("Waterborne monsters spawned on land!", true);
//	}

	theHorde = hordeCatalog[hordeID];

	if (theHorde.machine > 0) {
		// Build the accompanying machine (e.g. a goblin encampment)
		await buildAMachine(theHorde.machine, x, y, 0, NULL, NULL, NULL);
	}

	leader = generateMonster(theHorde.leaderType, true, true);
	leader.xLoc = x;
	leader.yLoc = y;

	if (hordeCatalog[hordeID].flags & HORDE_LEADER_CAPTIVE) {
		leader.bookkeepingFlags |= MB_CAPTIVE;
		leader.creatureState = MONSTER_WANDERING;
    if (leader.info.turnsBetweenRegen > 0) {
        leader.currentHP = Math.floor(leader.info.maxHP / 4) + 1;
    }

		// Draw the manacles unless the horde spawns in weird terrain (e.g. cages).
		if (!hordeCatalog[hordeID].spawnsIn) {
			drawManacles(x, y);
		}
	} else if (hordeCatalog[hordeID].flags & HORDE_ALLIED_WITH_PLAYER) {
		await becomeAllyWith(leader);
	}

  if (hordeCatalog[hordeID].flags & HORDE_SACRIFICE_TARGET) {
      leader.bookkeepingFlags |= MB_MARKED_FOR_SACRIFICE;
      leader.info.intrinsicLightType = SACRIFICE_MARK_LIGHT;
  }

  preexistingMonst = monsterAtLoc(x, y);
  if (preexistingMonst) {
      await killCreature(preexistingMonst, true); // If there's already a monster here, quietly bury the body.
  }

  brogueAssert(!(pmap[x][y].flags & HAS_MONSTER));

	pmap[x][y].flags |= HAS_MONSTER;
  if (playerCanSeeOrSense(x, y)) {
      refreshDungeonCell(x, y);
  }
	if (monsterCanSubmergeNow(leader)) {
		leader.bookkeepingFlags |= MB_SUBMERGED;
	}

  if (D_MESSAGE_MONSTER_GENERATION) {
    monsterName(buf, leader, false, true);
    sprintf(buf2, "Added monster: %s @ %i,%i", buf, leader.xLoc, leader.yLoc);
    message(buf2, false);
  }

	await spawnMinions(hordeID, leader, false);

	return leader;
}

function fadeInMonster( /* creature */ monst) {
	let fColor, bColor;
	let displayChar;
	const app = getCellAppearance(monst.xLoc, monst.yLoc);
	flashMonster(monst, app.backColor, 100);
}

function removeMonsterFromChain( /* creature */ monst, /* creature */ theChain) {
	let previousMonster; // creature *

	for (previousMonster = theChain;
		 previousMonster.nextCreature;
		 previousMonster = previousMonster.nextCreature)
  {
		if (previousMonster.nextCreature == monst) {
			previousMonster.nextCreature = monst.nextCreature;
			return true;
		}
	}
	return false;
}

async function summonMinions(/* creature */ summoner) {
	let summonerType = summoner.info.monsterID; // enum monsterTypes
	const hordeID = pickHordeType(0, summonerType, 0, 0);
  let seenMinionCount = 0, x, y;
	let atLeastOneMinion = false;
	let monst, host; // creature *
	const buf = STRING(); // char[DCOLS];
	const monstName = STRING(); // char[DCOLS];
  let grid;

	if (hordeID < 0) {
		return false;
	}

  host = NULL;

  if (summoner.info.abilityFlags & MA_ENTER_SUMMONS) {
      pmap[summoner.xLoc][summoner.yLoc].flags &= ~HAS_MONSTER;
      removeMonsterFromChain(summoner, monsters);
  }

	atLeastOneMinion = await spawnMinions(hordeID, summoner, true);

  if (hordeCatalog[hordeID].flags & HORDE_SUMMONED_AT_DISTANCE) {
      // Create a grid where "1" denotes a valid summoning location: within DCOLS/2 pathing distance,
      // not in harmful terrain, and outside of the player's field of view.
      grid = allocGrid();
      fillGrid(grid, 0);
      calculateDistances(grid, summoner.xLoc, summoner.yLoc, (T_PATHING_BLOCKER | T_SACRED), NULL, true, true);
      findReplaceGrid(grid, 1, Math.floor(DCOLS/2), 1);
      findReplaceGrid(grid, 2, 30000, 0);
      getTerrainGrid(grid, 0, (T_PATHING_BLOCKER | T_HARMFUL_TERRAIN), (IN_FIELD_OF_VIEW | CLAIRVOYANT_VISIBLE | HAS_PLAYER | HAS_MONSTER));
  } else {
      grid = NULL;
  }

	for (monst = monsters.nextCreature; monst != NULL; monst = monst.nextCreature) {
		if (monst != summoner && monstersAreTeammates(monst, summoner)
			&& (monst.bookkeepingFlags & MB_JUST_SUMMONED))
    {
      if (hordeCatalog[hordeID].flags & HORDE_SUMMONED_AT_DISTANCE) {
          x = y = -1;
          const loc = randomLocationInGrid(grid, 1);
          x = loc[0];
          y = loc[1];
          await teleport(monst, x, y, true);
          if (x != -1 && y != -1 && grid != NULL) {
              grid[x][y] = 0;
          }
      }

			monst.bookkeepingFlags &= ~MB_JUST_SUMMONED;
			if (canSeeMonster(monst)) {
				seenMinionCount++;
				refreshDungeonCell(monst.xLoc, monst.yLoc);
			}
			monst.ticksUntilTurn = 101;
			monst.leader = summoner;
			if (monst.carriedItem) {
				deleteItem(monst.carriedItem);
				monst.carriedItem = NULL;
			}
			fadeInMonster(monst);
			host = monst;
		}
	}

	if (canSeeMonster(summoner)) {
		monsterName(monstName, summoner, true);
		if (monsterText[summoner.info.monsterID].summonMessage) {
			sprintf(buf, "%s %s", monstName, monsterText[summoner.info.monsterID].summonMessage);
		} else {
			sprintf(buf, "%s incants darkly!", monstName);
		}
		message(buf, false);
	}

  if (summoner.info.abilityFlags & MA_ENTER_SUMMONS) {
      if (atLeastOneMinion && host) {
          host.carriedMonster = summoner;
          demoteMonsterFromLeadership(summoner);
          refreshDungeonCell(summoner.xLoc, summoner.yLoc);
      } else {
          pmap[summoner.xLoc][summoner.yLoc].flags |= HAS_MONSTER;
          summoner.nextCreature = monsters.nextCreature;
          monsters.nextCreature = summoner;
      }
  } else if (atLeastOneMinion) {
      summoner.bookkeepingFlags |= MB_LEADER;
  }
  createFlare(summoner.xLoc, summoner.yLoc, SUMMONING_FLASH_LIGHT);

  if (grid) {
    freeGrid(grid);
  }

	return atLeastOneMinion;
}

// Generates and places monsters for the level.
async function populateMonsters() {

	if (!MONSTERS_ENABLED) {
		return;
	}

	let i, numberOfMonsters = min(20, 6 + 3 * max(0, rogue.depthLevel - AMULET_LEVEL)); // almost always 6.

	while (rand_percent(60)) {
		numberOfMonsters++;
	}
  if (D_INSPECT_MON_GEN) {
    console.log('Generating ' + numberOfMonsters + ' monsters.');
  }
	for (i=0; i<numberOfMonsters; i++) {
		await spawnHorde(0, -1, -1, (HORDE_IS_SUMMONED | HORDE_MACHINE_ONLY), 0); // random horde type, random location
	}

  if (D_INSPECT_LEVELGEN) {
    let mon = monsters.nextMonster;
    while(mon) {
      hiliteCell(mon.xLoc, mon.yLoc, teal, 50);
      mon = mon.nextMonster;
    }
    await temporaryMessage("Added monsters.", true);
  }

}

async function getRandomMonsterSpawnLocation() {
    let grid;
    let x, y;

    grid = allocGrid();
    fillGrid(grid, 0);
    calculateDistances(grid, player.xLoc, player.yLoc, T_DIVIDES_LEVEL, NULL, true, true);
    getTerrainGrid(grid, 0, (T_PATHING_BLOCKER | T_HARMFUL_TERRAIN), (HAS_PLAYER | HAS_MONSTER | HAS_STAIRS | IN_FIELD_OF_VIEW));
    findReplaceGrid(grid, -30000, Math.floor(DCOLS/2) - 1, 0);
    findReplaceGrid(grid, 30000, 30000, 0);
    findReplaceGrid(grid, Math.floor(DCOLS/2), 30000-1, 1);
    let loc = randomLocationInGrid(grid, 1);
    x = loc[0];
    y = loc[1];
    if (x < 0 || y < 0) {
        fillGrid(grid, 1);
        getTerrainGrid(grid, 0, (T_PATHING_BLOCKER | T_HARMFUL_TERRAIN), (HAS_PLAYER | HAS_MONSTER | HAS_STAIRS | IN_FIELD_OF_VIEW | IS_IN_MACHINE));
        loc = randomLocationInGrid(grid, 1);
        x = loc[0];
        y = loc[1];
    }
    if (D_INSPECT_MONSTER_SPAWN) {
      const dbuf = GRID(COLS, ROWS, cellDisplayBuffer );
      copyDisplayBuffer(dbuf, displayBuffer);
      hiliteGrid(grid, orange, 50);
      plotCharWithColor('X', mapToWindowX(x), mapToWindowY(y), black, white);
      await temporaryMessage("Horde spawn location possibilities:", true);
      overlayDisplayBuffer(dbuf);
    }
    freeGrid(grid);
    if (x < 0 || y < 0) {
        return null;
    }
    return [x, y];
}

async function spawnPeriodicHorde() {
	let monst, monst2;   // creature *
	let x, y;

	if (!MONSTERS_ENABLED) {
		return;
	}

  const loc = await getRandomMonsterSpawnLocation();
  if (loc) {
    x = loc[0];
    y = loc[1];
    monst = await spawnHorde(0, x, y, (HORDE_IS_SUMMONED | HORDE_LEADER_CAPTIVE | HORDE_NO_PERIODIC_SPAWN | HORDE_MACHINE_ONLY), 0);
    if (monst) {
        monst.creatureState = MONSTER_WANDERING;
        for (monst2 = monsters.nextCreature; monst2 != NULL; monst2 = monst2.nextCreature) {
            if (monst2.leader == monst) {
                monst2.creatureState = MONSTER_WANDERING;
            }
        }
    }
  }
}

// x and y are optional.
async function teleport( /* creature */ monst, x, y, respectTerrainAvoidancePreferences) {
	let grid, i, j;
	let monstFOV = GRID(DCOLS, DROWS); // char[DCOLS][DROWS];

  if (!coordinatesAreInMap(x, y)) {
      zeroOutGrid(monstFOV);
      getFOVMask(monstFOV, monst.xLoc, monst.yLoc, DCOLS, T_OBSTRUCTS_VISION, 0, false);
      grid = allocGrid();
      fillGrid(grid, 0);
      calculateDistances(grid, monst.xLoc, monst.yLoc, forbiddenFlagsForMonster(monst.info) & T_DIVIDES_LEVEL, NULL, true, false);
      findReplaceGrid(grid, -30000, Math.floor(DCOLS/2), 0);
      findReplaceGrid(grid, 2, 30000, 1);
      if (validLocationCount(grid, 1) < 1) {
          fillGrid(grid, 1);
      }
      if (respectTerrainAvoidancePreferences) {
          if (monst.info.flags & MONST_RESTRICTED_TO_LIQUID) {
              fillGrid(grid, 0);
              getTMGrid(grid, 1, TM_ALLOWS_SUBMERGING);
          }
          getTerrainGrid(grid, 0, avoidedFlagsForMonster(monst.info), (IS_IN_MACHINE | HAS_PLAYER | HAS_MONSTER | HAS_STAIRS));
      } else {
          getTerrainGrid(grid, 0, forbiddenFlagsForMonster(monst.info), (IS_IN_MACHINE | HAS_PLAYER | HAS_MONSTER | HAS_STAIRS));
      }
      for (i=0; i<DCOLS; i++) {
          for (j=0; j<DROWS; j++) {
              if (monstFOV[i][j]) {
                  grid[i][j] = 0;
              }
          }
      }
      const loc = randomLocationInGrid(grid, 1);
//        DEBUG {
//            dumpLevelToScreen();
//            hiliteGrid(grid, orange, 50);
//            plotCharWithColor('X', mapToWindowX(x), mapToWindowY(y), &white, &red);
//            temporaryMessage("Teleport candidate locations:", true);
//        }
      freeGrid(grid);
      if (!loc || loc[0] < 0 || loc[1] < 0) {
          return; // Failure!
      }
      x = loc[0];
      y = loc[1];
  }
  setMonsterLocation(monst, x, y);
  if (monst !== player) {
      chooseNewWanderDestination(monst);
  }
}

function isValidWanderDestination( /* creature */ monst, wpIndex) {
    return (wpIndex >= 0
            && wpIndex < rogue.wpCount
            && !monst.waypointAlreadyVisited[wpIndex]
            && rogue.wpDistance[wpIndex][monst.xLoc][monst.yLoc] >= 0
            && nextStep(rogue.wpDistance[wpIndex], monst.xLoc, monst.yLoc, monst, false) != NO_DIRECTION);
}

function closestWaypointIndex( /* creature */ monst) {
    let i, closestDistance, closestIndex;

    closestDistance = Math.floor(DCOLS/2);
    closestIndex = -1;
    for (i=0; i < rogue.wpCount; i++) {
        if (isValidWanderDestination(monst, i)
            && rogue.wpDistance[i][monst.xLoc][monst.yLoc] < closestDistance)
        {

            closestDistance = rogue.wpDistance[i][monst.xLoc][monst.yLoc];
            closestIndex = i;
        }
    }
    return closestIndex;
}

function chooseNewWanderDestination( /* creature */ monst) {
    let i;

    brogueAssert(monst.targetWaypointIndex < MAX_WAYPOINT_COUNT);
    brogueAssert(rogue.wpCount > 0 && rogue.wpCount <= MAX_WAYPOINT_COUNT);

    // Set two checkpoints at random to false (which equilibrates to 50% of checkpoints being active).
    monst.waypointAlreadyVisited[rand_range(0, rogue.wpCount - 1)] = false;
    monst.waypointAlreadyVisited[rand_range(0, rogue.wpCount - 1)] = false;
    // Set the targeted checkpoint to true.
    if (monst.targetWaypointIndex >= 0) {
        monst.waypointAlreadyVisited[monst.targetWaypointIndex] = true;
    }

    monst.targetWaypointIndex = closestWaypointIndex(monst); // Will be -1 if no waypoints were available.
    if (monst.targetWaypointIndex == -1) {
        for (i=0; i < rogue.wpCount; i++) {
            monst.waypointAlreadyVisited[i] = 0;
        }
        monst.targetWaypointIndex = closestWaypointIndex(monst);
    }
}

ENUM('subseqDFTypes',
	'SUBSEQ_PROMOTE',
	'SUBSEQ_BURN',
  'SUBSEQ_DISCOVER',
);

// Returns the terrain flags of this tile after it's promoted according to the event corresponding to subseqDFTypes.
function successorTerrainFlags(/* tileType*/ tile, /* subseqDFTypes */ promotionType) {
    let DF = 0;   // enum dungeonFeatureTypes

    switch (promotionType) {
        case SUBSEQ_PROMOTE:
            DF = tileCatalog[tile].promoteType;
            break;
        case SUBSEQ_BURN:
            DF = tileCatalog[tile].fireType;
            break;
        case SUBSEQ_DISCOVER:
            DF = tileCatalog[tile].discoverType;
            break;
        default:
            break;
    }

    if (DF) {
        return tileCatalog[dungeonFeatureCatalog[DF].tile].flags;
    } else {
        return 0;
    }
}

function burnedTerrainFlagsAtLoc( x,  y) {
    let layer;
    let flags = 0;

    for (layer = 0; layer < NUMBER_TERRAIN_LAYERS; layer++) {
        if (tileCatalog[pmap[x][y].layers[layer]].flags & T_IS_FLAMMABLE) {
            flags |= successorTerrainFlags(pmap[x][y].layers[layer], SUBSEQ_BURN);
            if (tileCatalog[pmap[x][y].layers[layer]].mechFlags & TM_EXPLOSIVE_PROMOTE) {
                flags |= successorTerrainFlags(pmap[x][y].layers[layer], SUBSEQ_PROMOTE);
            }
        }
    }

    return flags;
}


function discoveredTerrainFlagsAtLoc(x, y) {
    let layer;
    let flags = 0;

    for (layer = 0; layer < NUMBER_TERRAIN_LAYERS; layer++) {
        if (tileCatalog[pmap[x][y].layers[layer]].mechFlags & TM_IS_SECRET) {
            flags |= successorTerrainFlags(pmap[x][y].layers[layer], SUBSEQ_DISCOVER);
        }
    }

    return flags;
}


function monsterAvoids( /* creature */ monst, x, y) {
  let terrainImmunities;
	let defender;  // creature *
  let tFlags, cFlags;

  const flags = getLocationFlags(x, y, monst === player);
  tFlags = flags.terrainFlags;
  cFlags = flags.cellFlags;

	// everyone but the player avoids the stairs
	if ((x == rogue.downLoc[0] && y == rogue.downLoc[1])
		|| (x == rogue.upLoc[0] && y == rogue.upLoc[1]))
  {
		return monst !== player;
	}

	// dry land
	if (monst.info.flags & MONST_RESTRICTED_TO_LIQUID
		&& !cellHasTMFlag(x, y, TM_ALLOWS_SUBMERGING)) {
		return true;
	}

	// non-allied monsters can always attack the player
	if (player.xLoc == x && player.yLoc == y && monst !== player && monst.creatureState != MONSTER_ALLY) {
		return false;
	}

	// walls
	if (tFlags & T_OBSTRUCTS_PASSABILITY) {
        if (monst !== player
            && cellHasTMFlag(x, y, TM_IS_SECRET)
            && !(discoveredTerrainFlagsAtLoc(x, y) & avoidedFlagsForMonster(monst.info)))
        {
            // This is so monsters can use secret doors but won't embed themselves in secret levers.
            return false;
        }
        if (distanceBetween(monst.xLoc, monst.yLoc, x, y) <= 1) {
            defender = monsterAtLoc(x, y);
            if (defender && (defender.info.flags & MONST_ATTACKABLE_THRU_WALLS)) {
                return false;
            }
        }
		return true;
	}

  // Monsters can always attack unfriendly neighboring monsters,
  // unless it is immune to us for whatever reason.
  if (distanceBetween(monst.xLoc, monst.yLoc, x, y) <= 1) {
      defender = monsterAtLoc(x, y);
      if (defender
        && !(defender.bookkeepingFlags & MB_IS_DYING)
        && monsterWillAttackTarget(monst, defender))
      {
          if (attackWouldBeFutile(monst, defender)) {
              return true;
          } else {
              return false;
          }
      }
  }

  // Monsters always avoid enemy monsters that we can't damage.
  defender = monsterAtLoc(x, y);
  if (defender
      && !(defender.bookkeepingFlags & MB_IS_DYING)
      && monstersAreEnemies(monst, defender)
      && attackWouldBeFutile(monst, defender))
  {
      return true;
  }

	// hidden terrain
	if (cellHasTMFlag(x, y, TM_IS_SECRET) && monst === player) {
		return false; // player won't avoid what he doesn't know about
	}

    // Determine invulnerabilities based only on monster characteristics.
    terrainImmunities = 0;
    if (monst.status[STATUS_IMMUNE_TO_FIRE]) {
        terrainImmunities |= (T_IS_FIRE | T_SPONTANEOUSLY_IGNITES | T_LAVA_INSTA_DEATH);
    }
    if (monst.info.flags & MONST_INVULNERABLE) {
        terrainImmunities |= T_HARMFUL_TERRAIN | T_ENTANGLES | T_SPONTANEOUSLY_IGNITES | T_LAVA_INSTA_DEATH;
    }
    if (monst.info.flags & MONST_INANIMATE) {
        terrainImmunities |= (T_CAUSES_DAMAGE | T_CAUSES_PARALYSIS | T_CAUSES_CONFUSION | T_CAUSES_NAUSEA | T_CAUSES_POISON);
    }
    if (monst.status[STATUS_LEVITATING]) {
        terrainImmunities |= (T_AUTO_DESCENT | T_CAUSES_POISON | T_IS_DEEP_WATER | T_IS_DF_TRAP | T_LAVA_INSTA_DEATH);
    }
    if (monst.info.flags & MONST_IMMUNE_TO_WEBS) {
        terrainImmunities |= T_ENTANGLES;
    }
    if (monst.info.flags & MONST_IMMUNE_TO_WATER) {
        terrainImmunities |= T_IS_DEEP_WATER;
    }
    if (monst === player) {
        terrainImmunities |= T_SACRED;
    }
    if (monst === player
        && rogue.armor
        && (rogue.armor.flags & ITEM_RUNIC)
        && rogue.armor.enchant2 == A_RESPIRATION)
    {
        terrainImmunities |= T_RESPIRATION_IMMUNITIES;
    }

    // sacred ground
    if ((tFlags & T_SACRED & ~terrainImmunities)) {
        return true;
    }

	// brimstone
	if (!(monst.status[STATUS_IMMUNE_TO_FIRE])
        && !(monst.info.flags & MONST_INVULNERABLE)
        && (tFlags & T_SPONTANEOUSLY_IGNITES)
		&& !(cFlags & (HAS_MONSTER | HAS_PLAYER))
		&& !cellHasTerrainFlag(monst.xLoc, monst.yLoc, T_IS_FIRE | T_SPONTANEOUSLY_IGNITES)
		&& (monst === player || (monst.creatureState != MONSTER_TRACKING_SCENT && monst.creatureState != MONSTER_FLEEING)))
  {
		return true;
	}

	// burning wandering monsters avoid flammable terrain out of common courtesy
	if (monst !== player
		&& monst.creatureState == MONSTER_WANDERING
		&& (monst.info.flags & MONST_FIERY)
		&& (tFlags & T_IS_FLAMMABLE))
  {
		return true;
	}

    // burning monsters avoid explosive terrain and steam-emitting terrain
    if (monst !== player
        && monst.status[STATUS_BURNING]
        && (burnedTerrainFlagsAtLoc(x, y) & (T_CAUSES_EXPLOSIVE_DAMAGE | T_CAUSES_DAMAGE | T_AUTO_DESCENT) & ~terrainImmunities))
    {
        return true;
    }

	// fire
	if ((tFlags & T_IS_FIRE & ~terrainImmunities)
		&& !cellHasTerrainFlag(monst.xLoc, monst.yLoc, T_IS_FIRE)
		&& !(cFlags & (HAS_MONSTER | HAS_PLAYER))
		&& (monst !== player || rogue.mapToShore[x][y] >= player.status[STATUS_IMMUNE_TO_FIRE]))
  {
		return true;
	}

	// non-fire harmful terrain
	if ((tFlags & T_HARMFUL_TERRAIN & ~T_IS_FIRE & ~terrainImmunities)
		&& !cellHasTerrainFlag(monst.xLoc, monst.yLoc, (T_HARMFUL_TERRAIN & ~T_IS_FIRE)))
  {
		return true;
	}

    // chasms or trap doors
    if ((tFlags & T_AUTO_DESCENT & ~terrainImmunities)
        && (!(tFlags & T_ENTANGLES) || !(monst.info.flags & MONST_IMMUNE_TO_WEBS)))
    {
        return true;
    }

    // gas or other environmental traps
    if ((tFlags & T_IS_DF_TRAP & ~terrainImmunities)
        && !(cFlags & PRESSURE_PLATE_DEPRESSED)
        && (monst === player || monst.creatureState == MONSTER_WANDERING
            || (monst.creatureState == MONSTER_ALLY && !(cellHasTMFlag(x, y, TM_IS_SECRET))))
        && !(monst.status[STATUS_ENTRANCED])
        && (!(tFlags & T_ENTANGLES) || !(monst.info.flags & MONST_IMMUNE_TO_WEBS)))
    {
        return true;
    }

    // lava
    if ((tFlags & T_LAVA_INSTA_DEATH & ~terrainImmunities)
        && (!(tFlags & T_ENTANGLES) || !(monst.info.flags & MONST_IMMUNE_TO_WEBS))
        && (monst !== player || rogue.mapToShore[x][y] >= max(player.status[STATUS_IMMUNE_TO_FIRE], player.status[STATUS_LEVITATING])))
    {
        return true;
    }

    // deep water
    if ((tFlags & T_IS_DEEP_WATER & ~terrainImmunities)
        && (!(tFlags & T_ENTANGLES) || !(monst.info.flags & MONST_IMMUNE_TO_WEBS))
        && !cellHasTerrainFlag(monst.xLoc, monst.yLoc, T_IS_DEEP_WATER))
    {
        return true; // avoid only if not already in it
    }

    // poisonous lichen
    if ((tFlags & T_CAUSES_POISON & ~terrainImmunities)
        && !cellHasTerrainFlag(monst.xLoc, monst.yLoc, T_CAUSES_POISON)
        && (monst === player || monst.creatureState != MONSTER_TRACKING_SCENT || monst.currentHP < 10))
    {
        return true;
    }

    // Smart monsters don't attack in corridors if they belong to a group and they can help it.
    if ((monst.info.abilityFlags & MA_AVOID_CORRIDORS)
        && monst.creatureState == MONSTER_TRACKING_SCENT
        && (monst.bookkeepingFlags & (MB_FOLLOWER | MB_LEADER))
        && passableArcCount(x, y) >= 2
        && passableArcCount(monst.xLoc, monst.yLoc) < 2
        && !cellHasTerrainFlag(monst.xLoc, monst.yLoc, (T_HARMFUL_TERRAIN & ~terrainImmunities)))
    {
        return true;
    }

    return false;
}

async function moveMonsterPassivelyTowards(/* creature */ monst, targetLoc /* short[2] */, willingToAttackPlayer) {
	let x, y, dx, dy, newX, newY;

	x = monst.xLoc;
	y = monst.yLoc;

	if (targetLoc[0] == x) {
		dx = 0;
	} else {
		dx = (targetLoc[0] < x ? -1 : 1);
	}
	if (targetLoc[1] == y) {
		dy = 0;
	} else {
		dy = (targetLoc[1] < y ? -1 : 1);
	}

	if (dx == 0 && dy == 0) { // already at the destination
		return false;
	}

	newX = x + dx;
	newY = y + dy;

	if (!coordinatesAreInMap(newX, newY)) {
		return false;
	}

	if (monst.creatureState != MONSTER_TRACKING_SCENT && dx && dy) {
		if (abs(targetLoc[0] - x) > abs(targetLoc[1] - y) && rand_range(0, abs(targetLoc[0] - x)) > abs(targetLoc[1] - y)) {
			if (!(monsterAvoids(monst, newX, y) || (!willingToAttackPlayer && (pmap[newX][y].flags & HAS_PLAYER)) || !await moveMonster(monst, dx, 0))) {
				return true;
			}
		} else if (abs(targetLoc[0] - x) < abs(targetLoc[1] - y) && rand_range(0, abs(targetLoc[1] - y)) > abs(targetLoc[0] - x)) {
			if (!(monsterAvoids(monst, x, newY) || (!willingToAttackPlayer && (pmap[x][newY].flags & HAS_PLAYER)) || !await moveMonster(monst, 0, dy))) {
				return true;
			}
		}
	}

	// Try to move toward the goal diagonally if possible or else straight.
	// If that fails, try both directions for the shorter coordinate.
	// If they all fail, return false.
	if (monsterAvoids(monst, newX, newY) || (!willingToAttackPlayer && (pmap[newX][newY].flags & HAS_PLAYER)) || ! await moveMonster(monst, dx, dy)) {
		if (distanceBetween(x, y, targetLoc[0], targetLoc[1]) <= 1 && (dx == 0 || dy == 0)) { // cardinally adjacent
			return false; // destination is blocked
		}
		//abs(targetLoc[0] - x) < abs(targetLoc[1] - y)
		if ((max(targetLoc[0], x) - min(targetLoc[0], x)) < (max(targetLoc[1], y) - min(targetLoc[1], y))) {
			if (monsterAvoids(monst, x, newY) || (!willingToAttackPlayer && pmap[x][newY].flags & HAS_PLAYER) || ! await moveMonster(monst, 0, dy)) {
				if (monsterAvoids(monst, newX, y) || (!willingToAttackPlayer &&  pmap[newX][y].flags & HAS_PLAYER) || ! await moveMonster(monst, dx, 0)) {
					if (monsterAvoids(monst, x-1, newY) || (!willingToAttackPlayer && pmap[x-1][newY].flags & HAS_PLAYER) || ! await moveMonster(monst, -1, dy)) {
						if (monsterAvoids(monst, x+1, newY) || (!willingToAttackPlayer && pmap[x+1][newY].flags & HAS_PLAYER) || ! await moveMonster(monst, 1, dy)) {
							return false;
						}
					}
				}
			}
		} else {
			if (monsterAvoids(monst, newX, y) || (!willingToAttackPlayer && pmap[newX][y].flags & HAS_PLAYER) || ! await moveMonster(monst, dx, 0)) {
				if (monsterAvoids(monst, x, newY) || (!willingToAttackPlayer && pmap[x][newY].flags & HAS_PLAYER) || ! await moveMonster(monst, 0, dy)) {
					if (monsterAvoids(monst, newX, y-1) || (!willingToAttackPlayer && pmap[newX][y-1].flags & HAS_PLAYER) || ! await moveMonster(monst, dx, -1)) {
						if (monsterAvoids(monst, newX, y+1) || (!willingToAttackPlayer && pmap[newX][y+1].flags & HAS_PLAYER) || ! await moveMonster(monst, dx, 1)) {
							return false;
						}
					}
				}
			}
		}
	}
	return true;
}

function distanceBetween(x1, y1, x2, y2) {
	return max(abs(x1 - x2), abs(y1 - y2));
}

function alertMonster( /* creature */ monst) {
    monst.creatureState = (monst.creatureMode == MODE_PERM_FLEEING ? MONSTER_FLEEING : MONSTER_TRACKING_SCENT);
    monst.lastSeenPlayerAt[0] = player.xLoc;
    monst.lastSeenPlayerAt[1] = player.yLoc;
}

function wakeUp(/* creature */ monst) {
	let teammate;  // creature *

	if (monst.creatureState != MONSTER_ALLY) {
    alertMonster(monst);
	}
	monst.ticksUntilTurn = 100;
	for (teammate = monsters.nextCreature; teammate != NULL; teammate = teammate.nextCreature) {
		if (monst != teammate && monstersAreTeammates(monst, teammate) && teammate.creatureMode == MODE_NORMAL) {
      if (teammate.creatureState == MONSTER_SLEEPING
          || teammate.creatureState == MONSTER_WANDERING)
      {
          teammate.ticksUntilTurn = max(100, teammate.ticksUntilTurn);
      }
			if (monst.creatureState != MONSTER_ALLY) {
				teammate.creatureState = (teammate.creatureMode == MODE_PERM_FLEEING ? MONSTER_FLEEING : MONSTER_TRACKING_SCENT);
        updateMonsterState(teammate);
			}
		}
	}
}

function monsterCanShootWebs(/* creature */ monst) {
    let i;
    for (i=0; monst.info.bolts[i] != 0; i++) {
        const theBolt = boltCatalog[monst.info.bolts[i]];
        if (theBolt.pathDF && (tileCatalog[dungeonFeatureCatalog[theBolt.pathDF].tile].flags & T_ENTANGLES)) {
            return true;
        }
    }
    return false;
}

// Assumes that observer is not the player.
// Returns approximately double the actual (quasi-euclidian) distance.
function awarenessDistance( /* creature */ observer, /* creature */ target) {
	let perceivedDistance;

	// start with base distance
	if ((observer.status[STATUS_LEVITATING]
         || (observer.info.flags & MONST_RESTRICTED_TO_LIQUID)
         || (observer.info.flags & MONST_IMMOBILE)
         || (observer.bookkeepingFlags & MB_SUBMERGED)
		 || ((observer.info.flags & MONST_IMMUNE_TO_WEBS) && monsterCanShootWebs(observer)))
		&& ((target === player && (pmap[observer.xLoc][observer.yLoc].flags & IN_FIELD_OF_VIEW))
            || (target !== player && openPathBetween(observer.xLoc, observer.yLoc, target.xLoc, target.yLoc)))) {
			// if monster flies or is immobile or waterbound or underwater or can cross pits with webs,
            // use absolute distance.
			perceivedDistance = scentDistance(observer.xLoc, observer.yLoc, target.xLoc, target.yLoc);
		} else {
			perceivedDistance = (rogue.scentTurnNumber - scentMap[observer.xLoc][observer.yLoc]); // this value is double the apparent distance
		}

	perceivedDistance = min(perceivedDistance, 1000);

	if (perceivedDistance < 0) {
		perceivedDistance = 1000;
	}
	return Math.floor(perceivedDistance);
}

// yes or no -- observer is aware of the target as of this new turn.
// takes into account whether it is ALREADY aware of the target.
function awareOfTarget( /* creature */ observer, /* creature */ target) {
	let perceivedDistance = awarenessDistance(observer, target);
	let awareness = rogue.aggroRange * 2;
  let retval;

  brogueAssert(perceivedDistance >= 0 && awareness >= 0);

	if (observer.info.flags & MONST_ALWAYS_HUNTING) {
    retval = true;
  } else if (observer.info.flags & MONST_IMMOBILE) {
    // Turrets and totems are aware of you iff they are within stealth range.
    // The only exception is mirror totems; they're always ready to shoot because they have "always hunting" set.
    retval = (perceivedDistance <= awareness);
  } else if (perceivedDistance > awareness * 3) {
		// out of awareness range, even if hunting
		retval = false;
	} else if (observer.creatureState == MONSTER_TRACKING_SCENT) {
		// already aware of the target, lose track 3% of the time if outside of stealth range.
    if (perceivedDistance > awareness) {
      retval = rand_percent(3);
    } else {
       retval = true;
    }
	} else if (target === player
		&& !(pmap[observer.xLoc][observer.yLoc].flags & IN_FIELD_OF_VIEW))
  {
		// observer not hunting and player-target not in field of view
		retval = false;
	} else if (perceivedDistance <= awareness) {
    // within range but currently unaware
    retval = rand_percent(25);
  } else {
    retval = false;
  }
  return retval;
}

function closestWaypointIndexTo(x, y) {
    let i, closestDistance, closestIndex;

    closestDistance = 1000;
    closestIndex = -1;
    for (i=0; i < rogue.wpCount; i++) {
        if (rogue.wpDistance[i][x][y] < closestDistance) {
            closestDistance = rogue.wpDistance[i][x][y];
            closestIndex = i;
        }
    }
    return closestIndex;
}

function wanderToward(/* creature */ monst, x, y) {
    if (coordinatesAreInMap(x, y)) {
        const theWaypointIndex = closestWaypointIndexTo(x, y);
        if (theWaypointIndex != -1) {
            monst.waypointAlreadyVisited[theWaypointIndex] = false;
            monst.targetWaypointIndex = theWaypointIndex;
        }
    }
}

function updateMonsterState( /* creature */ monst) {
	let x, y, closestFearedEnemy;
	let awareOfPlayer;
	//char buf[DCOLS*3], monstName[DCOLS];
  let monst2; // creature *

	x = monst.xLoc;
	y = monst.yLoc;

	if ((monst.info.flags & MONST_ALWAYS_HUNTING)
        && monst.creatureState != MONSTER_ALLY)
  {
    monst.creatureState = MONSTER_TRACKING_SCENT;
    return;
  }

	awareOfPlayer = awareOfTarget(monst, player);

  if ((monst.info.flags & MONST_IMMOBILE)
      && monst.creatureState != MONSTER_ALLY)
  {
      if (awareOfPlayer) {
          monst.creatureState = MONSTER_TRACKING_SCENT;
      } else {
          monst.creatureState = MONSTER_SLEEPING;
      }
		return;
	}

	if (monst.creatureMode == MODE_PERM_FLEEING
		&& (monst.creatureState == MONSTER_WANDERING || monst.creatureState == MONSTER_TRACKING_SCENT))
  {
		monst.creatureState = MONSTER_FLEEING;
	}

  closestFearedEnemy = DCOLS+DROWS;
  CYCLE_MONSTERS_AND_PLAYERS( (monst2) => {
      if (monsterFleesFrom(monst, monst2)
          && distanceBetween(x, y, monst2.xLoc, monst2.yLoc) < closestFearedEnemy
          && traversiblePathBetween(monst2, x, y)
          && openPathBetween(x, y, monst2.xLoc, monst2.yLoc))
      {
          closestFearedEnemy = distanceBetween(x, y, monst2.xLoc, monst2.yLoc);
      }
  });

	if ((monst.creatureState == MONSTER_WANDERING)
        && awareOfPlayer
        && (pmap[player.xLoc][player.yLoc].flags & IN_FIELD_OF_VIEW)) {

		// If wandering and you notice the player, start tracking the scent.
		alertMonster(monst);
	} else if (monst.creatureState == MONSTER_SLEEPING) {
		// if sleeping, the monster has a chance to awaken

		if (awareOfPlayer) {
			wakeUp(monst); // wakes up the whole horde if necessary

//			if (canSeeMonster(monst)) {
//				monsterName(monstName, monst, true);
//				sprintf(buf, "%s awakens!", monstName);
//				combatMessage(buf, 0);
//			}
		}
	} else if (monst.creatureState == MONSTER_TRACKING_SCENT && !awareOfPlayer) {
		// if tracking scent, but the scent is weaker than the scent detection threshold, begin wandering.
		monst.creatureState = MONSTER_WANDERING;
        wanderToward(monst, monst.lastSeenPlayerAt[0], monst.lastSeenPlayerAt[1]);
	} else if (monst.creatureState == MONSTER_TRACKING_SCENT
			   && closestFearedEnemy < 3)
  {
		monst.creatureState = MONSTER_FLEEING;
  } else if (monst.creatureState != MONSTER_ALLY
               && (monst.info.flags & MONST_FLEES_NEAR_DEATH)
               && monst.currentHP <= Math.floor(3 * monst.info.maxHP / 4))
  {
    if (monst.creatureState == MONSTER_FLEEING
        || monst.currentHP <= Math.floor(monst.info.maxHP / 4))
    {
        monst.creatureState = MONSTER_FLEEING;
    }
	} else if (monst.creatureMode == MODE_NORMAL
			   && monst.creatureState == MONSTER_FLEEING
			   && !(monst.status[STATUS_MAGICAL_FEAR])
			   && closestFearedEnemy >= 3)
 {
		monst.creatureState = MONSTER_TRACKING_SCENT;
	} else if (monst.creatureMode == MODE_PERM_FLEEING
			   && monst.creatureState == MONSTER_FLEEING
			   && (monst.info.abilityFlags & MA_HIT_STEAL_FLEE)
			   && !(monst.status[STATUS_MAGICAL_FEAR])
			   && !(monst.carriedItem))
 {
		monst.creatureMode = MODE_NORMAL;
    alertMonster(monst);
	} else if (monst.creatureMode == MODE_NORMAL
			   && monst.creatureState == MONSTER_FLEEING
			   && (monst.info.flags & MONST_FLEES_NEAR_DEATH)
			   && !(monst.status[STATUS_MAGICAL_FEAR])
			   && monst.currentHP >= Math.floor(monst.info.maxHP * 3 / 4))
   {
      if ((monst.bookkeepingFlags & MB_FOLLOWER) && monst.leader === player) {
          monst.creatureState = MONSTER_ALLY;
      } else {
          alertMonster(monst);
      }
	}

  if (awareOfPlayer) {
      if (monst.creatureState == MONSTER_FLEEING
          || monst.creatureState == MONSTER_TRACKING_SCENT)
      {
          monst.lastSeenPlayerAt[0] = player.xLoc;
          monst.lastSeenPlayerAt[1] = player.yLoc;
      }
  }
}

async function decrementMonsterStatus( /* creature */ monst) {
	let i, damage;
	const buf = STRING(), buf2 = STRING(); // char[COLS];

	monst.bookkeepingFlags &= ~MB_JUST_SUMMONED;

	if (monst.currentHP < monst.info.maxHP
        && monst.info.turnsBetweenRegen > 0
        && !monst.status[STATUS_POISONED])
  {
		if ((monst.turnsUntilRegen -= 1000) <= 0) {
			monst.currentHP++;
      monst.previousHealthPoints++;
			monst.turnsUntilRegen += monst.info.turnsBetweenRegen;
		}
	}

	for (i=0; i<NUMBER_OF_STATUS_EFFECTS; i++) {
    switch (i) {
      case STATUS_LEVITATING:
          if (monst.status[i] && !(monst.info.flags & MONST_FLIES)) {
              monst.status[i]--;
          }
          break;
      case STATUS_SLOWED:
          if (monst.status[i] && !--monst.status[i]) {
              monst.movementSpeed = monst.info.movementSpeed;
              monst.attackSpeed = monst.info.attackSpeed;
          }
          break;
      case STATUS_WEAKENED:
          if (monst.status[i] && !--monst.status[i]) {
              monst.weaknessAmount = 0;
          }
          break;
      case STATUS_HASTED:
          if (monst.status[i]) {
              if (!--monst.status[i]) {
                  monst.movementSpeed = monst.info.movementSpeed;
                  monst.attackSpeed = monst.info.attackSpeed;
              }
          }
          break;
      case STATUS_BURNING:
          if (monst.status[i]) {
              if (!(monst.info.flags & MONST_FIERY)) {
                  monst.status[i]--;
              }
              damage = rand_range(1, 3);
              if (!(monst.status[STATUS_IMMUNE_TO_FIRE])
                  && !(monst.info.flags & MONST_INVULNERABLE)
                  && await inflictDamage(NULL, monst, damage, orange, true))
              {
                  if (canSeeMonster(monst)) {
                      monsterName(buf, monst, true);
                      sprintf(buf2, "%s burns %s.",
                              buf,
                              (monst.info.flags & MONST_INANIMATE) ? "up" : "to death");
                      message(buf2, messageColorFromVictim(monst), false);
                  }
                  return;
              }
              if (monst.status[i] <= 0) {
                  extinguishFireOnCreature(monst);
              }
          }
          break;
      case STATUS_LIFESPAN_REMAINING:
          if (monst.status[i]) {
              monst.status[i]--;
              if (monst.status[i] <= 0) {
                  await killCreature(monst, false);
                  if (canSeeMonster(monst)) {
                      monsterName(buf, monst, true);
                      sprintf(buf2, "%s dissipates into thin air.", buf);
                      message(buf2, white, false);
                  }
                  return;
              }
          }
          break;
      case STATUS_POISONED:
          if (monst.status[i]) {
              monst.status[i]--;
              if (await inflictDamage(NULL, monst, monst.poisonAmount, green, true)) {
                  if (canSeeMonster(monst)) {
                      monsterName(buf, monst, true);
                      sprintf(buf2, "%s dies of poison.", buf);
                      message(buf2, messageColorFromVictim(monst), false);
                  }
                  return;
              }
              if (!monst.status[i]) {
                  monst.poisonAmount = 0;
              }
          }
          break;
      case STATUS_STUCK:
          if (monst.status[i] && !cellHasTerrainFlag(monst.xLoc, monst.yLoc, T_ENTANGLES)) {
              monst.status[i] = 0;
          }
          break;
      case STATUS_DISCORDANT:
          if (monst.status[i] && !--monst.status[i]) {
              if (monst.creatureState == MONSTER_FLEEING
                  && !monst.status[STATUS_MAGICAL_FEAR]
                  && monst.leader === player)
              {
                  monst.creatureState = MONSTER_ALLY;
                  if (monst.carriedItem) {
                      await makeMonsterDropItem(monst);
                  }
              }
          }
          break;
      case STATUS_MAGICAL_FEAR:
          if (monst.status[i]) {
              if (!--monst.status[i]) {
                  monst.creatureState = (monst.leader === player ? MONSTER_ALLY : MONSTER_TRACKING_SCENT);
              }
          }
          break;
      case STATUS_SHIELDED:
          monst.status[i] -= Math.floor(monst.maxStatus[i] / 20);
          if (monst.status[i] <= 0) {
              monst.status[i] = monst.maxStatus[i] = 0;
          }
          break;
      case STATUS_IMMUNE_TO_FIRE:
          if (monst.status[i] && !(monst.info.flags & MONST_IMMUNE_TO_FIRE)) {
              monst.status[i]--;
          }
          break;
      case STATUS_INVISIBLE:
          if (monst.status[i]
              && !(monst.info.flags & MONST_INVISIBLE)
              && !--monst.status[i]
              && playerCanSee(monst.xLoc, monst.yLoc))
          {
              refreshDungeonCell(monst.xLoc, monst.yLoc);
          }
          break;
      default:
          if (monst.status[i]) {
              monst.status[i]--;
          }
          break;
		}
	}

	if (monsterCanSubmergeNow(monst) && !(monst.bookkeepingFlags & MB_SUBMERGED)) {
		if (rand_percent(20)) {
			monst.bookkeepingFlags |= MB_SUBMERGED;
			if (!monst.status[STATUS_MAGICAL_FEAR]
        && monst.creatureState == MONSTER_FLEEING
				&& (!(monst.info.flags & MONST_FLEES_NEAR_DEATH) || monst.currentHP >= Math.floor(monst.info.maxHP * 3 / 4)))
      {
				monst.creatureState = MONSTER_TRACKING_SCENT;
			}
			refreshDungeonCell(monst.xLoc, monst.yLoc);
		} else if (monst.info.flags & (MONST_RESTRICTED_TO_LIQUID)
				   && monst.creatureState != MONSTER_ALLY)
    {
			monst.creatureState = MONSTER_FLEEING;
		}
	}
}


function traversiblePathBetween( /* creature */ monst, x2, y2) {
	const coords = ARRAY(DCOLS + DROWS, () => [-1, -1] );
  let i, x, y, n;
	let originLoc = [monst.xLoc, monst.yLoc];
	let targetLoc = [x2, y2];

	n = getLineCoordinates(coords, originLoc, targetLoc);

	for (i=0; i<n; i++) {
		x = coords[i][0];
		y = coords[i][1];
		if (x == x2 && y == y2) {
			return true;
		}
		if (monsterAvoids(monst, x, y)) {
			return false;
		}
	}
  brogueAssert(false);
	return true; // should never get here
}

// boolean specifiedPathBetween(short x1, short y1, short x2, short y2,
// 							 unsigned long blockingTerrain, unsigned long blockingFlags) {
// 	short coords[DCOLS][2], i, x, y, n;
// 	short originLoc[2] = {x1, y1};
// 	short targetLoc[2] = {x2, y2};
// 	n = getLineCoordinates(coords, originLoc, targetLoc);
//
// 	for (i=0; i<n; i++) {
// 		x = coords[i][0];
// 		y = coords[i][1];
// 		if (cellHasTerrainFlag(x, y, blockingTerrain) || (pmap[x][y].flags & blockingFlags)) {
// 			return false;
// 		}
// 		if (x == x2 && y == y2) {
// 			return true;
// 		}
// 	}
//     brogueAssert(false);
// 	return true; // should never get here
// }

function openPathBetween(x1, y1, x2, y2) {
	let returnLoc = [], startLoc = [x1, y1], targetLoc = [x2, y2];

	getImpactLoc(returnLoc, startLoc, targetLoc, DCOLS, false);
	if (returnLoc[0] == targetLoc[0] && returnLoc[1] == targetLoc[1]) {
		return true;
	}
	return false;
}

// will return the player if the player is at (x, y).
function monsterAtLoc(x, y) { // creature *
	let monst; // creature *
	if (!(pmap[x][y].flags & (HAS_MONSTER | HAS_PLAYER))) {
		return NULL;
	}
	if (player.xLoc == x && player.yLoc == y) {
		return player;
	}
	for (monst = monsters.nextCreature; monst != NULL && (monst.xLoc != x || monst.yLoc != y); monst = monst.nextCreature);
	return monst;
}

function dormantMonsterAtLoc(x, y) {  // creature *
	let monst; // creature *
	if (!(pmap[x][y].flags & HAS_DORMANT_MONSTER)) {
		return NULL;
	}
	for (monst = dormantMonsters.nextCreature; monst != NULL && (monst.xLoc != x || monst.yLoc != y); monst = monst.nextCreature);
	return monst;
}

function monsterHasBoltEffect( /* creature */ monst, boltEffectIndex) {
    let i;
    for (i=0; monst.info.bolts[i] != 0; i++) {
        if (boltCatalog[monst.info.bolts[i]].boltEffect == boltEffectIndex) {
            return monst.info.bolts[i];
        }
    }
    return BOLT_NONE;
}

async function pathTowardCreature( /* creature */ monst, /* creature */ target) {
	const targetLoc = [-1, -1];
  let dir;

	if (traversiblePathBetween(monst, target.xLoc, target.yLoc)) {
        if (distanceBetween(monst.xLoc, monst.yLoc, target.xLoc, target.yLoc) <= 2) {
            monst.bookkeepingFlags &= ~MB_GIVEN_UP_ON_SCENT;
        }
		targetLoc[0] = target.xLoc;
		targetLoc[1] = target.yLoc;
		await moveMonsterPassivelyTowards(monst, targetLoc, (monst.creatureState != MONSTER_ALLY));
		return;
	}

	// is the target missing his map altogether?
	if (!target.mapToMe) {
		target.mapToMe = allocGrid();
		fillGrid(target.mapToMe, 0);
		calculateDistances(target.mapToMe, target.xLoc, target.yLoc, 0, monst, true, false);
	}

	// is the target map out of date?
	if (target.mapToMe[target.xLoc][target.yLoc] > 3) {
		// it is. recalculate the map.
		calculateDistances(target.mapToMe, target.xLoc, target.yLoc, 0, monst, true, false);
	}

	// blink to the target?
	if (distanceBetween(monst.xLoc, monst.yLoc, target.xLoc, target.yLoc) > 10
        || monstersAreEnemies(monst, target))
  {
        if (await monsterBlinkToPreferenceMap(monst, target.mapToMe, false)) { // if it blinked
            monst.ticksUntilTurn = monst.attackSpeed * (monst.info.flags & MONST_CAST_SPELLS_SLOWLY ? 2 : 1);
            return;
        }
    }

	// follow the map.
	dir = nextStep(target.mapToMe, monst.xLoc, monst.yLoc, monst, true);
  if (dir == NO_DIRECTION) {
    targetLoc[0] = target.xLoc;
		targetLoc[1] = target.yLoc;
		await moveMonsterPassivelyTowards(monst, targetLoc, (monst.creatureState != MONSTER_ALLY));
		return;
  }
  targetLoc[0] = monst.xLoc + nbDirs[dir][0];
	targetLoc[1] = monst.yLoc + nbDirs[dir][1];

	if (!await moveMonsterPassivelyTowards(monst, targetLoc, (monst.creatureState != MONSTER_ALLY))) {
		// monster is blocking the way
		dir = randValidDirectionFrom(monst, monst.xLoc, monst.yLoc, true);
		if (dir != -1) {
			targetLoc[0] = monst.xLoc + nbDirs[dir][0];
			targetLoc[1] = monst.yLoc + nbDirs[dir][1];
			await moveMonsterPassivelyTowards(monst, targetLoc, (monst.creatureState != MONSTER_ALLY));
		}
	}
}

function creatureEligibleForSwarming(/* creature */ monst) {
    if ((monst.info.flags & (MONST_IMMOBILE | MONST_GETS_TURN_ON_ACTIVATION | MONST_MAINTAINS_DISTANCE))
        || monst.status[STATUS_ENTRANCED]
        || monst.status[STATUS_CONFUSED]
        || monst.status[STATUS_STUCK]
        || monst.status[STATUS_PARALYZED]
        || monst.status[STATUS_MAGICAL_FEAR]
        || monst.status[STATUS_LIFESPAN_REMAINING] == 1
        || (monst.bookkeepingFlags & (MB_SEIZED | MB_SEIZING)))
    {
        return false;
    }
    if (monst !== player
        && monst.creatureState != MONSTER_ALLY
        && monst.creatureState != MONSTER_TRACKING_SCENT)
    {
        return false;
    }
    return true;
}

// Swarming behavior.
// If you’re adjacent to an enemy and about to strike it, and you’re adjacent to a hunting-mode tribemate
// who is not adjacent to another enemy, and there is no empty space adjacent to the tribemate AND the enemy,
// and there is an empty space adjacent to you AND the enemy, then move into that last space.
// (In each case, "adjacent" excludes diagonal tiles obstructed by corner walls.)
function monsterSwarmDirection( /* creature */ monst, /* creature */ enemy) {
    let newX, newY, i;
    let dir, targetDir;
    const dirList = [0, 1, 2, 3, 4, 5, 6, 7];
    let alternateDirectionExists;
    let ally, otherEnemy;   // creature *

    if (monst === player || !creatureEligibleForSwarming(monst)) {
        return NO_DIRECTION;
    }

    if (distanceBetween(monst.xLoc, monst.yLoc, enemy.xLoc, enemy.yLoc) != 1
        || (diagonalBlocked(monst.xLoc, monst.yLoc, enemy.xLoc, enemy.yLoc, false) || (enemy.info.flags & MONST_ATTACKABLE_THRU_WALLS))
        || !monstersAreEnemies(monst, enemy))
    {
        return NO_DIRECTION; // Too far from the enemy, diagonally blocked, or not enemies with it.
    }

    // Find a location that is adjacent to you and to the enemy.
    targetDir = NO_DIRECTION;
    shuffleList(dirList, 0, 4);
    shuffleList(dirList, 4, 8);
    for (i=0; i<8 && targetDir == NO_DIRECTION; i++) {
        dir = dirList[i];
        newX = monst.xLoc + nbDirs[dir][0];
        newY = monst.yLoc + nbDirs[dir][1];
        if (coordinatesAreInMap(newX, newY)
            && distanceBetween(enemy.xLoc, enemy.yLoc, newX, newY) == 1
            && !(pmap[newX][newY].flags & (HAS_PLAYER | HAS_MONSTER))
            && !diagonalBlocked(monst.xLoc, monst.yLoc, newX, newY, false)
            && (!diagonalBlocked(enemy.xLoc, enemy.yLoc, newX, newY, false) || (enemy.info.flags & MONST_ATTACKABLE_THRU_WALLS))
            && !monsterAvoids(monst, newX, newY))
        {
            targetDir = dir;
        }
    }
    if (targetDir == NO_DIRECTION) {
        return NO_DIRECTION; // No open location next to both you and the enemy.
    }

    // OK, now we have a place to move toward. Let's analyze the teammates around us to make sure that
    // one of them could take advantage of the space we open.
    // CYCLE_MONSTERS_AND_PLAYERS( (ally) => {
    for (ally = player; ally != NULL; ally = (ally === player ? monsters.nextCreature : ally.nextCreature)) {

      if (ally !== monst
          && ally !== enemy
          && monstersAreTeammates(monst, ally)
          && monstersAreEnemies(ally, enemy)
          && creatureEligibleForSwarming(ally)
          && distanceBetween(monst.xLoc, monst.yLoc, ally.xLoc, ally.yLoc) == 1
          && !diagonalBlocked(monst.xLoc, monst.yLoc, ally.xLoc, ally.yLoc, false)
          && !monsterAvoids(ally, monst.xLoc, monst.yLoc)
          && (distanceBetween(enemy.xLoc, enemy.yLoc, ally.xLoc, ally.yLoc) > 1 || diagonalBlocked(enemy.xLoc, enemy.yLoc, ally.xLoc, ally.yLoc, false)))
      {
          // Found a prospective ally.
          // Check that there isn't already an open space from which to attack the enemy that is accessible to the ally.
          alternateDirectionExists = false;
          for (dir=0; dir< DIRECTION_COUNT && !alternateDirectionExists; dir++) {
              newX = ally.xLoc + nbDirs[dir][0];
              newY = ally.yLoc + nbDirs[dir][1];
              if (coordinatesAreInMap(newX, newY)
                  && !(pmap[newX][newY].flags & (HAS_PLAYER | HAS_MONSTER))
                  && distanceBetween(enemy.xLoc, enemy.yLoc, newX, newY) == 1
                  && !diagonalBlocked(enemy.xLoc, enemy.yLoc, newX, newY, false)
                  && !diagonalBlocked(ally.xLoc, ally.yLoc, newX, newY, false)
                  && !monsterAvoids(ally, newX, newY))
              {
                  alternateDirectionExists = true;
              }
          }
          if (!alternateDirectionExists) {
              // OK, no alternative open spaces exist.
              // Check that the ally isn't already occupied with an enemy of its own.

              // CYCLE_MONSTERS_AND_PLAYERS( (otherEnemy) => {
              for (otherEnemy = player; otherEnemy != NULL; otherEnemy = (otherEnemy === player ? monsters.nextCreature : otherEnemy.nextCreature)) {
                  if (ally !== otherEnemy
                      && monst !== otherEnemy
                      && enemy !== otherEnemy
                      && monstersAreEnemies(ally, otherEnemy)
                      && distanceBetween(ally.xLoc, ally.yLoc, otherEnemy.xLoc, otherEnemy.yLoc) == 1
                      && (!diagonalBlocked(ally.xLoc, ally.yLoc, otherEnemy.xLoc, otherEnemy.yLoc, false) || (otherEnemy.info.flags & MONST_ATTACKABLE_THRU_WALLS)))
                  {
                      break; // Ally is already occupied.
                  }
              }
              if (otherEnemy == NULL) {
                  // Success!
                  return targetDir;
              }
            }
        }
    }

    return NO_DIRECTION; // Failure!
}

// Isomorphs a number in [0, 39] to coordinates along the square of radius 5 surrounding (0,0).
// This is used as the sample space for bolt target coordinates, e.g. when reflecting or when
// monsters are deciding where to blink.
function perimeterCoords( returnCoords /* short[2] */, n) {
	if (n <= 10) {			// top edge, left to right
		returnCoords[0] = n - 5;
		returnCoords[1] = -5;
	} else if (n <= 21) {	// bottom edge, left to right
		returnCoords[0] = (n - 11) - 5;
		returnCoords[1] = 5;
	} else if (n <= 30) {	// left edge, top to bottom
		returnCoords[0] = -5;
		returnCoords[1] = (n - 22) - 4;
	} else if (n <= 39) {	// right edge, top to bottom
		returnCoords[0] = 5;
		returnCoords[1] = (n - 31) - 4;
	} else {
		ERROR("ERROR! Bad perimeter coordinate request!", true);
		returnCoords[0] = returnCoords[1] = 0; // garbage in, garbage out
	}
}

// Tries to make the monster blink to the most desirable square it can aim at, according to the
// preferenceMap argument. "blinkUphill" determines whether it's aiming for higher or lower numbers on
// the preference map -- true means higher. Returns true if the monster blinked; false if it didn't.
async function monsterBlinkToPreferenceMap(/* creature */ monst, /* short **/ preferenceMap, blinkUphill) {
	let i, bestPreference, nowPreference, maxDistance;
  const bestTarget = [-1, -1], target = [-1, -1], impact = [-1, -1], origin = [-1, -1];
	let gotOne;
	const monstName = STRING(); // char[DCOLS];
	const buf = STRING(); // char[DCOLS];
  let theBoltType;  // enum boltType
  let theBolt = bolt();

  theBoltType = monsterHasBoltEffect(monst, BE_BLINKING);
  if (!theBoltType) {
      return false;
  }

	maxDistance = fp_staffBlinkDistance(5 << FP_BASE);
	gotOne = false;

	origin[0] = monst.xLoc;
	origin[1] = monst.yLoc;

	bestTarget[0]	= 0;
	bestTarget[1]	= 0;
	bestPreference	= preferenceMap[monst.xLoc][monst.yLoc];

	// make sure that we beat the four cardinal neighbors
	for (i = 0; i < 4; i++) {
		nowPreference = preferenceMap[monst.xLoc + nbDirs[i][0]][monst.yLoc + nbDirs[i][1]];

		if (((blinkUphill && nowPreference > bestPreference) || (!blinkUphill && nowPreference < bestPreference))
			&& !monsterAvoids(monst, monst.xLoc + nbDirs[i][0], monst.yLoc + nbDirs[i][1]))
    {
			bestPreference = nowPreference;
		}
	}

	for (i=0; i<40; i++) {
		perimeterCoords(target, i);
		target[0] += monst.xLoc;
		target[1] += monst.yLoc;

		getImpactLoc(impact, origin, target, maxDistance, true);
		nowPreference = preferenceMap[impact[0]][impact[1]];

		if (((blinkUphill && (nowPreference > bestPreference))
         || (!blinkUphill && (nowPreference < bestPreference)))
			&& !monsterAvoids(monst, impact[0], impact[1]))
    {
			bestTarget[0]	= target[0];
			bestTarget[1]	= target[1];
			bestPreference	= nowPreference;

			if ((abs(impact[0] - origin[0]) > 1 || abs(impact[1] - origin[1]) > 1)
                || (cellHasTerrainFlag(impact[0], origin[1], T_OBSTRUCTS_PASSABILITY))
                || (cellHasTerrainFlag(origin[0], impact[1], T_OBSTRUCTS_PASSABILITY)))
      {
				gotOne = true;
			} else {
				gotOne = false;
			}
		}
	}

	if (gotOne) {
		if (canDirectlySeeMonster(monst)) {
			monsterName(monstName, monst, true);
			sprintf(buf, "%s blinks", monstName);
			combatMessage(buf, 0);
		}
		monst.ticksUntilTurn = monst.attackSpeed * (monst.info.flags & MONST_CAST_SPELLS_SLOWLY ? 2 : 1);
    theBolt.copy(boltCatalog[theBoltType]);
		await zap(origin, bestTarget, theBolt, false);
		return true;
	}
	return false;
}

function fleeingMonsterAwareOfPlayer(/* creature */ monst) {
    if (player.status[STATUS_INVISIBLE]) {
        return (distanceBetween(monst.xLoc, monst.yLoc, player.xLoc, player.yLoc) <= 1);
    } else {
        return (pmap[monst.xLoc][monst.yLoc].flags & IN_FIELD_OF_VIEW) ? true : false;
    }
}

// returns whether the monster did something (and therefore ended its turn)
async function monsterBlinkToSafety(/* creature */ monst) {
	let blinkSafetyMap;    // short **

	if (monst.creatureState == MONSTER_ALLY) {
		if (!rogue.updatedAllySafetyMapThisTurn) {
			updateAllySafetyMap();
		}
		blinkSafetyMap = allySafetyMap;
	} else if (fleeingMonsterAwareOfPlayer(monst)) {
		if (monst.safetyMap) {
			freeGrid(monst.safetyMap);
			monst.safetyMap = NULL;
		}
		if (!rogue.updatedSafetyMapThisTurn) {
			updateSafetyMap();
		}
		blinkSafetyMap = safetyMap;
	} else {
		if (!monst.safetyMap) {
			if (!rogue.updatedSafetyMapThisTurn) {
				updateSafetyMap();
			}
			monst.safetyMap = allocGrid();
			copyGrid(monst.safetyMap, safetyMap);
		}
		blinkSafetyMap = monst.safetyMap;
	}

	return await monsterBlinkToPreferenceMap(monst, blinkSafetyMap, false);
}

// returns whether or not the monster did something.
async function monsterSummons(/* creature */ monst, alwaysUse) {
	let target;    // creature *
	let minionCount = 0;

  if (monst.info.abilityFlags & (MA_CAST_SUMMON)) {
        // Count existing minions.
		for (target = monsters.nextCreature; target != NULL; target = target.nextCreature) {
      if (monst.creatureState == MONSTER_ALLY) {
          if (target.creatureState == MONSTER_ALLY) {
              minionCount++; // Allied summoners count all allies.
          }
			} else if ((target.bookkeepingFlags & MB_FOLLOWER) && target.leader == monst) {
				minionCount++; // Enemy summoners count only direct followers, not teammates.
			}
		}
    if (monst.creatureState == MONSTER_ALLY) { // Allied summoners also count monsters on the previous and next depths.
        if (rogue.depthLevel > 1) {
            for (target = levels[rogue.depthLevel - 2].monsters; target != NULL; target = target.nextCreature) {
                if (target.creatureState == MONSTER_ALLY && !(target.info.flags & MONST_WILL_NOT_USE_STAIRS)) {
                    minionCount++;
                }
            }
        }
        if (rogue.depthLevel < DEEPEST_LEVEL) {
            for (target = levels[rogue.depthLevel].monsters; target != NULL; target = target.nextCreature) {
                if (target.creatureState == MONSTER_ALLY && !(target.info.flags & MONST_WILL_NOT_USE_STAIRS)) {
                    minionCount++;
                }
            }
        }
    }
    if (alwaysUse && minionCount < 50) {
			await summonMinions(monst);
			return true;
    } else if (monst.info.abilityFlags & MA_ENTER_SUMMONS) {
        if (!rand_range(0, 7)) {
            await summonMinions(monst);
            return true;
        }
    } else if ((monst.creatureState != MONSTER_ALLY || minionCount < 5)
               && !rand_range(0, minionCount * minionCount * 3 + 1))
    {
			await summonMinions(monst);
			return true;
		}
	}
  return false;
}

// Some monsters never make good targets irrespective of what bolt we're contemplating.
// Return false for those. Otherwise, return true.
function generallyValidBoltTarget(/* creature */ caster, /* creature */ target) {
    if (caster === target) {
        // Can't target yourself; that's the fundamental theorem of Brogue bolts.
        return false;
    }
    if (monsterIsHidden(target, caster)
        || (target.bookkeepingFlags & MB_SUBMERGED))
    {
        // No bolt will affect a submerged creature. Can't shoot at invisible creatures unless it's in gas.
        return false;
    }
    return openPathBetween(caster.xLoc, caster.yLoc, target.xLoc, target.yLoc);
}

function targetEligibleForCombatBuff(/* creature */ caster, /* creature */ target) {
    let enemy;    // creature *

    if (caster.creatureState == MONSTER_ALLY) {
        if (canDirectlySeeMonster(caster)) {
            // CYCLE_MONSTERS_AND_PLAYERS(enemy) {
            for (enemy = player; enemy != NULL; enemy = (enemy === player ? monsters.nextCreature : enemy.nextCreature)) {
                if (monstersAreEnemies(player, enemy)
                    && canSeeMonster(enemy)
                    && (pmap[enemy.xLoc][enemy.yLoc].flags & IN_FIELD_OF_VIEW))
                {
                    return true;
                }
            }
        }
        return false;
    } else {
        return (target.creatureState == MONSTER_TRACKING_SCENT);
    }
}

// Make a decision as to whether the given caster should fire the given bolt at the given target.
// Assumes that the conditions in generallyValidBoltTarget have already been satisfied.
function specificallyValidBoltTarget(/* creature */ caster, /* creature */ target, theBoltType) {

    if ((boltCatalog[theBoltType].flags & BF_TARGET_ALLIES)
        && (!monstersAreTeammates(caster, target) || monstersAreEnemies(caster, target)))
    {
        return false;
    }
    if ((boltCatalog[theBoltType].flags & BF_TARGET_ENEMIES)
        && (!monstersAreEnemies(caster, target)))
    {
        return false;
    }
    if ((boltCatalog[theBoltType].flags & BF_TARGET_ENEMIES)
        && (target.info.flags & MONST_INVULNERABLE))
    {
        return false;
    }
    if ((target.info.flags & MONST_REFLECT_4)
        && target.creatureState != MONSTER_ALLY
        && !(boltCatalog[theBoltType].flags & (BF_NEVER_REFLECTS | BF_HALTS_BEFORE_OBSTRUCTION))) {
        // Don't fire a reflectable bolt at a reflective target unless it's your ally.
        return false;
    }
    if (boltCatalog[theBoltType].forbiddenMonsterFlags & target.info.flags) {
        // Don't fire a bolt at a creature type that it won't affect.
        return false;
    }
    if ((boltCatalog[theBoltType].flags & BF_FIERY)
        && target.status[STATUS_IMMUNE_TO_FIRE])
    {
        // Don't shoot fireballs at fire-immune creatures.
        return false;
    }
    if ((boltCatalog[theBoltType].flags & BF_FIERY)
        && burnedTerrainFlagsAtLoc(caster.xLoc, caster.yLoc) & avoidedFlagsForMonster((caster.info)))
    {
        // Don't shoot fireballs if you're standing on a tile that could combust into something that harms you.
        return false;
    }

    // Rules specific to bolt effects:
    switch (boltCatalog[theBoltType].boltEffect) {
        case BE_BECKONING:
            if (distanceBetween(caster.xLoc, caster.yLoc, target.xLoc, target.yLoc) <= 1) {
                return false;
            }
            break;
        case BE_ATTACK:
            if (cellHasTerrainFlag(target.xLoc, target.yLoc, T_OBSTRUCTS_PASSABILITY)
                && !(target.info.flags & MONST_ATTACKABLE_THRU_WALLS))
            {
                // Don't shoot an arrow at an embedded creature.
                return false;
            }
            // continue to BE_DAMAGE below
        case BE_DAMAGE:
            if (target.status[STATUS_ENTRANCED]
                && monstersAreEnemies(caster, target))
            {
                // Don't break your enemies' entrancement.
                return false;
            }
            break;
        case BE_NONE:
            // BE_NONE bolts are always going to be all about the terrain effects,
            // so our logic has to follow from the terrain parameters of the bolt's target DF.
            if (boltCatalog[theBoltType].targetDF) {
                const terrainFlags = tileCatalog[dungeonFeatureCatalog[boltCatalog[theBoltType].targetDF].tile].flags;
                if ((terrainFlags & T_ENTANGLES)
                    && target.status[STATUS_STUCK])
                {
                    // Don't try to entangle a creature that is already entangled.
                    return false;
                }
                if ((boltCatalog[theBoltType].flags & BF_TARGET_ENEMIES)
                    && !(terrainFlags & avoidedFlagsForMonster((target.info)))
                    && (!(terrainFlags & T_ENTANGLES) || (target.info.flags & MONST_IMMUNE_TO_WEBS)))
                {
                    return false;
                }
            }
            break;
        case BE_DISCORD:
            if (target.status[STATUS_DISCORDANT]
                || target === player)
            {
                // Don't cast discord if the target is already discordant, or if it is the player.
                // (Players should never be intentionally targeted by discord. It's just a fact of monster psychology.)
                return false;
            }
            break;
        case BE_NEGATION:
            if (monstersAreEnemies(caster, target)) {
                if (target.status[STATUS_HASTED] || target.status[STATUS_TELEPATHIC] || target.status[STATUS_SHIELDED]) {
                    // Dispel haste, telepathy, protection.
                    return true;
                }
                if (target.info.flags & (MONST_DIES_IF_NEGATED | MONST_IMMUNE_TO_WEAPONS)) {
                    // Dispel magic creatures; strip weapon invulnerability from revenants.
                    return true;
                }
                if ((target.status[STATUS_IMMUNE_TO_FIRE] || target.status[STATUS_LEVITATING])
                    && cellHasTerrainFlag(target.xLoc, target.yLoc, (T_LAVA_INSTA_DEATH | T_IS_DEEP_WATER | T_AUTO_DESCENT))) {
                    // Drop the target into lava or a chasm if opportunity knocks.
                    return true;
                }
                if (monstersAreTeammates(caster, target)
                    && target.status[STATUS_DISCORDANT]
                    && !(target.info.flags & MONST_DIES_IF_NEGATED))
                {
                    // Dispel discord from allies unless it would destroy them.
                    return true;
                }
            } else if (monstersAreTeammates(caster, target)) {
                if (target === player && rogue.armor && (rogue.armor.flags & ITEM_RUNIC) && (rogue.armor.flags & ITEM_RUNIC_IDENTIFIED)
                    && rogue.armor.enchant2 == A_REFLECTION && fp_netEnchant(rogue.armor) > 0)
                {
                    // Allies shouldn't cast negation on the player if she's knowingly wearing armor of reflection.
                    // Too much risk of negating themselves in the process.
                    return false;
                }
                if (target.info.flags & MONST_DIES_IF_NEGATED) {
                    // Never cast negation if it would destroy an allied creature.
                    return false;
                }
                if (target.status[STATUS_ENTRANCED]
                    && caster.creatureState != MONSTER_ALLY)
                {
                    // Non-allied monsters will dispel entrancement on their own kind.
                    return true;
                }
                if (target.status[STATUS_MAGICAL_FEAR]) {
                    // Dispel magical fear.
                    return true;
                }
            }
            return false; // Don't cast negation unless there's a good reason.
            break;
        case BE_SLOW:
            if (target.status[STATUS_SLOWED]) {
                return false;
            }
            break;
        case BE_HASTE:
            if (target.status[STATUS_HASTED]) {
                return false;
            }
            if (!targetEligibleForCombatBuff(caster, target)) {
                return false;
            }
            break;
        case BE_SHIELDING:
            if (target.status[STATUS_SHIELDED]) {
                return false;
            }
            if (!targetEligibleForCombatBuff(caster, target)) {
                return false;
            }
            break;
        case BE_HEALING:
            if (target.currentHP >= target.info.maxHP) {
                // Don't heal a creature already at full health.
                return false;
            }
            break;
        case BE_TUNNELING:
        case BE_OBSTRUCTION:
            // Monsters will never cast these.
            return false;
            break;
        default:
            break;
    }
    return true;
}

async function monsterCastSpell(/* creature */ caster, /* creature */ target,  boltIndex) {
    const theBolt = bolt();
    const originLoc = [-1, -1], targetLoc = [-1, -1];
    const buf = STRING(), monstName = STRING();

    if (canDirectlySeeMonster(caster)) {
        monsterName(monstName, caster, true);
        sprintf(buf, "%s %s", monstName, boltCatalog[boltIndex].description);
        resolvePronounEscapes(buf, caster);
        combatMessage(buf, 0);
    }

    theBolt.copy(boltCatalog[boltIndex]);
    originLoc[0] = caster.xLoc;
    originLoc[1] = caster.yLoc;
    targetLoc[0] = target.xLoc;
    targetLoc[1] = target.yLoc;
    await zap(originLoc, targetLoc, theBolt, false);

    if (player.currentHP <= 0) {
        await gameOver(monsterCatalog[caster.info.monsterID].monsterName, false);
    }
}

// returns whether the monster cast a bolt.
async function monstUseBolt(/* creature */ monst) {
  let target;   // creature *
  let i;

  if (!monst.info.bolts[0]) {
      return false; // Don't waste time with monsters that can't cast anything.
  }

  // CYCLE_MONSTERS_AND_PLAYERS(target) {
  for (target = player; target != NULL; target = (target === player ? monsters.nextCreature : target.nextCreature)) {
      if (generallyValidBoltTarget(monst, target)) {
          for (i = 0; monst.info.bolts[i]; i++) {
              if (boltCatalog[monst.info.bolts[i]].boltEffect == BE_BLINKING) {
                  continue; // Blinking is handled elsewhere.
              }
              if (specificallyValidBoltTarget(monst, target, monst.info.bolts[i])) {
                  if ((monst.info.flags & MONST_ALWAYS_USE_ABILITY)
                      || rand_percent(30))
                  {
                      await monsterCastSpell(monst, target, monst.info.bolts[i]);
                      return true;
                  }
              }
          }
      }
  }
  return false;
}

// returns whether the monster did something (and therefore ended its turn)
async function monstUseMagic(/* creature */ monst) {
    if (await monsterSummons(monst, (monst.info.flags & MONST_ALWAYS_USE_ABILITY))) {
        return true;
    } else if (await monstUseBolt(monst)) {
        return true;
    }
    return false;
}

function isLocalScentMaximum(x, y) {
    let dir;
    let newX, newY;

    const baselineScent = scentMap[x][y];

    for (dir=0; dir< DIRECTION_COUNT; dir++) {
        newX = x + nbDirs[dir][0];
        newY = y + nbDirs[dir][1];
        if (coordinatesAreInMap(newX, newY)
            && (scentMap[newX][newY] > baselineScent)
            && !cellHasTerrainFlag(newX, newY, T_OBSTRUCTS_PASSABILITY)
            && !diagonalBlocked(x, y, newX, newY, false))
        {
            return false;
        }
    }
    return true;
}

// Returns the direction the player's scent points to from a given cell. Returns -1 if the nose comes up blank.
function scentDirection(/* creature */ monst) {
	let newX, newY, x, y, newestX, newestY;
  let bestDirection = NO_DIRECTION, dir, dir2;
	let bestNearbyScent = 0;
	let canTryAgain = true;
	let otherMonst;  // creature *

	x = monst.xLoc;
	y = monst.yLoc;

	for (;;) {

		for (dir=0; dir< DIRECTION_COUNT; dir++) {
			newX = x + nbDirs[dir][0];
			newY = y + nbDirs[dir][1];
			otherMonst = monsterAtLoc(newX, newY);
			if (coordinatesAreInMap(newX, newY)
				&& (scentMap[newX][newY] > bestNearbyScent)
				&& (!(pmap[newX][newY].flags & HAS_MONSTER) || (otherMonst && canPass(monst, otherMonst)))
				&& !cellHasTerrainFlag(newX, newY, T_OBSTRUCTS_PASSABILITY)
				&& !diagonalBlocked(x, y, newX, newY, false)
				&& !monsterAvoids(monst, newX, newY))
      {
				bestNearbyScent = scentMap[newX][newY];
				bestDirection = dir;
			}
		}

		if (bestDirection >= 0 && bestNearbyScent > scentMap[x][y]) {
			return bestDirection;
		}

		if (canTryAgain) {
			// Okay, the monster may be stuck in some irritating diagonal.
			// If so, we can diffuse the scent into the offending kink and solve the problem.
			// There's a possibility he's stuck for some other reason, though, so we'll only
			// try once per his move -- hence the failsafe.
			canTryAgain = false;
			for (dir=0; dir<4; dir++) {
				newX = x + nbDirs[dir][0];
				newY = y + nbDirs[dir][1];
				for (dir2=0; dir2<4; dir2++) {
					newestX = newX + nbDirs[dir2][0];
					newestY = newY + nbDirs[dir2][1];
					if (coordinatesAreInMap(newX, newY) && coordinatesAreInMap(newestX, newestY)) {
						scentMap[newX][newY] = max(scentMap[newX][newY], scentMap[newestX][newestY] - 1);
					}
				}
			}
		} else {
			return NO_DIRECTION; // failure!
		}
	}
}

// returns true if the resurrection was successful.
function resurrectAlly( x, y) {
    let success;
    let monst;  // creature *
    monst = purgatory.nextCreature;
    if (monst) {
        // Remove from purgatory and insert into the mortal plane.
        purgatory.nextCreature = purgatory.nextCreature.nextCreature;
        monst.nextCreature = monsters.nextCreature;
        monsters.nextCreature = monst;
        const loc = getQualifyingPathLocNear(x, y, true,
                                 (T_PATHING_BLOCKER | T_HARMFUL_TERRAIN), 0,
                                 0, (HAS_PLAYER | HAS_MONSTER), false);
        monst.xLoc = loc[0];
        monst.yLoc = loc[1];
        pmap[monst.xLoc][monst.yLoc].flags |= HAS_MONSTER;

        // Restore health etc.
        monst.bookkeepingFlags &= ~(MB_IS_DYING | MB_IS_FALLING);
        if (!(monst.info.flags & MONST_FIERY)
             && monst.status[STATUS_BURNING])
        {
             monst.status[STATUS_BURNING] = 0;
        }
        monst.status[STATUS_DISCORDANT] = 0;
        heal(monst, 100, true);

        success = true;
    } else {
        success = false;
    }
    return success;
}

function unAlly( /* creature */ monst) {
	if (monst.creatureState == MONSTER_ALLY) {
		monst.creatureState = MONSTER_TRACKING_SCENT;
		monst.bookkeepingFlags &= ~(MB_FOLLOWER | MB_TELEPATHICALLY_REVEALED);
		monst.leader = NULL;
	}
}

function monsterFleesFrom( /* creature */ monst, /* creature */ defender) {
    const x = monst.xLoc;
    const y = monst.yLoc;

    if (!monsterWillAttackTarget(defender, monst)) {
        return false;
    }

    if (distanceBetween(x, y, defender.xLoc, defender.yLoc) >= 4) {
        return false;
    }

    if ((defender.info.flags & (MONST_IMMUNE_TO_WEAPONS | MONST_INVULNERABLE))
        && !(defender.info.flags & MONST_IMMOBILE)) {
        // Don't charge if the monster is damage-immune and is NOT immobile;
        // i.e., keep distance from revenants and stone guardians but not mirror totems.
        return true;
    }

    if ((monst.info.flags & MONST_MAINTAINS_DISTANCE)
        || (defender.info.abilityFlags & MA_KAMIKAZE))
    {
        // Don't charge if you maintain distance or if it's a kamikaze monster.
        return true;
    }

    if (monst.info.abilityFlags & MA_POISONS
        && defender.status[STATUS_POISONED] * defender.poisonAmount > defender.currentHP)
    {
        return true;
    }

    return false;
}

function allyFlees( /* creature */ ally, /* creature */ closestEnemy) {
    const x = ally.xLoc;
    const y = ally.yLoc;

    if (!closestEnemy) {
        return false; // No one to flee from.
    }

    if (ally.info.maxHP <= 1 || (ally.status[STATUS_LIFESPAN_REMAINING]) > 0) { // Spectral blades and timed allies should never flee.
        return false;
    }

    if (distanceBetween(x, y, closestEnemy.xLoc, closestEnemy.yLoc) < 10
        && (Math.floor(100 * ally.currentHP / ally.info.maxHP) <= 33)
        && ally.info.turnsBetweenRegen > 0
        && !ally.carriedMonster
        && ((ally.info.flags & MONST_FLEES_NEAR_DEATH) || (Math.floor(100 * ally.currentHP / ally.info.maxHP * 2) < Math.floor(100 * player.currentHP / player.info.maxHP))))
    {
        // Flee if you're within 10 spaces, your HP is under 1/3, you're not a phoenix or lich or vampire in bat form,
        // and you either flee near death or your health fraction is less than half of the player's.
        return true;
    }

    // so do allies that keep their distance or while in the presence of damage-immune or kamikaze enemies
    if (monsterFleesFrom(ally, closestEnemy)) {
        // Flee if you're within 3 spaces and you either flee near death or the closest enemy is a bloat, revenant or guardian.
        return true;
    }

    return false;
}

async function monsterMillAbout(/* creature */ monst, movementChance) {
  let dir;
  const targetLoc = [-1, -1];

  const x = monst.xLoc;
	const y = monst.yLoc;

    if (rand_percent(movementChance)) {
        dir = randValidDirectionFrom(monst, x, y, true);
        if (dir != -1) {
            targetLoc[0] = x + nbDirs[dir][0];
            targetLoc[1] = y + nbDirs[dir][1];
            await moveMonsterPassivelyTowards(monst, targetLoc, false);
        }
    }
}

async function moveAlly(/* creature */ monst) {
	let target, closestMonster = NULL;   // creature *
	let i, j, x, y, dir, shortestDistance, leashLength;
  const targetLoc = [-1, -1];
	let enemyMap, costMap;   // short **
	const buf = STRING(), monstName = STRING();

	x = monst.xLoc;
	y = monst.yLoc;

	targetLoc[0] = targetLoc[1] = 0;

  if (!(monst.leader)) {
		monst.leader = player;
		monst.bookkeepingFlags |= MB_FOLLOWER;
  }

	// If we're standing in harmful terrain and there is a way to escape it, spend this turn escaping it.
	if (cellHasTerrainFlag(x, y, (T_HARMFUL_TERRAIN & ~(T_IS_FIRE | T_CAUSES_DAMAGE | T_CAUSES_PARALYSIS | T_CAUSES_CONFUSION)))
		|| (cellHasTerrainFlag(x, y, T_IS_FIRE) && !monst.status[STATUS_IMMUNE_TO_FIRE])
		|| (cellHasTerrainFlag(x, y, T_CAUSES_DAMAGE | T_CAUSES_PARALYSIS | T_CAUSES_CONFUSION) && !(monst.info.flags & (MONST_INANIMATE | MONST_INVULNERABLE))))
  {
		if (!rogue.updatedMapToSafeTerrainThisTurn) {
			updateSafeTerrainMap();
		}

		if (await monsterBlinkToPreferenceMap(monst, rogue.mapToSafeTerrain, false)) {
			monst.ticksUntilTurn = monst.attackSpeed * (monst.info.flags & MONST_CAST_SPELLS_SLOWLY ? 2 : 1);
			return;
		}

		dir = nextStep(rogue.mapToSafeTerrain, x, y, monst, true);
		if (dir != -1) {
			targetLoc[0] = x + nbDirs[dir][0];
			targetLoc[1] = y + nbDirs[dir][1];
			if (await moveMonsterPassivelyTowards(monst, targetLoc, false)) {
				return;
			}
		}
	}

	// Look around for enemies; shortestDistance will be the distance to the nearest.
	shortestDistance = max(DROWS, DCOLS);
	for (target = monsters.nextCreature; target != NULL; target = target.nextCreature) {
		if (target != monst
			&& (!(target.bookkeepingFlags & MB_SUBMERGED) || (monst.bookkeepingFlags & MB_SUBMERGED))
			&& monsterWillAttackTarget(monst, target)
			&& distanceBetween(x, y, target.xLoc, target.yLoc) < shortestDistance
			&& traversiblePathBetween(monst, target.xLoc, target.yLoc)
			&& (!cellHasTerrainFlag(target.xLoc, target.yLoc, T_OBSTRUCTS_PASSABILITY) || (target.info.flags & MONST_ATTACKABLE_THRU_WALLS))
			&& (!target.status[STATUS_INVISIBLE] || rand_percent(33)))
    {
			shortestDistance = distanceBetween(x, y, target.xLoc, target.yLoc);
			closestMonster = target;
		}
	}

	// Weak allies in the presence of enemies seek safety;
	if (allyFlees(monst, closestMonster)) {
		if (monsterHasBoltEffect(monst, BE_BLINKING)
			&& ((monst.info.flags & MONST_ALWAYS_USE_ABILITY) || rand_percent(30))
			&& await monsterBlinkToSafety(monst))
    {
			return;
		}
    if (await monsterSummons(monst, (monst.info.flags & MONST_ALWAYS_USE_ABILITY))) {
        return;
    }
		if (!rogue.updatedAllySafetyMapThisTurn) {
			updateAllySafetyMap();
		}
		dir = nextStep(allySafetyMap, monst.xLoc, monst.yLoc, monst, true);
		if (dir != -1) {
			targetLoc[0] = x + nbDirs[dir][0];
			targetLoc[1] = y + nbDirs[dir][1];
		}
		if (dir == -1
			|| (allySafetyMap[targetLoc[0]][targetLoc[1]] >= allySafetyMap[x][y])
			|| (!await moveMonster(monst, nbDirs[dir][0], nbDirs[dir][1]) && !await moveMonsterPassivelyTowards(monst, targetLoc, true))) {
			// ally can't flee; continue below
		} else {
			return;
		}
	}

	// Magic users sometimes cast spells.
  if (await monstUseMagic(monst)) { // if he actually cast a spell
      monst.ticksUntilTurn = monst.attackSpeed * (monst.info.flags & MONST_CAST_SPELLS_SLOWLY ? 2 : 1);
      return;
  }

  if (monst.bookkeepingFlags & MB_SEIZED) {
       leashLength = max(DCOLS, DROWS); // Ally will never be prevented from attacking while seized.
   } else if (rogue.justRested || rogue.justSearched) {
       leashLength = 10;
   } else {
       leashLength = 4;
   }

   if (shortestDistance == 1) {
       if (closestMonster.movementSpeed < monst.movementSpeed
           && !(closestMonster.info.flags & (MONST_FLITS | MONST_IMMOBILE))
           && closestMonster.creatureState == MONSTER_TRACKING_SCENT)
       {
           // Never try to flee from combat with a faster enemy.
           leashLength = max(DCOLS, DROWS);
       } else {
           leashLength++; // If the ally is adjacent to a monster at the end of its leash, it shouldn't be prevented from attacking.
       }
   }

	if (closestMonster
		&& (distanceBetween(x, y, player.xLoc, player.yLoc) < leashLength || (monst.bookkeepingFlags & MB_DOES_NOT_TRACK_LEADER))
		&& !(monst.info.flags & MONST_MAINTAINS_DISTANCE)
        && !attackWouldBeFutile(monst, closestMonster))
  {
		// Blink toward an enemy?
		if (monsterHasBoltEffect(monst, BE_BLINKING)
			&& ((monst.info.flags & MONST_ALWAYS_USE_ABILITY) || rand_percent(30))) {

			enemyMap = allocGrid();
			costMap = allocGrid();

			for (i=0; i<DCOLS; i++) {
				for (j=0; j<DROWS; j++) {
					if (cellHasTerrainFlag(i, j, T_OBSTRUCTS_PASSABILITY)) {
						costMap[i][j] = cellHasTerrainFlag(i, j, T_OBSTRUCTS_DIAGONAL_MOVEMENT) ? PDS_OBSTRUCTION : PDS_FORBIDDEN;
						enemyMap[i][j] = 0; // safeguard against OOS
					} else if (monsterAvoids(monst, i, j)) {
						costMap[i][j] = PDS_FORBIDDEN;
						enemyMap[i][j] = 0; // safeguard against OOS
					} else {
						costMap[i][j] = 1;
						enemyMap[i][j] = 10000;
					}
				}
			}

			for (target = monsters.nextCreature; target != NULL; target = target.nextCreature) {
				if (target != monst
					&& (!(target.bookkeepingFlags & MB_SUBMERGED) || (monst.bookkeepingFlags & MB_SUBMERGED))
					&& monsterWillAttackTarget(monst, target)
					&& distanceBetween(x, y, target.xLoc, target.yLoc) < shortestDistance
					&& traversiblePathBetween(monst, target.xLoc, target.yLoc)
					&& (!monsterAvoids(monst, target.xLoc, target.yLoc) || (target.info.flags & MONST_ATTACKABLE_THRU_WALLS))
					&& (!target.status[STATUS_INVISIBLE] || ((monst.info.flags & MONST_ALWAYS_USE_ABILITY) || rand_percent(33))))
        {
					enemyMap[target.xLoc][target.yLoc] = 0;
					costMap[target.xLoc][target.yLoc] = 1;
				}
			}

			dijkstraScan(enemyMap, costMap, true);
			freeGrid(costMap);

			if (await monsterBlinkToPreferenceMap(monst, enemyMap, false)) {
				monst.ticksUntilTurn = monst.attackSpeed * (monst.info.flags & MONST_CAST_SPELLS_SLOWLY ? 2 : 1);
				freeGrid(enemyMap);
				return;
			}
			freeGrid(enemyMap);
		}

		targetLoc[0] = closestMonster.xLoc;
		targetLoc[1] = closestMonster.yLoc;
		await moveMonsterPassivelyTowards(monst, targetLoc, false);
	} else if (monst.targetCorpseLoc[0]
			   && !monst.status[STATUS_POISONED]
			   && (!monst.status[STATUS_BURNING] || monst.status[STATUS_IMMUNE_TO_FIRE])) // Going to start eating a corpse.
  {
		await moveMonsterPassivelyTowards(monst, monst.targetCorpseLoc, false);
		if (monst.xLoc == monst.targetCorpseLoc[0]
			&& monst.yLoc == monst.targetCorpseLoc[1]
			&& !(monst.bookkeepingFlags & MB_ABSORBING))
    {
			if (canSeeMonster(monst)) {
				monsterName(monstName, monst, true);
				sprintf(buf, "%s begins %s the fallen %s.", monstName, monsterText[monst.info.monsterID].absorbing, monst.targetCorpseName);
				message(buf, goodMessageColor, false);
			}
			monst.corpseAbsorptionCounter = 20;
			monst.bookkeepingFlags |= MB_ABSORBING;
		}
	} else if ((monst.bookkeepingFlags & MB_DOES_NOT_TRACK_LEADER)
			   || (distanceBetween(x, y, player.xLoc, player.yLoc) < 3 && (pmap[x][y].flags & IN_FIELD_OF_VIEW)))
  {
		monst.bookkeepingFlags &= ~MB_GIVEN_UP_ON_SCENT;
    await monsterMillAbout(monst, 30);
	} else {
		if (!(monst.bookkeepingFlags & MB_GIVEN_UP_ON_SCENT)
			&& distanceBetween(x, y, player.xLoc, player.yLoc) > 10
			&& await monsterBlinkToPreferenceMap(monst, scentMap, true))
    {
			monst.ticksUntilTurn = monst.attackSpeed * (monst.info.flags & MONST_CAST_SPELLS_SLOWLY ? 2 : 1);
			return;
		}
		dir = scentDirection(monst);
		if (dir == -1 || (monst.bookkeepingFlags & MB_GIVEN_UP_ON_SCENT)) {
			monst.bookkeepingFlags |= MB_GIVEN_UP_ON_SCENT;
			await pathTowardCreature(monst, monst.leader);
		} else {
			targetLoc[0] = x + nbDirs[dir][0];
			targetLoc[1] = y + nbDirs[dir][1];
			await moveMonsterPassivelyTowards(monst, targetLoc, false);
		}
	}
}


// Returns whether to abort the turn.
function updateMonsterCorpseAbsorption(/* creature */ monst) {
  let i;
	const buf = STRING(), buf2 = STRING();

    if (monst.xLoc == monst.targetCorpseLoc[0]
        && monst.yLoc == monst.targetCorpseLoc[1]
        && (monst.bookkeepingFlags & MB_ABSORBING))
    {
        if (--monst.corpseAbsorptionCounter <= 0) {
            monst.targetCorpseLoc[0] = monst.targetCorpseLoc[1] = 0;
            if (monst.absorptionBolt != BOLT_NONE) {
                for (i=0; monst.info.bolts[i] != BOLT_NONE; i++);
                monst.info.bolts[i] = monst.absorptionBolt;
            } else if (monst.absorbBehavior) {
                monst.info.flags |= monst.absorptionFlags;
            } else {
                monst.info.abilityFlags |= monst.absorptionFlags;
            }
            monst.newPowerCount--;
            monst.bookkeepingFlags &= ~MB_ABSORBING;

            if (monst.info.flags & MONST_FIERY) {
                monst.status[STATUS_BURNING] = monst.maxStatus[STATUS_BURNING] = 1000; // won't decrease
            }
            if (monst.info.flags & MONST_FLIES) {
                monst.status[STATUS_LEVITATING] = monst.maxStatus[STATUS_LEVITATING] = 1000; // won't decrease
                monst.info.flags &= ~(MONST_RESTRICTED_TO_LIQUID | MONST_SUBMERGES);
                monst.bookkeepingFlags &= ~(MB_SUBMERGED);
            }
            if (monst.info.flags & MONST_IMMUNE_TO_FIRE) {
                monst.status[STATUS_IMMUNE_TO_FIRE] = monst.maxStatus[STATUS_IMMUNE_TO_FIRE] = 1000; // won't decrease
            }
            if (monst.info.flags & MONST_INVISIBLE) {
                monst.status[STATUS_INVISIBLE] = monst.maxStatus[STATUS_INVISIBLE] = 1000; // won't decrease
            }
            if (canSeeMonster(monst)) {
                monsterName(buf2, monst, true);
                sprintf(buf, "%s finished %s the %s.", buf2, monsterText[monst.info.monsterID].absorbing, monst.targetCorpseName);
                message(buf, goodMessageColor, false);
                if (monst.absorptionBolt != BOLT_NONE) {
                    sprintf(buf, "%s %s!", buf2, boltCatalog[monst.absorptionBolt].abilityDescription);
                } else if (monst.absorbBehavior) {
                    sprintf(buf, "%s now %s!", buf2, monsterBehaviorFlagDescriptions[unflag(monst.absorptionFlags)]);
                } else {
                    sprintf(buf, "%s now %s!", buf2, monsterAbilityFlagDescriptions[unflag(monst.absorptionFlags)]);
                }
                resolvePronounEscapes(buf, monst);
                message(buf, advancementMessageColor, false);
            }
            monst.absorptionFlags = 0;
            monst.absorptionBolt = BOLT_NONE;
        }
        monst.ticksUntilTurn = 100;
        return true;
    } else if (--monst.corpseAbsorptionCounter <= 0) {
        monst.targetCorpseLoc[0] = monst.targetCorpseLoc[1] = 0; // lost its chance
        monst.bookkeepingFlags &= ~MB_ABSORBING;
        monst.absorptionFlags = 0;
        monst.absorptionBolt = BOLT_NONE;
    } else if (monst.bookkeepingFlags & MB_ABSORBING) {
        monst.bookkeepingFlags &= ~MB_ABSORBING; // absorbing but not on the corpse
        if (monst.corpseAbsorptionCounter <= 15) {
            monst.targetCorpseLoc[0] = monst.targetCorpseLoc[1] = 0; // lost its chance
            monst.absorptionFlags = 0;
            monst.absorptionBolt = BOLT_NONE;
        }
    }
    return false;
}

async function monstersTurn(/* creature */ monst) {
	let x, y, dir, shortestDistance;
  const playerLoc = [-1, -1], targetLoc = [-1, -1];
	let alreadyAtBestScent;
	let ally, target, closestMonster;    // creature *

	monst.turnsSpentStationary++;

	if (monst.corpseAbsorptionCounter >= 0 && updateMonsterCorpseAbsorption(monst)) {
        return;
	}

  if (monst.info.DFChance
      && (monst.info.flags & MONST_GETS_TURN_ON_ACTIVATION)
      && rand_percent(monst.info.DFChance))
  {
      await spawnDungeonFeature(monst.xLoc, monst.yLoc, dungeonFeatureCatalog[monst.info.DFType], true, false);
  }

  await applyInstantTileEffectsToCreature(monst); // Paralysis, confusion etc. take effect before the monster can move.

	// if the monster is paralyzed, entranced or chained, this is where its turn ends.
	if (monst.status[STATUS_PARALYZED] || monst.status[STATUS_ENTRANCED] || (monst.bookkeepingFlags & MB_CAPTIVE)) {
		monst.ticksUntilTurn = monst.movementSpeed;
		if ((monst.bookkeepingFlags & MB_CAPTIVE) && monst.carriedItem) {
			await makeMonsterDropItem(monst);
		}
		return;
	}

  if (monst.bookkeepingFlags & MB_IS_DYING) {
      return;
  }

	monst.ticksUntilTurn = Math.floor(monst.movementSpeed / 3); // will be later overwritten by movement or attack

	x = monst.xLoc;
	y = monst.yLoc;

	// Sleepers can awaken, but it takes a whole turn.
	if (monst.creatureState == MONSTER_SLEEPING) {
		monst.ticksUntilTurn = monst.movementSpeed;
		updateMonsterState(monst);
		return;
	}

	// Update creature state if appropriate.
	updateMonsterState(monst);

	if (monst.creatureState == MONSTER_SLEEPING) {
		monst.ticksUntilTurn = monst.movementSpeed;
		return;
	}

	// and move the monster.

	// immobile monsters can only use special abilities:
	if (monst.info.flags & MONST_IMMOBILE) {
    if (await monstUseMagic(monst)) { // if he actually cast a spell
        monst.ticksUntilTurn = monst.attackSpeed * (monst.info.flags & MONST_CAST_SPELLS_SLOWLY ? 2 : 1);
        return;
    }
		monst.ticksUntilTurn = monst.attackSpeed;
		return;
	}

	// discordant monsters
	if (monst.status[STATUS_DISCORDANT] && monst.creatureState != MONSTER_FLEEING) {
		shortestDistance = max(DROWS, DCOLS);
		closestMonster = NULL;
		// CYCLE_MONSTERS_AND_PLAYERS(target) {
    for (target = player; target != NULL; target = (target === player ? monsters.nextCreature : target.nextCreature)) {
			if (target !== monst
				&& (!(target.bookkeepingFlags & MB_SUBMERGED) || (monst.bookkeepingFlags & MB_SUBMERGED))
				&& monsterWillAttackTarget(monst, target)
				&& distanceBetween(x, y, target.xLoc, target.yLoc) < shortestDistance
				&& traversiblePathBetween(monst, target.xLoc, target.yLoc)
				&& (!monsterAvoids(monst, target.xLoc, target.yLoc) || (target.info.flags & MONST_ATTACKABLE_THRU_WALLS))
				&& (!target.status[STATUS_INVISIBLE] || rand_percent(33)))
      {
				shortestDistance = distanceBetween(x, y, target.xLoc, target.yLoc);
				closestMonster = target;
			}
		}
		if (closestMonster && await monstUseMagic(monst)) {
			monst.ticksUntilTurn = monst.attackSpeed * (monst.info.flags & MONST_CAST_SPELLS_SLOWLY ? 2 : 1);
			return;
		}
		if (closestMonster && !(monst.info.flags & MONST_MAINTAINS_DISTANCE)) {
			targetLoc[0] = closestMonster.xLoc;
			targetLoc[1] = closestMonster.yLoc;
			if (await moveMonsterPassivelyTowards(monst, targetLoc, false)) {
				return;
			}
		}
	}

	// hunting
	if ((monst.creatureState == MONSTER_TRACKING_SCENT
		   || (monst.creatureState == MONSTER_ALLY && monst.status[STATUS_DISCORDANT]))
		// eels don't charge if you're not in the water
		&& (!(monst.info.flags & MONST_RESTRICTED_TO_LIQUID) || cellHasTMFlag(player.xLoc, player.yLoc, TM_ALLOWS_SUBMERGING)))
  {
		// magic users sometimes cast spells
    if (await monstUseMagic(monst)
        || (monsterHasBoltEffect(monst, BE_BLINKING)
            && ((monst.info.flags & MONST_ALWAYS_USE_ABILITY) || rand_percent(30))
            && await monsterBlinkToPreferenceMap(monst, scentMap, true))) // if he actually cast a spell
    {
        monst.ticksUntilTurn = monst.attackSpeed * (monst.info.flags & MONST_CAST_SPELLS_SLOWLY ? 2 : 1);
        return;
    }

		// if the monster is adjacent to an ally and not adjacent to the player, attack the ally
		if (distanceBetween(x, y, player.xLoc, player.yLoc) > 1
			|| diagonalBlocked(x, y, player.xLoc, player.yLoc, false))
    {
			for (ally = monsters.nextCreature; ally != NULL; ally = ally.nextCreature) {
				if (monsterWillAttackTarget(monst, ally)
            && distanceBetween(x, y, ally.xLoc, ally.yLoc) == 1
		        && (!ally.status[STATUS_INVISIBLE] || rand_percent(33)))
        {
					targetLoc[0] = ally.xLoc;
					targetLoc[1] = ally.yLoc;
					if (await moveMonsterPassivelyTowards(monst, targetLoc, true)) { // attack
						return;
					}
				}
			}
		}

		if ((monst.status[STATUS_LEVITATING] || (monst.info.flags & MONST_RESTRICTED_TO_LIQUID) || (monst.bookkeepingFlags & MB_SUBMERGED)
			     || ((monst.info.flags & (MONST_IMMUNE_TO_WEBS | MONST_INVULNERABLE) && monsterCanShootWebs(monst))))
			  && pmap[x][y].flags & IN_FIELD_OF_VIEW)
    {
			playerLoc[0] = player.xLoc;
			playerLoc[1] = player.yLoc;
			await moveMonsterPassivelyTowards(monst, playerLoc, true); // attack
			return;
		}
    if ((monst.info.flags & MONST_ALWAYS_HUNTING)
        && (monst.bookkeepingFlags & MB_GIVEN_UP_ON_SCENT))
    {
        await pathTowardCreature(monst, player);
        return;
    }

		dir = scentDirection(monst);
		if (dir == NO_DIRECTION) {
			alreadyAtBestScent = isLocalScentMaximum(monst.xLoc, monst.yLoc);
			if (alreadyAtBestScent && monst.creatureState != MONSTER_ALLY) {
        if (monst.info.flags & MONST_ALWAYS_HUNTING) {
            await pathTowardCreature(monst, player);
            monst.bookkeepingFlags |= MB_GIVEN_UP_ON_SCENT;
            return;
        }
				monst.creatureState = MONSTER_WANDERING;
				chooseNewWanderDestination(monst);
			}
		} else {
			await moveMonster(monst, nbDirs[dir][0], nbDirs[dir][1]);
		}
	} else if (monst.creatureState == MONSTER_FLEEING) {
		// fleeing
		if (monsterHasBoltEffect(monst, BE_BLINKING)
			&& ((monst.info.flags & MONST_ALWAYS_USE_ABILITY) || rand_percent(30))
			&& await monsterBlinkToSafety(monst))
    {
			return;
		}

    if (await monsterSummons(monst, (monst.info.flags & MONST_ALWAYS_USE_ABILITY))) {
        return;
    }

		if (fleeingMonsterAwareOfPlayer(monst)) {
			if (monst.safetyMap) {
				freeGrid(monst.safetyMap);
				monst.safetyMap = NULL;
			}
			if (!rogue.updatedSafetyMapThisTurn) {
				updateSafetyMap();
			}
			dir = nextStep(safetyMap, monst.xLoc, monst.yLoc, NULL, true);
		} else {
			if (!monst.safetyMap) {
				monst.safetyMap = allocGrid();
				copyGrid(monst.safetyMap, safetyMap);
			}
			dir = nextStep(monst.safetyMap, monst.xLoc, monst.yLoc, NULL, true);
		}
		if (dir != -1) {
			targetLoc[0] = x + nbDirs[dir][0];
			targetLoc[1] = y + nbDirs[dir][1];
		}
		if (dir == -1 || (!moveMonster(monst, nbDirs[dir][0], nbDirs[dir][1]) && !await moveMonsterPassivelyTowards(monst, targetLoc, true))) {
			// CYCLE_MONSTERS_AND_PLAYERS(ally) {
      for (ally = player; ally != NULL; ally = (ally === player ? monsters.nextCreature : ally.nextCreature)) {
				if (!monst.status[STATUS_MAGICAL_FEAR] // Fearful monsters will never attack.
					&& monsterWillAttackTarget(monst, ally)
					&& distanceBetween(x, y, ally.xLoc, ally.yLoc) <= 1)
        {
					await moveMonster(monst, ally.xLoc - x, ally.yLoc - y); // attack the player if cornered
					return;
				}
			}
		}
		return;
	} else if (monst.creatureState == MONSTER_WANDERING
			   // eels wander if you're not in water
			   || ((monst.info.flags & MONST_RESTRICTED_TO_LIQUID) && !cellHasTMFlag(player.xLoc, player.yLoc, TM_ALLOWS_SUBMERGING)))
  {
		// if we're standing in harmful terrain and there is a way to escape it, spend this turn escaping it.
		if (cellHasTerrainFlag(x, y, (T_HARMFUL_TERRAIN & ~T_IS_FIRE))
			|| (cellHasTerrainFlag(x, y, T_IS_FIRE) && !monst.status[STATUS_IMMUNE_TO_FIRE] && !(monst.info.flags & MONST_INVULNERABLE)))
    {
			if (!rogue.updatedMapToSafeTerrainThisTurn) {
				updateSafeTerrainMap();
			}

			if (await monsterBlinkToPreferenceMap(monst, rogue.mapToSafeTerrain, false)) {
				monst.ticksUntilTurn = monst.attackSpeed * (monst.info.flags & MONST_CAST_SPELLS_SLOWLY ? 2 : 1);
				return;
			}

			dir = nextStep(rogue.mapToSafeTerrain, x, y, monst, true);
			if (dir != -1) {
				targetLoc[0] = x + nbDirs[dir][0];
				targetLoc[1] = y + nbDirs[dir][1];
				if (await moveMonsterPassivelyTowards(monst, targetLoc, true)) {
					return;
				}
			}
		}

    // if a captive leader is captive, regenerative and healthy enough to withstand an attack,
    // and we're not poisonous, then approach or attack him.
		if ((monst.bookkeepingFlags & MB_FOLLOWER)
            && (monst.leader.bookkeepingFlags & MB_CAPTIVE)
			      && monst.leader.currentHP > Number(BigInt(monst.info.damage.upperBound * fp_monsterDamageAdjustmentAmount(monst)) >> BIG_BASE)
            && monst.leader.info.turnsBetweenRegen > 0
            && !(monst.info.abilityFlags & MA_POISONS)
            && !diagonalBlocked(monst.xLoc, monst.yLoc, monst.leader.xLoc, monst.leader.yLoc, false))
    {
      if (distanceBetween(monst.xLoc, monst.yLoc, monst.leader.xLoc, monst.leader.yLoc) == 1) {
          // Attack if adjacent.
          monst.ticksUntilTurn = monst.attackSpeed;
          await attack(monst, monst.leader, false);
          return;
      } else {
          // Otherwise, approach.
          await pathTowardCreature(monst, monst.leader);
          return;
      }
		}

		// if the monster is adjacent to an ally and not fleeing, attack the ally
		if (monst.creatureState == MONSTER_WANDERING) {
			for (ally = monsters.nextCreature; ally != NULL; ally = ally.nextCreature) {
				if (monsterWillAttackTarget(monst, ally)
          && distanceBetween(x, y, ally.xLoc, ally.yLoc) == 1
					&& (!ally.status[STATUS_INVISIBLE] || rand_percent(33)))
        {
					targetLoc[0] = ally.xLoc;
					targetLoc[1] = ally.yLoc;
					if (await moveMonsterPassivelyTowards(monst, targetLoc, true)) {
						return;
					}
				}
			}
		}

		// if you're a follower, don't get separated from the pack
		if (monst.bookkeepingFlags & MB_FOLLOWER) {
      if (distanceBetween(x, y, monst.leader.xLoc, monst.leader.yLoc) > 2) {
          await pathTowardCreature(monst, monst.leader);
      } else if (monst.leader.info.flags & MONST_IMMOBILE) {
          await monsterMillAbout(monst, 100); // Worshipers will pace frenetically.
      } else if (monst.leader.bookkeepingFlags & MB_CAPTIVE) {
          await monsterMillAbout(monst, 10); // Captors are languid.
      } else {
          await monsterMillAbout(monst, 30); // Other followers mill about like your allies do.
      }
		} else {
        // Step toward the chosen waypoint.
        dir = NO_DIRECTION;
        if (isValidWanderDestination(monst, monst.targetWaypointIndex)) {
            dir = nextStep(rogue.wpDistance[monst.targetWaypointIndex], monst.xLoc, monst.yLoc, monst, false);
        }
        // If there's no path forward, call that waypoint finished and pick a new one.
        if (!isValidWanderDestination(monst, monst.targetWaypointIndex)
            || dir == NO_DIRECTION) {

            chooseNewWanderDestination(monst);
            if (isValidWanderDestination(monst, monst.targetWaypointIndex)) {
                dir = nextStep(rogue.wpDistance[monst.targetWaypointIndex], monst.xLoc, monst.yLoc, monst, false);
            }
        }
        // If there's still no path forward, step randomly as though flitting.
        // (This is how eels wander in deep water.)
        if (dir == NO_DIRECTION) {
            dir = randValidDirectionFrom(monst, x, y, true);
        }
        if (dir != NO_DIRECTION) {
				targetLoc[0] = x + nbDirs[dir][0];
				targetLoc[1] = y + nbDirs[dir][1];
				if (await moveMonsterPassivelyTowards(monst, targetLoc, true)) {
					return;
				}
      }
    }
	} else if (monst.creatureState == MONSTER_ALLY) {
		await moveAlly(monst);
	}
}


function canPass( /* creature */ mover, /* creature */ blocker) {

    if (blocker === player) {
        return false;
    }

	if (blocker.status[STATUS_CONFUSED]
		|| blocker.status[STATUS_STUCK]
		|| blocker.status[STATUS_PARALYZED]
		|| blocker.status[STATUS_ENTRANCED]
		|| mover.status[STATUS_ENTRANCED])
  {
		return false;
	}

	if ((blocker.bookkeepingFlags & (MB_CAPTIVE | MB_ABSORBING))
		|| (blocker.info.flags & MONST_IMMOBILE))
  {
		return false;
	}

	if (monstersAreEnemies(mover, blocker)) {
		return false;
	}

	if (blocker.leader == mover) {
		return true;
	}

	if (mover.leader == blocker) {
		return false;
	}

	return (monstersAreTeammates(mover, blocker) && blocker.currentHP < mover.currentHP);
}

function isPassableOrSecretDoor(x, y) {
	return (!cellHasTerrainFlag(x, y, T_OBSTRUCTS_PASSABILITY)
            || (cellHasTMFlag(x, y, TM_IS_SECRET) && !(discoveredTerrainFlagsAtLoc(x, y) & T_OBSTRUCTS_PASSABILITY)));
}

function knownToPlayerAsPassableOrSecretDoor(x, y) {
  let tFlags, TMFlags;
  const flags = getLocationFlags(x, y, true);
  tFlags = flags.terrainFlags;
  TMFlags = flags.TMFlags;
	return (!(tFlags & T_OBSTRUCTS_PASSABILITY)
            || ((TMFlags & TM_IS_SECRET) && !(discoveredTerrainFlagsAtLoc(x, y) & T_OBSTRUCTS_PASSABILITY)));
}

async function setMonsterLocation(/* creature */ monst, newX, newY) {
    const creatureFlag = (monst === player ? HAS_PLAYER : HAS_MONSTER);
    pmap[monst.xLoc][monst.yLoc].flags &= ~creatureFlag;
    refreshDungeonCell(monst.xLoc, monst.yLoc);
    monst.turnsSpentStationary = 0;
    monst.xLoc = newX;
    monst.yLoc = newY;
    pmap[newX][newY].flags |= creatureFlag;
    if ((monst.bookkeepingFlags & MB_SUBMERGED) && !cellHasTMFlag(newX, newY, TM_ALLOWS_SUBMERGING)) {
        monst.bookkeepingFlags &= ~MB_SUBMERGED;
    }
    if (playerCanSee(newX, newY)
        && cellHasTMFlag(newX, newY, TM_IS_SECRET)
        && cellHasTerrainFlag(newX, newY, T_OBSTRUCTS_PASSABILITY))
    {
        await discover(newX, newY); // if you see a monster use a secret door, you discover it
    }
    refreshDungeonCell(newX, newY);
    monst.ticksUntilTurn = monst.movementSpeed;
    await applyInstantTileEffectsToCreature(monst);
    if (monst === player) {
        updateVision(true);
        // get any items at the destination location
        if (pmap[player.xLoc][player.yLoc].flags & HAS_ITEM) {
            pickUpItemAt(player.xLoc, player.yLoc);
        }
    }

}

// Tries to move the given monster in the given vector; returns true if the move was legal
// (including attacking player, vomiting or struggling in vain)
// Be sure that dx, dy are both in the range [-1, 1] or the move will sometimes fail due to the diagonal check.
async function moveMonster(/* creature */ monst, dx, dy) {
	let x = monst.xLoc, y = monst.yLoc;
	let newX, newY;
  let i;
	let confusedDirection, swarmDirection;
	let defender = NULL; // creature *
  const hitList = []; // creature *[16] = {NULL};
  let dir;

  if (dx == 0 && dy == 0) {
      return false;
  }

	newX = x + dx;
	newY = y + dy;

	if (!coordinatesAreInMap(newX, newY)) {
		//DEBUG printf("\nProblem! Monster trying to move more than one space at a time.");
		return false;
	}

	// vomiting
	if (monst.status[STATUS_NAUSEOUS] && rand_percent(25)) {
		await vomit(monst);
		monst.ticksUntilTurn = monst.movementSpeed;
		return true;
	}

	// move randomly?
	if (!monst.status[STATUS_ENTRANCED]) {
		if (monst.status[STATUS_CONFUSED]) {
			confusedDirection = randValidDirectionFrom(monst, x, y, false);
			if (confusedDirection != -1) {
				dx = nbDirs[confusedDirection][0];
				dy = nbDirs[confusedDirection][1];
			}
		} else if ((monst.info.flags & MONST_FLITS) && !(monst.bookkeepingFlags & MB_SEIZING) && rand_percent(33)) {
			confusedDirection = randValidDirectionFrom(monst, x, y, true);
			if (confusedDirection != -1) {
				dx = nbDirs[confusedDirection][0];
				dy = nbDirs[confusedDirection][1];
			}
		}
	}

	newX = x + dx;
	newY = y + dy;

	// Liquid-based monsters should never move or attack outside of liquid.
	if ((monst.info.flags & MONST_RESTRICTED_TO_LIQUID) && !cellHasTMFlag(newX, newY, TM_ALLOWS_SUBMERGING)) {
		return false;
	}

	// Caught in spiderweb?
	if (monst.status[STATUS_STUCK] && !(pmap[newX][newY].flags & (HAS_PLAYER | HAS_MONSTER))
		&& cellHasTerrainFlag(x, y, T_ENTANGLES) && !(monst.info.flags & MONST_IMMUNE_TO_WEBS))
  {
		if (!(monst.info.flags & MONST_INVULNERABLE)
            && --monst.status[STATUS_STUCK])
    {
			monst.ticksUntilTurn = monst.movementSpeed;
			return true;
		} else if (tileCatalog[pmap[x][y].layers[SURFACE]].flags & T_ENTANGLES) {
			pmap[x][y].layers[SURFACE] = NOTHING;
		}
	}

	if (pmap[newX][newY].flags & (HAS_MONSTER | HAS_PLAYER)) {
		defender = monsterAtLoc(newX, newY);
	} else {
		if (monst.bookkeepingFlags & MB_SEIZED) {
			for (defender = monsters.nextCreature; defender != NULL; defender = defender.nextCreature) {
				if ((defender.bookkeepingFlags & MB_SEIZING)
					&& monstersAreEnemies(monst, defender)
          && distanceBetween(monst.xLoc, monst.yLoc, defender.xLoc, defender.yLoc) == 1
          && !diagonalBlocked(monst.xLoc, monst.yLoc, defender.xLoc, defender.yLoc, false))
        {
					monst.ticksUntilTurn = monst.movementSpeed;
					return true;
				}
			}
			monst.bookkeepingFlags &= ~MB_SEIZED; // failsafe
		}
		if (monst.bookkeepingFlags & MB_SEIZING) {
			monst.bookkeepingFlags &= ~MB_SEIZING;
		}
	}

  for (dir = 0; dir < DIRECTION_COUNT; dir++) {
       if (dx == nbDirs[dir][0]
           && dy == nbDirs[dir][1])
       {
           break;
       }
   }
   brogueAssert(dir != NO_DIRECTION);
   if (await handleWhipAttacks(monst, dir, NULL)
       || await handleSpearAttacks(monst, dir, NULL))
   {
       monst.ticksUntilTurn = monst.attackSpeed;
       return true;
   }

	if (((defender && (defender.info.flags & MONST_ATTACKABLE_THRU_WALLS))
		    || (isPassableOrSecretDoor(newX, newY)
            && !diagonalBlocked(x, y, newX, newY, false)
	          && isPassableOrSecretDoor(x, y)))
		 && (!defender || canPass(monst, defender) || monsterWillAttackTarget(monst, defender)))
  {
			// if it's a legal move

			if (defender) {
				if (canPass(monst, defender)) {
            // swap places
            pmap[defender.xLoc][defender.yLoc].flags &= ~HAS_MONSTER;
            refreshDungeonCell(defender.xLoc, defender.yLoc);

            pmap[monst.xLoc][monst.yLoc].flags &= ~HAS_MONSTER;
            refreshDungeonCell(monst.xLoc, monst.yLoc);

            monst.xLoc = newX;
            monst.yLoc = newY;
            pmap[monst.xLoc][monst.yLoc].flags |= HAS_MONSTER;

            if (monsterAvoids(defender, x, y)) { // don't want a flying monster to swap a non-flying monster into lava!
                const loc = getQualifyingPathLocNear(x, y, true,
                                         forbiddenFlagsForMonster((defender.info)), HAS_PLAYER,
                                         forbiddenFlagsForMonster((defender.info)), (HAS_PLAYER | HAS_MONSTER | HAS_STAIRS), false);
                defender.xLoc = loc[0];
                defender.yLoc = loc[1];
            } else {
                defender.xLoc = x;
                defender.yLoc = y;
            }
            pmap[defender.xLoc][defender.yLoc].flags |= HAS_MONSTER;

            refreshDungeonCell(monst.xLoc, monst.yLoc);
            refreshDungeonCell(defender.xLoc, defender.yLoc);

            monst.ticksUntilTurn = monst.movementSpeed;
            return true;
        }

        // Sights are set on an enemy monster. Would we rather swarm than attack?
        swarmDirection = monsterSwarmDirection(monst, defender);
        if (swarmDirection != NO_DIRECTION) {
            newX = monst.xLoc + nbDirs[swarmDirection][0];
            newY = monst.yLoc + nbDirs[swarmDirection][1];
            await setMonsterLocation(monst, newX, newY);
            monst.ticksUntilTurn = monst.movementSpeed;
            return true;
        } else {
            // attacking another monster!
            monst.ticksUntilTurn = monst.attackSpeed;
            if (!((monst.info.abilityFlags & MA_SEIZES) && !(monst.bookkeepingFlags & MB_SEIZING))) {
                // Bog monsters and krakens won't surface on the turn that they seize their target.
                monst.bookkeepingFlags &= ~MB_SUBMERGED;
            }
            refreshDungeonCell(x, y);

            buildHitList(hitList, monst, defender,
                         // (monst.info.abilityFlags & MA_ATTACKS_PENETRATE) ? true : false,
                         (monst.info.abilityFlags & MA_ATTACKS_ALL_ADJACENT) ? true : false);
            // Attack!
            for (i=0; i<16; i++) {
                if (hitList[i]
                    && monsterWillAttackTarget(monst, hitList[i])
                    && !(hitList[i].bookkeepingFlags & MB_IS_DYING)
                    && !rogue.gameHasEnded)
                {
                    await attack(monst, hitList[i], false);
                }
            }
        }
        return true;
			} else {
        // okay we're moving!
        await setMonsterLocation(monst, newX, newY);
        monst.ticksUntilTurn = monst.movementSpeed;
				return true;
			}
		}
	return false;
}


function clearStatus(/* creature */ monst) {
	let i;

	for (i=0; i<NUMBER_OF_STATUS_EFFECTS; i++) {
		monst.status[i] = monst.maxStatus[i] = 0;
	}
}

// Bumps a creature to a random nearby hospitable cell.
function findAlternativeHomeFor( /* creature */ monst, x, y, chooseRandomly) {
	let sCols = [], sRows = [], i, j, maxPermissibleDifference, dist;

  fillSequentialList(sCols, DCOLS);
  fillSequentialList(sRows, DROWS);
	if (chooseRandomly) {
		shuffleList(sCols, DCOLS);
		shuffleList(sRows, DROWS);
	}

	for (maxPermissibleDifference = 1; maxPermissibleDifference < max(DCOLS, DROWS); maxPermissibleDifference++) {
		for (i=0; i < DCOLS; i++) {
			for (j=0; j<DROWS; j++) {
				dist = abs(sCols[i] - monst.xLoc) + abs(sRows[j] - monst.yLoc);
				if (dist <= maxPermissibleDifference
					&& dist > 0
					&& !(pmap[sCols[i]][sRows[j]].flags & (HAS_PLAYER | HAS_MONSTER))
					&& !monsterAvoids(monst, sCols[i], sRows[j])
					&& !(monst === player && cellHasTerrainFlag(sCols[i], sRows[j], T_PATHING_BLOCKER)))
        {
					// Success!
					return [sCols[i], sRows[j]];
				}
			}
		}
	}
	// Failure!
  return [-1, -1];
}

// blockingMap is optional
function getQualifyingLocNear(x, y,
							 hallwaysAllowed,
							 blockingMap /* char[DCOLS][DROWS] */,
							 forbiddenTerrainFlags,
							 forbiddenMapFlags,
							 forbidLiquid,
							 deterministic)
{
  let loc = [];
	let i, j, k, candidateLocs, randIndex;

	candidateLocs = 0;

	// count up the number of candidate locations
	for (k=0; k<max(DROWS, DCOLS) && !candidateLocs; k++) {
		for (i = x-k; i <= x+k; i++) {
			for (j = y-k; j <= y+k; j++) {
				if (coordinatesAreInMap(i, j)
					&& (i == x-k || i == x+k || j == y-k || j == y+k)
					&& (!blockingMap || !blockingMap[i][j])
					&& !cellHasTerrainFlag(i, j, forbiddenTerrainFlags)
					&& !(pmap[i][j].flags & forbiddenMapFlags)
					&& (!forbidLiquid || pmap[i][j].layers[LIQUID] == NOTHING)
					&& (hallwaysAllowed || passableArcCount(i, j) < 2))
        {
					candidateLocs++;
				}
			}
		}
	}

	if (candidateLocs == 0) {
		return null;
	}

	// and pick one
	if (deterministic) {
    randIndex = 1 + Math.floor(candidateLocs / 2);
	} else {
		randIndex = rand_range(1, candidateLocs);
	}

	for (k=0; k<max(DROWS, DCOLS); k++) {
		for (i = x-k; i <= x+k; i++) {
			for (j = y-k; j <= y+k; j++) {
				if (coordinatesAreInMap(i, j)
					&& (i == x-k || i == x+k || j == y-k || j == y+k)
					&& (!blockingMap || !blockingMap[i][j])
					&& !cellHasTerrainFlag(i, j, forbiddenTerrainFlags)
					&& !(pmap[i][j].flags & forbiddenMapFlags)
					&& (!forbidLiquid || pmap[i][j].layers[LIQUID] == NOTHING)
					&& (hallwaysAllowed || passableArcCount(i, j) < 2))
        {
					if (--randIndex == 0) {
						loc[0] = i;
						loc[1] = j;
						return loc;
					}
				}
			}
		}
	}

  brogueAssert(false);
	return null; // should never reach this point
}

function getQualifyingGridLocNear(
								 x, y,
								 grid /* boolean[DCOLS][DROWS] */,
								 deterministic)
{
  let loc = [];
	let i, j, k, candidateLocs, randIndex;

	candidateLocs = 0;

	// count up the number of candidate locations
	for (k=0; k<max(DROWS, DCOLS) && !candidateLocs; k++) {
		for (i = x-k; i <= x+k; i++) {
			for (j = y-k; j <= y+k; j++) {
				if (coordinatesAreInMap(i, j)
					&& (i == x-k || i == x+k || j == y-k || j == y+k)
					&& grid[i][j])
        {
					candidateLocs++;
				}
			}
		}
	}

	if (candidateLocs == 0) {
		return null;
	}

	// and pick one
	if (deterministic) {
		randIndex = 1 + Math.floor(candidateLocs / 2);
	} else {
		randIndex = rand_range(1, candidateLocs);
	}

	for (k=0; k<max(DROWS, DCOLS); k++) {
		for (i = x-k; i <= x+k; i++) {
			for (j = y-k; j <= y+k; j++) {
				if (coordinatesAreInMap(i, j)
					&& (i == x-k || i == x+k || j == y-k || j == y+k)
					&& grid[i][j])
        {
					if (--randIndex == 0) {
						loc[0] = i;
						loc[1] = j;
						return loc;
					}
				}
			}
		}
	}

  brogueAssert(false);
	return null; // should never reach this point
}


async function makeMonsterDropItem(/* creature */ monst) {
	let x, y;
  const loc = getQualifyingPathLocNear(monst.xLoc, monst.yLoc, true,
                           T_DIVIDES_LEVEL, 0,
                           0, (HAS_PLAYER | HAS_STAIRS | HAS_ITEM), false);
  x = loc[0];
  y = loc[1];
	//getQualifyingLocNear(loc, monst.xLoc, monst.yLoc, true, 0, (T_OBSTRUCTS_ITEMS), (HAS_ITEM), false, false);
	await placeItem(monst.carriedItem, x, y);
	monst.carriedItem = NULL;
	refreshDungeonCell(x, y);
}


function checkForContinuedLeadership(/* creature */ monst) {
	let follower;  // creature *
  let maintainLeadership = false;

  if (monst.bookkeepingFlags & MB_LEADER) {
      for (follower = monsters.nextCreature; follower != NULL; follower = follower.nextCreature) {
          if (follower.leader === monst && monst !== follower) {
              maintainLeadership = true;
              break;
          }
      }
  }
  if (!maintainLeadership) {
      monst.bookkeepingFlags &= ~MB_LEADER;
  }
}

function demoteMonsterFromLeadership( /* creature */ monst) {
	let follower, newLeader = NULL; // creature *
  let atLeastOneNewFollower = false;

	monst.bookkeepingFlags &= ~MB_LEADER;
	if (monst.mapToMe) {
		freeGrid(monst.mapToMe);
		monst.mapToMe = NULL;
	}
	for (follower = monsters.nextCreature; follower != NULL; follower = follower.nextCreature) {
		if (follower.leader === monst && monst !== follower) {
			if (follower.bookkeepingFlags & MB_BOUND_TO_LEADER) {
				// gonna die in playerTurnEnded().
				follower.leader = NULL;
				follower.bookkeepingFlags &= ~MB_FOLLOWER;
			} else if (newLeader) {
				follower.leader = newLeader;
        atLeastOneNewFollower = true;
        follower.targetWaypointIndex = monst.targetWaypointIndex;
        if (follower.targetWaypointIndex >= 0) {
            follower.waypointAlreadyVisited[follower.targetWaypointIndex] = false;
        }
			} else {
				newLeader = follower;
				follower.bookkeepingFlags |= MB_LEADER;
				follower.bookkeepingFlags &= ~MB_FOLLOWER;
				follower.leader = NULL;
			}
		}
	}
  if (newLeader
      && !atLeastOneNewFollower)
  {
      newLeader.bookkeepingFlags &= ~MB_LEADER;
  }
	for (follower = dormantMonsters.nextCreature; follower != NULL; follower = follower.nextCreature) {
		if (follower.leader === monst && monst !== follower) {
			follower.leader = NULL;
			follower.bookkeepingFlags &= ~MB_FOLLOWER;
		}
	}
}

// Makes a monster dormant, or awakens it from that state
function toggleMonsterDormancy( /* creature */ monst) {
	let prevMonst;   // creature *
	let loc;

	for (prevMonst = dormantMonsters; prevMonst != NULL; prevMonst = prevMonst.nextCreature) {
		if (prevMonst.nextCreature == monst) {
			// Found it! It's dormant. Wake it up.

			// Remove it from the dormant chain.
			prevMonst.nextCreature = monst.nextCreature;

			// Add it to the normal chain.
			monst.nextCreature = monsters.nextCreature;
			monsters.nextCreature = monst;

			pmap[monst.xLoc][monst.yLoc].flags &= ~HAS_DORMANT_MONSTER;

			// Does it need a new location?
			if (pmap[monst.xLoc][monst.yLoc].flags & (HAS_MONSTER | HAS_PLAYER)) { // Occupied!
          loc = getQualifyingPathLocNear(monst.xLoc, monst.yLoc, true,
                                         T_DIVIDES_LEVEL & avoidedFlagsForMonster(monst.info), HAS_PLAYER,
                                         avoidedFlagsForMonster(monst.info), (HAS_PLAYER | HAS_MONSTER | HAS_STAIRS), false);
          if (loc) {
            monst.xLoc = loc[0];
            monst.yLoc = loc[1];
          }
			}

      if (monst.bookkeepingFlags & MB_MARKED_FOR_SACRIFICE) {
           monst.bookkeepingFlags |= MB_TELEPATHICALLY_REVEALED;
           if (monst.carriedItem) {
               makeMonsterDropItem(monst);
           }
       }

			// Miscellaneous transitional tasks.
			// Don't want it to move before the player has a chance to react.
			monst.ticksUntilTurn = 200;

			pmap[monst.xLoc][monst.yLoc].flags |= HAS_MONSTER;
			monst.bookkeepingFlags &= ~MB_IS_DORMANT;
			fadeInMonster(monst);
			return;
		}
	}

	for (prevMonst = monsters; prevMonst != NULL; prevMonst = prevMonst.nextCreature) {
		if (prevMonst.nextCreature == monst) {
			// Found it! It's alive. Put it into dormancy.
			// Remove it from the monsters chain.
			prevMonst.nextCreature = monst.nextCreature;
			// Add it to the dormant chain.
			monst.nextCreature = dormantMonsters.nextCreature;
			dormantMonsters.nextCreature = monst;
			// Miscellaneous transitional tasks.
			pmap[monst.xLoc][monst.yLoc].flags &= ~HAS_MONSTER;
			pmap[monst.xLoc][monst.yLoc].flags |= HAS_DORMANT_MONSTER;
			monst.bookkeepingFlags |= MB_IS_DORMANT;
			return;
		}
	}
}

function staffOrWandEffectOnMonsterDescription( newText, /* item */ theItem, /* creature */ monst) {
    const theItemName = STRING(), monstName = STRING(); // char[COLS];
    let successfulDescription = false;
    const enchant = fp_netEnchant(theItem);

    if ((theItem.category & (STAFF | WAND))
        && tableForItemCategory(theItem.category, NULL)[theItem.kind].identified)
    {
        monsterName(monstName, monst, true);
        itemName(theItem, theItemName, false, false, NULL);

        switch (boltEffectForItem(theItem)) {
            case BE_DAMAGE:
                if ((boltCatalog[boltForItem(theItem)].flags & BF_FIERY) && (monst.status[STATUS_IMMUNE_TO_FIRE])
                    || (monst.info.flags & MONST_INVULNERABLE))
                {
                    sprintf(newText, "\n     Your %s (%c) will not harm %s.",
                            theItemName,
                            theItem.inventoryLetter,
                            monstName);
                    successfulDescription = true;
                } else if (theItem.flags & (ITEM_MAX_CHARGES_KNOWN | ITEM_IDENTIFIED)) {
                    if (fp_staffDamageLow(enchant) >= monst.currentHP) {
                        sprintf(newText, "\n     Your %s (%c) will %s the %s in one hit.",
                                theItemName,
                                theItem.inventoryLetter,
                                (monst.info.flags & MONST_INANIMATE) ? "destroy" : "kill",
                                monstName);
                    } else {
                        sprintf(newText, "\n     Your %s (%c) will hit %s for between %i% and %i% of $HISHER current health.",
                                theItemName,
                                theItem.inventoryLetter,
                                monstName,
                                Math.floor(100 * fp_staffDamageLow(enchant) / monst.currentHP),
                                Math.floor(100 * fp_staffDamageHigh(enchant) / monst.currentHP));
                    }
                    successfulDescription = true;
                }
                break;
            case BE_POISON:
                if (monst.info.flags & (MONST_INANIMATE | MONST_INVULNERABLE)) {
                    sprintf(newText, "\n     Your %s (%c) will not affect %s.",
                            theItemName,
                            theItem.inventoryLetter,
                            monstName);
                } else {
                    sprintf(newText, "\n     Your %s (%c) will poison %s for %i% of $HISHER current health.",
                            theItemName,
                            theItem.inventoryLetter,
                            monstName,
                            Math.floor(100 * fp_staffPoison(enchant) / monst.currentHP));
                }
                successfulDescription = true;
                break;
            case BE_DOMINATION:
                if (monst.creatureState != MONSTER_ALLY) {
                    if (monst.info.flags & MONST_INANIMATE) {
                        sprintf(newText, "\n     A wand of domination will have no effect on objects like %s.",
                                monstName);
                    } else if (monst.info.flags & MONST_INVULNERABLE) {
                        sprintf(newText, "\n     A wand of domination will not affect %s.",
                                monstName);
                    } else if (wandDominate(monst) <= 0) {
                        sprintf(newText, "\n     A wand of domination will fail at %s's current health level.",
                                monstName);
                    } else if (wandDominate(monst) >= 100) {
                        sprintf(newText, "\n     A wand of domination will always succeed at %s's current health level.",
                                monstName);
                    } else {
                        sprintf(newText, "\n     A wand of domination will have a %i% chance of success at %s's current health level.",
                                wandDominate(monst),
                                monstName);
                    }
                    successfulDescription = true;
                }
                break;
            default:
                strcpy(newText, "");
                break;
        }
    }
    return successfulDescription;
}

function monsterDetails( buf, /* creature */ monst) {
	const monstName = STRING(), capMonstName = STRING(), theItemName = STRING(), newText = STRING(); // char[20*COLS];
	let i, j, combatMath, combatMath2, playerKnownAverageDamage, playerKnownMaxDamage, commaCount, realArmorValue;
	let anyFlags, displayedItemText = false, alreadyDisplayedDominationText = false;
	let theItem; // item *
  let color = null;

	buf.clear();
	commaCount = 0;

	monsterName(monstName, monst, true);
  strcpy(capMonstName, monstName);
	capitalize(capMonstName);

	if (!(monst.info.flags & MONST_RESTRICTED_TO_LIQUID)
		 || cellHasTMFlag(monst.xLoc, monst.yLoc, TM_ALLOWS_SUBMERGING))
  {
		// If the monster is not a beached whale, print the ordinary flavor text.
    sprintf(newText, "     %s\n     ", monsterText[monst.info.monsterID].flavorText);
		strcat(buf, newText);
	}

  if (monst.mutationIndex >= 0) {
    i = strlen(buf);
    i = encodeMessageColor(buf, i, mutationCatalog[monst.mutationIndex].textColor);
    strcpy(newText, mutationCatalog[monst.mutationIndex].description);
    resolvePronounEscapes(newText, monst);
    upperCase(newText);
    strcat(newText, "\n     ");
    strcat(buf, newText);
    i = strlen(buf);
    i = encodeMessageColor(buf, i, white);
  }

	if (!(monst.info.flags & MONST_ATTACKABLE_THRU_WALLS)
		&& cellHasTerrainFlag(monst.xLoc, monst.yLoc, T_OBSTRUCTS_PASSABILITY))
  {
		// If the monster is trapped in impassible terrain, explain as much.
		sprintf(newText, "%s is trapped %s %s.\n     ",
				capMonstName,
				(tileCatalog[pmap[monst.xLoc][monst.yLoc].layers[layerWithFlag(monst.xLoc, monst.yLoc, T_OBSTRUCTS_PASSABILITY)]].mechFlags & TM_STAND_IN_TILE) ? "in" : "on",
				tileCatalog[pmap[monst.xLoc][monst.yLoc].layers[layerWithFlag(monst.xLoc, monst.yLoc, T_OBSTRUCTS_PASSABILITY)]].description);
    strcat(buf, newText);
	}

	if (!rogue.armor || (rogue.armor.flags & ITEM_IDENTIFIED)) {
		combatMath2 = hitProbability(monst, player);
	} else {
		realArmorValue = player.info.defense;
		player.info.defense = Math.floor((armorTable[rogue.armor.kind].range.upperBound + armorTable[rogue.armor.kind].range.lowerBound) / 2);
		player.info.defense += Number(BigInt(10 * fp_strengthModifier(rogue.armor)) >> BIG_BASE);
		combatMath2 = hitProbability(monst, player);
		player.info.defense = realArmorValue;
	}

	if ((monst.info.flags & MONST_RESTRICTED_TO_LIQUID) && !cellHasTMFlag(monst.xLoc, monst.yLoc, TM_ALLOWS_SUBMERGING)) {
		sprintf(newText, "     %s writhes helplessly on dry land.\n     ", capMonstName);
	} else if (rogue.armor
			   && (rogue.armor.flags & ITEM_RUNIC)
			   && (rogue.armor.flags & ITEM_RUNIC_IDENTIFIED)
			   && rogue.armor.enchant2 == A_IMMUNITY
			   && monsterIsInClass(monst, rogue.armor.vorpalEnemy))
  {
    itemName(rogue.armor, theItemName, false, false, NULL);
    sprintf(newText, "Your %s renders you immune to %s.\n     ", theItemName, monstName);
	} else if (Number(BigInt(monst.info.damage.upperBound * fp_monsterDamageAdjustmentAmount(monst)) >> BIG_BASE) == 0) {
    sprintf(newText, "%s deals no direct damage.\n     ", capMonstName);
	} else {
    i = strlen(buf);
		encodeMessageColor(buf, i, badMessageColor);
    if (monst.info.abilityFlags & MA_POISONS) {
        combatMath = player.status[STATUS_POISONED]; // combatMath is poison duration
        for (i = 0; combatMath * (player.poisonAmount + i) < player.currentHP; i++) {
            combatMath += Number(BigInt(monst.info.damage.upperBound * fp_monsterDamageAdjustmentAmount(monst)) >> BIG_BASE);
        }
        if (i == 0) {
            // Already fatally poisoned.
            sprintf(newText, "%s has a %i% chance to poison you and typically poisons for %i turns.\n     ",
                    capMonstName,
                    combatMath2,
                    Number(BigInt((monst.info.damage.lowerBound + monst.info.damage.upperBound) * fp_monsterDamageAdjustmentAmount(monst)) / 2n >> BIG_BASE));
        } else {
          sprintf(newText, "%s has a %i% chance to poison you, typically poisons for %i turns, and at worst, could fatally poison you in %i hit%s.\n     ",
                capMonstName,
                combatMath2,
                Number(BigInt(monst.info.damage.lowerBound + monst.info.damage.upperBound) * fp_monsterDamageAdjustmentAmount(monst) / 2n >> BIG_BASE),
                i,
                (i > 1 ? "s" : ""));
        }
    } else {
        combatMath = Number( ((BigInt(player.currentHP + monst.info.damage.upperBound * fp_monsterDamageAdjustmentAmount(monst)) >> BIG_BASE - 1n) << BIG_BASE) / BigInt(monst.info.damage.upperBound * fp_monsterDamageAdjustmentAmount(monst) ));
        if (combatMath < 1) {
            combatMath = 1;
        }
        sprintf(newText, "%s has a %i% chance to hit you, typically hits for %i% of your current health, and at worst, could defeat you in %i hit%s.\n     ",
                capMonstName,
                combatMath2,
                Number((100n * BigInt(monst.info.damage.lowerBound + monst.info.damage.upperBound) * BigInt(fp_monsterDamageAdjustmentAmount(monst)) / 2n / BigInt(player.currentHP)) >> BIG_BASE),
                combatMath,
                (combatMath > 1 ? "s" : ""));
    }
	}
	capitalize(newText);
  strcat(buf, newText);

	if (monst.creatureState == MONSTER_ALLY) {
    i = strlen(buf);
		i = encodeMessageColor(buf, i, goodMessageColor);

		sprintf(newText, "%s is your ally.", capMonstName);
		if (monst.newPowerCount > 0) {
      capitalize(newText);
			strcat(buf, newText);
			strcat(buf, "\n     ");
			i = strlen(buf);
			i = encodeMessageColor(buf, i, advancementMessageColor);

      if (monst.newPowerCount == 1) {
          strcpy(newText, "$HESHE seems ready to learn something new.");
      } else {
          sprintf(newText, "$HESHE seems ready to learn %i new talents.", monst.newPowerCount);
      }
			resolvePronounEscapes(newText, monst); // So that it gets capitalized appropriately.
		}
	} else if (monst.bookkeepingFlags & MB_CAPTIVE) {
    i = strlen(buf);
		i = encodeMessageColor(buf, i, goodMessageColor);
		sprintf(newText, "%s is being held captive.", capMonstName);
	} else {

		if (!rogue.weapon || (rogue.weapon.flags & ITEM_IDENTIFIED)) {
			playerKnownAverageDamage = Math.floor((player.info.damage.upperBound + player.info.damage.lowerBound) / 2);
			playerKnownMaxDamage = player.info.damage.upperBound;
		} else {
			playerKnownAverageDamage = Math.floor((rogue.weapon.damage.upperBound + rogue.weapon.damage.lowerBound) / 2);
			playerKnownMaxDamage = rogue.weapon.damage.upperBound;
		}

		if (playerKnownMaxDamage == 0) {
      i = strlen(buf);
			i = encodeMessageColor(buf, i, white);

			sprintf(newText, "You deal no direct damage.");
    } else if (rogue.weapon
               && (rogue.weapon.flags & ITEM_RUNIC)
               && (rogue.weapon.flags & ITEM_RUNIC_IDENTIFIED)
               && rogue.weapon.enchant2 == W_SLAYING
               && monsterIsInClass(monst, rogue.weapon.vorpalEnemy))
    {
      i = strlen(buf);
			i = encodeMessageColor(buf, i, goodMessageColor);
      itemName(rogue.weapon, theItemName, false, false, NULL);
      sprintf(newText, "Your %s will slay %s in one stroke.", theItemName, monstName);
		} else if (monst.info.flags & (MONST_INVULNERABLE | MONST_IMMUNE_TO_WEAPONS)) {
      i = strlen(buf);
			i = encodeMessageColor(buf, i, white);
      sprintf(newText, "%s is immune to your attacks.", monstName);
    } else {
      i = strlen(buf);
			i = encodeMessageColor(buf, i, goodMessageColor);

			combatMath = Math.floor((monst.currentHP + playerKnownMaxDamage - 1) / playerKnownMaxDamage);
      if (combatMath < 1) {
          combatMath = 1;
      }
			if (rogue.weapon && !(rogue.weapon.flags & ITEM_IDENTIFIED)) {
				realArmorValue = rogue.weapon.enchant1;
				rogue.weapon.enchant1 = 0;
				combatMath2 = hitProbability(player, monst);
				rogue.weapon.enchant1 = realArmorValue;
			} else {
				combatMath2 = hitProbability(player, monst);
			}
			sprintf(newText, "You have a %i% chance to hit %s, typically hit for %i% of $HISHER current health, and at best, could defeat $HIMHER in %i hit%s.",
					combatMath2,
					monstName,
					Math.floor(100 * playerKnownAverageDamage / monst.currentHP),
					combatMath,
					(combatMath > 1 ? "s" : ""));
		}
	}
	capitalize(newText);
  strcat(buf, newText);

	for (theItem = packItems.nextItem; theItem != NULL; theItem = theItem.nextItem) {
		if (staffOrWandEffectOnMonsterDescription(newText, theItem, monst)) {
      if (boltEffectForItem(theItem) == BE_DOMINATION) {
          if (alreadyDisplayedDominationText) {
              continue;
          } else {
              alreadyDisplayedDominationText = true;
          }
      }
      i = strlen(buf);
			i = encodeMessageColor(buf, i, itemMessageColor);
			strcat(buf, newText);
			displayedItemText = true;
		}
	}

	if (monst.carriedItem) {
    i = strlen(buf);
		i = encodeMessageColor(buf, i, itemMessageColor);
		itemName(monst.carriedItem, theItemName, true, true, NULL);
		sprintf(newText, "%s has %s.", capMonstName, theItemName);
		upperCase(newText);
		strcat(buf, "\n     ");
		strcat(buf, newText);
	}

  strcat(buf, "\n     ");

  i = strlen(buf);
	i = encodeMessageColor(buf, i, white);

	anyFlags = false;
	sprintf(newText, "%s ", capMonstName);

	if (monst.attackSpeed < 100) {
    strcat(newText, "attacks quickly");
		anyFlags = true;
	} else if (monst.attackSpeed > 100) {
    strcat(newText, "attacks slowly");
		anyFlags = true;
	}

	if (monst.movementSpeed < 100) {
		if (anyFlags) {
      strcat(newText, "& ");
			commaCount++;
		}
    strcat(newText, "moves quickly");
		anyFlags = true;
	} else if (monst.movementSpeed > 100) {
		if (anyFlags) {
      strcat(newText, "& ");
			commaCount++;
		}
    strcat(newText, "moves slowly");
		anyFlags = true;
	}

	if (monst.info.turnsBetweenRegen == 0) {
		if (anyFlags) {
      strcat(newText, "& ");
			commaCount++;
		}
    strcat(newText, "does not regenerate");
		anyFlags = true;
	} else if (monst.info.turnsBetweenRegen < 5000) {
		if (anyFlags) {
      strcat(newText, "& ");
			commaCount++;
		}
    strcat(newText, "regenerates quickly");
		anyFlags = true;
	}

	// bolt flags
	for (i = 0; monst.info.bolts[i] != BOLT_NONE; i++) {
		if (boltCatalog[monst.info.bolts[i]].abilityDescription[0]) {
			if (anyFlags) {
        strcat(newText, "& ");
				commaCount++;
			}
      strcat(newText, boltCatalog[monst.info.bolts[i]].abilityDescription);
			anyFlags = true;
		}
	}

	// ability flags
	for (i=0; i<32; i++) {
		if ((monst.info.abilityFlags & (Fl(i)))
			&& monsterAbilityFlagDescriptions[i]) {
			if (anyFlags) {
        strcat(newText, "& ");
				commaCount++;
			}
      strcat(newText, monsterAbilityFlagDescriptions[i]);
			anyFlags = true;
		}
	}

	// behavior flags
	for (i=0; i<32; i++) {
		if ((monst.info.flags & (Fl(i)))
			&& monsterBehaviorFlagDescriptions[i]) {
			if (anyFlags) {
        strcat(newText, "& ");
				commaCount++;
			}
      strcat(newText, monsterBehaviorFlagDescriptions[i]);
			anyFlags = true;
		}
	}

	// bookkeeping flags
	for (i=0; i<32; i++) {
		if ((monst.bookkeepingFlags & (Fl(i)))
			&& monsterBookkeepingFlagDescriptions[i])
    {
			if (anyFlags) {
        strcat(newText, "& ");
				commaCount++;
			}
      strcat(newText, monsterBookkeepingFlagDescriptions[i]);
			anyFlags = true;
		}
	}

	if (anyFlags) {
    strcat(newText, ". ");
		//strcat(buf, "\n\n");
		// j = strlen(buf);
		for (i=0; i < strlen(newText); i++) {
			if (newText.text[i] == '&') {
				if (!--commaCount) {
					// buf[j] = '\0';
          strcat(buf, " and");
					// j += 4;
				} else {
          strcat(buf, ",");
				}
			} else {
        strcat(buf, newText.text[i]);
			}
		}
		// buf[j] = '\0';
	}
	resolvePronounEscapes(buf, monst);
}
/*
 *  RogueMain.c
 *  Brogue
 *
 *  Created by Brian Walker on 12/26/08.
 *  Copyright 2012. All rights reserved.
 *
 *  This file is part of Brogue.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

// #include "Rogue.h"
// #include "IncludeGlobals.h"
// #include <math.h>
// #include <time.h>


// TODO - Move to Rogue.js???
var noScores = true;
var noRecording = true;


async function rogueMain() {
	previousGameSeed = 0;
	initializeBrogueSaveLocation();
	await mainBrogueJunction();
}


async function executeEvent(/* rogueEvent */ theEvent) {
	rogue.playbackBetweenTurns = false;
	if (theEvent.eventType == KEYSTROKE) {
		await executeKeystroke(theEvent.param1, theEvent.controlKey, theEvent.shiftKey);
	} else if (theEvent.eventType == MOUSE_UP
			   || theEvent.eventType == RIGHT_MOUSE_UP)
  {
		await executeMouseClick(theEvent);
	}
}

function fileExists(pathname) {
	// FILE *openedFile;
	// openedFile = fopen(pathname, "rb");
	// if (openedFile) {
	// 	fclose(openedFile);
	// 	return true;
	// } else {
	// 	return false;
	// }
	throw new Error('Files not supported');
}

// Player specifies a file; if all goes well, put it into path and return true.
// Otherwise, return false.
function chooseFile(path, prompt, defaultName, suffix) {

	// if (getInputTextString(path,
	// 					   prompt,
	// 					   min(DCOLS-25, BROGUE_FILENAME_MAX - strlen(suffix)),
	// 					   defaultName,
	// 					   suffix,
	// 					   TEXT_INPUT_FILENAME,
	// 					   false)
	// 	&& path[0] != '\0') {
	//
	// 	strcat(path, suffix);
	// 	return true;
	// } else {
	// 	return false;
	// }
	throw new Error('Files not supported');
}

// If the file exists, copy it into currentFilePath. (Otherwise return false.)
// Then, strip off the suffix, replace it with ANNOTATION_SUFFIX,
// and if that file exists, copy that into annotationPathname. Return true.
function openFile(path) {
	// short i;
	// char buf[BROGUE_FILENAME_MAX];
	// boolean retval;
	//
	// if (fileExists(path)) {
	//
	// 	strcpy(currentFilePath, path);
	// 	annotationPathname[0] = '\0';
	//
	// 	// Clip off the suffix.
	// 	strcpy(buf, path);
	// 	for (i = strlen(path); buf[i] != '.' && i > 0; i--) continue;
	// 	if (buf[i] == '.'
	// 		&& i + strlen(ANNOTATION_SUFFIX) < BROGUE_FILENAME_MAX) {
	//
	// 		buf[i] = '\0'; // Snip!
	// 		strcat(buf, ANNOTATION_SUFFIX);
	// 		strcpy(annotationPathname, buf); // Load the annotations file too.
	// 	}
	// 	retval = true;
	// } else {
	// 	retval = false;
	// }
	//
	// return retval;

	throw new Error('Files not supported');
}

async function benchmark() {
    let i, j, k;
    const sparklesauce = color(10,	0, 20,	60,	40,	100, 30, true);
    let theChar;

    let initialTime = Date.now();
    for (k=0; k<500; k++) {
        for (i=0; i<COLS; i++) {
            for (j=0; j<ROWS; j++) {
                theChar = rand_range('!', '~');
                plotCharWithColor(theChar, i, j, sparklesauce, sparklesauce);
            }
        }
        await pauseBrogue(1);
    }
		let elapsed = Date.now() - initialTime;
    printf("Benchmark took a total of %lu seconds.", elapsed);
}

function welcome() {
  const buf = STRING(), buf2 = STRING(); // [DCOLS*3],
	message("Hello and welcome, adventurer, to the Dungeons of Doom!", false);
	strcpy(buf, "Retrieve the ");
	encodeMessageColor(buf, strlen(buf), itemMessageColor);
	strcat(buf, "Amulet of Yendor");
	encodeMessageColor(buf, strlen(buf), white);
	sprintf(buf2, " from the %{i}th floor and escape with it!", AMULET_LEVEL);
	strcat(buf, buf2);
	message(buf, false);
  if (KEYBOARD_LABELS) {
      message("Press <?> for help at any time.", backgroundMessageColor, false);
  }
	flavorMessage("The doors to the dungeon slam shut behind you.");
}


function generateFontFiles() {
  //   short i, j;
	// uchar k;
	//
	// uchar c8[16] = {
	// 	FLOOR_CHAR,
	// 	CHASM_CHAR,
	// 	TRAP_CHAR,
	// 	FIRE_CHAR,
	// 	FOLIAGE_CHAR,
	// 	AMULET_CHAR,
	// 	SCROLL_CHAR,
	// 	RING_CHAR,
	// 	WEAPON_CHAR,
	// 	GEM_CHAR,
	// 	TOTEM_CHAR,
	// 	TURRET_CHAR,
	// 	BAD_MAGIC_CHAR,
	// 	GOOD_MAGIC_CHAR,
	// 	' ',
	// 	' ',
	// };
	// uchar c9[16] = {
	// 	UP_ARROW_CHAR,
	// 	DOWN_ARROW_CHAR,
	// 	LEFT_ARROW_CHAR,
	// 	RIGHT_ARROW_CHAR,
	// 	UP_TRIANGLE_CHAR,
	// 	DOWN_TRIANGLE_CHAR,
	// 	OMEGA_CHAR,
	// 	THETA_CHAR,
	// 	LAMDA_CHAR,
	// 	KOPPA_CHAR,
	// 	LOZENGE_CHAR,
	// 	CROSS_PRODUCT_CHAR,
	// 	' ',
	// 	' ',
	// 	' ',
	// 	' ',
	// };
	//
	// for (i=0; i<COLS; i++) {
	// 	for(j=0; j<ROWS; j++ ) {
	// 		plotCharWithColor(' ', i, j, &white, &white);
	// 	}
	// }
	// i = j = 0;
	// for (k=0; k<256; k++) {
	// 	i = k % 16;
	// 	j = k / 16;
	// 	if (j >= ROWS) {
	// 		break;
	// 	}
	// 	if (j == 8) {
	// 		plotCharWithColor(c8[i], i, j+5, &white, &black);
	// 	} else if (j == 9) {
	// 		plotCharWithColor(c9[i], i, j+5, &white, &black);
	// 	} else {
	// 		plotCharWithColor(k, i, j+5, &white, &black);
	// 	}
	// }
	// for (;;) {
	// 	waitForAcknowledgment();
	// }
}

// Seed is used as the dungeon seed unless it's zero, in which case generate a new one.
// Either way, previousGameSeed is set to the seed we use.
// None of this seed stuff is applicable if we're playing a recording.
function initializeRogue(seed) {
	let i, j, k;
	let theItem;
	let playingback, playbackFF, playbackPaused;

	// generate libtcod font bitmap
	// add any new unicode characters here to include them
// #ifdef GENERATE_FONT_FILES
//     generateFontFiles();
// #endif

	playingback = rogue.playbackMode; // the only three animals that need to go on the ark
	playbackPaused = rogue.playbackPaused;
	playbackFF = rogue.playbackFastForward;
	// memset((void *) &rogue, 0, sizeof( playerCharacter )); // the flood
	// rogue = playerCharacter();	// reset

	// rogue.warningPauseMode = true;	// removed 1.7.5

	rogue.playbackMode = playingback;
	rogue.playbackPaused = playbackPaused;
	rogue.playbackFastForward = playbackFF;

	rogue.gameHasEnded = false;
	rogue.highScoreSaved = false;
	rogue.cautiousMode = false;
	rogue.milliseconds = 0;

	brogueAssert(rogue.RNG == RNG_SUBSTANTIVE);

	if (!rogue.playbackMode) {
		rogue.seed = seedRandomGenerator(seed);
		previousGameSeed = rogue.seed;
		console.log('SEED', rogue.seed);
	}

  // await benchmark();

	// initRecording();

  levels = ARRAY((DEEPEST_LEVEL+1), () => levelData() );
	levels[0].upStairsLoc[0] = Math.floor((DCOLS - 1) / 2) - 1;
	levels[0].upStairsLoc[1] = DROWS - 2;

	// reset enchant and gain strength frequencies
  rogue.lifePotionFrequency = 0;
	rogue.strengthPotionFrequency = 40;
	rogue.enchantScrollFrequency = 60;

	// all DF messages are eligible for display
	resetDFMessageEligibility();

	// initialize the levels list
	for (i=0; i<DEEPEST_LEVEL+1; i++) {
		levels[i].levelSeed = rand_range(0, 9999);
    levels[i].levelSeed += 10000 * rand_range(0, 9999);
		console.log("levelSeed", i, levels[i].levelSeed);
		levels[i].monsters = NULL;
		levels[i].dormantMonsters = NULL;
		levels[i].items = NULL;
		levels[i].visited = false;
		levels[i].playerExitedVia[0] = 0;
		levels[i].playerExitedVia[1] = 0;
		do {
			levels[i].downStairsLoc[0] = rand_range(1, DCOLS - 2);
			levels[i].downStairsLoc[1] = rand_range(1, DROWS - 2);
		} while (distanceBetween(levels[i].upStairsLoc[0], levels[i].upStairsLoc[1],
								 levels[i].downStairsLoc[0], levels[i].downStairsLoc[1]) < Math.floor(DCOLS / 3) );
		if (i < DEEPEST_LEVEL) {
			levels[i+1].upStairsLoc[0] = levels[i].downStairsLoc[0];
			levels[i+1].upStairsLoc[1] = levels[i].downStairsLoc[1];
		}
	}

  // initialize the waypoints list
  for (i=0; i<MAX_WAYPOINT_COUNT; i++) {
      rogue.wpDistance[i] = allocGrid();
      fillGrid(rogue.wpDistance[i], 0);
  }

	rogue.rewardRoomsGenerated = 0;

	// pre-shuffle the random terrain colors
	// assureCosmeticRNG();
	for (i=0; i<DCOLS; i++) {
		for( j=0; j<DROWS; j++ ) {
			for (k=0; k<8; k++) {
				terrainRandomValues[i][j][k] = cosmetic_range(0, 1000);
			}
		}
	}
	// restoreRNG();

	zeroOutGrid(displayDetail);

	for (i=0; i<NUMBER_MONSTER_KINDS; i++) {
		monsterCatalog[i].monsterID = i;
	}

	brogueAssert(rogue.RNG == RNG_SUBSTANTIVE);

	shuffleFlavors();

  for (i = 0; i < FEAT_COUNT; i++) {
    rogue.featRecord[i] = featTable[i].initialValue;
  }

	deleteMessages();
	for (i = 0; i < MESSAGE_ARCHIVE_LINES; i++) { // Clear the message archive.
		messageArchive[i] = '';
	}
	messageArchivePosition = 0;

	// Seed the stacks.
	floorItems = item();	// (item *) malloc(sizeof(item));
	// memset(floorItems, '\0', sizeof(item));
	floorItems.nextItem = NULL;

  packItems = item(); // (item *) malloc(sizeof(item));
	// memset(packItems, '\0', sizeof(item));
	packItems.nextItem = NULL;

  monsterItemsHopper = item(); // (item *) malloc(sizeof(item));
  // memset(monsterItemsHopper, '\0', sizeof(item));
  monsterItemsHopper.nextItem = NULL;

  for (i = 0; i < MAX_ITEMS_IN_MONSTER_ITEMS_HOPPER; i++) {
      theItem = generateItem(ALL_ITEMS & ~FOOD, -1); // Monsters can't carry food: the food clock cannot be cheated!
      theItem.nextItem = monsterItemsHopper.nextItem;
      monsterItemsHopper.nextItem = theItem;
  }

	monsters = creature(); // (creature *) malloc(sizeof(creature));
	// memset(monsters, '\0', sizeof(creature));
  monsters.nextCreature = NULL;

	dormantMonsters = creature(); // (creature *) malloc(sizeof(creature));
	// memset(dormantMonsters, '\0', sizeof(creature));
	dormantMonsters.nextCreature = NULL;

  graveyard = creature(); // (creature *) malloc(sizeof(creature));
	// memset(graveyard, '\0', sizeof(creature));
	graveyard.nextCreature = NULL;

  purgatory = creature(); // (creature *) malloc(sizeof(creature));
	// memset(purgatory, '\0', sizeof(creature));
	purgatory.nextCreature = NULL;

	scentMap			= NULL;
	safetyMap			= allocGrid();
	allySafetyMap = allocGrid();
	chokeMap			= allocGrid();

	rogue.mapToSafeTerrain = allocGrid();

	// Zero out the dynamic grids, as an essential safeguard against OOSes:
	fillGrid(safetyMap, 0);
	fillGrid(allySafetyMap, 0);
	fillGrid(chokeMap, 0);
	fillGrid(rogue.mapToSafeTerrain, 0);

	// initialize the player

	// memset(&player, '\0', sizeof(creature));
	player = creature();
	player.info = monsterCatalog[0];
	initializeGender(player);
	player.movementSpeed = player.info.movementSpeed;
	player.attackSpeed = player.info.attackSpeed;
	clearStatus(player);
	player.carriedItem = NULL;
	player.status[STATUS_NUTRITION] = player.maxStatus[STATUS_NUTRITION] = STOMACH_SIZE;
	player.currentHP = player.info.maxHP;
	// rogue.previousHealthPercent = 100;
  // rogue.previousPoisonPercent = 0;
	player.creatureState = MONSTER_ALLY;
	player.ticksUntilTurn = 0;
  player.mutationIndex = -1;
	player.info.displayChar = PLAYER_CHAR;

	rogue.depthLevel = 1;
  rogue.deepestLevel = 1;
	rogue.scentTurnNumber = 1000;
	rogue.playerTurnNumber = 0;
  rogue.absoluteTurnNumber = 0;
	rogue.previousPoisonPercent = 0;
	rogue.foodSpawned = 0;
  rogue.lifePotionsSpawned = 0;
	rogue.gold = 0;
	rogue.goldGenerated = 0;
	rogue.disturbed = false;
	rogue.autoPlayingLevel = false;
	rogue.automationActive = false;
	rogue.justRested = false;
	rogue.justSearched = false;
	rogue.easyMode = false;
	rogue.inWater = false;
	rogue.creaturesWillFlashThisTurn = false;
	rogue.updatedSafetyMapThisTurn = false;
	rogue.updatedAllySafetyMapThisTurn = false;
	rogue.updatedMapToSafeTerrainThisTurn = false;
	rogue.updatedMapToShoreThisTurn = false;
	rogue.strength = 12;
	rogue.weapon = NULL;
	rogue.armor = NULL;
	rogue.ringLeft = NULL;
	rogue.ringRight = NULL;
	rogue.monsterSpawnFuse = rand_range(125, 175);
	rogue.ticksTillUpdateEnvironment = 100;
	rogue.mapToShore = NULL;
	rogue.cursorLoc[0] = rogue.cursorLoc[1] = -1;
	rogue.xpxpThisTurn = 0;

  rogue.yendorWarden = NULL;

  rogue.flares = [];
  rogue.flareCount = rogue.flareCapacity = 0;

	rogue.minersLight.copy(lightCatalog[MINERS_LIGHT]);

	rogue.clairvoyance = rogue.regenerationBonus = rogue.stealthBonus = rogue.transference = rogue.wisdomBonus = rogue.reaping = 0;
	rogue.lightMultiplier = 1;

	theItem = generateItem(FOOD, RATION);
	theItem = addItemToPack(theItem);

	theItem = generateItem(WEAPON, DAGGER);
	theItem.enchant1 = theItem.enchant2 = 0;
	theItem.flags &= ~(ITEM_CURSED | ITEM_RUNIC);
	identify(theItem);
	theItem = addItemToPack(theItem);
	equipItem(theItem, false);

	theItem = generateItem(WEAPON, DART);
	theItem.enchant1 = theItem.enchant2 = 0;
	theItem.quantity = 15;
	theItem.flags &= ~(ITEM_CURSED | ITEM_RUNIC);
	identify(theItem);
	theItem = addItemToPack(theItem);

	theItem = generateItem(ARMOR, LEATHER_ARMOR);
	theItem.enchant1 = 0;
	theItem.flags &= ~(ITEM_CURSED | ITEM_RUNIC);
	identify(theItem);
	theItem = addItemToPack(theItem);
	equipItem(theItem, false);
  player.status[STATUS_DONNING] = 0;

  recalculateEquipmentBonuses();

	if (DEBUGGING) {
		theItem = generateItem(RING, RING_CLAIRVOYANCE);
		theItem.enchant1 = max(DROWS, DCOLS);
		theItem.flags &= ~ITEM_CURSED;
		identify(theItem);
		theItem = addItemToPack(theItem);

		theItem = generateItem(WEAPON, DAGGER);
		theItem.enchant1 = 50;
		theItem.enchant2 = W_QUIETUS;
		theItem.flags &= ~(ITEM_CURSED);
		theItem.flags |= (ITEM_PROTECTED | ITEM_RUNIC | ITEM_RUNIC_HINTED);
		theItem.damage.lowerBound = theItem.damage.upperBound = 25;
		identify(theItem);
		theItem = addItemToPack(theItem);

		theItem = generateItem(ARMOR, LEATHER_ARMOR);
		theItem.enchant1 = 50;
		theItem.enchant2 = A_REFLECTION;
		theItem.flags &= ~(ITEM_CURSED | ITEM_RUNIC_HINTED);
		theItem.flags |= (ITEM_PROTECTED | ITEM_RUNIC);
		identify(theItem);
		theItem = addItemToPack(theItem);

		theItem = generateItem(STAFF, STAFF_FIRE);
		theItem.enchant1 = 10;
		theItem.charges = 300;
		theItem.flags &= ~ITEM_CURSED;
		identify(theItem);
		theItem = addItemToPack(theItem);

		theItem = generateItem(STAFF, STAFF_LIGHTNING);
		theItem.enchant1 = 10;
		theItem.charges = 300;
		theItem.flags &= ~ITEM_CURSED;
		identify(theItem);
		theItem = addItemToPack(theItem);

		theItem = generateItem(STAFF, STAFF_BLINKING);
		theItem.enchant1 = theItem.charges = 10;
		theItem.flags &= ~ITEM_CURSED;
		identify(theItem);
		theItem = addItemToPack(theItem);

		theItem = generateItem(STAFF, STAFF_TUNNELING);
		theItem.enchant1 = 10;
		theItem.charges = 3000;
		theItem.flags &= ~ITEM_CURSED;
		identify(theItem);
		theItem = addItemToPack(theItem);

		theItem = generateItem(STAFF, STAFF_OBSTRUCTION);
		theItem.enchant1 = 10;
		theItem.charges = 300;
		theItem.flags &= ~ITEM_CURSED;
		identify(theItem);
		theItem = addItemToPack(theItem);

		theItem = generateItem(WAND, WAND_BECKONING);
		theItem.charges = 3000;
		theItem.flags &= ~ITEM_CURSED;
		identify(theItem);
		theItem = addItemToPack(theItem);

		theItem = generateItem(STAFF, STAFF_ENTRANCEMENT);
		theItem.enchant1 = 10;
		theItem.charges = 300;
		theItem.flags &= ~ITEM_CURSED;
		identify(theItem);
		theItem = addItemToPack(theItem);

		theItem = generateItem(STAFF, STAFF_HEALING);
		theItem.enchant1 = 10;
		theItem.charges = 300;
		theItem.flags &= ~ITEM_CURSED;
		identify(theItem);
		theItem = addItemToPack(theItem);

		theItem = generateItem(STAFF, STAFF_CONJURATION);
		theItem.enchant1 = 10;
		theItem.charges = 300;
		identify(theItem);
		theItem = addItemToPack(theItem);

		theItem = generateItem(STAFF, STAFF_POISON);
		theItem.enchant1 = 10;
		theItem.charges = 300;
		identify(theItem);
		theItem = addItemToPack(theItem);

		theItem = generateItem(WAND, WAND_DOMINATION);
		theItem.charges = 300;
		theItem.flags &= ~ITEM_CURSED;
		identify(theItem);
		theItem = addItemToPack(theItem);

		theItem = generateItem(WAND, WAND_POLYMORPH);
		theItem.charges = 300;
		theItem.flags &= ~ITEM_CURSED;
		identify(theItem);
		theItem = addItemToPack(theItem);

		theItem = generateItem(WAND, WAND_PLENTY);
		theItem.charges = 300;
		theItem.flags &= ~ITEM_CURSED;
		identify(theItem);
		theItem = addItemToPack(theItem);

		theItem = generateItem(WAND, WAND_NEGATION);
		theItem.charges = 300;
		theItem.flags &= ~ITEM_CURSED;
		identify(theItem);
		theItem = addItemToPack(theItem);

		theItem = generateItem(RING, RING_AWARENESS);
		theItem.enchant1 = 30;
		theItem.flags &= ~ITEM_CURSED;
		identify(theItem);
		theItem = addItemToPack(theItem);

//		short i;
//		for (i=0; i < NUMBER_CHARM_KINDS && i < 4; i++) {
//			theItem = generateItem(CHARM, i);
//			theItem = addItemToPack(theItem);
//		}
	}
	blackOutScreen();
	welcome();
}

// call this once per level to set all the dynamic colors as a function of depth
function updateColors() {
	let i;

	for (i=0; i<NUMBER_DYNAMIC_COLORS; i++) {
		Object.assign(dynamicColors[i][0], dynamicColors[i][1]);
		applyColorAverage(dynamicColors[i][0], dynamicColors[i][2], min(100, max(0, Math.floor(rogue.depthLevel * 100 / AMULET_LEVEL))));
	}
}

async function startLevel(oldLevelNumber, stairDirection) {
	let oldSeed;
	let theItem;
	let loc = []; // [2],
	let i, j, x, y, px, py, flying, dir;
	let placedPlayer;
	let monst;
	let layer;
	let timeAway;
	let mapToStairs;
	let mapToPit;
	let connectingStairsDiscovered;

  if (oldLevelNumber == DEEPEST_LEVEL && stairDirection != -1) {
    return;
  }

  synchronizePlayerTimeState();

  rogue.updatedSafetyMapThisTurn			  = false;
  rogue.updatedAllySafetyMapThisTurn		= false;
  rogue.updatedMapToSafeTerrainThisTurn	= false;

	rogue.cursorLoc[0] = -1;
	rogue.cursorLoc[1] = -1;
	rogue.lastTarget = NULL;

  connectingStairsDiscovered = (pmap[rogue.downLoc[0]][rogue.downLoc[1]].flags & (DISCOVERED | MAGIC_MAPPED) ? true : false);
	if (stairDirection == 0) { // fallen
		levels[oldLevelNumber-1].playerExitedVia[0] = player.xLoc;
		levels[oldLevelNumber-1].playerExitedVia[1] = player.yLoc;
	}

	if (oldLevelNumber != rogue.depthLevel) {
		px = player.xLoc;
		py = player.yLoc;
		if (cellHasTerrainFlag(player.xLoc, player.yLoc, T_AUTO_DESCENT)) {
			for (i=0; i<8; i++) {
				if (!cellHasTerrainFlag(player.xLoc+nbDirs[i][0], player.yLoc+nbDirs[i][1], (T_PATHING_BLOCKER))) {
					px = player.xLoc+nbDirs[i][0];
					py = player.yLoc+nbDirs[i][1];
					break;
				}
			}
		}
		mapToStairs = allocGrid();
		fillGrid(mapToStairs, 0);
		for (flying = 0; flying <= 1; flying++) {
			fillGrid(mapToStairs, 0);
			calculateDistances(mapToStairs, px, py, (flying ? T_OBSTRUCTS_PASSABILITY : T_PATHING_BLOCKER) | T_SACRED, NULL, true, true);
			for (monst = monsters.nextCreature; monst != NULL; monst = monst.nextCreature) {
				x = monst.xLoc;
				y = monst.yLoc;
				if (((monst.creatureState == MONSTER_TRACKING_SCENT && (stairDirection != 0 || monst.status[STATUS_LEVITATING]))
					 || monst.creatureState == MONSTER_ALLY || monst == rogue.yendorWarden)
					&& (stairDirection != 0 || monst.currentHP > 10 || monst.status[STATUS_LEVITATING])
					&& ((flying != 0) == ((monst.status[STATUS_LEVITATING] != 0)
										  || cellHasTerrainFlag(x, y, T_PATHING_BLOCKER)
										  || cellHasTerrainFlag(px, py, T_AUTO_DESCENT)))
					&& !(monst.bookkeepingFlags & MB_CAPTIVE)
					&& !(monst.info.flags & (MONST_WILL_NOT_USE_STAIRS | MONST_RESTRICTED_TO_LIQUID))
					&& !(cellHasTerrainFlag(x, y, T_OBSTRUCTS_PASSABILITY))
					&& !monst.status[STATUS_ENTRANCED]
					&& !monst.status[STATUS_PARALYZED]
					&& (mapToStairs[monst.xLoc][monst.yLoc] < 30000 || monst.creatureState == MONSTER_ALLY || monst === rogue.yendorWarden))
				{
					monst.status[STATUS_ENTERS_LEVEL_IN] = clamp(Math.floor(mapToStairs[monst.xLoc][monst.yLoc] * monst.movementSpeed / 100) + 1, 1, 150);
					switch (stairDirection) {
						case 1:
							monst.bookkeepingFlags |= MB_APPROACHING_DOWNSTAIRS;
							break;
						case -1:
							monst.bookkeepingFlags |= MB_APPROACHING_UPSTAIRS;
							break;
						case 0:
							monst.bookkeepingFlags |= MB_APPROACHING_PIT;
							break;
						default:
							break;
					}
				}
			}
		}
		freeGrid(mapToStairs);
	}

	for (monst = monsters.nextCreature; monst != NULL; monst = monst.nextCreature) {
		if (monst.mapToMe) {
			freeGrid(monst.mapToMe);
			monst.mapToMe = NULL;
		}
		if (monst.safetyMap) {
			freeGrid(monst.safetyMap);
			monst.safetyMap = NULL;
		}
	}
	levels[oldLevelNumber-1].monsters = monsters.nextCreature;
	levels[oldLevelNumber-1].dormantMonsters = dormantMonsters.nextCreature;
	levels[oldLevelNumber-1].items = floorItems.nextItem;

	for (i=0; i<DCOLS; i++) {
		for (j=0; j<DROWS; j++) {
      if (pmap[i][j].flags & VISIBLE) {
          // Remember visible cells upon exiting.
          storeMemories(i, j);
      }
			for (layer = 0; layer < NUMBER_TERRAIN_LAYERS; layer++) {
				levels[oldLevelNumber - 1].mapStorage[i][j].layers[layer] = pmap[i][j].layers[layer];
			}
			levels[oldLevelNumber - 1].mapStorage[i][j].volume = pmap[i][j].volume;
			levels[oldLevelNumber - 1].mapStorage[i][j].flags = (pmap[i][j].flags & PERMANENT_TILE_FLAGS);
			levels[oldLevelNumber - 1].mapStorage[i][j].rememberedAppearance = pmap[i][j].rememberedAppearance;
			levels[oldLevelNumber - 1].mapStorage[i][j].rememberedTerrain = pmap[i][j].rememberedTerrain;
			levels[oldLevelNumber - 1].mapStorage[i][j].rememberedItemCategory = pmap[i][j].rememberedItemCategory;
			levels[oldLevelNumber - 1].mapStorage[i][j].rememberedItemKind = pmap[i][j].rememberedItemKind;
			levels[oldLevelNumber - 1].mapStorage[i][j].rememberedCellFlags = pmap[i][j].rememberedCellFlags;
			levels[oldLevelNumber - 1].mapStorage[i][j].rememberedTerrainFlags = pmap[i][j].rememberedTerrainFlags;
			levels[oldLevelNumber - 1].mapStorage[i][j].rememberedTMFlags = pmap[i][j].rememberedTMFlags;
			levels[oldLevelNumber - 1].mapStorage[i][j].machineNumber = pmap[i][j].machineNumber;
		}
	}

	levels[oldLevelNumber - 1].awaySince = rogue.absoluteTurnNumber;

	//	Prepare the new level
	rogue.minersLightRadius = DCOLS - 1 << FP_BASE;
	for (i = 0; i < rogue.depthLevel; i++) {
			rogue.minersLightRadius = Math.floor(rogue.minersLightRadius * 85 / 100);
	}
	rogue.minersLightRadius += Math.floor((225 << FP_BASE)/100);
	updateColors();
	updateRingBonuses(); // also updates miner's light

	if (!levels[rogue.depthLevel - 1].visited) { // level has not already been visited
    levels[rogue.depthLevel - 1].scentMap = allocGrid();
    scentMap = levels[rogue.depthLevel - 1].scentMap;
    fillGrid(levels[rogue.depthLevel - 1].scentMap, 0);
		// generate new level
		oldSeed = rand_range(0, 9999);
    oldSeed += 10000 * rand_range(0, 9999);

		console.log('LEVEL SEED', levels[rogue.depthLevel - 1].levelSeed);
		seedRandomGenerator(levels[rogue.depthLevel - 1].levelSeed);
		logRNG();

		// Load up next level's monsters and items, since one might have fallen from above.
		monsters.nextCreature			= levels[rogue.depthLevel-1].monsters;
		dormantMonsters.nextCreature	= levels[rogue.depthLevel-1].dormantMonsters;
		floorItems.nextItem			= levels[rogue.depthLevel-1].items;

		levels[rogue.depthLevel-1].monsters = NULL;
		levels[rogue.depthLevel-1].dormantMonsters = NULL;
		levels[rogue.depthLevel-1].items = NULL;

		await digDungeon();
		await initializeLevel();
		setUpWaypoints();

		shuffleTerrainColors(100, false);

    // If we somehow failed to generate the amulet altar,
    // just toss an amulet in there somewhere.
    // It'll be fiiine!
		if (rogue.depthLevel == AMULET_LEVEL
        && !numberOfMatchingPackItems(AMULET, 0, 0, false)
				&& levels[rogue.depthLevel-1].visited == false)
		{
			for (theItem = floorItems.nextItem; theItem != NULL; theItem = theItem.nextItem) {
				if (theItem.category & AMULET) {
					break;
				}
			}
      for (monst = monsters.nextCreature; monst != NULL; monst = monst.nextCreature) {
          if (monst.carriedItem
              && (monst.carriedItem.category & AMULET))
					{
              theItem = monst.carriedItem;
              break;
          }
      }
			if (!theItem) {
				/* await */ placeItem(generateItem(AMULET, 0), 0, 0);	// should not generate an ACK
			}
		}
		seedRandomGenerator(oldSeed);

		//logLevel();

		// Simulate 50 turns so the level is broken in (swamp gas accumulating, brimstone percolating, etc.).
		timeAway = 50;

	} else { // level has already been visited

		// restore level
    scentMap = levels[rogue.depthLevel - 1].scentMap;
		timeAway = clamp(0, rogue.absoluteTurnNumber - levels[rogue.depthLevel - 1].awaySince, 30000);

		for (i=0; i<DCOLS; i++) {
			for (j=0; j<DROWS; j++) {
				for (layer = 0; layer < NUMBER_TERRAIN_LAYERS; layer++) {
					pmap[i][j].layers[layer] = levels[rogue.depthLevel - 1].mapStorage[i][j].layers[layer];
				}
				pmap[i][j].volume = levels[rogue.depthLevel - 1].mapStorage[i][j].volume;
				pmap[i][j].flags = (levels[rogue.depthLevel - 1].mapStorage[i][j].flags & PERMANENT_TILE_FLAGS);
				pmap[i][j].rememberedAppearance = levels[rogue.depthLevel - 1].mapStorage[i][j].rememberedAppearance;
				pmap[i][j].rememberedTerrain = levels[rogue.depthLevel - 1].mapStorage[i][j].rememberedTerrain;
				pmap[i][j].rememberedItemCategory = levels[rogue.depthLevel - 1].mapStorage[i][j].rememberedItemCategory;
				pmap[i][j].rememberedItemKind = levels[rogue.depthLevel - 1].mapStorage[i][j].rememberedItemKind;
				pmap[i][j].rememberedCellFlags = levels[rogue.depthLevel - 1].mapStorage[i][j].rememberedCellFlags;
				pmap[i][j].rememberedTerrainFlags = levels[rogue.depthLevel - 1].mapStorage[i][j].rememberedTerrainFlags;
				pmap[i][j].machineNumber = levels[rogue.depthLevel - 1].mapStorage[i][j].machineNumber;
			}
		}

		setUpWaypoints();

		rogue.downLoc[0]	= levels[rogue.depthLevel - 1].downStairsLoc[0];
		rogue.downLoc[1]	= levels[rogue.depthLevel - 1].downStairsLoc[1];
		rogue.upLoc[0]		= levels[rogue.depthLevel - 1].upStairsLoc[0];
		rogue.upLoc[1]		= levels[rogue.depthLevel - 1].upStairsLoc[1];

		monsters.nextCreature = levels[rogue.depthLevel - 1].monsters;
		dormantMonsters.nextCreature = levels[rogue.depthLevel - 1].dormantMonsters;
		floorItems.nextItem = levels[rogue.depthLevel - 1].items;

		levels[rogue.depthLevel-1].monsters = NULL;
		levels[rogue.depthLevel-1].dormantMonsters = NULL;
		levels[rogue.depthLevel-1].items = NULL;

		for (theItem = floorItems.nextItem; theItem != NULL; theItem = theItem.nextItem) {
			restoreItem(theItem);
		}

		mapToStairs = allocGrid();
		mapToPit = allocGrid();
		fillGrid(mapToStairs, 0);
		fillGrid(mapToPit, 0);
		calculateDistances(mapToStairs, player.xLoc, player.yLoc, T_PATHING_BLOCKER, NULL, true, true);
		calculateDistances(mapToPit, levels[rogue.depthLevel-1].playerExitedVia[0],
						   levels[rogue.depthLevel-1].playerExitedVia[0], T_PATHING_BLOCKER, NULL, true, true);
		for (monst = monsters.nextCreature; monst != NULL; monst = monst.nextCreature) {
			restoreMonster(monst, mapToStairs, mapToPit);
		}
		freeGrid(mapToStairs);
		freeGrid(mapToPit);
	}

	// Simulate the environment!
	// First bury the player in limbo while we run the simulation,
	// so that any harmful terrain doesn't affect her during the process.
	px = player.xLoc;
	py = player.yLoc;
	player.xLoc = player.yLoc = 0;
	for (i = 0; i < 100 && i < timeAway; i++) {
		await updateEnvironment();
	}
	player.xLoc = px;
	player.yLoc = py;

  if (!levels[rogue.depthLevel-1].visited) {
      levels[rogue.depthLevel-1].visited = true;
      if (rogue.depthLevel == AMULET_LEVEL) {
          message("An alien energy permeates the area. The Amulet of Yendor must be nearby!", itemMessageColor, false);
      } else if (rogue.depthLevel == DEEPEST_LEVEL) {
          message("An overwhelming sense of peace and tranquility settles upon you.", lightBlue, false);
      }
  }

	// Position the player.
	if (stairDirection == 0) { // fell into the level
		loc = getQualifyingLocNear(player.xLoc, player.yLoc, true, 0,
							 (T_PATHING_BLOCKER),
							 (HAS_MONSTER | HAS_ITEM | HAS_STAIRS | IS_IN_MACHINE), false, false);
	} else {
		if (stairDirection == 1) { // heading downward
			player.xLoc = rogue.upLoc[0];
			player.yLoc = rogue.upLoc[1];
		} else if (stairDirection == -1) { // heading upward
			player.xLoc = rogue.downLoc[0];
			player.yLoc = rogue.downLoc[1];
		}

    placedPlayer = false;
    for (dir=0; dir<4 && !placedPlayer; dir++) {
        const x = player.xLoc + nbDirs[dir][0];
        const y = player.yLoc + nbDirs[dir][1];
        if (!cellHasTerrainFlag(x, y, T_PATHING_BLOCKER)
            && !(pmap[x][y].flags & (HAS_MONSTER | HAS_ITEM | HAS_STAIRS | IS_IN_MACHINE)))
				{
            loc = [ x, y ];
        }
    }
		if (!loc) {
        loc = getQualifyingPathLocNear(player.xLoc, player.yLoc,
                   true,
                   T_DIVIDES_LEVEL, NULL,
                   T_PATHING_BLOCKER, (HAS_MONSTER | HAS_ITEM | HAS_STAIRS | IS_IN_MACHINE),
                   false);
    }
	}
	player.xLoc = loc[0];
	player.yLoc = loc[1];

	pmap[player.xLoc][player.yLoc].flags |= HAS_PLAYER;

	if (connectingStairsDiscovered) {
        for (i = rogue.upLoc[0]-1; i <= rogue.upLoc[0] + 1; i++) {
            for (j = rogue.upLoc[1]-1; j <= rogue.upLoc[1] + 1; j++) {
                if (coordinatesAreInMap(i, j)) {
                    discoverCell(i, j);
                }
            }
        }
	}
	if (cellHasTerrainFlag(player.xLoc, player.yLoc, T_IS_DEEP_WATER) && !player.status[STATUS_LEVITATING]
		&& !cellHasTerrainFlag(player.xLoc, player.yLoc, (T_ENTANGLES | T_OBSTRUCTS_PASSABILITY)))
	{
		rogue.inWater = true;
	}

	updateMapToShore();
	updateVision(true);
  rogue.aggroRange = currentAggroValue();

	// update monster states so none are hunting if there is no scent and they can't see the player
	for (monst = monsters.nextCreature; monst != NULL; monst = monst.nextCreature) {
		updateMonsterState(monst);
	}

	rogue.playbackBetweenTurns = true;
	displayLevel();
	refreshSideBar(-1, -1, false);

	if (rogue.playerTurnNumber) {
		rogue.playerTurnNumber++; // Increment even though no time has passed.
	}
	RNGCheck();
	flushBufferToFile();
  deleteAllFlares(); // So discovering something on the same turn that you fall down a level doesn't flash stuff on the previous level.
  hideCursor();
}

function freeGlobalDynamicGrid(grid) {
	if (grid) {
		freeGrid(grid);
		// grid = NULL;
	}
	return NULL;
}

function freeCreature(/* creature */ monst) {
	monst.mapToMe = freeGlobalDynamicGrid(monst.mapToMe);
	monst.safetyMap = freeGlobalDynamicGrid(monst.safetyMap);
	if (monst.carriedItem) {
		// free(monst.carriedItem);
		monst.carriedItem = NULL;
	}
	if (monst.carriedMonster) {
		freeCreature(monst.carriedMonster);
		monst.carriedMonster = NULL;
	}
	monst.nextMonster = null;
	// free(monst);
}

function emptyGraveyard() {
	let monst, monst2;
	for (monst = graveyard.nextCreature; monst != NULL; monst = monst2) {
		monst2 = monst.nextCreature;
		freeCreature(monst);
	}
	graveyard.nextCreature = NULL;
}

function freeEverything() {
	let i;
	let monst, monst2;
	let theItem, theItem2;

	safetyMap = freeGlobalDynamicGrid(safetyMap);
	allySafetyMap = freeGlobalDynamicGrid(allySafetyMap);
	chokeMap = freeGlobalDynamicGrid(chokeMap);
	rogue.mapToShore = freeGlobalDynamicGrid(rogue.mapToShore);
	rogue.mapToSafeTerrain = freeGlobalDynamicGrid(rogue.mapToSafeTerrain);

	for (i=0; i<DEEPEST_LEVEL+1; i++) {
		for (monst = levels[i].monsters; monst != NULL; monst = monst2) {
			monst2 = monst.nextCreature;
			freeCreature(monst);
		}
		levels[i].monsters = NULL;
		for (monst = levels[i].dormantMonsters; monst != NULL; monst = monst2) {
			monst2 = monst.nextCreature;
			freeCreature(monst);
		}
		levels[i].dormantMonsters = NULL;
		for (theItem = levels[i].items; theItem != NULL; theItem = theItem2) {
			theItem2 = theItem.nextItem;
			deleteItem(theItem);
		}
		levels[i].items = NULL;
    if (levels[i].scentMap) {
        freeGrid(levels[i].scentMap);
        levels[i].scentMap = NULL;
    }
	}
    scentMap = NULL;
    for (monst = monsters; monst != NULL; monst = monst2) {
        monst2 = monst.nextCreature;
        freeCreature(monst);
    }
    monsters = NULL;
    for (monst = dormantMonsters; monst != NULL; monst = monst2) {
        monst2 = monst.nextCreature;
        freeCreature(monst);
    }
    dormantMonsters = NULL;
    for (monst = graveyard; monst != NULL; monst = monst2) {
        monst2 = monst.nextCreature;
        freeCreature(monst);
    }
    graveyard = NULL;
    for (monst = purgatory; monst != NULL; monst = monst2) {
        monst2 = monst.nextCreature;
        freeCreature(monst);
    }
    purgatory = NULL;
    for (theItem = floorItems; theItem != NULL; theItem = theItem2) {
        theItem2 = theItem.nextItem;
        deleteItem(theItem);
    }
    floorItems = NULL;
    for (theItem = packItems; theItem != NULL; theItem = theItem2) {
        theItem2 = theItem.nextItem;
        deleteItem(theItem);
    }
    packItems = NULL;
    for (theItem = monsterItemsHopper; theItem != NULL; theItem = theItem2) {
        theItem2 = theItem.nextItem;
        deleteItem(theItem);
    }
    monsterItemsHopper = NULL;
    for (i=0; i<MAX_WAYPOINT_COUNT; i++) {
        freeGrid(rogue.wpDistance[i]);
    }

    deleteAllFlares();
    if (rogue.flares) {
        // free(rogue.flares);
        rogue.flares = NULL;
    }

    // free(levels);
    levels = NULL;
}

async function gameOver(killedBy, useCustomPhrasing) {
  let i, y;
	const buf = STRING(); // [200],
	const buf2 = STRING(); // [200];
	const highScoreText = STRING();
	let playback;
	let theEvent = rogueEvent();
  let theItem = null;

  if (player.bookkeepingFlags & MB_IS_DYING) {
      // we've already been through this once; let's avoid overkill.
      return;
  } else {
      player.bookkeepingFlags |= MB_IS_DYING;
  }

	rogue.autoPlayingLevel = false;

	flushBufferToFile();

	if (rogue.quit) {
		if (rogue.playbackMode) {
			playback = rogue.playbackMode;
			rogue.playbackMode = false;
			await messageWithAck("(The player quit at this point.)");
			rogue.playbackMode = playback;
		}

	} else {
		playback = rogue.playbackMode;
		if (!D_IMMORTAL) {
			rogue.playbackMode = false;
		}
		strcpy(buf, "You die...");
		if (KEYBOARD_LABELS) {
				encodeMessageColor(buf, strlen(buf), teal); // veryDarkGray);
				strcat(buf, " (press 'i' to view your inventory)");
		}
    player.currentHP = 0; // So it shows up empty in the side bar.
    refreshSideBar(-1, -1, false);
		message(buf, badMessageColor, false);
    displayMoreSignWithoutWaitingForAcknowledgment();

		do {
				await nextBrogueEvent(theEvent, false, false, false);
				if (theEvent.eventType == KEYSTROKE
						&& theEvent.param1 != ACKNOWLEDGE_KEY
						&& theEvent.param1 != ESCAPE_KEY
						&& theEvent.param1 != INVENTORY_KEY)
				{
						await flashTemporaryAlert(" -- Press space or click to continue, or press 'i' to view inventory -- ", 1500);
				} else if (theEvent.eventType == KEYSTROKE && theEvent.param1 == INVENTORY_KEY) {
						for (theItem = packItems.nextItem; theItem != NULL; theItem = theItem.nextItem) {
								identify(theItem);
								theItem.flags &= ~ITEM_MAGIC_DETECTED;
						}
						await displayInventory(ALL_ITEMS, 0, 0, true, false);
				}
		} while (!(theEvent.eventType == KEYSTROKE && (theEvent.param1 == ACKNOWLEDGE_KEY || theEvent.param1 == ESCAPE_KEY)
							 || theEvent.eventType == MOUSE_UP));

		confirmMessages();
		rogue.playbackMode = playback;
	}

	let theEntry = rogueHighScoresEntry();
	let dbuf = GRID(COLS, ROWS, cellDisplayBuffer );

  rogue.creaturesWillFlashThisTurn = false;

	if (D_IMMORTAL && !rogue.quit) {
		message("...but then you get better.", false);
		player.currentHP = player.info.maxHP;
		if (player.status[STATUS_NUTRITION] < 10) {
			player.status[STATUS_NUTRITION] = STOMACH_SIZE;
		}
		player.bookkeepingFlags &= ~MB_IS_DYING;
		return;
	}

	if (rogue.highScoreSaved) {
		return;
	}
	rogue.highScoreSaved = true;

	if (rogue.quit) {
		blackOutScreen();
	} else {
		copyDisplayBuffer(dbuf, displayBuffer);
		await funkyFade(dbuf, black, 0, 120, mapToWindowX(player.xLoc), mapToWindowY(player.yLoc), false);
	}

	if (useCustomPhrasing) {
		sprintf(buf, "%s on depth %i", killedBy, rogue.depthLevel);
	} else {
		sprintf(buf, "Killed by a%s %s on depth %i", (isVowelish(killedBy) ? "n" : ""), killedBy,
				rogue.depthLevel);
	}
  theEntry.score = rogue.gold;
	if (rogue.easyMode) {
		theEntry.score /= 10;
	}
	strcpy(highScoreText, buf);
  if (theEntry.score > 0) {
		sprintf(buf2, " with %li gold", theEntry.score);
		strcat(buf, buf2);
  }
  if (numberOfMatchingPackItems(AMULET, 0, 0, false) > 0) {
		strcat(buf, ", amulet in hand");
  }
	strcat(buf, ".");
	strcat(highScoreText, ".");

	strcpy(theEntry.description, highScoreText);

	if (!rogue.quit) {
        printString(buf, Math.round((COLS - strLenWithoutEscapes(buf)) / 2), Math.round(ROWS / 2), gray, black, 0);

        y = Math.round(ROWS / 2) + 3;
        for (i = 0; i < FEAT_COUNT; i++) {
            //printf("\nConduct %i (%s) is %s.", i, featTable[i].name, rogue.featRecord[i] ? "true" : "false");
            if (rogue.featRecord[i] && !featTable[i].initialValue)
						{
							sprintf(buf, "%s: %s", featTable[i].name, featTable[i].description);
                printString(buf, Math.round((COLS - strLenWithoutEscapes(buf)) / 2), y, advancementMessageColor, black, 0);
                y++;
            }
        }

		await displayMoreSign();
	}

	const recordingFilename = STRING(); // [BROGUE_FILENAME_MAX] = {0};

	if (!rogue.playbackMode) {
		if (saveHighScore(theEntry) && !noScores) {
			await printHighScores(true);
		}
		blackOutScreen();
		if(!noRecording) {
			saveRecording();
		}
		else {
			saveRecordingNoPrompt(recordingFilename);
		}

		if(!rogue.quit) {
			notifyEvent(GAMEOVER_DEATH, theEntry.score, 0, theEntry.description, recordingFilename);
		}
		else {
			notifyEvent(GAMEOVER_QUIT, theEntry.score, 0, theEntry.description, recordingFilename);
  	}
	}
	else {
		notifyEvent(GAMEOVER_RECORDING, 0, 0, "recording ended", "none");
	}

	rogue.gameHasEnded = true;
}


async function victory(superVictory) {
	const buf = STRING(); // [COLS*3],
	const victoryVerb = STRING(); // [20];
	let theItem;
	let i, j, gemCount = 0;
	let totalValue = 0;
	let theEntry = rogueHighScoresEntry();
	let qualified, isPlayback;
	let dbuf = GRID(COLS, ROWS, cellDisplayBuffer );

	flushBufferToFile();

	deleteMessages();
  if (superVictory) {
      message(    "Light streams through the portal, and you are teleported out of the dungeon.", false);
      copyDisplayBuffer(dbuf, displayBuffer);
      await funkyFade(dbuf, superVictoryColor, 0, 240, mapToWindowX(player.xLoc), mapToWindowY(player.yLoc), false);
      displayMoreSign();
      printString("Congratulations; you have transcended the Dungeons of Doom!                 ", mapToWindowX(0), mapToWindowY(-1), black, white, 0);
      await displayMoreSign();
      clearDisplayBuffer(dbuf);
      deleteMessages();
      strcpy(displayedMessage[0], "You retire in splendor, forever renowned for your remarkable triumph.     ");
  } else {
      message(    "You are bathed in sunlight as you throw open the heavy doors.", false);
      copyDisplayBuffer(dbuf, displayBuffer);
      await funkyFade(dbuf, white, 0, 240, mapToWindowX(player.xLoc), mapToWindowY(player.yLoc), false);
      displayMoreSign();
      printString("Congratulations; you have escaped from the Dungeons of Doom!     ", mapToWindowX(0), mapToWindowY(-1), black, white, 0);
      await displayMoreSign();
      clearDisplayBuffer(dbuf);
      deleteMessages();
      strcpy(displayedMessage[0], "You sell your treasures and live out your days in fame and glory.");
  }

	printString(displayedMessage[0], mapToWindowX(0), mapToWindowY(-1), white, black, dbuf);

	printString("Gold", mapToWindowX(2), mapToWindowY(1), white, black, dbuf);
	sprintf(buf, "%li", rogue.gold);
	printString(buf, mapToWindowX(60), mapToWindowY(1), itemMessageColor, black, dbuf);
	totalValue += rogue.gold;

	for (i = 4, theItem = packItems.nextItem; theItem != NULL; theItem = theItem.nextItem) {
		if (theItem.category & GEM) {
			gemCount += theItem.quantity;
		}
    if (theItem.category == AMULET && superVictory) {
        printString("The Birthright of Yendor", mapToWindowX(2), min(ROWS-1, i + 1), itemMessageColor, black, dbuf);
				sprintf(buf, "%li", max(0, itemValue(theItem) * 2));
        printString(buf, mapToWindowX(60), min(ROWS-1, i + 1), itemMessageColor, black, dbuf);
        totalValue += max(0, itemValue(theItem) * 2);
        i++;
    } else if (itemValue(theItem) > 0) {
        identify(theItem);
        itemName(theItem, buf, true, true, white);
        capitalize(buf);
        printString(buf, mapToWindowX(2), min(ROWS-1, i + 1), white, black, dbuf);
				sprintf(buf, "%li", max(0, itemValue(theItem)));
        printString(buf, mapToWindowX(60), min(ROWS-1, i + 1), itemMessageColor, black, dbuf);
        totalValue += max(0, itemValue(theItem));
        i++;
    }
	}
	i++;
	printString("TOTAL:", mapToWindowX(2), min(ROWS-1, i + 1), lightBlue, black, dbuf);
	sprintf(buf, "%li", totalValue);
	printString(buf, mapToWindowX(60), min(ROWS-1, i + 1), lightBlue, black, dbuf);

  i += 4;
  for (j = 0; i < ROWS && j < FEAT_COUNT; j++) {
      if (rogue.featRecord[j]) {
          buf = `${featTable[j].name}: ${featTable[j].description}`;
          printString(buf, mapToWindowX(2), i, advancementMessageColor, black, dbuf);
          i++;
      }
  }

	await funkyFade(dbuf, white, 0, 120, Math.round(COLS/2), Math.round(ROWS/2), true);

	strcpy(victoryVerb, superVictory ? "Mastered" : "Escaped");
	if (gemCount == 0) {
		sprintf(theEntry.description, "%s the Dungeons of Doom!", victoryVerb);
	} else if (gemCount == 1) {
		sprintf(theEntry.description, "%s the Dungeons of Doom with a lumenstone!", victoryVerb);
	} else {
		sprintf(theEntry.description, "%s the Dungeons of Doom with %i lumenstones!", victoryVerb, gemCount);
	}

	theEntry.score = totalValue;

	if (rogue.easyMode) {
		theEntry.score /= 10;
	}

	if (!DEBUGGING && !rogue.playbackMode) {
		qualified = saveHighScore(theEntry);
	} else {
		qualified = false;
	}

	isPlayback = rogue.playbackMode;
	rogue.playbackMode = false;
	await displayMoreSign();
	rogue.playbackMode = isPlayback;

	const recordingFilename = STRING(); // [BROGUE_FILENAME_MAX] = {0};

	if(!noRecording) {
		saveRecording();
	}
	else {
		saveRecordingNoPrompt(recordingFilename);
	}

	if(!noScores) {
		await printHighScores(qualified);
	}

	if (!rogue.playbackMode) {
		if(superVictory) {
			notifyEvent(GAMEOVER_SUPERVICTORY, theEntry.score, 0, theEntry.description, recordingFilename);
		}
		else {
			notifyEvent(GAMEOVER_VICTORY, theEntry.score, 0, theEntry.description, recordingFilename);
		}
	}
	else {
		notifyEvent(GAMEOVER_RECORDING, 0, 0, "recording ended", "none");
	}

	rogue.gameHasEnded = true;
}

async function enableEasyMode() {
	if (rogue.easyMode) {
		message("Alas, all hope of salvation is lost. You shed scalding tears at your plight.", false);
		return;
	}
	await messageWithAck("A dark presence surrounds you, whispering promises of stolen power.");
	if (await confirm("Succumb to demonic temptation (i.e. enable Easy Mode)?", false)) {
		recordKeystroke(EASY_MODE_KEY, false, true);
		await messageWithAck("An ancient and terrible evil burrows into your willing flesh!");
		player.info.displayChar = '&';
		rogue.easyMode = true;
		refreshDungeonCell(player.xLoc, player.yLoc);
		refreshSideBar(-1, -1, false);
		message("Wracked by spasms, your body contorts into an ALL-POWERFUL AMPERSAND!!!", false);
		message("You have a feeling that you will take 20% as much damage from now on.", false);
		message("But great power comes at a great price -- specifically, a 90% income tax rate.", false);
	} else {
		message("The evil dissipates, hissing, from the air around you.", false);
	}
}

// takes a flag of the form Fl(n) and returns n
function unflag(flag) {
	let i;
	for (i=0; i<32; i++) {
		if (flag >> i == 1) {
			return i;
		}
	}
	return -1;
}
/*
 *  IO.c
 *  Brogue
 *
 *  Created by Brian Walker on 1/10/09.
 *  Copyright 2012. All rights reserved.
 *
 *  This file is part of Brogue.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

// #include <math.h>
// #include <time.h>
//
// #include "Rogue.h"
// #include "IncludeGlobals.h"

var noSaves = false;

// Populates path[][] with a list of coordinates starting at origin and traversing down the map. Returns the number of steps in the path.
function getPlayerPathOnMap(path /* short [1000][2] */, /* short **/ map, originX, originY) {
	let dir, x, y, steps;

	x = originX;
	y = originY;

	dir = 0;

	for (steps = 0; dir != -1;) {
		dir = nextStep(map, x, y, player, false);
		if (dir != -1) {
			x += nbDirs[dir][0];
			y += nbDirs[dir][1];
			path[steps][0] = x;
			path[steps][1] = y;
			steps++;
      brogueAssert(coordinatesAreInMap(x, y));
		}
	}
	return steps;
}


function reversePath( path /* short[1000][2] */, steps) {
	let i, x, y;

	for (i=0; i<steps / 2; i++) {
		x = path[steps - i - 1][0];
		y = path[steps - i - 1][1];

		path[steps - i - 1][0] = path[i][0];
		path[steps - i - 1][1] = path[i][1];

		path[i][0] = x;
		path[i][1] = y;
	}
}

function hilitePath( path /* short[1000][2] */, steps, unhilite) {
	let i;
	if (unhilite) {
		for (i=0; i<steps; i++) {
      brogueAssert(coordinatesAreInMap(path[i][0], path[i][1]));
			pmap[path[i][0]][path[i][1]].flags &= ~IS_IN_PATH;
			refreshDungeonCell(path[i][0], path[i][1]);
		}
	} else {
		for (i=0; i<steps; i++) {
      brogueAssert(coordinatesAreInMap(path[i][0], path[i][1]));
			pmap[path[i][0]][path[i][1]].flags |= IS_IN_PATH;
			refreshDungeonCell(path[i][0], path[i][1]);
		}
	}
}


// More expensive than hilitePath(__, __, true), but you don't need access to the path itself.
function clearCursorPath() {
	let i, j;

	if (!rogue.playbackMode) { // There are no cursor paths during playback.
		for (i=1; i<DCOLS; i++) {
			for (j=1; j<DROWS; j++) {
				if (pmap[i][j].flags & IS_IN_PATH) {
					pmap[i][j].flags &= ~IS_IN_PATH;
					refreshDungeonCell(i, j);
				}
			}
		}
	}
}


function hideCursor() {
    // Drop out of cursor mode if we're in it, and hide the path either way.
    rogue.cursorMode = false;
    rogue.cursorPathIntensity = (rogue.cursorMode ? 50 : 20);
    rogue.cursorLoc[0] = -1;
    rogue.cursorLoc[1] = -1;
}


function showCursor() {
    // Return or enter turns on cursor mode. When the path is hidden, move the cursor to the player.
    if (!coordinatesAreInMap(rogue.cursorLoc[0], rogue.cursorLoc[1])) {
        rogue.cursorLoc[0] = player.xLoc;
        rogue.cursorLoc[1] = player.yLoc;
        rogue.cursorMode = true;
        rogue.cursorPathIntensity = (rogue.cursorMode ? 50 : 20);
    } else {
        rogue.cursorMode = true;
        rogue.cursorPathIntensity = (rogue.cursorMode ? 50 : 20);
    }
}


function getClosestValidLocationOnMap( loc /* short[2] */, /* short */map, x, y) {
	let i, j, dist, closestDistance, lowestMapScore;

	closestDistance = 10000;
	lowestMapScore = 10000;
	for (i=1; i<DCOLS-1; i++) {
		for (j=1; j<DROWS-1; j++) {
			if (map[i][j] >= 0 && map[i][j] < 30000) {
				dist = (i - x)*(i - x) + (j - y)*(j - y);
				//hiliteCell(i, j, &purple, min(dist / 2, 100), false);
				if (dist < closestDistance
					|| dist == closestDistance && map[i][j] < lowestMapScore)
				{
					loc[0] = i;
					loc[1] = j;
					closestDistance = dist;
					lowestMapScore = map[i][j];
				}
			}
		}
	}
}


function processSnapMap( /*short **/ map, costMap) {
  // let costMap;
  let dir;
  let i, j, newX, newY;

  // costMap = allocGrid();

  // populateCreatureCostMap(costMap, player);
  fillGrid(map, 30000);
  map[player.xLoc][player.yLoc] = 0;
  dijkstraScan(map, costMap, true);

	for (i = 0; i < DCOLS; i++) {
		for (j = 0; j < DROWS; j++) {
      if (cellHasTMFlag(i, j, TM_INVERT_WHEN_HIGHLIGHTED)) {
	      for (dir = 0; dir < 4; dir++) {
	        newX = i + nbDirs[dir][0];
	        newY = j + nbDirs[dir][1];
	        if (coordinatesAreInMap(newX, newY)
	            && map[newX][newY] >= 0
	            && map[newX][newY] < map[i][j])
					{
	            map[i][j] = map[newX][newY];
	        }
	      }
    	}
  	}
	}

  // freeGrid(costMap);
}


// Displays a menu of buttons for various commands.
// Buttons will be disabled if not permitted based on the playback state.
// Returns the keystroke to effect the button's command, or -1 if canceled.
// Some buttons take effect in this function instead of returning a value,
// i.e. true colors mode and display stealth mode.
async function actionMenu(x, playingBack) {
	let buttonCount;
  let y;
  let takeActionOurselves = []; // boolean[ROWS] = {false};
  const theEvent = rogueEvent();

	const buttons = ARRAY(ROWS, brogueButton); // [ROWS] = {{{0}}};
	const yellowColorEscape = STRING();
	const whiteColorEscape = STRING();
	const darkGrayColorEscape = STRING();
	let i, j, longestName = 0, buttonChosen;
	const dbuf = GRID(COLS, ROWS, cellDisplayBuffer); // cellDisplayBuffer[COLS][ROWS],
	const rbuf = GRID(COLS, ROWS, cellDisplayBuffer); // cellDisplayBuffer[COLS][ROWS];

	encodeMessageColor(yellowColorEscape, 0, itemMessageColor);
	encodeMessageColor(whiteColorEscape, 0, white);
	encodeMessageColor(darkGrayColorEscape, 0, black);

  do {
      for (i=0; i<ROWS; i++) {
          initializeButton(buttons[i]);
          buttons[i].buttonColor = interfaceBoxColor;
          buttons[i].opacity = INTERFACE_OPACITY;
      }

      buttonCount = 0;

      if (playingBack) {
          if (KEYBOARD_LABELS) {
              sprintf(buttons[buttonCount].text,	"  %{s}k: %{s}Faster playback  ", yellowColorEscape, whiteColorEscape);
          } else {
              strcpy(buttons[buttonCount].text, "  Faster playback  ");
          }
          buttons[buttonCount].hotkey[0] = UP_KEY;
          buttons[buttonCount].hotkey[1] = UP_ARROW;
          buttons[buttonCount].hotkey[2] = NUMPAD_8;
          buttonCount++;
					if (KEYBOARD_LABELS) {
							sprintf(buttons[buttonCount].text,	"  %{s}j: %{s}Slower playback  ", yellowColorEscape, whiteColorEscape);
					} else {
							strcpy(buttons[buttonCount].text, "  Slower playback  ");
					}
          buttons[buttonCount].hotkey[0] = DOWN_KEY;
          buttons[buttonCount].hotkey[1] = DOWN_ARROW;
          buttons[buttonCount].hotkey[2] = NUMPAD_2;
          buttonCount++;
					sprintf(buttons[buttonCount].text, "    %s---", darkGrayColorEscape);
          buttons[buttonCount].flags &= ~B_ENABLED;
          buttonCount++;

					if (KEYBOARD_LABELS) {
							sprintf(buttons[buttonCount].text,	"%{s}0-9: %{s}Fast forward to turn  ", yellowColorEscape, whiteColorEscape);
					} else {
							strcpy(buttons[buttonCount].text, "  Fast forward to turn  ");
					}
          buttons[buttonCount].hotkey[0] = '0';
          buttonCount++;
					if (KEYBOARD_LABELS) {
							sprintf(buttons[buttonCount].text,	"  %{s}>:%{s} Next Level  ", yellowColorEscape, whiteColorEscape);
					} else {
							strcpy(buttons[buttonCount].text, "  Next Level  ");
					}
          buttons[buttonCount].hotkey[0] = DESCEND_KEY;
          buttonCount++;
					sprintf(buttons[buttonCount].text, "    %s---", darkGrayColorEscape);
          buttons[buttonCount].flags &= ~B_ENABLED;
          buttonCount++;
      } else {
					if (KEYBOARD_LABELS) {
							sprintf(buttons[buttonCount].text, "  %{s}Z: %{s}Rest until better  ",		yellowColorEscape, whiteColorEscape);
					} else {
							strcpy(buttons[buttonCount].text, "  Rest until better  ");
					}
          buttons[buttonCount].hotkey[0] = AUTO_REST_KEY;
          buttonCount++;

					if (KEYBOARD_LABELS) {
							sprintf(buttons[buttonCount].text, "  %{s}A: %{s}Autopilot  ",				yellowColorEscape, whiteColorEscape);
					} else {
							strcpy(buttons[buttonCount].text, "  Autopilot  ");
					}
          buttons[buttonCount].hotkey[0] = AUTOPLAY_KEY;
          buttonCount++;

          if (!rogue.easyMode) {
							if (KEYBOARD_LABELS) {
									sprintf(buttons[buttonCount].text, "  %{s}&: %{s}Easy mode  ",				yellowColorEscape, whiteColorEscape);
							} else {
									strcpy(buttons[buttonCount].text, "  Easy mode  ");
							}
              buttons[buttonCount].hotkey[0] = EASY_MODE_KEY;
              buttonCount++;
          }

					sprintf(buttons[buttonCount].text, "    %s---", darkGrayColorEscape);
          buttons[buttonCount].flags &= ~B_ENABLED;
          buttonCount++;

          if(!noSaves) {
							if (KEYBOARD_LABELS) {
									sprintf(buttons[buttonCount].text, "  %{s}S: %{s}Suspend game and quit  ",	yellowColorEscape, whiteColorEscape);
							} else {
									strcpy(buttons[buttonCount].text, "  Suspend game and quit  ");
							}
              buttons[buttonCount].hotkey[0] = SAVE_GAME_KEY;
              buttonCount++;

							if (KEYBOARD_LABELS) {
									sprintf(buttons[buttonCount].text, "  %{s}O: %{s}Open suspended game  ",		yellowColorEscape, whiteColorEscape);
							} else {
									strcpy(buttons[buttonCount].text, "  Open suspended game  ");
							}
              buttons[buttonCount].hotkey[0] = LOAD_SAVED_GAME_KEY;
              buttonCount++;
          }
      }
      if(!noSaves) {
				if (KEYBOARD_LABELS) {
						sprintf(buttons[buttonCount].text, "  %{s}V: %{s}View saved recording  ",		yellowColorEscape, whiteColorEscape);
				} else {
						strcpy(buttons[buttonCount].text, "  View saved recording  ");
				}
          buttons[buttonCount].hotkey[0] = VIEW_RECORDING_KEY;
          buttonCount++;
      }
			sprintf(buttons[buttonCount].text, "    %s---", darkGrayColorEscape);
      buttons[buttonCount].flags &= ~B_ENABLED;
      buttonCount++;

			if (KEYBOARD_LABELS) {
					sprintf(buttons[buttonCount].text, "  %s\\: %s[%s] Hide color effects  ",	yellowColorEscape, whiteColorEscape, rogue.trueColorMode ? "X" : " ");
			} else {
					sprintf(buttons[buttonCount].text, "  [%s] Hide color effects  ",	rogue.trueColorMode ? " " : "X");
			}
      buttons[buttonCount].hotkey[0] = TRUE_COLORS_KEY;
      takeActionOurselves[buttonCount] = true;
      buttonCount++;
			if (KEYBOARD_LABELS) {
					sprintf(buttons[buttonCount].text, "  %s]: %s[%s] Display stealth range  ",	yellowColorEscape, whiteColorEscape, rogue.displayAggroRangeMode ? "X" : " ");
			} else {
					sprintf(buttons[buttonCount].text, "  [%s] Show stealth range  ",	rogue.displayAggroRangeMode ? "X" : " ");
			}
      buttons[buttonCount].hotkey[0] = AGGRO_DISPLAY_KEY;
      takeActionOurselves[buttonCount] = true;
      buttonCount++;
      // if (KEYBOARD_LABELS) {
			// 	sprintf(buttons[buttonCount].text, "  %s[: %s%s low hitpoint warnings  ",	yellowColorEscape, whiteColorEscape, rogue.warningPauseMode ? "Disable" : "Enable");
			// } else {
			// 	sprintf(buttons[buttonCount].text, "  %s low hitpoint warnings  ",	rogue.warningPauseMode ? "Disable" : "Enable");
			// }
			// buttons[buttonCount].hotkey[0] = WARNING_PAUSE_KEY;
			// takeActionOurselves[buttonCount] = true;
			// buttonCount++;
			sprintf(buttons[buttonCount].text, "    %s---", darkGrayColorEscape);
      buttons[buttonCount].flags &= ~B_ENABLED;
      buttonCount++;

			if (KEYBOARD_LABELS) {
					sprintf(buttons[buttonCount].text, "  %{s}D: %{s}Discovered items  ",	yellowColorEscape, whiteColorEscape);
			} else {
					strcpy(buttons[buttonCount].text, "  Discovered items  ");
			}
      buttons[buttonCount].hotkey[0] = DISCOVERIES_KEY;
      buttonCount++;
			if (KEYBOARD_LABELS) {
					sprintf(buttons[buttonCount].text, "  %s~: %{s}View dungeon seed  ",	yellowColorEscape, whiteColorEscape);
			} else {
					strcpy(buttons[buttonCount].text, "  View dungeon seed  ");
			}
      buttons[buttonCount].hotkey[0] = SEED_KEY;
      buttonCount++;
      if (KEYBOARD_LABELS) { // No help button if we're not in keyboard mode.
				sprintf(buttons[buttonCount].text, "  %s?: %{s}Help  ", yellowColorEscape, whiteColorEscape);
          buttons[buttonCount].hotkey[0] = HELP_KEY;
          buttonCount++;
      }
			sprintf(buttons[buttonCount].text, "    %s---", darkGrayColorEscape);
      buttons[buttonCount].flags &= ~B_ENABLED;
      buttonCount++;

			if (KEYBOARD_LABELS) {
					sprintf(buttons[buttonCount].text, "  %{s}Q: %{s}Quit %s  ",	yellowColorEscape, whiteColorEscape, (playingBack ? "to title screen" : "without saving"));
			} else {
					sprintf(buttons[buttonCount].text, "  Quit %s  ",	(playingBack ? "to title screen" : "without saving"));
			}
      buttons[buttonCount].hotkey[0] = QUIT_KEY;
      buttonCount++;

			strcpy(buttons[buttonCount].text, " ");
      buttons[buttonCount].flags &= ~B_ENABLED;
      buttonCount++;

      for (i=0; i<buttonCount; i++) {
          longestName = max(longestName, strLenWithoutEscapes(buttons[i].text));
      }
			if (x + longestName >= COLS) {
					x = COLS - longestName - 1;
			}
      y = ROWS - buttonCount;
      for (i=0; i<buttonCount; i++) {
          buttons[i].x = x;
          buttons[i].y = y + i;
          for (j = strLenWithoutEscapes(buttons[i].text); j < longestName; j++) {
						strcat(buttons[i].text, " "); // Schlemiel the Painter, but who cares.
          }
      }

      clearDisplayBuffer(dbuf);
      rectangularShading(x - 1, y, longestName + 2, buttonCount, black, INTERFACE_OPACITY / 2, dbuf);
      overlayDisplayBuffer(dbuf, rbuf);
      buttonChosen = await buttonInputLoop(buttons, buttonCount, x - 1, y, longestName + 2, buttonCount, NULL);
      overlayDisplayBuffer(rbuf, NULL);
      if (buttonChosen == -1) {
          return -1;
      }
			else if (takeActionOurselves[buttonChosen])
			{
          theEvent.eventType = KEYSTROKE;
          theEvent.param1 = buttons[buttonChosen].hotkey[0];
          theEvent.param2 = 0;
          theEvent.shiftKey = theEvent.controlKey = false;
          await executeEvent(theEvent);
      } else {
          return buttons[buttonChosen].hotkey[0];
      }
  } while (takeActionOurselves[buttonChosen]);

  brogueAssert(false);
}


const MAX_MENU_BUTTON_COUNT = 5;

function initializeMenuButtons( /* buttonState */ state, buttons /* brogueButton[5] */) {
	let i, x, buttonCount;
	const goldTextEscape = STRING(); // char[MAX_MENU_BUTTON_COUNT] = "";
	const whiteTextEscape = STRING(); // char[MAX_MENU_BUTTON_COUNT] = "";
	let tempColor;

	encodeMessageColor(goldTextEscape, 0, KEYBOARD_LABELS ? yellow : white);
	encodeMessageColor(whiteTextEscape, 0, white);

	for (i=0; i<MAX_MENU_BUTTON_COUNT; i++) {
		initializeButton(buttons[i]);
		buttons[i].opacity = 75;
		buttons[i].buttonColor.copy(interfaceButtonColor);
		buttons[i].y = ROWS - 1;
		buttons[i].flags |= B_WIDE_CLICK_AREA;
		buttons[i].flags &= ~B_KEYPRESS_HIGHLIGHT;
	}

	buttonCount = 0;

	if (rogue.playbackMode) {
		if (KEYBOARD_LABELS) {
				sprintf(buttons[buttonCount].text,  " Unpause (%{s}space%s) ", goldTextEscape, whiteTextEscape);
		} else {
				strcpy(buttons[buttonCount].text,   "     Unpause     ");
		}
		buttons[buttonCount].hotkey[0] = ACKNOWLEDGE_KEY;
		buttonCount++;

		if (KEYBOARD_LABELS) {
				sprintf(buttons[buttonCount].text,  "Omniscience (%{s}tab%s)", goldTextEscape, whiteTextEscape);
		} else {
				strcpy(buttons[buttonCount].text,	"   Omniscience   ");
		}
		buttons[buttonCount].hotkey[0] = TAB_KEY;
		buttonCount++;

		if (KEYBOARD_LABELS) {
				sprintf(buttons[buttonCount].text,	" Next Turn (%{s}l%s) ", goldTextEscape, whiteTextEscape);
		} else {
				strcpy(buttons[buttonCount].text,	"   Next Turn   ");
		}
		buttons[buttonCount].hotkey[0] = RIGHT_KEY;
		buttons[buttonCount].hotkey[1] = RIGHT_ARROW;
		buttons[buttonCount].hotkey[2] = NUMPAD_6;
		buttonCount++;

		strcpy(buttons[buttonCount].text,		"  Menu  ");
		buttonCount++;
	} else {
		sprintf(buttons[buttonCount].text,	"   E%{s}x%{s}plore   ", goldTextEscape, whiteTextEscape);
		buttons[buttonCount].hotkey[0] = EXPLORE_KEY;
		buttons[buttonCount].hotkey[1] = 'X';
		buttonCount++;

		if (KEYBOARD_LABELS) {
				sprintf(buttons[buttonCount].text,	"   Rest (%{s}z%s)   ", goldTextEscape, whiteTextEscape);
		} else {
				strcpy(buttons[buttonCount].text,	"     Rest     ");
		}
		buttons[buttonCount].hotkey[0] = REST_KEY;
		buttonCount++;

		if (KEYBOARD_LABELS) {
				sprintf(buttons[buttonCount].text,	"  Search (%{s}s%s)  ", goldTextEscape, whiteTextEscape);
		} else {
				strcpy(buttons[buttonCount].text,	"    Search    ");
		}
		buttons[buttonCount].hotkey[0] = SEARCH_KEY;
		buttonCount++;

		strcpy(buttons[buttonCount].text,		"    Menu    ");
		buttonCount++;
	}

	sprintf(buttons[4].text,	"   %{s}I%{s}nventory   ", goldTextEscape, whiteTextEscape);
	buttons[4].hotkey[0] = INVENTORY_KEY;
	buttons[4].hotkey[1] = 'I';

	x = mapToWindowX(0);
	for (i=0; i<5; i++) {
		buttons[i].x = x;
		x += strLenWithoutEscapes(buttons[i].text) + 2; // Gap between buttons.
	}

	initializeButtonState(state,
						  buttons,
						  5,
						  mapToWindowX(0),
						  ROWS - 1,
						  COLS - mapToWindowX(0),
						  1);

	for (i=0; i < 5; i++) {
		drawButton(state.buttons[i], BUTTON_NORMAL, state.rbuf);
	}
	for (i=0; i<COLS; i++) { // So the buttons stay (but are dimmed and desaturated) when inactive.
		tempColor = colorFromComponents(state.rbuf[i][ROWS - 1].backColorComponents);
		desaturate(tempColor, 60);
		applyColorAverage(tempColor, black, 50);
		storeColorComponents(state.rbuf[i][ROWS - 1].backColorComponents, tempColor);
		tempColor = colorFromComponents(state.rbuf[i][ROWS - 1].foreColorComponents);
		desaturate(tempColor, 60);
		applyColorAverage(tempColor, black, 50);
		storeColorComponents(state.rbuf[i][ROWS - 1].foreColorComponents, tempColor);
	}
}


function recordCurrentCreatureHealths() {
    let monst;	// creature *
    CYCLE_MONSTERS_AND_PLAYERS( (monst) => {
        monst.previousHealthPoints = monst.currentHP;
    });
}


// This is basically the main loop for the game.
async function mainInputLoop() {
	const originLoc = [-1, -1]; // short[2],
	const pathDestination = [-1, -1]; // short[2],
	const oldTargetLoc = [-1, -1]; // short[2],
	const path = ARRAY(1000, () => [-1, -1] ); // [1000][2],
	let steps, oldRNG, dir, newX, newY;
	let monst = null;	// creature *
	let theItem; // item *
	const rbuf = GRID(COLS, ROWS, cellDisplayBuffer ); // cellDisplayBuffer[COLS][ROWS];

	let canceled, targetConfirmed, tabKey, focusedOnMonster, focusedOnItem, focusedOnTerrain, playingBack, doEvent, textDisplayed;

	const theEvent = rogueEvent();
	let costMap, playerPathingMap, cursorSnapMap;
	let buttons = ARRAY(5, brogueButton ); // [5] = {{{0}}};
	const state = buttonState();
	let buttonInput;
  let backupCost;

	const cursor = rogue.cursorLoc; // shorthand

	canceled = false;
	rogue.cursorMode = false; // Controls whether the keyboard moves the cursor or the character.
	steps = 0;

	rogue.cursorPathIntensity = (rogue.cursorMode ? 50 : 20);

	// Initialize buttons.
	initializeMenuButtons(state, buttons);

	playingBack = rogue.playbackMode;
	rogue.playbackMode = false;
	costMap = allocGrid();
  playerPathingMap = allocGrid();
  cursorSnapMap = allocGrid();

	cursor[0] = cursor[1] = -1;

	while (!rogue.gameHasEnded && (!playingBack || !canceled)) { // repeats until the game ends

		// assureCosmeticRNG();
		// oldRNG = rogue.RNG;
		// rogue.RNG = RNG_COSMETIC;

		focusedOnMonster = focusedOnItem = focusedOnTerrain = false;
		steps = 0;
		clearCursorPath();

		originLoc[0] = player.xLoc;
		originLoc[1] = player.yLoc;

		if (playingBack && rogue.cursorMode) {
			await temporaryMessage("Examine what? (<hjklyubn>, mouse, or <tab>)", false);
		}

		if (!playingBack
			&& player.xLoc == cursor[0]
			&& player.yLoc == cursor[1]
			&& oldTargetLoc[0] == cursor[0]
			&& oldTargetLoc[1] == cursor[1])
		{
			// Path hides when you reach your destination.
			rogue.cursorMode = false;
			rogue.cursorPathIntensity = (rogue.cursorMode ? 50 : 20);
			cursor[0] = -1;
			cursor[1] = -1;
		}

		oldTargetLoc[0] = cursor[0];
		oldTargetLoc[1] = cursor[1];

		populateCreatureCostMap(costMap, player);

		fillGrid(playerPathingMap, 30000);
		playerPathingMap[player.xLoc][player.yLoc] = 0;
		dijkstraScan(playerPathingMap, costMap, true);
    processSnapMap(cursorSnapMap, costMap);

		do {
			textDisplayed = false;

			// Draw the cursor and path
			if (coordinatesAreInMap(oldTargetLoc[0], oldTargetLoc[1])) {
				refreshDungeonCell(oldTargetLoc[0], oldTargetLoc[1]);				// Remove old cursor.
			}
			if (!playingBack) {
				if (coordinatesAreInMap(oldTargetLoc[0], oldTargetLoc[1])) {
					hilitePath(path, steps, true);									// Unhilite old path.
				}
				if (coordinatesAreInMap(cursor[0], cursor[1])) {
					if (cursorSnapMap[cursor[0]][cursor[1]] >= 0
						&& cursorSnapMap[cursor[0]][cursor[1]] < 30000)
					{
						pathDestination[0] = cursor[0];
						pathDestination[1] = cursor[1];
					} else {
						// If the cursor is aimed at an inaccessible area, find the nearest accessible area to path toward.
						getClosestValidLocationOnMap(pathDestination, cursorSnapMap, cursor[0], cursor[1]);
					}

          fillGrid(playerPathingMap, 30000);
          playerPathingMap[pathDestination[0]][pathDestination[1]] = 0;
          backupCost = costMap[pathDestination[0]][pathDestination[1]];
          costMap[pathDestination[0]][pathDestination[1]] = 1;
          dijkstraScan(playerPathingMap, costMap, true);
          costMap[pathDestination[0]][pathDestination[1]] = backupCost;
          steps = getPlayerPathOnMap(path, playerPathingMap, player.xLoc, player.yLoc);

//					steps = getPlayerPathOnMap(path, playerPathingMap, pathDestination[0], pathDestination[1]) - 1;	// Get new path.
//					reversePath(path, steps);   // Flip it around, back-to-front.

          if (steps >= 0) {
              path[steps][0] = pathDestination[0];
              path[steps][1] = pathDestination[1];
          }
					steps++;
//					if (playerPathingMap[cursor[0]][cursor[1]] != 1
          if (playerPathingMap[player.xLoc][player.yLoc] != 1
						|| pathDestination[0] != cursor[0]
						|| pathDestination[1] != cursor[1])
					{
						hilitePath(path, steps, false);		// Hilite new path.
					}
				}
			}

			if (coordinatesAreInMap(cursor[0], cursor[1])) {
				hiliteCell(cursor[0], cursor[1], white,
						   (steps <= 0
								 || (path[steps-1][0] == cursor[0] && path[steps-1][1] == cursor[1])
								 || (!playingBack && distanceBetween(player.xLoc, player.yLoc, cursor[0], cursor[1]) <= 1) ? 100 : 25),
						   true);

				oldTargetLoc[0] = cursor[0];
				oldTargetLoc[1] = cursor[1];

				monst = monsterAtLoc(cursor[0], cursor[1]);
				theItem = itemAtLoc(cursor[0], cursor[1]);
				if (monst != NULL && (canSeeMonster(monst) || rogue.playbackOmniscience)) {
					rogue.playbackMode = playingBack;
					refreshSideBar(cursor[0], cursor[1], false);
					rogue.playbackMode = false;

					focusedOnMonster = true;
					if (monst !== player && (!player.status[STATUS_HALLUCINATING] || rogue.playbackOmniscience)) {
						printMonsterDetails(monst, rbuf);
						textDisplayed = true;
					}
				} else if (theItem != NULL && playerCanSeeOrSense(cursor[0], cursor[1])) {
					rogue.playbackMode = playingBack;
					refreshSideBar(cursor[0], cursor[1], false);
					rogue.playbackMode = false;

					focusedOnItem = true;
					if (!player.status[STATUS_HALLUCINATING] || rogue.playbackOmniscience) {
						printFloorItemDetails(theItem, rbuf);
						textDisplayed = true;
					}
				} else if (cellHasTMFlag(cursor[0], cursor[1], TM_LIST_IN_SIDEBAR) && playerCanSeeOrSense(cursor[0], cursor[1])) {
					rogue.playbackMode = playingBack;
					refreshSideBar(cursor[0], cursor[1], false);
					rogue.playbackMode = false;
          focusedOnTerrain = true;
				}

				printLocationDescription(cursor[0], cursor[1]);
			}

			// Get the input!
			rogue.playbackMode = playingBack;
			// TODO - Move targetConfirmed, canceled, tabKey to event or return
			const moveResult = await moveCursor(/* &targetConfirmed, &canceled, &tabKey, */ cursor, theEvent, state, !textDisplayed, rogue.cursorMode, true);
			doEvent = moveResult.executeEvent;
			targetConfirmed = moveResult.targetConfirmed;
			canceled = moveResult.canceled;
			tabKey = moveResult.tabKey;
			rogue.playbackMode = false;

			if (state.buttonChosen == 3) { // Actions menu button.
				buttonInput = await actionMenu(buttons[3].x - 4, playingBack); // Returns the corresponding keystroke.
				if (buttonInput == -1) { // Canceled.
					doEvent = false;
				} else {
					theEvent.eventType = KEYSTROKE;
					theEvent.param1 = buttonInput;
					theEvent.param2 = 0;
					theEvent.shiftKey = theEvent.controlKey = false;
					doEvent = true;
				}
			} else if (state.buttonChosen > -1) {
				theEvent.eventType = KEYSTROKE;
				theEvent.param1 = buttons[state.buttonChosen].hotkey[0];
				theEvent.param2 = 0;
			}
			state.buttonChosen = -1;

			if (playingBack) {
				if (canceled) {
					rogue.cursorMode = false;
					rogue.cursorPathIntensity = (rogue.cursorMode ? 50 : 20);
				}

				if (theEvent.eventType == KEYSTROKE
					&& theEvent.param1 == ACKNOWLEDGE_KEY) // To unpause by button during playback.
				{
					canceled = true;
				} else {
					canceled = false;
				}
			}

			if (focusedOnMonster || focusedOnItem || focusedOnTerrain) {
				focusedOnMonster = false;
				focusedOnItem = false;
        focusedOnTerrain = false;
				if (textDisplayed) {
					overlayDisplayBuffer(rbuf, 0); // Erase the monster info window.
				}
				rogue.playbackMode = playingBack;
				refreshSideBar(-1, -1, false);
				rogue.playbackMode = false;
			}

			if (tabKey && !playingBack) { // The tab key cycles the cursor through monsters, items and terrain features.
				const target = nextTargetAfter(cursor[0], cursor[1], true, true, true, true, false, theEvent.shiftKey)
				if (target) {
            cursor[0] = target.x;
            cursor[1] = target.y;
        }
			}

			if (theEvent.eventType == KEYSTROKE
				&& (theEvent.param1 == ASCEND_KEY && cursor[0] == rogue.upLoc[0] && cursor[1] == rogue.upLoc[1]
					|| theEvent.param1 == DESCEND_KEY && cursor[0] == rogue.downLoc[0] && cursor[1] == rogue.downLoc[1]))
			{
				targetConfirmed = true;
				doEvent = false;
			}
		} while (!targetConfirmed && !canceled && !doEvent && !rogue.gameHasEnded);

		if (coordinatesAreInMap(oldTargetLoc[0], oldTargetLoc[1])) {
			refreshDungeonCell(oldTargetLoc[0], oldTargetLoc[1]);						// Remove old cursor.
		}

		// restoreRNG();
		recordCurrentCreatureHealths();

		if (canceled && !playingBack) {
      hideCursor();
      confirmMessages();
		} else if (targetConfirmed && !playingBack && coordinatesAreInMap(cursor[0], cursor[1])) {
			if (theEvent.eventType == MOUSE_UP
				&& theEvent.controlKey
				&& steps > 1)
			{
				// Control-clicking moves the player one step along the path.
				for (dir=0;
					 dir < DIRECTION_COUNT && (player.xLoc + nbDirs[dir][0] != path[0][0] || player.yLoc + nbDirs[dir][1] != path[0][1]);
					 dir++);
				await playerMoves(dir);
			} else if (D_WORMHOLING) {
				await travel(cursor[0], cursor[1], true);
			} else {
				confirmMessages();
				if (originLoc[0] == cursor[0]
					&& originLoc[1] == cursor[1])
				{
					confirmMessages();
				} else if (abs(player.xLoc - cursor[0]) + abs(player.yLoc - cursor[1]) == 1 // horizontal or vertical
						   || (distanceBetween(player.xLoc, player.yLoc, cursor[0], cursor[1]) == 1 // includes diagonals
							   && (!diagonalBlocked(player.xLoc, player.yLoc, cursor[0], cursor[1], !rogue.playbackOmniscience)
                   || ((pmap[cursor[0]][cursor[1]].flags & HAS_MONSTER) && (monsterAtLoc(cursor[0], cursor[1]).info.flags & MONST_ATTACKABLE_THRU_WALLS)) // there's a turret there
                   || ((terrainFlags(cursor[0], cursor[1]) & T_OBSTRUCTS_PASSABILITY) && (terrainMechFlags(cursor[0], cursor[1]) & TM_PROMOTES_ON_PLAYER_ENTRY))))) // there's a lever there
				{
             for (dir=0;
                  dir < DIRECTION_COUNT && (player.xLoc + nbDirs[dir][0] != cursor[0] || player.yLoc + nbDirs[dir][1] != cursor[1]);
                  dir++);
             await playerMoves(dir);
         } else if (steps) {
             await travelRoute(path, steps);
         }
			}
		} else if (doEvent) {
			// If the player entered input during moveCursor() that wasn't a cursor movement command.
			// Mainly, we want to filter out directional keystrokes when we're in cursor mode, since
			// those should move the cursor but not the player.
      brogueAssert(rogue.RNG == RNG_SUBSTANTIVE);
			if (playingBack) {
				rogue.playbackMode = true;
				executePlaybackInput(theEvent);
				playingBack = rogue.playbackMode;
				rogue.playbackMode = false;
			} else {
				await executeEvent(theEvent);
				if (rogue.playbackMode) {
					playingBack = true;
					rogue.playbackMode = false;
					confirmMessages();
					break;
				}
			}
		}
	}

	rogue.playbackMode = playingBack;
	refreshSideBar(-1, -1, false);
	freeGrid(costMap);
  freeGrid(playerPathingMap);
  freeGrid(cursorSnapMap);
}

//
// // accuracy depends on how many clock cycles occur per second
// function MILLISECONDS() { return performance.now(); } // (clock() * 1000 / CLOCKS_PER_SEC);

const MILLISECONDS_FOR_CAUTION	= 100;

function considerCautiousMode() {
	/*
	signed long oldMilliseconds = rogue.milliseconds;
	rogue.milliseconds = MILLISECONDS();
	clock_t i = clock();
	printf("\n%li", i);
	if (rogue.milliseconds - oldMilliseconds < MILLISECONDS_FOR_CAUTION) {
		rogue.cautiousMode = true;
	}*/
}

// // flags the entire window as needing to be redrawn at next flush.
// // very low level -- does not interface with the guts of the game.
// function refreshScreen() {
// 	let i, j;
//
// 	for( i=0; i<COLS; i++ ) {
// 		for( j=0; j<ROWS; j++ ) {
// 			displayBuffer[i][j].needsUpdate = true;
// 		}
// 	}
// 	commitDraws();
// }
//

// higher-level redraw
function displayLevel() {
	let i, j;

	for( i=0; i<DCOLS; i++ ) {
		for( j=0; j<DROWS; j++ ) {
			refreshDungeonCell(i, j);
		}
	}
}

function dumpDisplay(buf) {
	let i, j;

	buf = buf || displayBuffer;

	for( j=0; j < ROWS; j++) {
		let line = '';
		for( i=0; i < COLS; i++) {
			line += buf[i][j].char;
		}
		console.log(line);
	}
}


// converts colors into components
function storeColorComponents( components /* char[3] */, /* color */ theColor) {
	let rand = cosmetic_range(0, theColor.rand);
	components[0] = max(0, min(100, theColor.red + cosmetic_range(0, theColor.redRand) + rand));
	components[1] = max(0, min(100, theColor.green + cosmetic_range(0, theColor.greenRand) + rand));
	components[2] = max(0, min(100, theColor.blue + cosmetic_range(0, theColor.blueRand) + rand));
}


function bakeTerrainColors(/* color */foreColor, /* color */backColor, x, y) {
    let vals;
    if (rogue.trueColorMode) {
        const nf = 1000;
        const nb = 0;
        const neutralColors = [nf, nf, nf, nf, nb, nb, nb, nb];
        vals = neutralColors;
    } else {
        vals = terrainRandomValues[x][y];
    }

	const foreRand = Math.round(foreColor.rand * vals[6] / 1000);
	const backRand = Math.round(backColor.rand * vals[7] / 1000);

	foreColor.red   += Math.round(foreColor.redRand * vals[0] / 1000 + foreRand);
	foreColor.green += Math.round(foreColor.greenRand * vals[1] / 1000 + foreRand);
	foreColor.blue  += Math.round(foreColor.blueRand * vals[2] / 1000 + foreRand);
	foreColor.redRand = foreColor.greenRand = foreColor.blueRand = foreColor.rand = 0;

	backColor.red   += Math.round(backColor.redRand * vals[3] / 1000 + backRand);
	backColor.green += Math.round(backColor.greenRand * vals[4] / 1000 + backRand);
	backColor.blue  += Math.round(backColor.blueRand * vals[5] / 1000 + backRand);
	backColor.redRand = backColor.greenRand = backColor.blueRand = backColor.rand = 0;

	if (foreColor.colorDances || backColor.colorDances) {
		pmap[x][y].flags |= TERRAIN_COLORS_DANCING;
	} else {
		pmap[x][y].flags &= ~TERRAIN_COLORS_DANCING;
	}
}


function bakeColor(/* color */theColor) {
	let rand;
	rand = cosmetic_range(0, theColor.rand);
	theColor.red   += Math.round(cosmetic_range(0, theColor.redRand) + rand);
	theColor.green += Math.round(cosmetic_range(0, theColor.greenRand) + rand);
	theColor.blue  += Math.round(cosmetic_range(0, theColor.blueRand) + rand);
	theColor.redRand = theColor.greenRand = theColor.blueRand = theColor.rand = 0;
}


function shuffleTerrainColors(percentOfCells, refreshCells) {
  let dir;
	let i, j;

	// assureCosmeticRNG();

	for (i=0; i<DCOLS; i++) {
		for(j=0; j<DROWS; j++) {
			if (playerCanSeeOrSense(i, j)
				&& (!rogue.automationActive || !(rogue.playerTurnNumber % 5))
				&& ((pmap[i][j].flags & TERRAIN_COLORS_DANCING)
					|| (player.status[STATUS_HALLUCINATING] && playerCanDirectlySee(i, j)))
				&& (i != rogue.cursorLoc[0] || j != rogue.cursorLoc[1])
				&& (percentOfCells >= 100 || cosmetic_range(1, 100) <= percentOfCells))
			{
					for (dir=0; dir<DIRECTION_COUNT; dir++) {
						terrainRandomValues[i][j][dir] += cosmetic_range(-600, 600);
						terrainRandomValues[i][j][dir] = clamp(terrainRandomValues[i][j][dir], 0, 1000);
					}

					if (refreshCells) {
						refreshDungeonCell(i, j);
					}
				}
		}
	}

	// restoreRNG();
}


// if forecolor is too similar to back, darken or lighten it and return true.
// Assumes colors have already been baked (no random components).
function separateColors(/* color */ fore, /* color */ back) {
	let f, b, modifier = null;
	let failsafe;
	let madeChange;

	f = fore.clone();
	b = back.clone();

	f.red			= clamp(f.red, 0, 100);
	f.green		= clamp(f.green, 0, 100);
	f.blue		= clamp(f.blue, 0, 100);
	b.red			= clamp(b.red, 0, 100);
	b.green		= clamp(b.green, 0, 100);
	b.blue		= clamp(b.blue, 0, 100);

	if (f.red + f.blue + f.green > 50 * 3) {
		modifier = black;
	} else {
		modifier = white;
	}

	madeChange = false;
	failsafe = 10;

	while(COLOR_DIFF(f, b) < MIN_COLOR_DIFF && --failsafe) {
		applyColorAverage(f, modifier, 20);
		madeChange = true;
	}

	if (madeChange) {
		fore.copy(f);
		return true;
	} else {
		return false;
	}
}

function normColor( /* color */ baseColor, aggregateMultiplier, colorTranslation) {

    baseColor.red += colorTranslation;
    baseColor.green += colorTranslation;
    baseColor.blue += colorTranslation;
    let vectorLength =  baseColor.red + baseColor.green + baseColor.blue;

    if (vectorLength != 0) {
        baseColor.red =    Math.round(baseColor.red * 300    / vectorLength * aggregateMultiplier / 100);
        baseColor.green =  Math.round(baseColor.green * 300  / vectorLength * aggregateMultiplier / 100);
        baseColor.blue =   Math.round(baseColor.blue * 300   / vectorLength * aggregateMultiplier / 100);
    }
    baseColor.redRand = 0;
    baseColor.greenRand = 0;
    baseColor.blueRand = 0;
    baseColor.rand = 0;
}


var CELL_APPEARANCE = {
	char: null,
	foreColor: color(),
	backColor: color()
};

// okay, this is kind of a beast...
function getCellAppearance(x, y) {
	let bestBCPriority, bestFCPriority, bestCharPriority;
  let distance;
	let cellChar = 0;
	let cellForeColor = color(), cellBackColor = color(), lightMultiplierColor = color(), gasAugmentColor = color();
	let monsterWithDetectedItem = false, needDistinctness = false;
	let gasAugmentWeight = 0;
	let monst = NULL;	// creature *
	let theItem = NULL; // item *
  let tile = NOTHING;	// enum tileType
	const itemChars = [POTION_CHAR, SCROLL_CHAR, FOOD_CHAR, WAND_CHAR,
						STAFF_CHAR, GOLD_CHAR, ARMOR_CHAR, WEAPON_CHAR, RING_CHAR, CHARM_CHAR];
	let layer, maxLayer;	// enum dungeonLayers

	// assureCosmeticRNG();

  brogueAssert(coordinatesAreInMap(x, y));

	if (pmap[x][y].flags & HAS_MONSTER) {
		monst = monsterAtLoc(x, y);
	} else if (pmap[x][y].flags & HAS_DORMANT_MONSTER) {
		monst = dormantMonsterAtLoc(x, y);
	}
	if (monst) {
		monsterWithDetectedItem = (monst.carriedItem && (monst.carriedItem.flags & ITEM_MAGIC_DETECTED)
								   && itemMagicChar(monst.carriedItem) && !canSeeMonster(monst));
	}

	if (monsterWithDetectedItem) {
		theItem = monst.carriedItem;
	} else {
		theItem = itemAtLoc(x, y);
	}

	if (!playerCanSeeOrSense(x, y)
		&& !(pmap[x][y].flags & (ITEM_DETECTED | HAS_PLAYER))
		&& (!monst || !monsterRevealed(monst))
		&& !monsterWithDetectedItem
		&& (pmap[x][y].flags & (DISCOVERED | MAGIC_MAPPED))
		&& (pmap[x][y].flags & STABLE_MEMORY))
	{
		// restore memory
		cellChar = pmap[x][y].rememberedAppearance.char;
		cellForeColor = colorFromComponents(pmap[x][y].rememberedAppearance.foreColorComponents);
		cellBackColor = colorFromComponents(pmap[x][y].rememberedAppearance.backColorComponents);
	} else {
		// Find the highest-priority fore color, back color and character.
		bestFCPriority = bestBCPriority = bestCharPriority = 10000;

    // Default to the appearance of floor.
    cellForeColor.copy(tileCatalog[FLOOR].foreColor);
    cellBackColor.copy(tileCatalog[FLOOR].backColor);
    cellChar = tileCatalog[FLOOR].displayChar;

		if (!(pmap[x][y].flags & DISCOVERED) && !rogue.playbackOmniscience) {
      if (pmap[x][y].flags & MAGIC_MAPPED) {
          maxLayer = LIQUID + 1; // Can see only dungeon and liquid layers with magic mapping.
      } else {
          maxLayer = 0; // Terrain shouldn't influence the tile appearance at all if it hasn't been discovered.
      }
		} else {
			maxLayer = NUMBER_TERRAIN_LAYERS;
		}

		for (layer = 0; layer < maxLayer; layer++) {
			// Gas shows up as a color average, not directly.
			if (pmap[x][y].layers[layer] && layer != GAS) {
        tile = pmap[x][y].layers[layer];
        if (rogue.playbackOmniscience && (tileCatalog[tile].mechFlags & TM_IS_SECRET)) {
            tile = dungeonFeatureCatalog[tileCatalog[tile].discoverType].tile;
        }

				if (tileCatalog[tile].drawPriority < bestFCPriority
					&& tileCatalog[tile].foreColor)
				{
					cellForeColor.copy(tileCatalog[tile].foreColor);
					bestFCPriority = tileCatalog[tile].drawPriority;
				}
				if (tileCatalog[tile].drawPriority < bestBCPriority
					&& tileCatalog[tile].backColor)
				{
					cellBackColor.copy(tileCatalog[tile].backColor);
					bestBCPriority = tileCatalog[tile].drawPriority;
				}
				if (tileCatalog[tile].drawPriority < bestCharPriority
					&& tileCatalog[tile].displayChar)
				{
					cellChar = tileCatalog[tile].displayChar;
					bestCharPriority = tileCatalog[tile].drawPriority;
          needDistinctness = (tileCatalog[tile].mechFlags & TM_VISUALLY_DISTINCT) ? true : false;
				}
			}
		}

		if (rogue.trueColorMode) {
			lightMultiplierColor.copy(colorMultiplier100);
		} else {
			colorMultiplierFromDungeonLight(x, y, lightMultiplierColor);
		}

		if (pmap[x][y].layers[GAS]
			&& tileCatalog[pmap[x][y].layers[GAS]].backColor)
		{
			gasAugmentColor.copy(tileCatalog[pmap[x][y].layers[GAS]].backColor);
			if (rogue.trueColorMode) {
				gasAugmentWeight = 30;
			} else {
				gasAugmentWeight = min(90, 30 + pmap[x][y].volume);
			}
		}

    if (D_DISABLE_BACKGROUND_COLORS) {
        if (COLOR_DIFF(cellBackColor, black) > COLOR_DIFF(cellForeColor, black)) {
            cellForeColor.copy(cellBackColor);
        }
        cellBackColor.copy(black);
        needDistinctness = true;
    }

		if (pmap[x][y].flags & HAS_PLAYER) {
			cellChar = player.info.displayChar;
			cellForeColor.copy(player.info.foreColor);
			needDistinctness = true;
		} else if (((pmap[x][y].flags & HAS_ITEM) && (pmap[x][y].flags & ITEM_DETECTED)
					&& itemMagicChar(theItem)
					&& !playerCanSeeOrSense(x, y))
				|| monsterWithDetectedItem)
		{
			cellChar = itemMagicChar(theItem);
			needDistinctness = true;
			if (cellChar == GOOD_MAGIC_CHAR) {
				cellForeColor.copy(goodMessageColor);
			} else if (cellChar == BAD_MAGIC_CHAR) {
				cellForeColor.copy(badMessageColor);
			} else {
        cellForeColor.copy(white);
      }
			//cellBackColor = black;
		} else if ((pmap[x][y].flags & HAS_MONSTER)
				   && (playerCanSeeOrSense(x, y) || ((monst.info.flags & MONST_IMMOBILE) && (pmap[x][y].flags & DISCOVERED)))
                   && (!monsterIsHidden(monst, player) || rogue.playbackOmniscience)) {
			needDistinctness = true;
			if (player.status[STATUS_HALLUCINATING] > 0 && !(monst.info.flags & (MONST_INANIMATE | MONST_INVULNERABLE)) && !rogue.playbackOmniscience) {
				cellChar = String.fromCharCode(cosmetic_range('a'.charCodeAt(0), 'z'.charCodeAt(0)));
        if (cosmetic_range(0, 1)) {
            cellChar = cellChar.toUpperCase();
        }
				cellForeColor.copy(monsterCatalog[cosmetic_range(1, NUMBER_MONSTER_KINDS - 1)].foreColor);
			} else {
				cellChar = monst.info.displayChar;
        cellForeColor.copy(monst.info.foreColor);
				if (monst.status[STATUS_INVISIBLE] || (monst.bookkeepingFlags & MB_SUBMERGED)) {
                    // Invisible allies show up on the screen with a transparency effect.
					//cellForeColor = cellBackColor;
          applyColorAverage(cellForeColor, cellBackColor, 75);
				} else {
					if (monst.creatureState == MONSTER_ALLY
						&& (monst.info.displayChar >= 'a' && monst.info.displayChar <= 'z' || monst.info.displayChar >= 'A' && monst.info.displayChar <= 'Z'))
					{
						if (rogue.trueColorMode) {
                cellForeColor.copy(white);
            } else {
                //applyColorAverage(&cellForeColor, &blue, 50);
                applyColorAverage(cellForeColor, pink, 50);
            }
					}
				}
				//DEBUG if (monst.bookkeepingFlags & MB_LEADER) applyColorAverage(&cellBackColor, &purple, 50);
			}
		} else if (monst
           && monsterRevealed(monst)
				   && !canSeeMonster(monst)) {
			if (player.status[STATUS_HALLUCINATING] && !rogue.playbackOmniscience) {
				cellChar = (cosmetic_range(0, 1) ? 'X' : 'x');
			} else {
				cellChar = (monst.info.displayChar >= 'a' && monst.info.displayChar <= 'z' ? 'x' : 'X');
			}
			cellForeColor.copy(white);
			lightMultiplierColor.copy(white);
			if (!(pmap[x][y].flags & DISCOVERED)) {
				cellBackColor.copy(black);
				gasAugmentColor.copy(black);
			}
		} else if ((pmap[x][y].flags & HAS_ITEM) && !cellHasTerrainFlag(x, y, T_OBSTRUCTS_ITEMS)
				   && (playerCanSeeOrSense(x, y) || ((pmap[x][y].flags & DISCOVERED) && !cellHasTerrainFlag(x, y, T_MOVES_ITEMS))))
 	  {
			 needDistinctness = true;
			if (player.status[STATUS_HALLUCINATING] && !rogue.playbackOmniscience) {
				cellChar = itemChars[cosmetic_range(0, 9)];
				cellForeColor.copy(itemColor);
			} else {
				theItem = itemAtLoc(x, y);
				cellChar = theItem.displayChar;
				cellForeColor.copy(theItem.foreColor);
			}
		} else if (playerCanSeeOrSense(x, y) || (pmap[x][y].flags & (DISCOVERED | MAGIC_MAPPED))) {
			// just don't want these to be plotted as black
		} else {
			CELL_APPEARANCE.char = ' ';
			CELL_APPEARANCE.foreColor.copy(black);
			CELL_APPEARANCE.backColor.copy(undiscoveredColor);

      if (D_DISABLE_BACKGROUND_COLORS) CELL_APPEARANCE.backColor.copy(black);

			// restoreRNG();
			return CELL_APPEARANCE;
		}

		if (gasAugmentWeight && ((pmap[x][y].flags & DISCOVERED) || rogue.playbackOmniscience)) {
			if (!rogue.trueColorMode || !needDistinctness) {
				applyColorAverage(cellForeColor, gasAugmentColor, gasAugmentWeight);
			}
			// phantoms create sillhouettes in gas clouds
			if ((pmap[x][y].flags & HAS_MONSTER)
				&& monst.status[STATUS_INVISIBLE]
				&& playerCanSeeOrSense(x, y)
                && !monsterRevealed(monst)
                && !monsterHiddenBySubmersion(monst, player)) {

				if (player.status[STATUS_HALLUCINATING] && !rogue.playbackOmniscience) {
					cellChar = monsterCatalog[cosmetic_range(1, NUMBER_MONSTER_KINDS - 1)].displayChar;
				} else {
					cellChar = monst.info.displayChar;
				}
				cellForeColor.copy(cellBackColor);
			}
			applyColorAverage(cellBackColor, gasAugmentColor, gasAugmentWeight);
		}

		if (!(pmap[x][y].flags & (ANY_KIND_OF_VISIBLE | ITEM_DETECTED | HAS_PLAYER))
			&& !playerCanSeeOrSense(x, y)
			&& (!monst || !monsterRevealed(monst)) && !monsterWithDetectedItem)
		{
      if (rogue.trueColorMode) {
          bakeTerrainColors(cellForeColor, cellBackColor, x, y);
      }

			// store memory
			storeColorComponents(pmap[x][y].rememberedAppearance.foreColorComponents, cellForeColor);
			storeColorComponents(pmap[x][y].rememberedAppearance.backColorComponents, cellBackColor);

			applyColorAugment(lightMultiplierColor, basicLightColor, 100);
			if (!rogue.trueColorMode || !needDistinctness) {
				applyColorMultiplier(cellForeColor, lightMultiplierColor);
			}
			applyColorMultiplier(cellBackColor, lightMultiplierColor);
			bakeTerrainColors(cellForeColor, cellBackColor, x, y);

			pmap[x][y].rememberedAppearance.char = cellChar;
			pmap[x][y].flags |= STABLE_MEMORY;
			if (pmap[x][y].flags & HAS_ITEM) {
        theItem = itemAtLoc(x, y);
				pmap[x][y].rememberedItemCategory = theItem.category;
        pmap[x][y].rememberedItemKind = theItem.kind;
        pmap[x][y].rememberedItemQuantity = theItem.quantity;
			} else {
				pmap[x][y].rememberedItemCategory = 0;
        pmap[x][y].rememberedItemKind = 0;
        pmap[x][y].rememberedItemQuantity = 0;
			}

			// Then restore, so that it looks the same on this pass as it will when later refreshed.
			cellForeColor = colorFromComponents(pmap[x][y].rememberedAppearance.foreColorComponents);
			cellBackColor = colorFromComponents(pmap[x][y].rememberedAppearance.backColorComponents);
		}
	}

	if (((pmap[x][y].flags & ITEM_DETECTED) || monsterWithDetectedItem
		 || (monst && monsterRevealed(monst)))
		&& !playerCanSeeOrSense(x, y)) {
		// do nothing
	} else if (!(pmap[x][y].flags & VISIBLE) && (pmap[x][y].flags & CLAIRVOYANT_VISIBLE)) {
		// can clairvoyantly see it
		if (rogue.trueColorMode) {
			lightMultiplierColor.copy(basicLightColor);
		} else {
			applyColorAugment(lightMultiplierColor, basicLightColor, 100);
		}
		if (!rogue.trueColorMode || !needDistinctness) {
			applyColorMultiplier(cellForeColor, lightMultiplierColor);
			applyColorMultiplier(cellForeColor, clairvoyanceColor);
		}
		applyColorMultiplier(cellBackColor, lightMultiplierColor);
		applyColorMultiplier(cellBackColor, clairvoyanceColor);
	} else if (!(pmap[x][y].flags & VISIBLE) && (pmap[x][y].flags & TELEPATHIC_VISIBLE)) {
		// Can telepathically see it through another creature's eyes.

		applyColorAugment(lightMultiplierColor, basicLightColor, 100);

		if (!rogue.trueColorMode || !needDistinctness) {
			applyColorMultiplier(cellForeColor, lightMultiplierColor);
			applyColorMultiplier(cellForeColor, telepathyMultiplier);
		}
		applyColorMultiplier(cellBackColor, lightMultiplierColor);
		applyColorMultiplier(cellBackColor, telepathyMultiplier);
	} else if (!(pmap[x][y].flags & DISCOVERED) && (pmap[x][y].flags & MAGIC_MAPPED)) {
		// magic mapped only
		if (!rogue.playbackOmniscience) {
			needDistinctness = false;
			if (!rogue.trueColorMode || !needDistinctness) {
				applyColorMultiplier(cellForeColor, magicMapColor);
			}
			applyColorMultiplier(cellBackColor, magicMapColor);
		}
	} else if (!(pmap[x][y].flags & VISIBLE) && !rogue.playbackOmniscience) {
		// if it's not visible

		needDistinctness = false;
		if (rogue.inWater) {
			applyColorAverage(cellForeColor, black, 80);
			applyColorAverage(cellBackColor, black, 80);
		} else {
			if (!cellHasTMFlag(x, y, TM_BRIGHT_MEMORY)
          && (!rogue.trueColorMode || !needDistinctness))
			{
				applyColorMultiplier(cellForeColor, memoryColor);
				applyColorAverage(cellForeColor, memoryOverlay, 25);
			}
			applyColorMultiplier(cellBackColor, memoryColor);
			applyColorAverage(cellBackColor, memoryOverlay, 25);
		}
	} else if (playerCanSeeOrSense(x, y) && rogue.playbackOmniscience && !(pmap[x][y].flags & ANY_KIND_OF_VISIBLE)) {
		// omniscience
		applyColorAugment(lightMultiplierColor, basicLightColor, 100);
		if (!rogue.trueColorMode || !needDistinctness) {
			applyColorMultiplier(cellForeColor, lightMultiplierColor);
			applyColorMultiplier(cellForeColor, omniscienceColor);
		}
    applyColorMultiplier(cellBackColor, lightMultiplierColor);
		applyColorMultiplier(cellBackColor, omniscienceColor);
	} else {
		if (!rogue.trueColorMode || !needDistinctness) {
			applyColorMultiplier(cellForeColor, lightMultiplierColor);
		}
		applyColorMultiplier(cellBackColor, lightMultiplierColor);

		if (player.status[STATUS_HALLUCINATING] && !rogue.trueColorMode) {
			randomizeColor(cellForeColor, 40 * player.status[STATUS_HALLUCINATING] / 300 + 20);
			randomizeColor(cellBackColor, 40 * player.status[STATUS_HALLUCINATING] / 300 + 20);
		}
		if (rogue.inWater) {
			applyColorMultiplier(cellForeColor, deepWaterLightColor);
			applyColorMultiplier(cellBackColor, deepWaterLightColor);
		}
	}
	// DEBUG cellBackColor.red = max(0,((scentMap[x][y] - rogue.scentTurnNumber) * 2) + 100);
	// DEBUG if (pmap[x][y].flags & KNOWN_TO_BE_TRAP_FREE) cellBackColor.red += 20;
	// DEBUG if (cellHasTerrainFlag(x, y, T_IS_FLAMMABLE)) cellBackColor.red += 50;

	if (pmap[x][y].flags & IS_IN_PATH) {
        if (cellHasTMFlag(x, y, TM_INVERT_WHEN_HIGHLIGHTED)) {
            swapColors(cellForeColor, cellBackColor);
        } else {
            if (!rogue.trueColorMode || !needDistinctness) {
                applyColorAverage(cellForeColor, yellow, rogue.cursorPathIntensity);
            }
            applyColorAverage(cellBackColor, yellow, rogue.cursorPathIntensity);
        }
		needDistinctness = true;
	}

	bakeTerrainColors(cellForeColor, cellBackColor, x, y);

    if (rogue.displayAggroRangeMode && (pmap[x][y].flags & IN_FIELD_OF_VIEW)) {
        distance = min(rogue.scentTurnNumber - scentMap[x][y], scentDistance(x, y, player.xLoc, player.yLoc));
        if (distance > rogue.aggroRange * 2) {
            applyColorAverage(cellForeColor, orange, 12);
            applyColorAverage(cellBackColor, orange, 12);
            applyColorAugment(cellForeColor, orange, 12);
            applyColorAugment(cellBackColor, orange, 12);
        }
    }

	if (rogue.trueColorMode
        && playerCanSeeOrSense(x, y))
	{
		if (displayDetail[x][y] == DV_DARK) {
      applyColorMultiplier(cellForeColor, inDarknessMultiplierColor);
      applyColorMultiplier(cellBackColor, inDarknessMultiplierColor);

			applyColorAugment(cellForeColor, purple, 10);
			applyColorAugment(cellBackColor, white, -10);
			applyColorAverage(cellBackColor, purple, 20);
		}
		else if (displayDetail[x][y] == DV_LIT)
		{
			colorMultiplierFromDungeonLight(x, y, lightMultiplierColor);
      normColor(lightMultiplierColor, 175, 50);
      //applyColorMultiplier(cellForeColor, lightMultiplierColor);
      //applyColorMultiplier(cellBackColor, lightMultiplierColor);
			applyColorAugment(cellForeColor, lightMultiplierColor, 5);
			applyColorAugment(cellBackColor, lightMultiplierColor, 5);
		}
	}

	if (needDistinctness) {
		separateColors(cellForeColor, cellBackColor);
	}

  if (D_SCENT_VISION) {
      if (rogue.scentTurnNumber > Math.floor(scentMap[x][y]) ) {
          cellBackColor.red = rogue.scentTurnNumber - Math.floor(scentMap[x][y]);
          cellBackColor.red = clamp(cellBackColor.red, 0, 100);
      } else {
          cellBackColor.green = abs(rogue.scentTurnNumber - Math.floor(scentMap[x][y]));
          cellBackColor.green = clamp(cellBackColor.green, 0, 100);
      }
  }

	CELL_APPEARANCE.char = cellChar;
	CELL_APPEARANCE.foreColor.copy(cellForeColor);
	CELL_APPEARANCE.backColor.copy(cellBackColor);

  if (D_DISABLE_BACKGROUND_COLORS) CELL_APPEARANCE.backColor.copy(black);
	// restoreRNG();

	return CELL_APPEARANCE;
}


function refreshDungeonCell(x, y) {
	let cellChar;
  brogueAssert(coordinatesAreInMap(x, y));
	const appearance = getCellAppearance(x, y);
	plotCharWithColor(appearance.char, mapToWindowX(x), mapToWindowY(y), appearance.foreColor, appearance.backColor);
}


function applyColorMultiplier(baseColor, multiplierColor) {
	baseColor.red = Math.round(baseColor.red * multiplierColor.red / 100);
	baseColor.redRand = Math.round(baseColor.redRand * multiplierColor.redRand / 100);
	baseColor.green = Math.round(baseColor.green * multiplierColor.green / 100);
	baseColor.greenRand = Math.round(baseColor.greenRand * multiplierColor.greenRand / 100);
	baseColor.blue = Math.round(baseColor.blue * multiplierColor.blue / 100);
	baseColor.blueRand = Math.round(baseColor.blueRand * multiplierColor.blueRand / 100);
	baseColor.rand = Math.round(baseColor.rand * multiplierColor.rand / 100);
	//baseColor.colorDances *= multiplierColor.colorDances;
	return;
}

function applyColorAverage(baseColor, newColor, averageWeight) {
	const weightComplement = 100 - averageWeight;
	baseColor.red = Math.round((baseColor.red * weightComplement + newColor.red * averageWeight) / 100);
	baseColor.redRand = Math.round((baseColor.redRand * weightComplement + newColor.redRand * averageWeight) / 100);
	baseColor.green = Math.round((baseColor.green * weightComplement + newColor.green * averageWeight) / 100);
	baseColor.greenRand = Math.round((baseColor.greenRand * weightComplement + newColor.greenRand * averageWeight) / 100);
	baseColor.blue = Math.round((baseColor.blue * weightComplement + newColor.blue * averageWeight) / 100);
	baseColor.blueRand = Math.round((baseColor.blueRand * weightComplement + newColor.blueRand * averageWeight) / 100);
	baseColor.rand = Math.round((baseColor.rand * weightComplement + newColor.rand * averageWeight) / 100);
	baseColor.colorDances = (baseColor.colorDances || newColor.colorDances);
	return;
}

function applyColorAugment(baseColor, augmentingColor, augmentWeight) {
	baseColor.red += Math.round((augmentingColor.red * augmentWeight) / 100);
	baseColor.redRand += Math.round((augmentingColor.redRand * augmentWeight) / 100);
	baseColor.green += Math.round((augmentingColor.green * augmentWeight) / 100);
	baseColor.greenRand += Math.round((augmentingColor.greenRand * augmentWeight) / 100);
	baseColor.blue += Math.round((augmentingColor.blue * augmentWeight) / 100);
	baseColor.blueRand += Math.round((augmentingColor.blueRand * augmentWeight) / 100);
	baseColor.rand += Math.round((augmentingColor.rand * augmentWeight) / 100);
	return;
}

function applyColorScalar(baseColor, scalar) {
	baseColor.red          = Math.round(baseColor.red        * scalar / 100);
	baseColor.redRand      = Math.round(baseColor.redRand    * scalar / 100);
	baseColor.green        = Math.round(baseColor.green      * scalar / 100);
	baseColor.greenRand    = Math.round(baseColor.greenRand  * scalar / 100);
	baseColor.blue         = Math.round(baseColor.blue       * scalar / 100);
	baseColor.blueRand     = Math.round(baseColor.blueRand   * scalar / 100);
	baseColor.rand         = Math.round(baseColor.rand       * scalar / 100);
}

function applyColorBounds(baseColor, lowerBound, upperBound) {
	baseColor.red          = clamp(baseColor.red, lowerBound, upperBound);
	baseColor.redRand      = clamp(baseColor.redRand, lowerBound, upperBound);
	baseColor.green        = clamp(baseColor.green, lowerBound, upperBound);
	baseColor.greenRand    = clamp(baseColor.greenRand, lowerBound, upperBound);
	baseColor.blue         = clamp(baseColor.blue, lowerBound, upperBound);
	baseColor.blueRand     = clamp(baseColor.blueRand, lowerBound, upperBound);
	baseColor.rand         = clamp(baseColor.rand, lowerBound, upperBound);
}

function desaturate(baseColor, weight) {
	let avg;
	avg = (baseColor.red + baseColor.green + baseColor.blue) / 3 + 1;
	baseColor.red = Math.round(baseColor.red * (100 - weight) / 100 + (avg * weight / 100));
	baseColor.green = Math.round(baseColor.green * (100 - weight) / 100 + (avg * weight / 100));
	baseColor.blue = Math.round(baseColor.blue * (100 - weight) / 100 + (avg * weight / 100));

	avg = (baseColor.redRand + baseColor.greenRand + baseColor.blueRand);
  baseColor.redRand = Math.round(baseColor.redRand * (100 - weight) / 100);
  baseColor.greenRand = Math.round(baseColor.greenRand * (100 - weight) / 100);
  baseColor.blueRand = Math.round(baseColor.blueRand * (100 - weight) / 100);

	baseColor.rand += Math.round(avg * weight / 3 / 100);
}


function randomizeByPercent(input, percent) {
	return (cosmetic_range( Math.floor(input * (100 - percent) / 100), Math.floor(input * (100 + percent) / 100)));
}

function randomizeColor(baseColor, randomizePercent) {
	baseColor.red = randomizeByPercent(baseColor.red, randomizePercent);
	baseColor.green = randomizeByPercent(baseColor.green, randomizePercent);
	baseColor.blue = randomizeByPercent(baseColor.blue, randomizePercent);
}

function swapColors(color1, color2) {
    const tempColor = color1.clone();
    color1.copy(color2);
    color2.copy(tempColor);
}


// Assumes colors are pre-baked.
function blendAppearances(/* color */ fromForeColor, /* color */ fromBackColor, fromChar,
                      /* color */ toForeColor, /* color */ toBackColor, toChar,
                      // /* color */ retForeColor, color return.backColor, uchar *retChar,
                      percent)
{
	const result = {
		foreColor: color(),
		backColor: color(),
		char: ' '
	};

  // Straight average of the back color:
  result.backColor.copy(fromBackColor);
  applyColorAverage(result.backColor, toBackColor, percent);

  // Pick the character:
  if (percent >= 50) {
      result.char = toChar;
  } else {
      result.char = fromChar;
  }

  // Pick the method for blending the fore color.
  if (fromChar == toChar) {
      // If the character isn't changing, do a straight average.
      result.foreColor.copy(fromForeColor);
      applyColorAverage(result.foreColor, toForeColor, percent);
  } else {
      // If it is changing, the first half blends to the current back color, and the second half blends to the final back color.
      if (percent >= 50) {
          result.foreColor.copy(result.backColor);
          applyColorAverage(result.foreColor, toForeColor, (percent - 50) * 2);
      } else {
          result.foreColor.copy(fromForeColor);
          applyColorAverage(result.foreColor, result.backColor, percent * 2);
      }
  }
}

async function irisFadeBetweenBuffers( fromBuf /* cellDisplayBuffer[COLS][ROWS] */,
                            toBuf, // cellDisplayBuffer[COLS][ROWS],
                            x, y,
                            frameCount,
                            outsideIn)
{
    let i, j, frame, percentBasis, thisCellPercent;
    let fastForward;
    let fromBackColor, toBackColor, fromForeColor, toForeColor, currentForeColor, currentBackColor;	// color
    let fromChar, toChar, currentChar;
    const completionMap = GRID(COLS, ROWS); // short[COLS][ROWS],
		let maxDistance;

    fastForward = false;
    frame = 1;

    // Calculate the square of the maximum distance from (x, y) that the iris will have to spread.
    if (x < COLS / 2) {
        i = COLS - x;
    } else {
        i = x;
    }
    if (y < ROWS / 2) {
        j = ROWS - y;
    } else {
        j = y;
    }
    maxDistance = i*i + j*j;

    // Generate the initial completion map as a percent of maximum distance.
    for (i=0; i<COLS; i++) {
        for (j=0; j<ROWS; j++) {
            completionMap[i][j] = (i - x)*(i - x) + (j - y)*(j - y); // square of distance
            completionMap[i][j] = Math.floor(100 * completionMap[i][j] / maxDistance); // percent of max distance
            if (outsideIn) {
                completionMap[i][j] -= 100; // translate to [-100, 0], with the origin at -100 and the farthest point at 0.
            } else {
                completionMap[i][j] *= -1; // translate to [-100, 0], with the origin at 0 and the farthest point at -100.
            }
        }
    }

    do {
        percentBasis = 10000 * frame / frameCount;

        for (i=0; i<COLS; i++) {
            for (j=0; j<ROWS; j++) {
                thisCellPercent = Math.floor(percentBasis * 3 / 100 + completionMap[i][j]);

                fromBackColor = colorFromComponents(fromBuf[i][j].backColorComponents);
                fromForeColor = colorFromComponents(fromBuf[i][j].foreColorComponents);
                fromChar = fromBuf[i][j].char;

                toBackColor = colorFromComponents(toBuf[i][j].backColorComponents);
                toForeColor = colorFromComponents(toBuf[i][j].foreColorComponents);
                toChar = toBuf[i][j].char;

                const app = blendAppearances(fromForeColor, fromBackColor, fromChar, toForeColor, toBackColor, toChar, clamp(thisCellPercent, 0, 100));
								currentBackColor = app.backColor;
								currentForeColor = app.foreColor;
								currentChar = app.char;
                plotCharWithColor(currentChar, i, j, currentForeColor, currentBackColor);
            }
        }

        fastForward = await pauseBrogue(10);
        frame++;
    } while (frame <= frameCount && !fastForward);
    overlayDisplayBuffer(toBuf, NULL);
}

// takes dungeon coordinates
function colorBlendCell(x, y, /* color */ hiliteColor, hiliteStrength) {
	let displayChar;
	// let foreColor, backColor;

	const app = getCellAppearance(x, y);
	applyColorAverage(app.foreColor, hiliteColor, hiliteStrength);
	applyColorAverage(app.backColor, hiliteColor, hiliteStrength);
	plotCharWithColor(app.char, mapToWindowX(x), mapToWindowY(y), app.foreColor, app.backColor);
}


// takes dungeon coordinates
function hiliteCell(x, y, /* color */ hiliteColor, hiliteStrength, distinctColors) {
	let displayChar;
	let foreColor, backColor;

	// assureCosmeticRNG();

	let appearance = getCellAppearance(x, y);
	applyColorAugment(appearance.foreColor, hiliteColor, hiliteStrength);
	applyColorAugment(appearance.backColor, hiliteColor, hiliteStrength);
	if (distinctColors) {
		separateColors(appearance.foreColor, appearance.backColor);
	}
	// restoreRNG();

	plotCharWithColor(appearance.char, mapToWindowX(x), mapToWindowY(y), appearance.foreColor, appearance.backColor);

}

function adjustedLightValue(x) {
    if (x <= LIGHT_SMOOTHING_THRESHOLD) {
        return x;
    } else {
        return fp_sqrt( Math.floor((x << FP_BASE)/LIGHT_SMOOTHING_THRESHOLD) ) * LIGHT_SMOOTHING_THRESHOLD >> FP_BASE;
    }
}

function colorMultiplierFromDungeonLight(x, y, /* color */ editColor) {

	editColor.red		= editColor.redRand		= adjustedLightValue(max(0, tmap[x][y].light[0]));
	editColor.green	= editColor.greenRand	= adjustedLightValue(max(0, tmap[x][y].light[1]));
	editColor.blue	= editColor.blueRand	= adjustedLightValue(max(0, tmap[x][y].light[2]));

	editColor.rand = adjustedLightValue(max(0, tmap[x][y].light[0] + tmap[x][y].light[1] + tmap[x][y].light[2]) / 3);
	editColor.colorDances = false;
}

function plotCharWithColor(inputChar, xLoc, yLoc, /* color */ cellForeColor, /* color */ cellBackColor) {

	let foreRed = cellForeColor.red,
	foreGreen = cellForeColor.green,
	foreBlue = cellForeColor.blue,

	backRed = cellBackColor.red,
	backGreen = cellBackColor.green,
	backBlue = cellBackColor.blue,

	foreRand, backRand;

  brogueAssert(coordinatesAreInWindow(xLoc, yLoc));

	if (rogue.gameHasEnded || rogue.playbackFastForward) {
		return;
	}

  // assureCosmeticRNG();

	foreRand = cosmetic_range(0, cellForeColor.rand);
	backRand = cosmetic_range(0, cellBackColor.rand);
	foreRed += cosmetic_range(0, cellForeColor.redRand) + foreRand;
	foreGreen += cosmetic_range(0, cellForeColor.greenRand) + foreRand;
	foreBlue += cosmetic_range(0, cellForeColor.blueRand) + foreRand;
	backRed += cosmetic_range(0, cellBackColor.redRand) + backRand;
	backGreen += cosmetic_range(0, cellBackColor.greenRand) + backRand;
	backBlue += cosmetic_range(0, cellBackColor.blueRand) + backRand;

	foreRed =		min(100, max(0, foreRed));
	foreGreen =		min(100, max(0, foreGreen));
	foreBlue =		min(100, max(0, foreBlue));
	backRed =		min(100, max(0, backRed));
	backGreen =		min(100, max(0, backGreen));
	backBlue =		min(100, max(0, backBlue));

	if (inputChar != ' '
		&& foreRed		== backRed
		&& foreGreen	== backGreen
		&& foreBlue		== backBlue)
  {
		inputChar = ' ';
	}

	if (inputChar		!= displayBuffer[xLoc][yLoc].char
		|| foreRed		!= displayBuffer[xLoc][yLoc].foreColorComponents[0]
		|| foreGreen	!= displayBuffer[xLoc][yLoc].foreColorComponents[1]
		|| foreBlue		!= displayBuffer[xLoc][yLoc].foreColorComponents[2]
		|| backRed		!= displayBuffer[xLoc][yLoc].backColorComponents[0]
		|| backGreen	!= displayBuffer[xLoc][yLoc].backColorComponents[1]
		|| backBlue		!= displayBuffer[xLoc][yLoc].backColorComponents[2])
  {
		displayBuffer[xLoc][yLoc].needsUpdate = true;

		displayBuffer[xLoc][yLoc].char = inputChar;
		displayBuffer[xLoc][yLoc].foreColorComponents[0] = foreRed;
		displayBuffer[xLoc][yLoc].foreColorComponents[1] = foreGreen;
		displayBuffer[xLoc][yLoc].foreColorComponents[2] = foreBlue;
		displayBuffer[xLoc][yLoc].backColorComponents[0] = backRed;
		displayBuffer[xLoc][yLoc].backColorComponents[1] = backGreen;
		displayBuffer[xLoc][yLoc].backColorComponents[2] = backBlue;
	}

	// restoreRNG();
}

function plotCharToBuffer(inputChar, x, y, /* color */ foreColor, /* color */ backColor,  dbuf /* cellDisplayBuffer[COLS][ROWS] */) {

  if (!dbuf) {
		plotCharWithColor(inputChar, x, y, foreColor, backColor);
		return;
	}

  brogueAssert(coordinatesAreInWindow(x, y));

	// oldRNG = rogue.RNG;
  // rogue.RNG = RNG_COSMETIC;
	// assureCosmeticRNG();

  const foreRand = cosmetic_range(0, foreColor.rand);
	const backRand = cosmetic_range(0, backColor.rand);

  dbuf[x][y].char = inputChar;
	dbuf[x][y].foreColorComponents[0] = foreColor.red + cosmetic_range(0, foreColor.redRand) + foreRand;
	dbuf[x][y].foreColorComponents[1] = foreColor.green + cosmetic_range(0, foreColor.greenRand) + foreRand;
	dbuf[x][y].foreColorComponents[2] = foreColor.blue + cosmetic_range(0, foreColor.blueRand) + foreRand;
	dbuf[x][y].backColorComponents[0] = backColor.red + cosmetic_range(0, backColor.redRand) + backRand;
	dbuf[x][y].backColorComponents[1] = backColor.green + cosmetic_range(0, backColor.greenRand) + backRand;
	dbuf[x][y].backColorComponents[2] = backColor.blue + cosmetic_range(0, backColor.blueRand) + backRand;
	dbuf[x][y].opacity = 100;
  dbuf[x][y].needsUpdate = true;

  // restoreRNG();
}

function plotForegroundChar( inputChar, x, y, /* color */foreColor, affectedByLighting) {
    const multColor = color(), myColor = color();
    let ignoredChar;

    myColor.copy(foreColor);
    const app = getCellAppearance(x, y);
    if (affectedByLighting) {
        colorMultiplierFromDungeonLight(x, y, multColor);
        applyColorMultiplier(myColor, multColor);
    }
    plotCharWithColor(inputChar, mapToWindowX(x), mapToWindowY(y), myColor, app.backColor);
}

// Set to false and draws don't take effect, they simply queue up. Set to true and all of the
// queued up draws take effect.
function commitDraws() {
	// let i, j;
	// let tempFore = color();
	// let tempBack = color();
	//
	// for (i=0; i<COLS; i++) {
	// 	for (j=0; j<ROWS; j++) {
	// 		if (displayBuffer[i][j].needsUpdate) {
	// 			plotChar(displayBuffer[i][j].char, i, j,
	// 					 displayBuffer[i][j].foreColorComponents[0],
	// 					 displayBuffer[i][j].foreColorComponents[1],
	// 					 displayBuffer[i][j].foreColorComponents[2],
	// 					 displayBuffer[i][j].backColorComponents[0],
	// 					 displayBuffer[i][j].backColorComponents[1],
	// 					 displayBuffer[i][j].backColorComponents[2]);
	// 			displayBuffer[i][j].needsUpdate = false;
	// 		}
	// 	}
	// }
}

// Debug feature: display the level to the screen without regard to lighting, field of view, etc.
function dumpLevelToScreen() {
	let i, j;
	let backup = pcell();

	// assureCosmeticRNG();
	for (i=0; i<DCOLS; i++) {
		for (j=0; j<DROWS; j++) {
			// if (pmap[i][j].layers[DUNGEON] != GRANITE
      //     || (pmap[i][j].flags & DISCOVERED))
			// {
				Object.assign(backup, pmap[i][j]);
				pmap[i][j].flags |= (VISIBLE | DISCOVERED);
				tmap[i][j].light[0] = 100;
				tmap[i][j].light[1] = 100;
				tmap[i][j].light[2] = 100;
				refreshDungeonCell(i, j);
				Object.assign(pmap[i][j], backup);
			// } else {
			// 	plotCharWithColor(' ', mapToWindowX(i), mapToWindowY(j), white, black);
			// }

		}
	}
	// restoreRNG();
}

// To be used immediately after dumpLevelToScreen() above.
// Highlight the portion indicated by hiliteCharGrid with the hiliteColor at the hiliteStrength -- both latter arguments are optional.
function hiliteCharGrid( hiliteCharGrid /* char[DCOLS][DROWS] */, /* color */ hiliteColor, hiliteStrength) {
	let i, j, x, y;
	let hCol;

	// assureCosmeticRNG();

	if (hiliteColor) {
		hCol = hiliteColor.clone();
	} else {
		hCol = yellow.clone();
	}

	bakeColor(hCol);

	if (!hiliteStrength) {
		hiliteStrength = 75;
	}

	for (i=0; i<DCOLS; i++) {
		for (j=0; j<DROWS; j++) {
			if (hiliteCharGrid[i][j]) {
				x = mapToWindowX(i);
				y = mapToWindowY(j);

				displayBuffer[x][y].needsUpdate = true;
				displayBuffer[x][y].backColorComponents[0] = clamp(displayBuffer[x][y].backColorComponents[0] + hCol.red * hiliteStrength / 100, 0, 100);
				displayBuffer[x][y].backColorComponents[1] = clamp(displayBuffer[x][y].backColorComponents[1] + hCol.green * hiliteStrength / 100, 0, 100);
				displayBuffer[x][y].backColorComponents[2] = clamp(displayBuffer[x][y].backColorComponents[2] + hCol.blue * hiliteStrength / 100, 0, 100);
				displayBuffer[x][y].foreColorComponents[0] = clamp(displayBuffer[x][y].foreColorComponents[0] + hCol.red * hiliteStrength / 100, 0, 100);
				displayBuffer[x][y].foreColorComponents[1] = clamp(displayBuffer[x][y].foreColorComponents[1] + hCol.green * hiliteStrength / 100, 0, 100);
				displayBuffer[x][y].foreColorComponents[2] = clamp(displayBuffer[x][y].foreColorComponents[2] + hCol.blue * hiliteStrength / 100, 0, 100);
			}
		}
	}
	// restoreRNG();
}


function blackOutScreen() {
	let i, j;

	for (i=0; i<COLS; i++) {
		for (j=0; j<ROWS; j++) {
			plotCharWithColor(' ', i, j, black, black);
		}
	}
}


function colorOverDungeon( /* const color */color) {
	let i, j;

	for (i=0; i<DCOLS; i++) {
		for (j=0; j<DROWS; j++) {
			plotCharWithColor(' ', mapToWindowX(i), mapToWindowY(j), color, color);
		}
	}
}


function copyDisplayBuffer( toBuf /* cellDisplayBuffer[COLS][ROWS] */, fromBuf /* cellDisplayBuffer[COLS][ROWS] */) {
	let i, j, k;

	for (i=0; i<COLS; i++) {
		for (j=0; j<ROWS; j++) {
			toBuf[i][j].char = fromBuf[i][j].char;
      for(k = 0; k < 3; ++k) {
        toBuf[i][j].foreColorComponents[k] = fromBuf[i][j].foreColorComponents[k];
        toBuf[i][j].backColorComponents[k] = fromBuf[i][j].backColorComponents[k];
      }
      toBuf[i][j].opacity = fromBuf[i][j].opacity;
      toBuf[i][j].needsUpdate = fromBuf[i][j].needsUpdate;
		}
	}
}

function clearDisplayBuffer( dbuf /* cellDisplayBuffer[COLS][ROWS] */) {
	let i, j, k;

	dbuf = dbuf || displayBuffer;

	for (i=0; i<COLS; i++) {
		for (j=0; j<ROWS; j++) {
			dbuf[i][j].char = ' ';
			for (k=0; k<3; k++) {
				dbuf[i][j].foreColorComponents[k] = 0;
				dbuf[i][j].backColorComponents[k] = 0;
			}
			dbuf[i][j].opacity = 0;
		}
	}
}

function colorFromComponents( rgb /* char[3] */) {
	let theColor = color();
	theColor.red	= rgb[0];
	theColor.green	= rgb[1];
	theColor.blue	= rgb[2];
	return theColor;
}

// draws overBuf over the current display with per-cell pseudotransparency as specified in overBuf.
// If previousBuf is not null, it gets filled with the preexisting display for reversion purposes.
function overlayDisplayBuffer( overBuf /* cellDisplayBuffer[COLS][ROWS] */,  previousBuf /* cellDisplayBuffer[COLS][ROWS]*/) {
	let i, j;
	let foreColor, backColor, tempColor;
	let character;

	if (previousBuf) {
		copyDisplayBuffer(previousBuf, displayBuffer);
	}

	for (i=0; i<COLS; i++) {
		for (j=0; j<ROWS; j++) {

			if (overBuf[i][j].opacity != 0) {
				backColor = colorFromComponents(overBuf[i][j].backColorComponents);

				if (overBuf[i][j].char === 0) {
					throw new Error('Where is this coming from!');
				}

				// character and fore color:
				if (overBuf[i][j].char == ' ') { // Blank cells in the overbuf take the character from the screen.
					character = displayBuffer[i][j].char;
					foreColor = colorFromComponents(displayBuffer[i][j].foreColorComponents);
					applyColorAverage(foreColor, backColor, overBuf[i][j].opacity);
				} else {
					character = overBuf[i][j].char;
					foreColor = colorFromComponents(overBuf[i][j].foreColorComponents);
				}

				// back color:
				tempColor = colorFromComponents(displayBuffer[i][j].backColorComponents);
				applyColorAverage(backColor, tempColor, 100 - overBuf[i][j].opacity);

				plotCharWithColor(character, i, j, foreColor, backColor);
			}
		}
	}
}


// Takes a list of locations, a color and a list of strengths and flashes the foregrounds of those locations.
// Strengths are percentages measuring how hard the color flashes at its peak.
async function flashForeground(/* short[] */ x, /* short[] */ y, /* color[] */ flashColor, /* short[] */ flashStrength, count, frames) {
	let i, j, percent;
	let displayChar;	// uchar *
	let bColor, fColor, newColor = color();
  // short oldRNG;

	if (count <= 0) {
		return;
	}

	// oldRNG = rogue.RNG;
  // rogue.RNG = RNG_COSMETIC;
	// assureCosmeticRNG();

	displayChar = ARRAY(count); // (uchar *) malloc(count * sizeof(uchar));
	fColor = ARRAY(count, color); // (color *) malloc(count * sizeof(color));
	bColor = ARRAY(count, color); // (color *) malloc(count * sizeof(color));

	for (i=0; i<count; i++) {
		const app = getCellAppearance(x[i], y[i]);
		displayChar[i] = app.char;
		fColor[i].copy(app.foreColor);
		bColor[i].copy(app.backColor);
		bakeColor(fColor[i]);
		bakeColor(bColor[i]);
	}

	// restoreRNG();

	for (j=frames; j>= 0; j--) {
		// assureCosmeticRNG();
		for (i=0; i<count; i++) {
			percent = flashStrength[i] * j / frames;
			newColor.copy(fColor[i]);
			applyColorAverage(newColor, flashColor[i], percent);
			plotCharWithColor(displayChar[i], mapToWindowX(x[i]), mapToWindowY(y[i]), newColor, (bColor[i]));
		}
		// restoreRNG();
		if (j) {
			if (await pauseBrogue(16)) {
				j = 1;
			}
		}
	}

	// free(displayChar);
	// free(fColor);
	// free(bColor);

	// restoreRNG();
}

async function flashCell( /* color */ theColor, frames, x, y) {
	let i;
	let interrupted = false;

	for (i=0; i<frames && !interrupted; i++) {
		colorBlendCell(x, y, theColor, 100 - 100 * i / frames);
		interrupted = await pauseBrogue(50);
	}

	refreshDungeonCell(x, y);
}

// special effect expanding flash of light at dungeon coordinates (x, y) restricted to tiles with matching flags
async function colorFlash( /* color */ theColor, reqTerrainFlags, reqTileFlags, frames, maxRadius, x, y)
{
	let i, j, k, intensity, currentRadius, fadeOut;
	let localRadius = GRID(DCOLS, DROWS); // short[DCOLS][DROWS];
	let tileQualifies = GRID(DCOLS, DROWS); // boolean[DCOLS][DROWS],
	let aTileQualified, fastForward;

	aTileQualified = false;
	fastForward = false;
	maxRadius = Math.floor(maxRadius);

	for (i = max(x - maxRadius, 0); i <= min(x + maxRadius, DCOLS - 1); i++) {
		for (j = max(y - maxRadius, 0); j <= min(y + maxRadius, DROWS - 1); j++) {
			if ((!reqTerrainFlags || cellHasTerrainFlag(reqTerrainFlags, i, j))
				&& (!reqTileFlags || (pmap[i][j].flags & reqTileFlags))
				&& (i-x) * (i-x) + (j-y) * (j-y) <= maxRadius * maxRadius)
			{
				tileQualifies[i][j] = true;
				localRadius[i][j] = fp_sqrt((i-x) * (i-x) + (j-y) * (j-y) << FP_BASE) >> FP_BASE;
				aTileQualified = true;
			} else {
				tileQualifies[i][j] = false;
			}
		}
	}

	if (!aTileQualified) {
		return;
	}

	for (k = 1; k <= frames; k++) {
		currentRadius = max(1, maxRadius * k / frames);
		fadeOut = min(100, (frames - k) * 100 * 5 / frames);
		for (i = max(x - maxRadius, 0); i <= min(x + maxRadius, DCOLS - 1); i++) {
			for (j = max(y - maxRadius, 0); j <= min(y + maxRadius, DROWS - 1); j++) {
				if (tileQualifies[i][j] && (localRadius[i][j] <= currentRadius))
				{
					intensity = 100 - 100 * (currentRadius - localRadius[i][j] - 2) / currentRadius;
					intensity = fadeOut * intensity / 100;

					hiliteCell(i, j, theColor, intensity, false);
				}
			}
		}
		if (!fastForward && (rogue.playbackFastForward || await pauseBrogue(50))) {
			k = frames - 1;
			fastForward = true;
		}
	}

}

function bCurve(x) { return (((x) * (x) + 11) / (10 * ((x) * (x) + 1)) - 0.1); }

const WEIGHT_GRID = GRID(COLS, ROWS, () => [0,0,0] ); // [COLS][ROWS][3],


// x and y are global coordinates, not within the playing square
async function funkyFade( displayBuf /* cellDisplayBuffer[COLS][ROWS] */, /* color */ colorStart,
			   /* color */ colorEnd, stepCount, x, y, invert)
{
	let i, j, n, weight;
	let x2, y2;
  let percentComplete;
	let tempColor = color(), colorMid = color(), foreColor = color(), backColor = color();
	let tempChar;
	let distanceMap;
	let fastForward;

// #ifdef BROGUE_LIBTCOD
// 	stepCount *= 15; // libtcod displays much faster
// #endif

	fastForward = false;
	distanceMap = allocGrid();
	fillGrid(distanceMap, 0);
	calculateDistances(distanceMap, player.xLoc, player.yLoc, T_OBSTRUCTS_PASSABILITY, 0, true, true);

	for (i=0; i<COLS; i++) {
		x2 = ((i - x) * 5.0 / COLS);
		for (j=0; j<ROWS; j++) {
			y2 = ((j - y) * 2.5 / ROWS);

			WEIGHT_GRID[i][j][0] = bCurve(x2*x2+y2*y2) * (.7 + .3 * cos(5*x2*x2) * cos(5*y2*y2));
			WEIGHT_GRID[i][j][1] = bCurve(x2*x2+y2*y2) * (.7 + .3 * sin(5*x2*x2) * cos(5*y2*y2));
			WEIGHT_GRID[i][j][2] = bCurve(x2*x2+y2*y2);
		}
	}


	for (n=(invert ? stepCount - 1 : 0); (invert ? n >= 0 : n <= stepCount); n += (invert ? -1 : 1)) {

		// assureCosmeticRNG();

		for (i=0; i<COLS; i++) {
			for (j=0; j<ROWS; j++) {

				percentComplete = (n) * 100 / stepCount;

				colorMid.copy(colorStart);
				if (colorEnd) {
					applyColorAverage(colorMid, colorEnd, n * 100 / stepCount);
				}

				// the fade color floods the reachable dungeon tiles faster
				if (!invert && coordinatesAreInMap(windowToMapX(i), windowToMapY(j))
					&& distanceMap[windowToMapX(i)][windowToMapY(j)] >= 0 && distanceMap[windowToMapX(i)][windowToMapY(j)] < 30000)
				{
					percentComplete *= 1.0 + (100.0 - min(100, distanceMap[windowToMapX(i)][windowToMapY(j)])) / 100.;
				}

				weight = Math.floor(percentComplete + WEIGHT_GRID[i][j][2] * percentComplete * 10);
				weight = min(100, weight);
				tempColor.copy(black);

				tempColor.red = Math.floor((percentComplete + WEIGHT_GRID[i][j][0] * percentComplete * 10) * colorMid.red / 100);
				tempColor.red = min(colorMid.red, tempColor.red);

				tempColor.green = Math.floor((percentComplete + WEIGHT_GRID[i][j][1] * percentComplete * 10) * colorMid.green / 100);
				tempColor.green = min(colorMid.green, tempColor.green);

				tempColor.blue = Math.floor((percentComplete + WEIGHT_GRID[i][j][2] * percentComplete * 10) * colorMid.blue / 100);
				tempColor.blue = min(colorMid.blue, tempColor.blue);

				backColor.copy(black);

				backColor.red = displayBuf[i][j].backColorComponents[0];
				backColor.green = displayBuf[i][j].backColorComponents[1];
				backColor.blue = displayBuf[i][j].backColorComponents[2];

				foreColor.copy(invert ? white : black);

				if (j < MESSAGE_LINES
					&& i >= mapToWindowX(0)
					&& i < mapToWindowX(strLenWithoutEscapes(displayedMessage[MESSAGE_LINES - j - 1])))
				{
					tempChar = displayedMessage[MESSAGE_LINES - j - 1].charAt(windowToMapX(i));
				} else {
					tempChar = displayBuf[i][j].char;

					foreColor.red = displayBuf[i][j].foreColorComponents[0];
					foreColor.green = displayBuf[i][j].foreColorComponents[1];
					foreColor.blue = displayBuf[i][j].foreColorComponents[2];

					applyColorAverage(foreColor, tempColor, weight);
				}
				applyColorAverage(backColor, tempColor, weight);
				plotCharWithColor(tempChar, i, j, foreColor, backColor);
			}
		}
		// restoreRNG();
		if (!fastForward && await pauseBrogue(16)) {
			fastForward = true;
			n = (invert ? 1 : stepCount - 2);
		}
	}

	freeGrid(distanceMap);

}


async function displayWaypoints() {
    let i, j, w, lowestDistance;

    for (i=0; i<DCOLS; i++) {
        for (j=0; j<DROWS; j++) {
            lowestDistance = 30000;
            for (w=0; w<rogue.wpCount; w++) {
                if (rogue.wpDistance[w][i][j] < lowestDistance) {
                    lowestDistance = rogue.wpDistance[w][i][j];
                }
            }
            if (lowestDistance < 10) {
                hiliteCell(i, j, white, clamp(100 - lowestDistance*15, 0, 100), true);
            }
        }
    }
    await temporaryMessage("Waypoints:", true);
}


async function displayMachines() {
	let i, j;
	let foreColor, backColor, machineColors = [];
	let dchar;

	// assureCosmeticRNG();

	for (i=0; i<50; i++) {
		machineColors[i] = color();
		machineColors[i].red = cosmetic_range(0, 100);
		machineColors[i].green = cosmetic_range(0, 100);
		machineColors[i].blue = cosmetic_range(0, 100);
	}

	for (i=0; i<DCOLS; i++) {
		for (j=0; j<DROWS; j++) {
			if (pmap[i][j].machineNumber) {
				const app = getCellAppearance(i, j);
				applyColorAugment(app.backColor, machineColors[pmap[i][j].machineNumber], 50);
				//plotCharWithColor(dchar, mapToWindowX(i), mapToWindowY(j), &foreColor, &backColor);
          if (pmap[i][j].machineNumber < 10) {
              dchar = String.fromCharCode('0'.charCodeAt(0) + pmap[i][j].machineNumber);
          } else if (pmap[i][j].machineNumber < 10 + 26) {
              dchar = String.fromCharCode('a'.charCodeAt(0) + pmap[i][j].machineNumber - 10);
          } else {
              dchar = String.fromCharCode('A'.charCodeAt(0) + pmap[i][j].machineNumber - 10 - 26);
          }
          plotCharWithColor(dchar, mapToWindowX(i), mapToWindowY(j), app.foreColor, app.backColor);
			}
		}
	}

	// restoreRNG();

	await displayMoreSign();
	displayLevel();

}

const CHOKEMAP_DISPLAY_CUTOFF	 = 160;

async function displayChokeMap() {
	let i, j;
	let foreColor, backColor;
	let dchar;
	let app;

	for (i=0; i<DCOLS; i++) {
		for (j=0; j<DROWS; j++) {
			if (chokeMap[i][j] < CHOKEMAP_DISPLAY_CUTOFF) {
				if (pmap[i][j].flags & IS_GATE_SITE) {
					app = getCellAppearance(i, j);
					applyColorAugment(app.backColor, teal, 50);
					plotCharWithColor(app.char, mapToWindowX(i), mapToWindowY(j), app.foreColor, app.backColor);
				} else
					if (chokeMap[i][j] < CHOKEMAP_DISPLAY_CUTOFF) {
					app = getCellAppearance(i, j);
					applyColorAugment(app.backColor, red, 100 - chokeMap[i][j] * 100 / CHOKEMAP_DISPLAY_CUTOFF);
					plotCharWithColor(app.char, mapToWindowX(i), mapToWindowY(j), app.foreColor, app.backColor);
				}
			}
		}
	}
	await displayMoreSign();
	displayLevel();
}

async function displayLoops() {
	let i, j;
	let foreColor, backColor;
	let dchar;
	let app;

	for (i=0; i<DCOLS; i++) {
		for (j=0; j<DROWS; j++) {
			if (pmap[i][j].flags & IN_LOOP) {
				app = getCellAppearance(i, j);
				applyColorAugment(app.backColor, yellow, 50);
				plotCharWithColor(app.char, mapToWindowX(i), mapToWindowY(j), app.foreColor, app.backColor);
				//colorBlendCell(i, j, &tempColor, 100);//hiliteCell(i, j, &tempColor, 100, true);
			}
			if (pmap[i][j].flags & IS_CHOKEPOINT) {
				getCellAppearance(i, j);
				applyColorAugment(app.backColor, teal, 50);
				plotCharWithColor(app.char, mapToWindowX(i), mapToWindowY(j), app.foreColor, app.backColor);
			}
		}
	}
	await waitForAcknowledgment();
}

async function exploreKey(controlKey) {
  let x, y, finalX, finalY;
  let exploreMap;
  let dir;
  let tooDark = false;

  // fight any adjacent enemies first
  dir = adjacentFightingDir();
  if (dir == NO_DIRECTION) {
      for (dir = 0; dir < DIRECTION_COUNT; dir++) {
          x = player.xLoc + nbDirs[dir][0];
          y = player.yLoc + nbDirs[dir][1];
          if (coordinatesAreInMap(x, y)
              && !(pmap[x][y].flags & DISCOVERED))
					{
              tooDark = true;
              break;
          }
      }
      if (!tooDark) {
          x = finalX = player.xLoc;
          y = finalY = player.yLoc;

          exploreMap = allocGrid();
          getExploreMap(exploreMap, false);
          do {
              dir = nextStep(exploreMap, x, y, NULL, false);
              if (dir != NO_DIRECTION) {
                  x += nbDirs[dir][0];
                  y += nbDirs[dir][1];
                  if (pmap[x][y].flags & (DISCOVERED | MAGIC_MAPPED)) {
                      finalX = x;
                      finalY = y;
                  }
              }
          } while (dir != NO_DIRECTION);
          freeGrid(exploreMap);
      }
  } else {
      x = finalX = player.xLoc + nbDirs[dir][0];
      y = finalY = player.yLoc + nbDirs[dir][1];
  }

  if (tooDark) {
      message("It's too dark to explore!", false);
  } else if (x == player.xLoc && y == player.yLoc) {
      message("I see no path for further exploration.", false);
  } else if (proposeOrConfirmLocation(finalX, finalY, "I see no path for further exploration.")) {
      await explore(controlKey ? 1 : 20); // Do the exploring until interrupted.
      hideCursor();
      await exploreKey(controlKey);
  }
}


function pausingTimerStartsNow() {
	// NULL
}




async function pauseBrogue(milliseconds, wantMouseMoves) {
	let interrupted = false;

	commitDraws();
	if (rogue.playbackMode && rogue.playbackFastForward) {
    interrupted = true;
	} else {
		interrupted = await pauseForMilliseconds(milliseconds, wantMouseMoves);
	}
	// pausingTimerStartsNow();
	return interrupted;
}


async function nextBrogueEvent( returnEvent, textInput, colorsDance, realInputEvenInPlayback ) {
	const recordingInput = rogueEvent();
	let repeatAgain;
	let pauseDuration;

	returnEvent.eventType = EVENT_ERROR;

	if (rogue.playbackMode && !realInputEvenInPlayback) {
		do {
			repeatAgain = false;
			if ((!rogue.playbackFastForward && rogue.playbackBetweenTurns)
				|| rogue.playbackOOS)
			{
				pauseDuration = (rogue.playbackPaused ? DEFAULT_PLAYBACK_DELAY : rogue.playbackDelayThisTurn);
				if (pauseDuration && await pauseBrogue(pauseDuration)) {
					// if the player did something during playback
					await nextBrogueEvent(recordingInput, false, false, true);
					await executePlaybackInput(recordingInput);
					repeatAgain = !rogue.playbackPaused;
				}
			}
		} while ((repeatAgain || rogue.playbackOOS) && !rogue.gameHasEnded);
		rogue.playbackDelayThisTurn = rogue.playbackDelayPerTurn;
		recallEvent(returnEvent);
	} else {
		commitDraws();
		if (rogue.creaturesWillFlashThisTurn) {
			await displayMonsterFlashes(true);
		}
		do {
			await nextKeyOrMouseEvent(returnEvent, textInput, colorsDance); // No mouse clicks outside of the window will register.
		} while (returnEvent.eventType == MOUSE_UP && !coordinatesAreInWindow(returnEvent.param1, returnEvent.param2));
		// recording done elsewhere
		// console.log('nextBrogueEvent', returnEvent.eventType);
	}

	if (returnEvent.eventType == EVENT_ERROR) {
		rogue.playbackPaused = rogue.playbackMode; // pause if replaying
		ERROR("Event error!", true);
	}
}


async function executeMouseClick( /* rogueEvent */ theEvent) {
	let x, y;
	let autoConfirm;
	x = theEvent.param1;
	y = theEvent.param2;
	autoConfirm = theEvent.controlKey;

	if (theEvent.eventType == RIGHT_MOUSE_UP) {
		await displayInventory(ALL_ITEMS, 0, 0, true, true);
	} else if (coordinatesAreInMap(windowToMapX(x), windowToMapY(y))) {
		if (autoConfirm) {
			// await travel(windowToMapX(x), windowToMapY(y), autoConfirm);
		} else {
			rogue.cursorLoc[0] = windowToMapX(x);
			rogue.cursorLoc[1] = windowToMapY(y);
			// await mainInputLoop();
		}

	} else if (windowToMapX(x) >= 0 && windowToMapX(x) < DCOLS && y >= 0 && y < MESSAGE_LINES) {
		// If the click location is in the message block, display the message archive.
		await displayMessageArchive();
	}
}

async function executeKeystroke( keystroke, controlKey, shiftKey) {
	let path; // char[BROGUE_FILENAME_MAX];
	let direction = -1;

	confirmMessages();
	keystroke = stripShiftFromMovementKeystroke(keystroke);

	switch (keystroke) {
		case UP_KEY:
		case UP_ARROW:
		case NUMPAD_8:
			direction = UP;
			break;
		case DOWN_KEY:
		case DOWN_ARROW:
		case NUMPAD_2:
			direction = DOWN;
			break;
		case LEFT_KEY:
		case LEFT_ARROW:
		case NUMPAD_4:
			direction = LEFT;
			break;
		case RIGHT_KEY:
		case RIGHT_ARROW:
		case NUMPAD_6:
			direction = RIGHT;
			break;
		case NUMPAD_7:
		case UPLEFT_KEY:
			direction = UPLEFT;
			break;
		case UPRIGHT_KEY:
		case NUMPAD_9:
			direction = UPRIGHT;
			break;
		case DOWNLEFT_KEY:
		case NUMPAD_1:
			direction = DOWNLEFT;
			break;
		case DOWNRIGHT_KEY:
		case NUMPAD_3:
			direction = DOWNRIGHT;
			break;
		case DESCEND_KEY:
			considerCautiousMode();
			if (D_WORMHOLING) {
				recordKeystroke(DESCEND_KEY, false, false);
				await useStairs(1);
			} else if (proposeOrConfirmLocation(rogue.downLoc[0], rogue.downLoc[1], "I see no way down.")) {
		    await travel(rogue.downLoc[0], rogue.downLoc[1], true);
			}
			break;
		case ASCEND_KEY:
			considerCautiousMode();
			if (D_WORMHOLING) {
				recordKeystroke(ASCEND_KEY, false, false);
				await useStairs(-1);
			} else if (proposeOrConfirmLocation(rogue.upLoc[0], rogue.upLoc[1], "I see no way up.")) {
		    await travel(rogue.upLoc[0], rogue.upLoc[1], true);
			}
			break;
    case RETURN_KEY:
        showCursor();
        break;
		case REST_KEY:
		case PERIOD_KEY:
		case NUMPAD_5:
			considerCautiousMode();
			rogue.justRested = true;
			recordKeystroke(REST_KEY, false, false);
			await playerTurnEnded();
			break;
		case AUTO_REST_KEY:
			rogue.justRested = true;
			await autoRest();
			break;
		case SEARCH_KEY:
			await manualSearch();
			break;
		case INVENTORY_KEY:
			await displayInventory(ALL_ITEMS, 0, 0, true, true);
			break;
		case EQUIP_KEY:
			await equip(NULL);
			break;
		case UNEQUIP_KEY:
			await unequip(NULL);
			break;
		case DROP_KEY:
			await drop(NULL);
			break;
		case APPLY_KEY:
			await apply(NULL, true);
			break;
		case THROW_KEY:
			await throwCommand(NULL);
			break;
    case RELABEL_KEY:
        await relabel(NULL);
        break;
		case TRUE_COLORS_KEY:
			rogue.trueColorMode = !rogue.trueColorMode;
			displayLevel();
			refreshSideBar(-1, -1, false);
			if (rogue.trueColorMode) {
				message(KEYBOARD_LABELS ? "Color effects disabled. Press '\\' again to enable." : "Color effects disabled.",
                                 teal, false);
			} else {
				message(KEYBOARD_LABELS ? "Color effects enabled. Press '\\' again to disable." : "Color effects enabled.",
                                 teal, false);
			}
			break;
		case AGGRO_DISPLAY_KEY:
			rogue.displayAggroRangeMode = !rogue.displayAggroRangeMode;
			displayLevel();
			refreshSideBar(-1, -1, false);
			if (rogue.displayAggroRangeMode) {
          message(KEYBOARD_LABELS ? "Stealth range displayed. Press ']' again to hide." : "Stealth range displayed.",
                           teal, false);
      } else {
          message(KEYBOARD_LABELS ? "Stealth range hidden. Press ']' again to display." : "Stealth range hidden.",
                           teal, false);
			}
			break;
		// case WARNING_PAUSE_KEY:
		// 	rogue.warningPauseMode = !rogue.warningPauseMode;
		// 	if (rogue.warningPauseMode) {
    //     message(KEYBOARD_LABELS ? "Low hitpoint warnings (paused) enabled. Press '[' again to disable." : "Low HP warnings (paused) activated.",
    //                      teal, false);
    //   } else {
    //     message(KEYBOARD_LABELS ? "Low hitpoint warnings (paused) disabled. Press '[' again to enable." : "Low HP warnings (paused) deactivated.",
    //                      teal, false);
		// 	}
		// 	break;
		case CALL_KEY:
			await call(NULL);
			break;
		case EXPLORE_KEY:
			considerCautiousMode();
      await exploreKey(controlKey);
			break;
		// case AUTOPLAY_KEY:
		// 	autoPlayLevel(controlKey);
		// 	break;
		case MESSAGE_ARCHIVE_KEY:
			await displayMessageArchive();
			break;
		case HELP_KEY:
			await printHelpScreen();
			break;
		case DISCOVERIES_KEY:
			await printDiscoveriesScreen();
			break;
		// case VIEW_RECORDING_KEY:
		// 	if (rogue.playbackMode) {
		// 		return;
		// 	}
		// 	if (noSaves) {
    //     return;
    //   }
		// 	confirmMessages();
		// 	if ((rogue.playerTurnNumber < 50 || confirm("End this game and view a recording?", false))
		// 		&& dialogChooseFile(path, RECORDING_SUFFIX, "View recording: ")) {
		// 		if (fileExists(path)) {
		// 			strcpy(rogue.nextGamePath, path);
		// 			rogue.nextGame = NG_VIEW_RECORDING;
		// 			rogue.gameHasEnded = true;
		// 		} else {
		// 			message("File not found.", false);
		// 		}
		// 	}
		// 	break;
		// case LOAD_SAVED_GAME_KEY:
		// 	if (rogue.playbackMode) {
		// 		return;
		// 	}
		// 	if (noSaves) {
    //     return;
    //   }
		// 	confirmMessages();
		// 	if ((rogue.playerTurnNumber < 50 || confirm("End this game and load a saved game?", false))
		// 		&& dialogChooseFile(path, GAME_SUFFIX, "Open saved game: ")) {
		// 		if (fileExists(path)) {
		// 			strcpy(rogue.nextGamePath, path);
		// 			rogue.nextGame = NG_OPEN_GAME;
		// 			rogue.gameHasEnded = true;
		// 		} else {
		// 			message("File not found.", false);
		// 		}
		// 	}
		// 	break;
		// case SAVE_GAME_KEY:
		// 	if (rogue.playbackMode) {
		// 		return;
		// 	}
		// 	if (noSaves) {
		// 	  return;
		// 	}
		// 	if (confirm("Suspend this game? (This feature is still in beta.)", false)) {
		// 		saveGame();
		// 	}
		// 	break;
		case NEW_GAME_KEY:
			if (rogue.playerTurnNumber < 50 || await confirm("End this game and begin a new game?", false)) {
				rogue.nextGame = NG_NEW_GAME;
				rogue.gameHasEnded = true;
			}
			break;
		case QUIT_KEY:
			if (await confirm("Quit this game without saving?", false)) {
				recordKeystroke(QUIT_KEY, false, false);
				rogue.quit = true;
				await gameOver("Quit", true);
			}
			break;
		case SEED_KEY:
			// DEBUG {
			// 	cellDisplayBuffer dbuf[COLS][ROWS];
			// 	copyDisplayBuffer(dbuf, displayBuffer);
			// 	await funkyFade(dbuf, &white, 0, 100, mapToWindowX(player.xLoc), mapToWindowY(player.yLoc), false);
			// }
			// DEBUG displayLoops();
			// DEBUG displayChokeMap();
			if (DEBUG) { await displayMachines(); }
      //DEBUG displayWaypoints();
			// DEBUG {displayGrid(safetyMap); displayMoreSign(); displayLevel();}
			// parseFile();
			// DEBUG spawnDungeonFeature(player.xLoc, player.yLoc, &dungeonFeatureCatalog[DF_METHANE_GAS_ARMAGEDDON], true, false);
			printSeed();
			break;
		case EASY_MODE_KEY:
			//if (shiftKey) {
				await enableEasyMode();
			//}
			break;
		case TEST_KEY:
			await flashCreatureAlert(player, 'Testing', teal, black);
			break;
		default:
			break;
	}
	if (direction >= 0) { // if it was a movement command
    hideCursor();
		considerCautiousMode();
		if (controlKey || shiftKey) {
			await playerRuns(direction);
		} else {
			await playerMoves(direction);
		}
		refreshSideBar(-1, -1, false);
	}

  if (D_SAFETY_VISION) {
      displayGrid(safetyMap);
  }
  if (rogue.trueColorMode || D_SCENT_VISION) {
      displayLevel();
  }

	rogue.cautiousMode = false;
}




async function getInputTextString( /* char */ inputText,
						   prompt,
						   maxLength,
						   defaultEntry,
						   promptSuffix,
						   textEntryType,
						   useDialogBox)
{
	let charNum, i, x, y;
	let keystroke;
	const suffix = STRING();
	const textEntryBounds = [[' ', '~'], [' ', '~'], ['0', '9']];
	const dbuf = GRID(COLS, ROWS, cellDisplayBuffer), rbuf = GRID(COLS, ROWS, cellDisplayBuffer);

	inputText = STRING(inputText);
	defaultEntry = STRING(defaultEntry);
	promptSuffix = STRING(promptSuffix);

	// x and y mark the origin for text entry.
	if (useDialogBox) {
		x = Math.floor((COLS - max(maxLength, strLenWithoutEscapes(prompt))) / 2);
		y = Math.floor(ROWS / 2 - 1);
		clearDisplayBuffer(dbuf);
		rectangularShading(x - 1, y - 2, max(maxLength, strLenWithoutEscapes(prompt)) + 2,
						   4, interfaceBoxColor, INTERFACE_OPACITY, dbuf);
		overlayDisplayBuffer(dbuf, rbuf);
		printString(prompt, x, y - 1, white, interfaceBoxColor, NULL);
		for (i=0; i<maxLength; i++) {
			plotCharWithColor(' ', x + i, y, black, black);
		}
		printString(defaultEntry, x, y, white, black, 0);
	} else {
		confirmMessages();
		x = mapToWindowX(strLenWithoutEscapes(prompt));
		y = MESSAGE_LINES - 1;
		message(prompt, false);
		printString(defaultEntry, x, y, white, black, 0);
	}

	maxLength = min(maxLength, COLS - x);

	strcpy(inputText, defaultEntry);
	charNum = strLenWithoutEscapes(inputText);
	// for (i = charNum; i < maxLength; i++) {
	// 	inputText.append(' '); // TODO - Make more efficient
	// }

	if (strlen(promptSuffix) == 0) { // empty suffix
		strcpy(suffix, " "); // so that deleting doesn't leave a white trail
	} else {
		strcpy(suffix, promptSuffix);
	}

	do {
		printString(suffix, charNum + x, y, gray, black, 0);
		plotCharWithColor((strlen(suffix) ? suffix.charAt(0) : ' '), x + charNum, y, black, white);
		keystroke = await nextKeyPress(true);
		if ( (keystroke == DELETE_KEY || keystroke == BACKSPACE_KEY) && charNum > 0) {
			printString(suffix, charNum + x - 1, y, gray, black, 0);
			plotCharWithColor(' ', x + charNum + strlen(suffix) - 1, y, black, black);
			charNum--;
			inputText.splice(charNum, 1);
		} else if (strlen(keystroke) > 1) {
			// ignore other special keys...
		} else if (keystroke >= textEntryBounds[textEntryType][0]
				   && keystroke <= textEntryBounds[textEntryType][1]) // allow only permitted input
		{
      if (textEntryType == TEXT_INPUT_FILENAME
          && characterForbiddenInFilename(keystroke))
			{
          keystroke = '-';
      }

			strcat(inputText, keystroke);
			plotCharWithColor(keystroke, x + charNum, y, white, black);
			printString(suffix, charNum + x + 1, y, gray, black, 0);
			if (charNum < maxLength) {
				charNum++;
			}
		}
	} while (keystroke != RETURN_KEY && keystroke != ESCAPE_KEY && keystroke != ENTER_KEY);

	if (useDialogBox) {
		overlayDisplayBuffer(rbuf, NULL);
	}

	// inputText[charNum] = '\0';

	if (keystroke == ESCAPE_KEY) {
		return false;
	}
	strcat(displayedMessage[0], inputText);
	strcat(displayedMessage[0], suffix);
	return true;
}


// void displayCenteredAlert(char *message) {
// 	printString(message, (COLS - strLenWithoutEscapes(message)) / 2, ROWS / 2, &teal, &black, 0);
// }

// Flashes a message on the screen starting at (x, y) lasting for the given time and with the given colors.
async function flashMessage(message, x, y, time, /* color */ fColor, /* color */ bColor) {
	let fastForward;
	let		i, j, messageLength, percentComplete, previousPercentComplete;
	let backColors = []; // color[COLS],
  let backColor = color(), foreColor = color();
	const dbufs = ARRAY(COLS, cellDisplayBuffer); // cellDisplayBuffer[COLS];
	let dchar;
  const startTime = performance.now();
	let nowTime, elapsed;

	if (rogue.playbackFastForward) {
		return;
	}

  previousPercentComplete = -1;
	messageLength = strLenWithoutEscapes(message);
	fastForward = false;

  // assureCosmeticRNG();
	for (j=0; j<messageLength; j++) {
		backColors[j] = colorFromComponents(displayBuffer[j + x][y].backColorComponents);
		dbufs[j].copy(displayBuffer[j + x][y]);
	}
  // restoreRNG();

	previousPercentComplete = -1;
	// for (i=0; i < time && fastForward == false; i++) {
	while( previousPercentComplete < 100 && !fastForward ) {
		// assureCosmeticRNG();

		nowTime = performance.now();
		elapsed = nowTime - startTime;
		percentComplete = Math.floor(100 * elapsed / time);
		percentComplete = Math.floor(percentComplete * percentComplete / 100); // transition is front-loaded
		percentComplete = Math.min(100, Math.max(0, percentComplete));

		if (previousPercentComplete != percentComplete) {
			for (j=0; j<messageLength; j++) {
				if (i==0) {
					backColors[j] = colorFromComponents(displayBuffer[j + x][y].backColorComponents);
					dbufs[j] = displayBuffer[j + x][y];
				}
				backColor.copy(backColors[j]);
				applyColorAverage(backColor, bColor, 100 - percentComplete);
				if (percentComplete < 50) {
					dchar = message.charAt(j); // [j];
					foreColor.copy(fColor);
					applyColorAverage(foreColor, backColor, percentComplete * 2);
				} else {
					dchar = dbufs[j].char;
					foreColor = colorFromComponents(dbufs[j].foreColorComponents);
					applyColorAverage(foreColor, backColor, (100 - percentComplete) * 2);
				}
				plotCharWithColor(dchar, j+x, y, foreColor, backColor);
			}
		}
		previousPercentComplete = percentComplete;
		// restoreRNG();
		fastForward = await pauseBrogue(1);
	}

	console.log('FlashMessage', time, elapsed);

	// assureCosmeticRNG();
	for (j=0; j<messageLength; j++) {
    foreColor = colorFromComponents(dbufs[j].foreColorComponents);
		plotCharWithColor(dbufs[j].char, j+x, y, foreColor, (backColors[j]));
	}
	// restoreRNG();
}

async function flashTemporaryAlert(message, time) {
	await flashMessage(message, Math.round((COLS - strLenWithoutEscapes(message)) / 2), Math.round(ROWS / 2), time, teal, black);
}

async function waitForAcknowledgment() {
	const theEvent = rogueEvent();

	if (rogue.autoPlayingLevel || (rogue.playbackMode && !rogue.playbackOOS)) {
		return;
	}

	do {
		await nextBrogueEvent(theEvent, false, false, false);
		if (theEvent.eventType == KEYSTROKE && theEvent.param1 != ACKNOWLEDGE_KEY && theEvent.param1 != ESCAPE_KEY) {
			await flashTemporaryAlert(" -- Press space or click to continue -- ", 500);
		}
	} while (!(theEvent.eventType == KEYSTROKE && (theEvent.param1 == ACKNOWLEDGE_KEY || theEvent.param1 == ESCAPE_KEY)
			   || theEvent.eventType == MOUSE_UP));
}


async function waitForKeystrokeOrMouseClick() {
	const theEvent = rogueEvent();
	do {
		await nextBrogueEvent(theEvent, false, false, false);
	} while (theEvent.eventType != KEYSTROKE && theEvent.eventType != MOUSE_UP);
}


async function confirm(prompt, alsoDuringPlayback) {
	let retVal;
	let buttons = ARRAY(2, brogueButton); // brogueButton[2] = {{{0}}};
	const rbuf = GRID(COLS, ROWS, cellDisplayBuffer); // cellDisplayBuffer[COLS][ROWS];
	const whiteColorEscape = STRING();
	const yellowColorEscape = STRING();

	if (rogue.autoPlayingLevel || (!alsoDuringPlayback && rogue.playbackMode)) {
		return true; // oh yes he did
	}

	encodeMessageColor(whiteColorEscape, 0, white);
	encodeMessageColor(yellowColorEscape, 0, KEYBOARD_LABELS ? yellow : white);

	initializeButton(buttons[0]);
	sprintf(buttons[0].text, "     %{s}Y%{s}es     ", yellowColorEscape, whiteColorEscape);
	buttons[0].hotkey[0] = 'y';
	buttons[0].hotkey[1] = 'Y';
	buttons[0].hotkey[2] = RETURN_KEY;
	buttons[0].hotkey[3] = ENTER_KEY;
	buttons[0].flags |= (B_WIDE_CLICK_AREA | B_KEYPRESS_HIGHLIGHT);

	initializeButton(buttons[1]);
	sprintf(buttons[1].text, "     %{s}N%{s}o      ", yellowColorEscape, whiteColorEscape);
	buttons[1].hotkey[0] = 'n';
	buttons[1].hotkey[1] = 'N';
	buttons[1].hotkey[2] = ACKNOWLEDGE_KEY;
	buttons[1].hotkey[3] = ESCAPE_KEY;
	buttons[1].flags |= (B_WIDE_CLICK_AREA | B_KEYPRESS_HIGHLIGHT);

	retVal = await printTextBox(prompt, Math.round(COLS/3), Math.round(ROWS/3), Math.round(COLS/3), white, interfaceBoxColor, rbuf, buttons, 2);
	overlayDisplayBuffer(rbuf, NULL);

	if (retVal == -1 || retVal == 1) { // If they canceled or pressed no.
		return false;
	} else {
		return true;
	}

	confirmMessages();	// UNREACHABLE!!!!
	return retVal;
}



function clearMonsterFlashes() {

}

async function displayMonsterFlashes(flashingEnabled) {
	let monst;	// creature *
	const x = [], y = [], strength = [];
	let count = 0;
	const flashColor = ARRAY(100, color); // color *[100];
  // short oldRNG;

	rogue.creaturesWillFlashThisTurn = false;

	if (rogue.autoPlayingLevel || rogue.blockCombatText) {
		return;
	}

  // oldRNG = rogue.RNG;
  // rogue.RNG = RNG_COSMETIC;
	// assureCosmeticRNG();

	CYCLE_MONSTERS_AND_PLAYERS( (monst) => {
		if (monst.bookkeepingFlags & MB_WILL_FLASH) {
			monst.bookkeepingFlags &= ~MB_WILL_FLASH;
			if (flashingEnabled && canSeeMonster(monst) && count < 100) {
				x[count] = monst.xLoc;
				y[count] = monst.yLoc;
				strength[count] = monst.flashStrength;
				flashColor[count].copy(monst.flashColor);
				count++;
			}
		}
	});
	await flashForeground(x, y, flashColor, strength, count, 20);
	// restoreRNG();
}


async function dequeueEvent() {
	const returnEvent = rogueEvent();
	await nextBrogueEvent(returnEvent, false, false, true);
}


async function displayMessageArchive() {
	let i, j, k, reverse, fadePercent, totalMessageCount, currentMessageCount;
	let fastForward;
	const dbuf = GRID(COLS, ROWS, cellDisplayBuffer), rbuf = GRID(COLS, ROWS, cellDisplayBuffer); // [COLS][ROWS];

	// Count the number of lines in the archive.
	for (totalMessageCount=0;
		 totalMessageCount < MESSAGE_ARCHIVE_LINES && strlen(messageArchive[totalMessageCount]);
		 totalMessageCount++);

	if (totalMessageCount <= MESSAGE_LINES) return;

	copyDisplayBuffer(rbuf, displayBuffer);

	// Pull-down/pull-up animation:
	for (reverse = 0; reverse <= 1; reverse++) {
		fastForward = false;
		for (currentMessageCount = (reverse ? totalMessageCount : MESSAGE_LINES);
			 (reverse ? currentMessageCount >= MESSAGE_LINES : currentMessageCount <= totalMessageCount);
			 currentMessageCount += (reverse ? -1 : 1))
	  {
			clearDisplayBuffer(dbuf);

			// Print the message archive text to the dbuf.
			for (j=0; j < currentMessageCount && j < ROWS; j++) {
				printString(messageArchive[(messageArchivePosition - currentMessageCount + MESSAGE_ARCHIVE_LINES + j) % MESSAGE_ARCHIVE_LINES],
							mapToWindowX(0), j, white, black, dbuf);
			}

			// Set the dbuf opacity, and do a fade from bottom to top to make it clear that the bottom messages are the most recent.
			for (j=0; j < currentMessageCount && j<ROWS; j++) {
				fadePercent = 50 * (j + totalMessageCount - currentMessageCount) / totalMessageCount + 50;
				for (i=0; i<DCOLS; i++) {
					dbuf[mapToWindowX(i)][j].opacity = INTERFACE_OPACITY;
					if (dbuf[mapToWindowX(i)][j].char != ' ') {
						for (k=0; k<3; k++) {
							dbuf[mapToWindowX(i)][j].foreColorComponents[k] = dbuf[mapToWindowX(i)][j].foreColorComponents[k] * fadePercent / 100;
						}
					}
				}
			}

			// Display.
			overlayDisplayBuffer(rbuf, 0);
			overlayDisplayBuffer(dbuf, 0);

			if (!fastForward && await pauseBrogue(reverse ? 1 : 2)) {
				fastForward = true;
				// dequeueEvent();
				currentMessageCount = (reverse ? MESSAGE_LINES + 1 : totalMessageCount - 1); // skip to the end
			}
		}

		if (!reverse) {
			await displayMoreSign();
		}
	}
	overlayDisplayBuffer(rbuf, 0);
	updateFlavorText();
	confirmMessages();
	updateMessageDisplay();
}

// Clears the message area and prints the given message in the area.
// It will disappear when messages are refreshed and will not be archived.
// This is primarily used to display prompts.
async function temporaryMessage(msg, requireAcknowledgment) {
	let message; // char[COLS];
	let i, j;

	// assureCosmeticRNG();
	message = capitalize(msg);

	// for (i=0; message[i] == COLOR_ESCAPE; i += 4) {
	// 	message[i] = capitalize(&(message[i]));
	// }

	refreshSideBar(-1, -1, false);

	for (i=0; i<MESSAGE_LINES; i++) {
		for (j=0; j<DCOLS; j++) {
			plotCharWithColor(' ', mapToWindowX(j), i, black, black);
		}
	}
	printString(message, mapToWindowX(0), mapToWindowY(-1), white, black, 0);
	// restoreRNG();

	if (requireAcknowledgment) {
		await waitForAcknowledgment();
		updateMessageDisplay();
	}
}


function flavorMessage(msg) {
	let i;
	let text; // char[COLS*20];

	msg = STRING(msg);
	capitalize(msg);

	printString(msg, mapToWindowX(0), ROWS - 2, flavorTextColor, black, 0);
	for (i = strLenWithoutEscapes(msg); i < DCOLS; i++) {
		plotCharWithColor(' ', mapToWindowX(i), ROWS - 2, black, black);
	}
}


// function messageWithoutCaps(msg, requireAcknowledgment) {
function addMessageLine(msg) {
	let i;
	if (!strlen(msg)) {
      return;
  }

	// // need to confirm the oldest message? (Disabled!)
	// if (!messageConfirmed[MESSAGE_LINES - 1]) {
	// 	//refreshSideBar(-1, -1, false);
	// 	displayMoreSign();
	// 	for (i=0; i<MESSAGE_LINES; i++) {
	// 		messageConfirmed[i] = true;
	// 	}
	// }

	for (i = MESSAGE_LINES - 1; i >= 1; i--) {
		messageConfirmed[i] = messageConfirmed[i-1];
		displayedMessage[i] = displayedMessage[i-1];
	}
	messageConfirmed[0] = false;
	displayedMessage[0] = STRING(msg);

	// Add the message to the archive.
	messageArchive[messageArchivePosition] = displayedMessage[0];
	messageArchivePosition = (messageArchivePosition + 1) % MESSAGE_ARCHIVE_LINES;

}


// function messageWith_Color(msg, /* color */ theColor, requireAcknowledgment) {
// 	let buf; // char[COLS*2] = "";
// 	let i;
//
// 	i=0;
// 	buf = encodeMessageColor(theColor, msg);
// 	message(buf, requireAcknowledgment);
// }


async function messageWithAck(msg, color) {

	refreshSideBar(-1, -1, false);
  message(msg, color);

	await displayMoreSign();

  confirmMessages();
	rogue.cautiousMode = false;
}

function message(msg, color) {
	let msgPtr;
	const text = STRING();
	let i, lines;

	// assureCosmeticRNG();

	rogue.disturbed = true;
	displayCombatText();

	msg = STRING(msg);
	capitalize(msg);

  if (color) {
		const buf = STRING();
    encodeMessageColor(buf, 0, color);
		strcat(buf, msg);
		msg = buf;
  }

	lines = wrapText(text, msg, DCOLS);

  // Implement the American quotation mark/period/comma ordering rule.
  for (i=0; text.text[i] && text.text[i+1]; i++) {
      if (text.charCodeAt(i) === COLOR_ESCAPE) {
          i += 4;
      } else if (text.text[i] === '"'
                 && (text.text[i+1] === '.' || text.text[i+1] === ','))
			{
				const replace = text.text[i+1] + '"';
				text.splice(i, 2, replace);
      }
  }

	if (lines == 1) {
		addMessageLine(text);
	}
	else {
		let msgPtr = 0;
		for (i=0; text.text[i]; i++) {
			if (text.text[i] === '\n') {
				addMessageLine( text.text.substring(msgPtr, i) );
				msgPtr = i + 1;
			}
		}
		if (msgPtr < strlen(text)) {
			addMessageLine( text.text.substring(msgPtr) );
		}
	}

  // display the message:
	updateMessageDisplay();
  // restoreRNG();

  if (rogue.playbackMode) {
		rogue.playbackDelayThisTurn += rogue.playbackDelayPerTurn * 5;
	}
}


// Only used for the "you die..." message, to enable posthumous inventory viewing.
function displayMoreSignWithoutWaitingForAcknowledgment() {
	if (strLenWithoutEscapes(displayedMessage[0]) < DCOLS - 8 || messageConfirmed[0]) {
		printString("--MORE--", COLS - 8, MESSAGE_LINES-1, black, white, 0);
	} else {
		printString("--MORE--", COLS - 8, MESSAGE_LINES, black, white, 0);
	}
}

function displayMoreSign() {
	let i;

	if (rogue.autoPlayingLevel) {
		return;
	}

	if (strLenWithoutEscapes(displayedMessage[0]) < DCOLS - 8 || messageConfirmed[0]) {
		printString("--MORE--", COLS - 8, MESSAGE_LINES-1, black, white, 0);
		return waitForAcknowledgment( () => {
			printString("        ", COLS - 8, MESSAGE_LINES-1, black, black, 0);
		});
	} else {
		printString("--MORE--", COLS - 8, MESSAGE_LINES, black, white, 0);
		return waitForAcknowledgment( () => {
			for (i=1; i<=8; i++) {
				refreshDungeonCell(DCOLS - i, 0);
			}
		});
	}
}

// Inserts a four-character color escape sequence into a string at the insertion point.
// Does NOT check string lengths, so it could theoretically write over the null terminator.
// Returns the new insertion point.
function encodeMessageColor(theMsg, i, theColor) {
  if (!theColor) {
    return theMsg;
  }

	if (i == 0) {
		theMsg.clear();
	}

	const col = theColor.clone();
	// assureCosmeticRNG();
	bakeColor(col);
	col.red		= clamp(col.red, 0, 100);
	col.green	= clamp(col.green, 0, 100);
	col.blue	= clamp(col.blue, 0, 100);
	// restoreRNG();

	theMsg.encodeColor(col, i);
	return i + 4;
}

// Call this when the i'th character of msg is COLOR_ESCAPE.
// It will return the encoded color, and will advance i past the color escape sequence.
function decodeMessageColor(msg, i, /* color */ returnColor) {

	msg = STRING(msg).text;

	if (msg.charCodeAt(i) !== COLOR_ESCAPE) {
		printf("\nAsked to decode a color escape that didn't exist!");
		returnColor.copy(white);
	} else {
		i++;
		returnColor.copy(black);
		returnColor.red	= (msg.charCodeAt(i++) - COLOR_VALUE_INTERCEPT);
		returnColor.green	= (msg.charCodeAt(i++) - COLOR_VALUE_INTERCEPT);
		returnColor.blue	= (msg.charCodeAt(i++) - COLOR_VALUE_INTERCEPT);

		returnColor.red	= clamp(returnColor.red, 0, 100);
		returnColor.green	= clamp(returnColor.green, 0, 100);
		returnColor.blue	= clamp(returnColor.blue, 0, 100);
	}
	return i;
}



// Returns a color for combat text based on the identity of the victim.
function messageColorFromVictim(/* creature */monst) {
	if (monst === player) {
		return badMessageColor;
  } else if (player.status[STATUS_HALLUCINATING] && !rogue.playbackOmniscience) {
      return white;
  } else if (monst.creatureState == MONSTER_ALLY) {
      return badMessageColor;
	} else if (monstersAreEnemies(player, monst)) {
		return goodMessageColor;
	} else {
		return white;
	}
}


function updateMessageDisplay() {
	let i, j, m;
	let messageColor = color();

	for (i=0; i<MESSAGE_LINES; i++) {
		messageColor.copy(white);

		if (messageConfirmed[i]) {
			applyColorAverage(messageColor, black, 50);
			applyColorAverage(messageColor, black, 75 * i / MESSAGE_LINES);
		}

		for (j = m = 0; displayedMessage[i].text[m] && j < DCOLS; j++, m++) {

			while (displayedMessage[i].charCodeAt(m) === COLOR_ESCAPE) {
				m = decodeMessageColor(displayedMessage[i], m, messageColor); // pulls the message color out and advances m
				if (messageConfirmed[i]) {
					applyColorAverage(messageColor, black, 50);
					applyColorAverage(messageColor, black, 75 * i / MESSAGE_LINES);
				}
			}

      plotCharWithColor(displayedMessage[i].text[m], mapToWindowX(j), MESSAGE_LINES - i - 1, messageColor, black);
    }

		for (; j < DCOLS; j++) {
			plotCharWithColor(' ', mapToWindowX(j), MESSAGE_LINES - i - 1, black, black);
		}
	}
}

// Does NOT clear the message archive.
function deleteMessages() {
	let i;
	for (i=0; i<MESSAGE_LINES; i++) {
		displayedMessage[i].clear();
	}
	confirmMessages();
}

function confirmMessages() {
	let i;
	for (i=0; i<MESSAGE_LINES; i++) {
		messageConfirmed[i] = true;
	}
	updateMessageDisplay();
}

const shiftedKeystrokes = [
  SHIFT_UP_KEY, SHIFT_DOWN_KEY, SHIFT_LEFT_KEY, SHIFT_RIGHT_KEY,
  SHIFT_UPLEFT_KEY, SHIFT_UPRIGHT_KEY, SHIFT_DOWNLEFT_KEY, SHIFT_DOWNRIGHT_KEY,
  SHIFT_UP_ARROW, SHIFT_LEFT_ARROW, SHIFT_DOWN_ARROW, SHIFT_RIGHT_ARROW];

const normalKeystrokes = [
  UP_KEY, DOWN_KEY, LEFT_KEY, RIGHT_KEY,
  UPLEFT_KEY, UPRIGHT_KEY, DOWNLEFT_KEY, DOWNRIGHT_KEY,
  UP_ARROW, LEFT_ARROW, DOWN_ARROW, RIGHT_ARROW];

function stripShiftFromMovementKeystroke(keystroke) {
  const index = shiftedKeystrokes.indexOf(keystroke);
  if (index < 0) return keystroke;
  return normalKeystrokes[index];
}


function upperCase(theChar) {
  theChar.capitalize();
}


ENUM('entityDisplayTypes',
	'EDT_NOTHING',
	'EDT_CREATURE',
	'EDT_ITEM',
  'EDT_TERRAIN',
);


// Refreshes the sidebar.
// Progresses from the closest visible monster to the farthest.
// If a monster, item or terrain is focused, then display the sidebar with that monster/item highlighted,
// in the order it would normally appear. If it would normally not fit on the sidebar at all,
// then list it first.
// Also update rogue.sidebarLocationList[ROWS][2] list of locations so that each row of
// the screen is mapped to the corresponding entity, if any.
// FocusedEntityMustGoFirst should usually be false when called externally. This is because
// we won't know if it will fit on the screen in normal order until we try.
// So if we try and fail, this function will call itself again, but with this set to true.
function refreshSideBar(focusX, focusY, focusedEntityMustGoFirst) {
	let printY, oldPrintY, shortestDistance, i, j, k, px, py, x, y, displayEntityCount, indirectVision;
	let monst, closestMonst; // creature *
	let theItem, closestItem;  // item *
	let buf = ''; // char[COLS];
	let entityList = [], focusEntity = NULL;
	let entityType = [], focusEntityType = EDT_NOTHING;
  let terrainLocationMap = ARRAY(ROWS, () => [] ); // short[ROWS][2];
	let gotFocusedEntityOnScreen = (focusX >= 0 ? false : true);
	let addedEntity = GRID(DCOLS, DROWS); // char[DCOLS][DROWS];
  // short oldRNG;

	if (rogue.gameHasEnded || rogue.playbackFastForward) {
		return false;
	}

	// assureCosmeticRNG();

	if (focusX < 0) {
		focusedEntityMustGoFirst = false; // just in case!
	} else {
		if (pmap[focusX][focusY].flags & (HAS_MONSTER | HAS_PLAYER)) {
			monst = monsterAtLoc(focusX, focusY);
			if (canSeeMonster(monst) || rogue.playbackOmniscience) {
				focusEntity = monst;
				focusEntityType = EDT_CREATURE;
			}
		}
		if (!focusEntity && (pmap[focusX][focusY].flags & HAS_ITEM)) {
			theItem = itemAtLoc(focusX, focusY);
			if (playerCanSeeOrSense(focusX, focusY)) {
				focusEntity = theItem;
				focusEntityType = EDT_ITEM;
			}
		}
    if (!focusEntity
        && cellHasTMFlag(focusX, focusY, TM_LIST_IN_SIDEBAR)
        && playerCanSeeOrSense(focusX, focusY))
    {
        focusEntity = tileCatalog[pmap[focusX][focusY].layers[layerWithTMFlag(focusX, focusY, TM_LIST_IN_SIDEBAR)]].description;
        focusEntityType = EDT_TERRAIN;
    }
	}

	printY = 0;

	px = player.xLoc;
	py = player.yLoc;

	zeroOutGrid(addedEntity);

	// Header information for playback mode.
	if (rogue.playbackMode) {
		printString("   -- PLAYBACK --   ", 0, printY++, white, black, 0);
		if (rogue.howManyTurns > 0) {
			buf = `Turn ${rogue.playerTurnNumber}/${rogue.howManyTurns}`;
			printProgressBar(0, printY++, buf, rogue.playerTurnNumber, rogue.howManyTurns, darkPurple, false);
		}
		if (rogue.playbackOOS) {
			printString("    [OUT OF SYNC]   ", 0, printY++, badMessageColor, black, 0);
		} else if (rogue.playbackPaused) {
			printString("      [PAUSED]      ", 0, printY++, gray, black, 0);
		}
		printString("                    ", 0, printY++, white, black, 0);
	}

	// Now list the monsters that we'll be displaying in the order of their proximity to player (listing the focused first if required).

	// Initialization.
	displayEntityCount = 0;
	for (i=0; i<ROWS*2; i++) {
		rogue.sidebarLocationList[i][0] = -1;
		rogue.sidebarLocationList[i][1] = -1;
	}

	// Player always goes first.
	entityList[displayEntityCount] = player;
	entityType[displayEntityCount] = EDT_CREATURE;
	displayEntityCount++;
	addedEntity[player.xLoc][player.yLoc] = true;

	// Focused entity, if it must go first.
	if (focusedEntityMustGoFirst && !addedEntity[focusX][focusY]) {
		addedEntity[focusX][focusY] = true;
		entityList[displayEntityCount] = focusEntity;
		entityType[displayEntityCount] = focusEntityType;
    terrainLocationMap[displayEntityCount][0] = focusX;
    terrainLocationMap[displayEntityCount][1] = focusY;
		displayEntityCount++;
	}

  for (indirectVision = 0; indirectVision < 2; indirectVision++) {
      // Non-focused monsters.
      do {
          shortestDistance = 10000;
          for (monst = monsters.nextCreature; monst != NULL; monst = monst.nextCreature) {
              if ((canDirectlySeeMonster(monst) || (indirectVision && (canSeeMonster(monst) || rogue.playbackOmniscience)))
                  && !addedEntity[monst.xLoc][monst.yLoc]
                  && !(monst.info.flags & MONST_NOT_LISTED_IN_SIDEBAR)
                  && (px - monst.xLoc) * (px - monst.xLoc) + (py - monst.yLoc) * (py - monst.yLoc) < shortestDistance)
              {
                  shortestDistance = (px - monst.xLoc) * (px - monst.xLoc) + (py - monst.yLoc) * (py - monst.yLoc);
                  closestMonst = monst;
              }
          }
          if (shortestDistance < 10000) {
              addedEntity[closestMonst.xLoc][closestMonst.yLoc] = true;
              entityList[displayEntityCount] = closestMonst;
              entityType[displayEntityCount] = EDT_CREATURE;
              displayEntityCount++;
          }
      } while (shortestDistance < 10000 && displayEntityCount * 2 < ROWS); // Because each entity takes at least 2 rows in the sidebar.

      // Non-focused items.
      do {
          shortestDistance = 10000;
          for (theItem = floorItems.nextItem; theItem != NULL; theItem = theItem.nextItem) {
              if ((playerCanDirectlySee(theItem.xLoc, theItem.yLoc) || (indirectVision && (playerCanSeeOrSense(theItem.xLoc, theItem.yLoc) || rogue.playbackOmniscience)))
                  && !addedEntity[theItem.xLoc][theItem.yLoc]
                  && (px - theItem.xLoc) * (px - theItem.xLoc) + (py - theItem.yLoc) * (py - theItem.yLoc) < shortestDistance)
              {
                  shortestDistance = (px - theItem.xLoc) * (px - theItem.xLoc) + (py - theItem.yLoc) * (py - theItem.yLoc);
                  closestItem = theItem;
              }
          }
          if (shortestDistance < 10000) {
              addedEntity[closestItem.xLoc][closestItem.yLoc] = true;
              entityList[displayEntityCount] = closestItem;
              entityType[displayEntityCount] = EDT_ITEM;
              displayEntityCount++;
          }
      } while (shortestDistance < 10000 && displayEntityCount * 2 < ROWS); // Because each entity takes at least 2 rows in the sidebar.

      // Non-focused terrain.

      // count up the number of candidate locations
      for (k=0; k<max(DROWS, DCOLS); k++) {
          for (i = px-k; i <= px+k; i++) {
              for (j = py-k; j <= py+k; j++) {
                  if (coordinatesAreInMap(i, j)
                      && (i == px-k || i == px+k || j == py-k || j == py+k)
                      && !addedEntity[i][j]
                      && (playerCanDirectlySee(i, j) || (indirectVision && (playerCanSeeOrSense(i, j) || rogue.playbackOmniscience)))
                      && cellHasTMFlag(i, j, TM_LIST_IN_SIDEBAR)
                      && displayEntityCount < ROWS - 1)
                  {
                      addedEntity[i][j] = true;
                      entityList[displayEntityCount] = tileCatalog[pmap[i][j].layers[layerWithTMFlag(i, j, TM_LIST_IN_SIDEBAR)]].description;
                      entityType[displayEntityCount] = EDT_TERRAIN;
                      terrainLocationMap[displayEntityCount][0] = i;
                      terrainLocationMap[displayEntityCount][1] = j;
                      displayEntityCount++;
                  }
              }
          }
      }
  }

	// Entities are now listed. Start printing.

	for (i=0; i<displayEntityCount && printY < ROWS - 1; i++) { // Bottom line is reserved for the depth.
		oldPrintY = printY;
		if (entityType[i] == EDT_CREATURE) {
			x = entityList[i].xLoc;
			y = entityList[i].yLoc;
			printY = printMonsterInfo(entityList[i],
									  printY,
									  (focusEntity && (x != focusX || y != focusY)),
									  (x == focusX && y == focusY));

		}
    else if (entityType[i] == EDT_ITEM)
    {
			x = entityList[i].xLoc;
			y = entityList[i].yLoc;
			printY = printItemInfo(entityList[i],
								   printY,
								   (focusEntity && (x != focusX || y != focusY)),
								   (x == focusX && y == focusY));
		} else if (entityType[i] == EDT_TERRAIN) {
            x = terrainLocationMap[i][0];
            y = terrainLocationMap[i][1];
            printY = printTerrainInfo(x, y,
                                      printY,
                                      entityList[i],
                                      (focusEntity && (x != focusX || y != focusY)),
                                      (x == focusX && y == focusY));
        }
		if (focusEntity && (x == focusX && y == focusY) && printY < ROWS) {
			gotFocusedEntityOnScreen = true;
		}
		for (j=oldPrintY; j<printY; j++) {
			rogue.sidebarLocationList[j][0] = x;
			rogue.sidebarLocationList[j][1] = y;
		}
	}

	if (gotFocusedEntityOnScreen) {
		// Wrap things up.
		for (i=printY; i< ROWS - 1; i++) {
			printString("                    ", 0, i, white, black, 0);
		}
		buf = `  -- Depth: ${rogue.depthLevel} --${rogue.depthLevel < 10 ? " " : ""}   `;
		printString(buf, 0, ROWS - 1, white, black, 0);
	} else if (!focusedEntityMustGoFirst) {
		// Failed to get the focusMonst printed on the screen. Try again, this time with the focus first.
		// restoreRNG();
		return refreshSideBar(focusX, focusY, true);
	}

	// restoreRNG();
	return !!focusEntity;
}


function printString(theString, x, y, /* color */ foreColor, /* color */ backColor,  dbuf /* cellDisplayBuffer[COLS][ROWS] */) {
	const fColor = color();
	let i;

	theString = STRING(theString);
	fColor.copy(foreColor);

	for (i=0; theString.text[i] && x < COLS; i++, x++) {
		while (theString.charCodeAt(i) === COLOR_ESCAPE) {
			i = decodeMessageColor(theString, i, fColor);
			if (!theString.text[i]) {
        return;
			}
		}

    if (dbuf) {
			plotCharToBuffer(theString.text[i], x, y, fColor, backColor, dbuf);
		} else {
			plotCharWithColor(theString.text[i], x, y, fColor, backColor);
		}
  }
}


// Inserts line breaks into really long words. Optionally adds a hyphen, but doesn't do anything
// clever regarding hyphen placement. Plays nicely with color escapes.
function breakUpLongWordsIn(sourceText, width, useHyphens) {
	let buf = ''; // char[COLS * ROWS * 2] = "";
	let i, m, nextChar, wordWidth;
	//const short maxLength = useHyphens ? width - 1 : width;

	sourceText = STRING(sourceText);
	const text = sourceText.text;

	// i iterates over characters in sourceText; m keeps track of the length of buf.
	wordWidth = 0;
	for (i=0; text[i]; ) {
		if (text.charCodeAt(i) === COLOR_ESCAPE) {
			buf += text.substring(i, i + 4);
			i += 4;
		} else if (text[i] === ' ' || text[i] === '\n') {
			wordWidth = 0;
			buf += text[i++];
		} else {
			if (!useHyphens && wordWidth >= width) {
				buf += '\n';
				wordWidth = 0;
			} else if (useHyphens && wordWidth >= width - 1) {
				nextChar = i+1;
				while (text[nextChar] === COLOR_ESCAPE) {
					nextChar += 4;
				}
				if (text[nextChar] && text[nextChar] !== ' ' && text[nextChar] !== '\n') {
					buf += '-\n';
					wordWidth = 0;
				}
			}
			buf += text[i++];
			wordWidth++;
		}
	}
	strcpy(sourceText, buf);
}


// Returns the number of lines, including the newlines already in the text.
// Puts the output in "to" only if we receive a "to" -- can make it null and just get a line count.
function wrapText(to, sourceText, width) {
	let i, w, textLength, lineCount;
	const printString = STRING(); // char[COLS * ROWS * 2];
	let spaceLeftOnLine, wordWidth;

	strcpy(printString, sourceText); // a copy we can write on
	breakUpLongWordsIn(printString, width, true); // break up any words that are wider than the width.

	textLength = strlen(printString); // do NOT discount escape sequences
	lineCount = 1;

	// Now go through and replace spaces with newlines as needed.

	// Fast foward until i points to the first character that is not a color escape.
	for (i=0; printString.charCodeAt(i) == COLOR_ESCAPE; i+= 4);
	spaceLeftOnLine = width;

	while (i < textLength) {
		// wordWidth counts the word width of the next word without color escapes.
		// w indicates the position of the space or newline or null terminator that terminates the word.
		wordWidth = 0;
		for (w = i + 1; w < textLength && printString.text[w] !== ' ' && printString.text[w] !== '\n';) {
			if (printString.charCodeAt(w) === COLOR_ESCAPE) {
				w += 4;
			} else {
				w++;
				wordWidth++;
			}
		}

		if (1 + wordWidth > spaceLeftOnLine || printString.text[i] === '\n') {
			printString.splice(i, 1, '\n');	// [i] = '\n';
			lineCount++;
			spaceLeftOnLine = width - wordWidth; // line width minus the width of the word we just wrapped
			//printf("\n\n%s", printString);
		} else {
			spaceLeftOnLine -= 1 + wordWidth;
		}
		i = w; // Advance to the terminator that follows the word.
	}
	if (to) {
		strcpy(to, printString);
	}

	return lineCount;
}

//
// // returns the y-coordinate of the last line
// function printStringWithWrapping(theString, x, y, width, /* color */foreColor,
//   					/* color */ backColor,
// 						dbuf /* cellDisplayBuffer[COLS][ROWS] */)
// {
// 	const fColor = color();
// 	const printString = STRING(); // char[COLS * ROWS * 2];
// 	let i, px, py;
// 	const lines = [];
//
// 	wrapText(lines, theString, width); // inserts newlines as necessary
//
// 	// display the string
// 	px = x; //px and py are the print insertion coordinates; x and y remain the top-left of the text box
// 	py = y;
// 	fColor.copy(foreColor);
//
// 	for (i=0; printString.text[i]; i++) {
// 		if (printString.text[i] === '\n') {
// 			px = x; // back to the leftmost column
// 			if (py < ROWS - 1) { // don't advance below the bottom of the screen
// 				py++; // next line
// 			} else {
// 				break; // If we've run out of room, stop.
// 			}
// 			continue;
// 		} else if (printString.text.charCodeAt(i) === COLOR_ESCAPE) {
// 			i = decodeMessageColor(printString, i, fColor) - 1;
// 			continue;
// 		}
//
// 		if (dbuf) {
// 			if (coordinatesAreInWindow(px, py)) {
// 				plotCharToBuffer(printString.text[i], px, py, fColor, backColor, dbuf);
// 			}
// 		} else {
// 			if (coordinatesAreInWindow(px, py)) {
// 				plotCharWithColor(printString.text[i], px, py, fColor, backColor);
// 			}
// 		}
//
// 		px++;
// 	}
// 	return py;
// }

// returns the y-coordinate of the last line
function printStringWithWrapping(theString, x, y, width, /* color */ foreColor,
  /* color */ backColor, dbuf /* cellDisplayBuffer[COLS][ROWS] */)
{
	const fColor = color();
	let i, px, py;
	const printString = STRING();

	wrapText(printString, theString, width); // inserts newlines as necessary

	// display the string
	px = x; //px and py are the print insertion coordinates; x and y remain the top-left of the text box
	py = y;
	fColor.copy(foreColor);

	for (i=0; printString.text[i]; i++) {
		if (printString.text[i] === '\n') {
			px = x; // back to the leftmost column
			if (py < ROWS - 1) { // don't advance below the bottom of the screen
				py++; // next line
			} else {
				break; // If we've run out of room, stop.
			}
			continue;
		} else if (printString.charCodeAt(i) === COLOR_ESCAPE) {
			i = decodeMessageColor(printString, i, fColor) - 1;
			continue;
		}

		if (dbuf) {
			if (coordinatesAreInWindow(px, py)) {
				plotCharToBuffer(printString.text[i], px, py, fColor, backColor, dbuf);
			}
		} else {
			if (coordinatesAreInWindow(px, py)) {
				plotCharWithColor(printString.text[i], px, py, fColor, backColor);
			}
		}

		px++;
	}

  return py;
}

async function nextKeyPress(textInput) {
	const theEvent = rogueEvent();
	do {
		await nextBrogueEvent(theEvent, textInput, false, false);
	} while (theEvent.eventType != KEYSTROKE);
	return theEvent.param1;
}

// const BROGUE_HELP_LINE_COUNT	 = 33;

async function printHelpScreen() {
	let i, j;
	const dbuf = GRID(COLS, ROWS, cellDisplayBuffer), rbuf = GRID(COLS, ROWS, cellDisplayBuffer); // cellDisplayBuffer[COLS][ROWS];
	let helpText = [
		"",
		"",
		"          -- Commands --",
		"",
		"         mouse  ****move cursor (including to examine monsters and terrain)",
		"         click  ****travel",
		" control-click  ****advance one space",
		"      <return>  ****enable keyboard cursor control",
		"   <space/esc>  ****disable keyboard cursor control",
		"hjklyubn, arrow keys, or numpad  ****move or attack (control or shift to run)",
		"",
		" a/e/r/t/d/c/R  ****apply/equip/remove/throw/drop/call/relabel an item",
		"i, right-click  ****view inventory",
		"             D  ****list discovered items",
        "",
		"             z  ****rest once",
		"             Z  ****rest for 100 turns or until something happens",
		"             s  ****search for secret doors and traps",
		"          <, >  ****travel to stairs",
		"             x  ****auto-explore (control-x: fast forward)",
		"             A  ****autopilot (control-A: fast forward)",
		"             M  ****display old messages",
        "",
		"             Q  ****quit to title screen",
        "",
		"             \\  ****disable/enable color effects",
		"             ]  ****display/hide stealth range",
		// "             [  ****enable/disable low HP warning",
		"   <space/esc>  ****clear message or cancel command",
		"",
		"        -- press space or click to continue --"
	];

	const BROGUE_HELP_LINE_COUNT = helpText.length;

	// Replace the "****"s with color escapes.
	for (i=0; i<BROGUE_HELP_LINE_COUNT; i++) {
		helpText[i] = STRING(helpText[i]);
		for (j=0; j < strlen(helpText[i]); j++) {
			if (helpText[i].charAt(j) == '*') {
				j = encodeMessageColor(helpText[i], j, white);
			}
		}
	}

	clearDisplayBuffer(dbuf);

	// Print the text to the dbuf.
	for (i=0; i<helpText.length && i < ROWS; i++) {
		printString(helpText[i], mapToWindowX(1), i, itemMessageColor, black, dbuf);
	}

	// Set the dbuf opacity.
	for (i=0; i<DCOLS; i++) {
		for (j=0; j<ROWS; j++) {
			//plotCharWithColor(' ', mapToWindowX(i), j, &black, &black);
			dbuf[mapToWindowX(i)][j].opacity = INTERFACE_OPACITY;
		}
	}

	// Display.
	overlayDisplayBuffer(dbuf, rbuf);
	commitDraws();
	await waitForAcknowledgment();
	overlayDisplayBuffer(rbuf, 0);
	updateFlavorText();
	updateMessageDisplay();
	commitDraws();
}


function printDiscoveries(category, count, itemCharacter, x, y, dbuf /* cellDisplayBuffer[COLS][ROWS] */) {
	const theColor = color(), goodColor = color(), badColor = color();
	const buf = STRING(), buf2 = STRING(); // char[COLS];
	let i, magic, totalFrequency;
	const theTable = tableForItemCategory(category, NULL);	// itemTable *

	goodColor.copy(goodMessageColor);
	applyColorAverage(goodColor, black, 50);
	badColor.copy(badMessageColor);
	applyColorAverage(badColor, black, 50);

  totalFrequency = 0;
	for (i = 0; i < count; i++) {
      if (!theTable[i].identified) {
          totalFrequency += theTable[i].frequency;
      }
  }

	for (i = 0; i < count; i++) {
		if (theTable[i].identified) {
			theColor.copy(white);
			plotCharToBuffer(itemCharacter, x, y + i, itemColor, black, dbuf);
		} else {
			theColor.copy(darkGray);
      magic = magicCharDiscoverySuffix(category, i);
      if (magic == 1) {
          plotCharToBuffer(GOOD_MAGIC_CHAR, x, y + i, goodColor, black, dbuf);
      } else if (magic == -1) {
          plotCharToBuffer(BAD_MAGIC_CHAR, x, y + i, badColor, black, dbuf);
      }
		}
		strcpy(buf, theTable[i].name);

	  if (!theTable[i].identified
	      && theTable[i].frequency > 0
	      && totalFrequency > 0)
		{
	      sprintf(buf2, " (%i%)", Math.floor(theTable[i].frequency * 100 / totalFrequency));
	      strcat(buf, buf2);
	  }

		capitalize(buf);
		strcat(buf, " ");
		printString(buf, x + 2, y + i, theColor, black, dbuf);
	}
}


async function printDiscoveriesScreen() {
	let i, j, y;
	const dbuf = GRID(COLS, ROWS, cellDisplayBuffer), rbuf = GRID(COLS, ROWS, cellDisplayBuffer); // cellDisplayBuffer[COLS][ROWS];

	clearDisplayBuffer(dbuf);

	printString("-- SCROLLS --", mapToWindowX(2), y = mapToWindowY(1), flavorTextColor, black, dbuf);
	printDiscoveries(SCROLL, NUMBER_SCROLL_KINDS, SCROLL_CHAR, mapToWindowX(3), ++y, dbuf);

	printString("-- RINGS --", mapToWindowX(2), y += NUMBER_SCROLL_KINDS + 1, flavorTextColor, black, dbuf);
	printDiscoveries(RING, NUMBER_RING_KINDS, RING_CHAR, mapToWindowX(3), ++y, dbuf);

	printString("-- POTIONS --", mapToWindowX(29), y = mapToWindowY(1), flavorTextColor, black, dbuf);
	printDiscoveries(POTION, NUMBER_POTION_KINDS, POTION_CHAR, mapToWindowX(30), ++y, dbuf);

	printString("-- STAFFS --", mapToWindowX(53), y = mapToWindowY(1), flavorTextColor, black, dbuf);
	printDiscoveries(STAFF, NUMBER_STAFF_KINDS, STAFF_CHAR, mapToWindowX(54), ++y, dbuf);

	printString("-- WANDS --", mapToWindowX(53), y += NUMBER_STAFF_KINDS + 1, flavorTextColor, black, dbuf);
	printDiscoveries(WAND, NUMBER_WAND_KINDS, WAND_CHAR, mapToWindowX(54), ++y, dbuf);

  printString(KEYBOARD_LABELS ? "-- press any key to continue --" : "-- touch anywhere to continue --",
              mapToWindowX(20), mapToWindowY(DROWS-2), itemMessageColor, black, dbuf);

	for (i=0; i<COLS; i++) {
		for (j=0; j<ROWS; j++) {
			dbuf[i][j].opacity = (i < STAT_BAR_WIDTH ? 0 : INTERFACE_OPACITY);
		}
	}
	overlayDisplayBuffer(dbuf, rbuf);

  await waitForKeystrokeOrMouseClick();
  overlayDisplayBuffer(rbuf, NULL);

}

//
//
// /* ALWAYS
//
// // Creates buttons for the discoveries screen in the buttons pointer; returns the number of buttons created.
// //short createDiscoveriesButtons(short category, short count, unsigned short itemCharacter, short x, short y, brogueButton *buttons) {
// //	color *theColor, goodColor, badColor;
// //	char whiteColorEscape[20] = "", darkGrayColorEscape[20] = "", yellowColorEscape[20] = "", goodColorEscape[20] = "", badColorEscape[20] = "";
// //	short i, x2, magic, symbolCount;
// //	itemTable *theTable = tableForItemCategory(category, NULL);
// //
// //	goodColor = goodMessageColor;
// //	applyColorAverage(&goodColor, &black, 50);
// //	encodeMessageColor(goodColorEscape, 0, &goodColor);
// //	badColor = badMessageColor;
// //	applyColorAverage(&badColor, &black, 50);
// //	encodeMessageColor(badColorEscape, 0, &goodColor);
// //	encodeMessageColor(whiteColorEscape, 0, &white);
// //	encodeMessageColor(darkGrayColorEscape, 0, &darkGray);
// //
// //	for (i = 0; i < count; i++) {
// //		buttons[i].x = x;
// //		buttons[i].y = y + i;
// //		buttons[i].opacity = 100;
// //		symbolCount = 0;
// //		if (theTable[i].identified) {
// //			strcat(buttons[i].text, yellowColorEscape);
// //			buttons[i].symbol[symbolCount++] = itemCharacter;
// //			strcat(buttons[i].text, "*");
// //			strcat(buttons[i].text, whiteColorEscape);
// //			//plotCharToBuffer(itemCharacter, x, y + i, &itemColor, &black, dbuf);
// //		} else {
// //			strcat(buttons[i].text, darkGrayColorEscape);
// //		}
// //		strcpy(buf, theTable[i].name);
// //		buf = capitalize(buf);
// //		strcat(buf, " ");
// //		printString(buf, x + 2, y + i, theColor, &black, dbuf);
// //
// //		x2 = x + 2 + strLenWithoutEscapes(buf);
// //		magic = magicCharDiscoverySuffix(category, i);
// //		plotCharToBuffer('(', x2++, y + i, &darkGray, &black, dbuf);
// //		if (magic != -1) {
// //			plotCharToBuffer(GOOD_MAGIC_CHAR, x2++, y + i, &goodColor, &black, dbuf);
// //		}
// //		if (magic != 1) {
// //			plotCharToBuffer(BAD_MAGIC_CHAR, x2++, y + i, &badColor, &black, dbuf);
// //		}
// //		plotCharToBuffer(')', x2++, y + i, &darkGray, &black, dbuf);
// //	}
// //	return i;
// //}
// //
// //void printDiscoveriesScreen() {
// //	short i, j, y, buttonCount;
// //	cellDisplayBuffer dbuf[COLS][ROWS], rbuf[COLS][ROWS];
// //	brogueButton buttons[NUMBER_SCROLL_KINDS + NUMBER_WAND_KINDS + NUMBER_POTION_KINDS + NUMBER_STAFF_KINDS + NUMBER_RING_KINDS] = {{{0}}};
// //
// //	clearDisplayBuffer(dbuf);
// //	buttonCount = 0;
// //
// //	printString("-- SCROLLS --", mapToWindowX(3), y = mapToWindowY(1), &flavorTextColor, &black, dbuf);
// //	buttonCount += createDiscoveriesButtons(SCROLL, NUMBER_SCROLL_KINDS, SCROLL_CHAR, mapToWindowX(3), ++y, &(buttons[buttonCount]));
// //
// //	printString("-- WANDS --", mapToWindowX(3), y += NUMBER_SCROLL_KINDS + 1, &flavorTextColor, &black, dbuf);
// //	buttonCount += createDiscoveriesButtons(WAND, NUMBER_WAND_KINDS, WAND_CHAR, mapToWindowX(3), ++y, &(buttons[buttonCount]));
// //
// //	printString("-- POTIONS --", mapToWindowX(29), y = mapToWindowY(1), &flavorTextColor, &black, dbuf);
// //	buttonCount += createDiscoveriesButtons(POTION, NUMBER_POTION_KINDS, POTION_CHAR, mapToWindowX(29), ++y, &(buttons[buttonCount]));
// //
// //	printString("-- STAFFS --", mapToWindowX(54), y = mapToWindowY(1), &flavorTextColor, &black, dbuf);
// //	buttonCount += createDiscoveriesButtons(STAFF, NUMBER_STAFF_KINDS, STAFF_CHAR, mapToWindowX(54), ++y, &(buttons[buttonCount]));
// //
// //	printString("-- RINGS --", mapToWindowX(54), y += NUMBER_STAFF_KINDS + 1, &flavorTextColor, &black, dbuf);
// //	buttonCount += createDiscoveriesButtons(RING, NUMBER_RING_KINDS, RING_CHAR, mapToWindowX(54), ++y, &(buttons[buttonCount]));
// //
// //	for (i=0; i<COLS; i++) {
// //		for (j=0; j<ROWS; j++) {
// //			dbuf[i][j].opacity = (i < STAT_BAR_WIDTH ? 0 : INTERFACE_OPACITY);
// //		}
// //	}
// //	overlayDisplayBuffer(dbuf, rbuf);
// //
// //	displayMoreSign();
// //
// //	overlayDisplayBuffer(rbuf, NULL);
// //}
//
// // ALWAYS
//  */
//
//

async function printHighScores(hiliteMostRecent) {
	let i, hiliteLineNum, maxLength = 0, leftOffset;
	const list = ARRAY(HIGH_SCORES_COUNT, rogueHighScoresEntry); // rogueHighScoresEntry[HIGH_SCORES_COUNT] = {{0}};
	const buf = STRING(); // char[DCOLS*3];
	const scoreColor = color();

	hiliteLineNum = getHighScoresList(list);

	if (!hiliteMostRecent) {
		hiliteLineNum = -1;
	}

	blackOutScreen();

	for (i = 0; i < HIGH_SCORES_COUNT && list[i].score > 0; i++) {
		if (strLenWithoutEscapes(list[i].description) > maxLength) {
			maxLength = strLenWithoutEscapes(list[i].description);
		}
	}

	leftOffset = min(COLS - maxLength - 21 - 1, Math.round(COLS/5));

	scoreColor.copy(black);
	applyColorAverage(scoreColor, itemMessageColor, 100);
	printString("-- HIGH SCORES --", (COLS - 17 + 1) / 2, 0, scoreColor, black, 0);

	for (i = 0; i < HIGH_SCORES_COUNT && list[i].score > 0; i++) {
		scoreColor.copy(black);
		if (i == hiliteLineNum) {
			applyColorAverage(scoreColor, itemMessageColor, 100);
		} else {
			applyColorAverage(scoreColor, white, 100);
			applyColorAverage(scoreColor, black, (i * 50 / 24));
		}

		// rank
		sprintf(buf, "%s%i)", (i + 1 < 10 ? " " : ""), i + 1);
		printString(buf, leftOffset, i + 2, scoreColor, black, 0);

		// score
		sprintf(buf, "%i", list[i].score);
		printString(buf, leftOffset + 5, i + 2, scoreColor, black, 0);

		// date
		printString(list[i].date, leftOffset + 12, i + 2, scoreColor, black, 0);

		// description
		printString(list[i].description, leftOffset + 21, i + 2, scoreColor, black, 0);
	}

	scoreColor.copy(black);
	applyColorAverage(scoreColor, goodMessageColor, 100);

	printString(KEYBOARD_LABELS ? "Press space to continue." : "Touch anywhere to continue.",
                (COLS - strLenWithoutEscapes(KEYBOARD_LABELS ? "Press space to continue." : "Touch anywhere to continue.")) / 2,
                ROWS - 1, scoreColor, black, 0);

	commitDraws();
	await waitForAcknowledgment();
}

function displayGrid(/* short **/ map) {
	let i, j, score, topRange, bottomRange;
	let tempColor, foreColor, backColor;
	let dchar;

	topRange = -30000;
	bottomRange = 30000;
	tempColor = black.clone();

	if (map == safetyMap && !rogue.updatedSafetyMapThisTurn) {
		updateSafetyMap();
	}

	for (i=0; i<DCOLS; i++) {
		for (j=0; j<DROWS; j++) {
			if (cellHasTerrainFlag(i, j, T_WAYPOINT_BLOCKER) || (map[i][j] == map[0][0]) || (i == player.xLoc && j == player.yLoc)) {
				continue;
			}
			if (map[i][j] > topRange) {
				topRange = map[i][j];
				//if (topRange == 0) {
					//printf("\ntop is zero at %i,%i", i, j);
				//}
			}
			if (map[i][j] < bottomRange) {
				bottomRange = map[i][j];
			}
		}
	}

	for (i=0; i<DCOLS; i++) {
		for (j=0; j<DROWS; j++) {
			if (cellHasTerrainFlag(i, j, T_OBSTRUCTS_PASSABILITY | T_LAVA_INSTA_DEATH)
				|| (map[i][j] == map[0][0])
				|| (i == player.xLoc && j == player.yLoc))
			{
				continue;
			}
			score = 300 - (map[i][j] - bottomRange) * 300 / max(1, (topRange - bottomRange));
			tempColor.blue = max(min(score, 100), 0);
			score -= 100;
			tempColor.red = max(min(score, 100), 0);
			score -= 100;
			tempColor.green = max(min(score, 100), 0);
			const app = getCellAppearance(i, j);
			plotCharWithColor(app.char, mapToWindowX(i), mapToWindowY(j), app.foreColor, tempColor);
			//colorBlendCell(i, j, &tempColor, 100);//hiliteCell(i, j, &tempColor, 100, false);
		}
	}
	//printf("\ntop: %i; bottom: %i", topRange, bottomRange);
}

function printSeed() {
	const buf = STRING(); // char[COLS];
	sprintf(buf, "Dungeon seed #%i; turn #%i", rogue.seed, rogue.playerTurnNumber);
	message(buf, false);
}


function printProgressBar(x, y, barLabel, amtFilled, amtMax, /* color */ fillColor, dim) {
	const barText = STRING(barLabel); // string length is 20
	let i, labelOffset;
	let currentFillColor = color(), textColor = color(), progressBarColor, darkenedBarColor; // color

	if (y >= ROWS - 1) { // don't write over the depth number
		return;
	}

	if (amtFilled > amtMax) {
		amtFilled = amtMax;
	}

	if (amtMax <= 0) {
		amtMax = 1;
	}

	progressBarColor = fillColor.clone();
	if (!(y % 2)) {
		applyColorAverage(progressBarColor, black, 25);
	}

	if (dim) {
		applyColorAverage(progressBarColor, black, 50);
	}
	darkenedBarColor = progressBarColor.clone();
	applyColorAverage(darkenedBarColor, black, 75);

  centerText(barText, 20);

	amtFilled = clamp(amtFilled, 0, amtMax);

	if (amtMax < 10000000) {
		amtFilled *= 100;
		amtMax *= 100;
	}

	for (i=0; i<20; i++) {
		currentFillColor.copy(i <= (20 * amtFilled / amtMax) ? progressBarColor : darkenedBarColor);
		if (i == 20 * amtFilled / amtMax) {
			applyColorAverage(currentFillColor, black, 75 - 75 * (amtFilled % (amtMax / 20)) / (amtMax / 20));
		}
		textColor.copy(dim ? gray : white);
		applyColorAverage(textColor, currentFillColor, (dim ? 50 : 33));
		plotCharWithColor(barText.text[i], x + i, y, textColor, currentFillColor);
	}

}


// // Very low-level. Changes displayBuffer directly.
function highlightScreenCell(x, y, /* color */ highlightColor, strength)
{
	let tempColor; // color

	tempColor = colorFromComponents(displayBuffer[x][y].foreColorComponents);
	applyColorAugment(tempColor, highlightColor, strength);
	storeColorComponents(displayBuffer[x][y].foreColorComponents, tempColor);

	tempColor = colorFromComponents(displayBuffer[x][y].backColorComponents);
	applyColorAugment(tempColor, highlightColor, strength);
	storeColorComponents(displayBuffer[x][y].backColorComponents, tempColor);

	displayBuffer[x][y].needsUpdate = true;
}

function estimatedArmorValue() {
    let retVal = 0;

    retVal = ((armorTable[rogue.armor.kind].range.upperBound + armorTable[rogue.armor.kind].range.lowerBound) / 2) / 10;
    retVal += fp_strengthModifier(rogue.armor) >> FP_BASE;
    retVal -= player.status[STATUS_DONNING];

    return max(0, Math.floor(retVal));
}

function creatureHealthChangePercent(/* creature */ monst) {
    let currentPercent, previousPercent;
    if (monst.previousHealthPoints <= 0) {
        return 0;
    }
    currentPercent = Math.floor(monst.currentHP * 100 / monst.info.maxHP);
    previousPercent = Math.floor(monst.previousHealthPoints * 100 / monst.info.maxHP);
    return Math.floor(monst.currentHP * 100 / monst.previousHealthPoints) - 100;
}


// returns the y-coordinate after the last line printed
function printMonsterInfo(/* creature */monst, y, dim, highlight)
{
	const buf = STRING(), buf2 = STRING(), monstName = STRING(), tempColorEscape = STRING(), grayColorEscape = STRING();
	let monstChar;
	let monstForeColor, monstBackColor, healthBarColor, tempColor = white.clone();
	let initialY, i, j, highlightStrength, displayedArmor, percent;
	let inPath;

	if (y >= ROWS - 1) {
		return ROWS - 1;
	}

	initialY = y;

	// assureCosmeticRNG();

	if (y < ROWS - 1) {
		printString("                    ", 0, y, white, black, 0); // Start with a blank line

		// Unhighlight if it's highlighted as part of the path.
		inPath = (pmap[monst.xLoc][monst.yLoc].flags & IS_IN_PATH) ? true : false;
		pmap[monst.xLoc][monst.yLoc].flags &= ~IS_IN_PATH;
		const monstApp = getCellAppearance(monst.xLoc, monst.yLoc);

    applyColorBounds(monstApp.foreColor, 0, 100);
    applyColorBounds(monstApp.backColor, 0, 100);
		if (inPath) {
			pmap[monst.xLoc][monst.yLoc].flags |= IS_IN_PATH;
		}

		if (dim) {
			applyColorAverage(monstApp.foreColor, black, 50);
			applyColorAverage(monstApp.backColor, black, 50);
		} else if (highlight) {
			applyColorAugment(monstApp.foreColor, black, 100);
			applyColorAugment(monstApp.backColor, black, 100);
		}
		plotCharWithColor(monstApp.char, 0, y, monstApp.foreColor, monstApp.backColor);

		//patch to indicate monster is carrying item
		// if(monst.carriedItem) {
		// 	plotCharWithColor(monst.carriedItem.displayChar, 1, y, itemColor, black);
		// }
		//end patch


		monsterName(monstName, monst, false);
		capitalize(monstName);

    if (monst === player) {
        if (player.status[STATUS_INVISIBLE]) {
					strcat(monstName, " ");
					encodeMessageColor(monstName, strlen(monstName), monstForeColor);
					strcat(monstName, "(invisible)");
        } else if (playerInDarkness()) {
					strcat(monstName, " ");
					//encodeMessageColor(monstName, strlen(monstName) - 4, &playerInDarknessColor);
					encodeMessageColor(monstName, strlen(monstName), monstForeColor);
					strcat(monstName, "(dark)");
        } else if (!pmap[player.xLoc][player.yLoc].flags & IS_IN_SHADOW) {
					strcat(monstName, " ");
					//encodeMessageColor(monstName, strlen(monstName) - 4, &playerInLightColor);
					encodeMessageColor(monstName, strlen(monstName), monstForeColor);
					strcat(monstName, "(lit)");
        }
    }

		sprintf(buf, ": %s", monstName);

		printString("                   ", 1, y, white, black, 0);
		printString(buf, 1, y++, (dim ? gray : white), black, 0);
	}

  // mutation, if any
  if (y < ROWS - 1
      && monst.mutationIndex >= 0
      && (!player.status[STATUS_HALLUCINATING] || rogue.playbackOmniscience))
  {
      tempColor.copy(mutationCatalog[monst.mutationIndex].textColor);
      if (dim) {
          applyColorAverage(tempColor, black, 50);
      }
			encodeMessageColor(buf, 0, tempColor);
			sprintf(buf2, "(%s)", mutationCatalog[monst.mutationIndex].title);
			strcat(buf, buf2);
      centerText(buf, 20);
	    printString(buf, 0, y++, (dim ? gray : white), black, 0);
  }

	// hit points
	if (monst.info.maxHP > 1 && !(monst.info.flags & MONST_INVULNERABLE))
  {
		if (monst === player) {
			healthBarColor = redBar.clone();
			applyColorAverage(healthBarColor, blueBar, min(100, 100 * player.currentHP / player.info.maxHP));
		} else {
			healthBarColor = blueBar;
		}

		percent = creatureHealthChangePercent(monst);
		if (monst.currentHP <= 0) {
				strcpy(buf, "Dead");
		} else if (percent != 0) {
				strcpy(buf, "Health");
				sprintf(buf2, " (%s%i%)", percent > 0 ? "+" : "", percent);
				strcat(buf, buf2);
				centerText(buf, 20);
		} else {
				strcpy(buf, "Health");
		}
		printProgressBar(0, y++, buf, monst.currentHP, monst.info.maxHP, healthBarColor, dim);
	}

	if (monst === player) {
		// nutrition
		if (player.status[STATUS_NUTRITION] > HUNGER_THRESHOLD) {
			printProgressBar(0, y++, "Nutrition", player.status[STATUS_NUTRITION], STOMACH_SIZE, blueBar, dim);
		} else if (player.status[STATUS_NUTRITION] > WEAK_THRESHOLD) {
			printProgressBar(0, y++, "Nutrition (Hungry)", player.status[STATUS_NUTRITION], STOMACH_SIZE, blueBar, dim);
		} else if (player.status[STATUS_NUTRITION] > FAINT_THRESHOLD) {
			printProgressBar(0, y++, "Nutrition (Weak)", player.status[STATUS_NUTRITION], STOMACH_SIZE, blueBar, dim);
		} else if (player.status[STATUS_NUTRITION] > 0) {
			printProgressBar(0, y++, "Nutrition (Faint)", player.status[STATUS_NUTRITION], STOMACH_SIZE, blueBar, dim);
		} else if (y < ROWS - 1) {
			printString("      STARVING      ", 0, y++, badMessageColor, black, NULL);
		}
	}

	if (!player.status[STATUS_HALLUCINATING] || rogue.playbackOmniscience || monst === player) {

		for (i=0; i<NUMBER_OF_STATUS_EFFECTS; i++) {
			if (i == STATUS_WEAKENED && monst.status[i] > 0) {
				buf = statusStrings[STATUS_WEAKENED] + monst.weaknessAmount;
				printProgressBar(0, y++, buf, monst.status[i], monst.maxStatus[i], redBar, dim);
			} else if (i == STATUS_LEVITATING && monst.status[i] > 0) {
				printProgressBar(0, y++, (monst === player ? "Levitating" : "Flying"), monst.status[i], monst.maxStatus[i], redBar, dim);
			} else if (i == STATUS_POISONED
					   && monst.status[i] > 0)
      {
				if (monst.status[i] * monst.poisonAmount >= monst.currentHP) {
						strcpy(buf, "Fatal Poison");
				} else {
						strcpy(buf, "Poisoned");
				}
        if (monst.poisonAmount == 1) {
            printProgressBar(0, y++, buf, monst.status[i], monst.maxStatus[i], redBar, dim);
        } else {
						sprintf(buf2, "%s (x%i)",
									buf,
									monst.poisonAmount);
            printProgressBar(0, y++, buf2, monst.status[i], monst.maxStatus[i], redBar, dim);
        }
			} else if (statusStrings[i][0] && monst.status[i] > 0) {
				printProgressBar(0, y++, statusStrings[i], monst.status[i], monst.maxStatus[i], redBar, dim);
			}
		}
		if (monst.targetCorpseLoc[0] == monst.xLoc && monst.targetCorpseLoc[1] == monst.yLoc) {
			printProgressBar(0, y++,  monsterText[monst.info.monsterID].absorbStatus, monst.corpseAbsorptionCounter, 20, redBar, dim);
		}
	}

	if (monst !== player &&
    (!(monst.info.flags & MONST_INANIMATE) || monst.creatureState == MONSTER_ALLY))
  {
			if (y < ROWS - 1) {
				if (player.status[STATUS_HALLUCINATING] && !rogue.playbackOmniscience && y < ROWS - 1) {
					printString(hallucinationStrings[cosmetic_range(0, 9)], 0, y++, (dim ? darkGray : gray), black, 0);
				} else if (monst.bookkeepingFlags & MB_CAPTIVE && y < ROWS - 1) {
					printString("     (Captive)      ", 0, y++, (dim ? darkGray : gray), black, 0);
				} else if ((monst.info.flags & MONST_RESTRICTED_TO_LIQUID)
						   && !cellHasTMFlag(monst.xLoc, monst.yLoc, TM_ALLOWS_SUBMERGING)) {
					printString("     (Helpless)     ", 0, y++, (dim ? darkGray : gray), black, 0);
				} else if (monst.creatureState == MONSTER_SLEEPING && y < ROWS - 1) {
					printString("     (Sleeping)     ", 0, y++, (dim ? darkGray : gray), black, 0);
        } else if ((monst.creatureState == MONSTER_ALLY) && y < ROWS - 1) {
                    printString("       (Ally)       ", 0, y++, (dim ? darkGray : gray), black, 0);
				} else if (monst.creatureState == MONSTER_FLEEING && y < ROWS - 1) {
					printString("     (Fleeing)      ", 0, y++, (dim ? darkGray : gray), black, 0);
				} else if ((monst.creatureState == MONSTER_WANDERING) && y < ROWS - 1) {
					if ((monst.bookkeepingFlags & MB_FOLLOWER) && monst.leader && (monst.leader.info.flags & MONST_IMMOBILE)) {
						// follower of an immobile leader -- i.e. a totem
						printString("    (Worshiping)    ", 0, y++, (dim ? darkGray : gray), black, 0);
					} else if ((monst.bookkeepingFlags & MB_FOLLOWER) && monst.leader && (monst.leader.bookkeepingFlags & MB_CAPTIVE)) {
						// actually a captor/torturer
						printString("     (Guarding)     ", 0, y++, (dim ? darkGray : gray), black, 0);
					} else {
						printString("    (Wandering)     ", 0, y++, (dim ? darkGray : gray), black, 0);
					}
        } else if (monst.ticksUntilTurn > max(0, player.ticksUntilTurn) + player.movementSpeed) {
            printString("   (Off balance)    ", 0, y++, (dim ? darkGray : gray), black, 0);
        } else if ((monst.creatureState == MONSTER_TRACKING_SCENT) && y < ROWS - 1) {
					printString("     (Hunting)      ", 0, y++, (dim ? darkGray : gray), black, 0);
				}
			}
	} else if (monst === player) {
		if (y < ROWS - 1) {
			// tempColorEscape[0] = '\0';
			// grayColorEscape[0] = '\0';
			if (player.status[STATUS_WEAKENED]) {
				tempColor.copy(red);
				if (dim) {
					applyColorAverage(tempColor, black, 50);
				}
				// encodeMessageColor(tempColorEscape, 0, &tempColor);
				// encodeMessageColor(grayColorEscape, 0, (dim ? &darkGray : &gray));
			}

      displayedArmor = displayedArmorValue();

			if (!rogue.armor || rogue.armor.flags & ITEM_IDENTIFIED || rogue.playbackOmniscience) {
				sprintf(buf, "Str: %s%i%s  Armor: %i",
						tempColorEscape,
						rogue.strength - player.weaknessAmount,
						grayColorEscape,
						displayedArmor);
			} else {
				sprintf(buf, "Str: %s%i%s  Armor: %i?",
						tempColorEscape,
						rogue.strength - player.weaknessAmount,
						grayColorEscape,
						estimatedArmorValue());
			}
			//buf[20] = '\0';
			centerText(buf, 20);
			printString(buf, 0, y++, (dim ? darkGray : gray), black, 0);
		}
		if (y < ROWS - 1 && rogue.gold) {
			sprintf(buf, "Gold: %li", rogue.gold);
			centerText(buf, 20);
			printString(buf, 0, y++, (dim ? darkGray : gray), black, 0);
		}
    if (y < ROWS - 1) {
      tempColor.copy(playerInShadowColor);
      percent = (rogue.aggroRange - 2) * 100 / 28;
      applyColorAverage(tempColor, black, percent);
      applyColorAugment(tempColor, playerInLightColor, percent);
      if (dim) {
          applyColorAverage(tempColor, black, 50);
      }
			encodeMessageColor(tempColorEscape, 0, tempColor);
			encodeMessageColor(grayColorEscape, 0, (dim ? darkGray : gray));
			sprintf(buf, "%{s}Stealth range: %i%s",
							tempColorEscape,
							rogue.aggroRange,
							grayColorEscape);
			centerText(buf, 20);
			// printString("                    ", 0, y, white, black, 0);
			printString(buf, 0, y++, (dim ? darkGray : gray), black, 0);
    }
  }

	if (y < ROWS - 1) {
		printString("                    ", 0, y++, (dim ? darkGray : gray), black, 0);
	}

	if (highlight) {
		for (i=0; i<20; i++) {
			highlightStrength = smoothHiliteGradient(i, 20-1) / 10;
			for (j=initialY; j < (y == ROWS - 1 ? y : min(y - 1, ROWS - 1)); j++) {
				highlightScreenCell(i, j, white, highlightStrength);
			}
		}
	}

	// restoreRNG();
	return y;
}


function describeHallucinatedItem(buf) {
	const itemCats = [FOOD, WEAPON, ARMOR, POTION, SCROLL, STAFF, WAND, RING, CHARM/* , GOLD */];
  let cat, kind, maxKinds, table;
  // assureCosmeticRNG();
	do {
		cat = itemCats[cosmetic_range(0, 9)];
	  table = tableForItemCategory(cat);
		if (!table) {
			message('ERROR - item category has no table = ' + itemCategory.toString(cat), red);
		}
	}
	while(!table)

  kind = cosmetic_range(0, table.length - 1);
  describedItemBasedOnParameters(cat, kind, 1, buf);
  // restoreRNG();
}

// Returns the y-coordinate after the last line printed.
function printItemInfo(/* item */ theItem, y, dim, highlight) {
	const name = STRING(); // char[COLS * 3];
	let itemChar;
	let itemForeColor, itemBackColor;  // color
	let initialY, i, j, highlightStrength, lineCount;
	let inPath;

	if (y >= ROWS - 1) {
		return ROWS - 1;
	}

	initialY = y;

	// assureCosmeticRNG();

	if (y < ROWS - 1) {
		// Unhighlight if it's highlighted as part of the path.
		inPath = (pmap[theItem.xLoc][theItem.yLoc].flags & IS_IN_PATH) ? true : false;
		pmap[theItem.xLoc][theItem.yLoc].flags &= ~IS_IN_PATH;
		const app = getCellAppearance(theItem.xLoc, theItem.yLoc);
    applyColorBounds(app.foreColor, 0, 100);
    applyColorBounds(app.backColor, 0, 100);
		if (inPath) {
			pmap[theItem.xLoc][theItem.yLoc].flags |= IS_IN_PATH;
		}
		if (dim) {
			applyColorAverage(app.foreColor, black, 50);
			applyColorAverage(app.backColor, black, 50);
		}
		plotCharWithColor(app.char, 0, y, app.foreColor, app.backColor);
		printString(":                  ", 1, y, (dim ? gray : white), black, 0);
		if (rogue.playbackOmniscience || !player.status[STATUS_HALLUCINATING]) {
			itemName(theItem, name, true, true, (dim ? gray : white));
		} else {
      describeHallucinatedItem(name);
		}
		capitalize(name);
		lineCount = wrapText(NULL, name, 20-3);
		for (i=initialY + 1; i <= initialY + lineCount + 1 && i < ROWS - 1; i++) {
			printString("                    ", 0, i, (dim ? darkGray : gray), black, 0);
		}
		y = printStringWithWrapping(name, 3, y, 20-3, (dim ? gray : white), black, NULL); // Advances y.
	}

	if (highlight) {
		for (i=0; i<20; i++) {
			highlightStrength = smoothHiliteGradient(i, 20-1) / 10;
			for (j=initialY; j <= y && j < ROWS - 1; j++) {
				highlightScreenCell(i, j, white, highlightStrength);
			}
		}
	}
	y += 2;

	// restoreRNG();
	return y;
}

// Returns the y-coordinate after the last line printed.
function printTerrainInfo(x, y, py, description, dim, highlight) {
	let displayChar;
	let foreColor, backColor;    // color
	let initialY, i, j, highlightStrength, lineCount;
	let inPath;
  const name = STRING(); // char[DCOLS*2];
  const textColor = color();

	if (py >= ROWS - 1) {
		return ROWS - 1;
	}

	initialY = py;
  // assureCosmeticRNG();

	if (py < ROWS - 1) {
		// Unhighlight if it's highlighted as part of the path.
		inPath = (pmap[x][y].flags & IS_IN_PATH) ? true : false;
		pmap[x][y].flags &= ~IS_IN_PATH;
		const app = getCellAppearance(x, y);
    applyColorBounds(app.foreColor, 0, 100);
    applyColorBounds(app.backColor, 0, 100);
		if (inPath) {
			pmap[x][y].flags |= IS_IN_PATH;
		}
		if (dim) {
			applyColorAverage(app.foreColor, black, 50);
			applyColorAverage(app.backColor, black, 50);
		}
		plotCharWithColor(app.char, 0, py, app.foreColor, app.backColor);
		printString(":                  ", 1, py, (dim ? gray : white), black, 0);
		strcpy(name, description);
		capitalize(name);
		lineCount = wrapText(NULL, name, 20-3);
		for (i=initialY + 1; i <= initialY + lineCount + 1 && i < ROWS - 1; i++) {
			printString("                    ", 0, i, (dim ? darkGray : gray), black, 0);
		}
    textColor.copy(flavorTextColor);
    if (dim) {
        applyColorScalar(textColor, 50);
    }
		py = printStringWithWrapping(name, 3, py, 20-3, textColor, black, NULL); // Advances y.
	}

	if (highlight) {
		for (i=0; i<20; i++) {
			highlightStrength = smoothHiliteGradient(i, 20-1) / 10;
			for (j=initialY; j <= py && j < ROWS - 1; j++) {
				highlightScreenCell(i, j, white, highlightStrength);
			}
		}
	}
	py += 2;

	// restoreRNG();
	return py;
}


function rectangularShading( x,  y,  width,  height,
  /* color */ backColor, opacity,  dbuf /* cellDisplayBuffer[COLS][ROWS] */)
{
	let i, j, dist;

	// assureCosmeticRNG();
	for (i=0; i<COLS; i++) {
		for (j=0; j<ROWS; j++) {
			storeColorComponents(dbuf[i][j].backColorComponents, backColor);

			if (i >= x && i < x + width
				&& j >= y && j < y + height)
      {
				dbuf[i][j].opacity = min(100, opacity);
			} else {
				dist = 0;
				dist += max(0, max(x - i, i - x - width + 1));
				dist += max(0, max(y - j, j - y - height + 1));
				dbuf[i][j].opacity = Math.floor((opacity - 10) / max(1, dist));
				if (dbuf[i][j].opacity < 3) {
					dbuf[i][j].opacity = 0;
				}
			}
		}
	}

//	for (i=0; i<COLS; i++) {
//		for (j=0; j<ROWS; j++) {
//			if (i >= x && i < x + width && j >= y && j < y + height) {
//				plotCharWithColor(' ', i, j, &white, &darkGreen);
//			}
//		}
//	}
//	displayMoreSign();

	// restoreRNG();
}

const MIN_DEFAULT_INFO_PANEL_WIDTH	= 33;



// y and width are optional and will be automatically calculated if width <= 0.
// Width will automatically be widened if the text would otherwise fall off the bottom of the
// screen, and x will be adjusted to keep the widening box from spilling off the right of the
// screen.
// If buttons are provided, we'll extend the text box downward, re-position the buttons,
// run a button input loop and return the result.
// (Returns -1 for canceled; otherwise the button index number.)
async function printTextBox(textBuf, x, y, width,
				   /* color */ foreColor, /* color */ backColor,
				   rbuf /* cellDisplayBuffer[COLS][ROWS] */,
				   /* brogueButton[] */ buttons, buttonCount)
{
	const dbuf = GRID(COLS, ROWS, cellDisplayBuffer); // cellDisplayBuffer[COLS][ROWS];

	let x2, y2, lineCount, i, bx, by, padLines;

	if (width <= 0) {
		// autocalculate y and width
		if (x < DCOLS / 2 - 1) {
			x2 = mapToWindowX(x + 10);
			width = (DCOLS - x) - 20;
		} else {
			x2 = mapToWindowX(10);
			width = x - 20;
		}
		y2 = mapToWindowY(2);

		if (width < MIN_DEFAULT_INFO_PANEL_WIDTH) {
      x2 -= Math.round((MIN_DEFAULT_INFO_PANEL_WIDTH - width) / 2);
			width = MIN_DEFAULT_INFO_PANEL_WIDTH;
		}
	} else {
		y2 = y;
		x2 = x;
	}

	while (((lineCount = wrapText(NULL, textBuf, width)) + y2) >= ROWS - 2 && width < COLS-5) {
		// While the text doesn't fit and the width doesn't fill the screen, increase the width.
		width++;
		if (x2 + (width / 2) > COLS / 2) {
			// If the horizontal midpoint of the text box is on the right half of the screen,
			// move the box one space to the left.
			x2--;
		}
	}

	if (buttonCount > 0) {
		padLines = 2;
		bx = x2 + width;
		by = y2 + lineCount + 1;
		for (i=0; i<buttonCount; i++) {
			if (buttons[i].flags & B_DRAW) {
				bx -= strLenWithoutEscapes(buttons[i].text) + 2;
				buttons[i].x = bx;
				buttons[i].y = by;
				if (bx < x2) {
					// Buttons can wrap to the next line (though are double-spaced).
					bx = x2 + width - (strLenWithoutEscapes(buttons[i].text) + 2);
					by += 2;
					padLines += 2;
					buttons[i].x = bx;
					buttons[i].y = by;
				}
			}
		}
	} else {
		padLines = 0;
	}

	clearDisplayBuffer(dbuf);
	printStringWithWrapping(textBuf, x2, y2, width, foreColor, backColor, dbuf);
	rectangularShading(x2, y2, width, lineCount + padLines, backColor, INTERFACE_OPACITY, dbuf);
	overlayDisplayBuffer(dbuf, rbuf);

	if (buttonCount > 0) {
		return await buttonInputLoop(buttons, buttonCount, x2, y2, width, by - y2 + 1 + padLines, NULL);
	} else {
		return -1;
	}
}

function printMonsterDetails( /* creature */ monst,  rbuf /* cellDisplayBuffer[COLS][ROWS] */) {
	const textBuf = STRING(); // char[COLS * 100];

	monsterDetails(textBuf, monst);
	printTextBox(textBuf, monst.xLoc, 0, 0, white, black, rbuf);
}

// Displays the item info box with the dark blue background.
// If includeButtons is true, we include buttons for item actions.
// Returns the key of an action to take, if any; otherwise -1.
async function printCarriedItemDetails( /* item */ theItem,
									  x, y, width,
									  includeButtons,
									  rbuf /* cellDisplayBuffer[COLS][ROWS] */)
{
	const textBuf = STRING();  // [COLS * 100],
  const goldColorEscape = STRING(), whiteColorEscape = STRING();
	const buttons = ARRAY(20, brogueButton ); // [20] = {{{0}}};
	let b;

	itemDetails(textBuf, theItem);

	for (b=0; b<20; b++) {
		initializeButton(buttons[b]);
		buttons[b].flags |= B_WIDE_CLICK_AREA;
	}

	b = 0;
	if (includeButtons) {
		encodeMessageColor(goldColorEscape, 0, KEYBOARD_LABELS ? yellow : white);
		encodeMessageColor(whiteColorEscape, 0, white);

		if (theItem.category & (FOOD | SCROLL | POTION | WAND | STAFF | CHARM)) {
			sprintf(buttons[b].text, "   %{s}a%{s}pply   ", goldColorEscape, whiteColorEscape);
			buttons[b].hotkey[0] = APPLY_KEY;
			b++;
		}
		if (theItem.category & (ARMOR | WEAPON | RING)) {
			if (theItem.flags & ITEM_EQUIPPED) {
				sprintf(buttons[b].text, "  %{s}r%{s}emove   ", goldColorEscape, whiteColorEscape);
				buttons[b].hotkey[0] = UNEQUIP_KEY;
				b++;
			} else {
				sprintf(buttons[b].text, "   %{s}e%{s}quip   ", goldColorEscape, whiteColorEscape);
				buttons[b].hotkey[0] = EQUIP_KEY;
				b++;
			}
		}
		sprintf(buttons[b].text, "   %{s}d%{s}rop    ", goldColorEscape, whiteColorEscape);
		buttons[b].hotkey[0] = DROP_KEY;
		b++;

		sprintf(buttons[b].text, "   %{s}t%{s}hrow   ", goldColorEscape, whiteColorEscape);
		buttons[b].hotkey[0] = THROW_KEY;
		b++;

		if (itemCanBeCalled(theItem)) {
			sprintf(buttons[b].text, "   %{s}c%{s}all    ", goldColorEscape, whiteColorEscape);
			buttons[b].hotkey[0] = CALL_KEY;
			b++;
		}

		if (KEYBOARD_LABELS) {
        sprintf(buttons[b].text, "  %{s}R%{s}elabel  ", goldColorEscape, whiteColorEscape);
        buttons[b].hotkey[0] = RELABEL_KEY;
        b++;
    }

		// Add invisible previous and next buttons, so up and down arrows can page through items.
		// Previous
		buttons[b].flags = B_ENABLED; // clear everything else
		buttons[b].hotkey[0] = UP_KEY;
		buttons[b].hotkey[1] = NUMPAD_8;
		buttons[b].hotkey[2] = UP_ARROW;
		b++;
		// Next
		buttons[b].flags = B_ENABLED; // clear everything else
		buttons[b].hotkey[0] = DOWN_KEY;
		buttons[b].hotkey[1] = NUMPAD_2;
		buttons[b].hotkey[2] = DOWN_ARROW;
		b++;
	}

  b = await printTextBox(textBuf, x, y, width, white, interfaceBoxColor, rbuf, buttons, b);

	if (!includeButtons) {
		await waitForKeystrokeOrMouseClick();
		return -1;
	}

	if (b >= 0) {
		return buttons[b].hotkey[0];
	} else {
		return -1;
	}
}

// Returns true if an action was taken.
function printFloorItemDetails( /* item */ theItem,  rbuf /* cellDisplayBuffer[COLS][ROWS] */) {
	const textBuf = STRING(); // char[COLS * 100];

	itemDetails(textBuf, theItem);
	printTextBox(textBuf, theItem.xLoc, 0, 0, white, black, rbuf);
}
/*
 *  Buttons.c
 *  Brogue
 *
 *  Created by Brian Walker on 11/18/11.
 *  Copyright 2012. All rights reserved.
 *
 *  This file is part of Brogue.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

// #include "Rogue.h"
// #include "IncludeGlobals.h"
// #include <math.h>
// #include <time.h>

// Draws the smooth gradient that appears on a button when you hover over or depress it.
// Returns the percentage by which the current tile should be averaged toward a hilite color.
function smoothHiliteGradient(currentXValue, maxXValue) {
    return Math.floor(100 * Math.sin(PI * currentXValue / (maxXValue)));
}




// Draws the button to the screen, or to a display buffer if one is given.
// Button back color fades from -50% intensity at the edges to the back color in the middle.
// Text is white, but can use color escapes.
//		Hovering highlight augments fore and back colors with buttonHoverColor by 20%.
//		Pressed darkens the middle color (or turns it the hover color if the button is black).
function drawButton( /* brogueButton */ button, /*enum buttonDrawStates */ highlight, /* cellDisplayBuffer */ dbuf)
{
	let i, textLoc, width, midPercent, symbolNumber, opacity, oldRNG;
	let fColor = color(), bColor = color(), fColorBase, bColorBase, bColorEdge, bColorMid;
	let displayCharacter;

	if (!(button.flags & B_DRAW)) {
		return;
	}

  // assureCosmeticRNG();
	// oldRNG = rogue.RNG;
  // rogue.RNG = RNG_COSMETIC;

	symbolNumber = 0;

	width = strLenWithoutEscapes(button.text);
	bColorBase = button.buttonColor.clone();
	fColorBase = ((button.flags & B_ENABLED) ? white : gray).clone();

	if (highlight == BUTTON_HOVER && (button.flags & B_HOVER_ENABLED)) {
		//applyColorAugment(&fColorBase, &buttonHoverColor, 20);
		//applyColorAugment(&bColorBase, &buttonHoverColor, 20);
		applyColorAverage(fColorBase, buttonHoverColor, 25);
		applyColorAverage(bColorBase, buttonHoverColor, 25);
	}

	bColorEdge = bColorBase.clone();
	bColorMid	= bColorBase.clone();
	applyColorAverage(bColorEdge, black, 50);

	if (highlight == BUTTON_PRESSED) {
		applyColorAverage(bColorMid, black, 75);
		if (COLOR_DIFF(bColorMid, bColorBase) < 50) {
			bColorMid	= bColorBase;
			applyColorAverage(bColorMid, buttonHoverColor, 50);
		}
	}
	// bColor = bColorMid.clone();

	opacity = button.opacity;
	if (highlight == BUTTON_HOVER || highlight == BUTTON_PRESSED) {
		opacity = 100 - ((100 - opacity) * opacity / 100); // Apply the opacity twice.
	}

  for (i = textLoc = 0; i < width && i + button.x < COLS; i++, textLoc++) {
		while (button.text.charCodeAt(textLoc) === COLOR_ESCAPE) {
			textLoc = decodeMessageColor(button.text, textLoc, fColorBase);
		}

		fColor.copy(fColorBase);

  	if (button.flags & B_GRADIENT) {
      midPercent = smoothHiliteGradient(i, width - 1);
			bColor.copy(bColorEdge);
			applyColorAverage(bColor, bColorMid, midPercent);
		}
    else {
      bColor.copy(bColorMid);
    }

		if (highlight == BUTTON_PRESSED) {
			applyColorAverage(fColor, bColor, 30);
		}

		if (button.opacity < 100) {
			applyColorAverage(fColor, bColor, 100 - opacity);
		}

		bakeColor(fColor);
		bakeColor(bColor);
		separateColors(fColor, bColor);

		displayCharacter = button.text.text[textLoc];
		if (displayCharacter === '*') {
			if (button.symbol[symbolNumber]) {
				displayCharacter = button.symbol[symbolNumber];
			}
			symbolNumber++;
		}

		if (coordinatesAreInWindow(button.x + i, button.y)) {
			if (dbuf) {
				plotCharToBuffer(displayCharacter, button.x + i, button.y, fColor, bColor, dbuf);
				dbuf[button.x + i][button.y].opacity = opacity;
			} else {
				plotCharWithColor(displayCharacter, button.x + i, button.y, fColor, bColor);
			}
		}

  }

  // restoreRNG();
}


function clearButton(button) {
  	button.text = STRING(); // [COLS*3];			// button label; can include color escapes
  	button.x = 0;					// button's leftmost cell will be drawn at (x, y)
  	button.y = 0;
  	button.hotkey = []; // [10];		// up to 10 hotkeys to trigger the button
  	button.buttonColor = null;			// background of the button; further gradient-ized when displayed
  	button.opacity = 0;				// further reduced by 50% if not enabled
  	button.symbol = [];	//[COLS]		// Automatically replace the nth asterisk in the button label text with
  								// the nth character supplied here, if one is given.
  								// (Primarily to display magic character and item symbols in the inventory display.)
  	button.flags = 0;
}


function initializeButton(button) {

	clearButton(button);
	// button.text = '';
	button.flags |= (B_ENABLED | B_GRADIENT | B_HOVER_ENABLED | B_DRAW | B_KEYPRESS_HIGHLIGHT);
	button.buttonColor = interfaceButtonColor;
	button.opacity = 100;
}

function drawButtonsInState(/* buttonState */ state) {
	let i;

	// Draw the buttons to the dbuf:
	for (i=0; i < state.buttonCount; i++) {
		if (state.buttons[i].flags & B_DRAW) {
			drawButton(state.buttons[i], BUTTON_NORMAL, state.dbuf);
		}
	}
}

function initializeButtonState(/* buttonState */ state,
						   buttons,
						   buttonCount,
						   winX,
						   winY,
						   winWidth,
						   winHeight)
{
	let i, j;

	// Initialize variables for the state struct:
	state.buttonChosen = state.buttonFocused = state.buttonDepressed = -1;
	state.buttonCount	= buttonCount;
	state.winX			= winX;
	state.winY			= winY;
	state.winWidth	= winWidth;
	state.winHeight	= winHeight;
	for (i=0; i < state.buttonCount; i++) {
		state.buttons[i] = buttons[i];
	}
	copyDisplayBuffer(state.rbuf, displayBuffer);
	clearDisplayBuffer(state.dbuf);

	drawButtonsInState(state);

	// Clear the rbuf so that it resets only those parts of the screen in which buttons are drawn in the first place:
	for (i=0; i<COLS; i++) {
		for (j=0; j<ROWS; j++) {
			state.rbuf[i][j].opacity = (state.dbuf[i][j].opacity ? 100 : 0);
		}
	}
}

// Processes one round of user input, and bakes the necessary graphical changes into state.dbuf.
// Does NOT display the buttons or revert the display afterward.
// Assumes that the display has already been updated (via overlayDisplayBuffer(state.dbuf, NULL))
// and that input has been solicited (via nextBrogueEvent(event, ___, ___, ___)).
// Also relies on the buttonState having been initialized with initializeButtonState() or otherwise.
// Returns the index of a button if one is chosen.
// Otherwise, returns -1. That can be if the user canceled (in which case *canceled is true),
// or, more commonly, if the user's input in this particular split-second round was not decisive.
async function processButtonInput(/*buttonState */ state, /* rogueEvent */ theEvent) {
	let i, k, x, y;
	let buttonUsed = false;

	// Mouse event:
	if (theEvent.eventType == MOUSE_DOWN
		|| theEvent.eventType == MOUSE_UP
		|| theEvent.eventType == MOUSE_ENTERED_CELL)
  {
		x = theEvent.param1;
		y = theEvent.param2;

		// Revert the button with old focus, if any.
		if (state.buttonFocused >= 0) {
			drawButton(state.buttons[state.buttonFocused], BUTTON_NORMAL, state.dbuf);
			state.buttonFocused = -1;
		}

    if (theEvent.eventType == MOUSE_ENTERED_CELL && state.buttonDepressed >= 0) {
			drawButton(state.buttons[state.buttonDepressed], BUTTON_NORMAL, state.dbuf);
			state.buttonDepressed = -1;
		}

		// Find the button with new focus, if any.
		for (i=0; i < state.buttonCount; i++) {
			if ((state.buttons[i].flags & B_DRAW)
				&& (state.buttons[i].flags & B_ENABLED)
				&& (state.buttons[i].y == y || ((state.buttons[i].flags & B_WIDE_CLICK_AREA) && abs(state.buttons[i].y - y) <= 1))
				&& x >= state.buttons[i].x
				&& x < state.buttons[i].x + strLenWithoutEscapes(state.buttons[i].text))
      {
				state.buttonFocused = i;
				if (theEvent.eventType == MOUSE_DOWN) {
					state.buttonDepressed = i; // Keeps track of which button is down at the moment. Cleared on mouseup.
				}
				break;
			}
		}
		if (i == state.buttonCount) { // No focus this round.
			state.buttonFocused = -1;
		}

		if (state.buttonDepressed >= 0) {
			if (state.buttonDepressed == state.buttonFocused) {
				drawButton(state.buttons[state.buttonDepressed], BUTTON_PRESSED, state.dbuf);
			}
		} else if (state.buttonFocused >= 0) {
			// If no button is depressed, then update the appearance of the button with the new focus, if any.
			drawButton(state.buttons[state.buttonFocused], BUTTON_HOVER, state.dbuf);
		}

		// Mouseup:
		if (theEvent.eventType == MOUSE_UP) {
			if (state.buttonDepressed == state.buttonFocused && state.buttonFocused >= 0) {
				// If a button is depressed, and the mouseup happened on that button, it has been chosen and we're done.
				buttonUsed = true;
			} else {
				// Otherwise, no button is depressed. If one was previously depressed, redraw it.
				if (state.buttonDepressed >= 0) {
					drawButton(state.buttons[state.buttonDepressed], BUTTON_NORMAL, state.dbuf);
				} else if (!(x >= state.winX && x < state.winX + state.winWidth
							 && y >= state.winY && y < state.winY + state.winHeight))
        {
					// Clicking outside of a button means canceling.
					theEvent.canceled = true;
				}

				if (state.buttonFocused >= 0) {
					// Buttons don't hover-highlight when one is depressed, so we have to fix that when the mouse is up.
					drawButton(state.buttons[state.buttonFocused], BUTTON_HOVER, state.dbuf);
				}
				state.buttonDepressed = -1;
			}
		}
	}

	// Keystroke:
	if (theEvent.eventType == KEYSTROKE) {

		// Cycle through all of the hotkeys of all of the buttons.
		for (i=0; i < state.buttonCount; i++) {
			for (k = 0; k < 10 && state.buttons[i].hotkey[k]; k++) {
				if (theEvent.param1 == state.buttons[i].hotkey[k]) {
					// This button was chosen.

					if (state.buttons[i].flags & B_DRAW) {
						// Restore the depressed and focused buttons.
						if (state.buttonDepressed >= 0) {
							drawButton(state.buttons[state.buttonDepressed], BUTTON_NORMAL, state.dbuf);
						}
						if (state.buttonFocused >= 0) {
							drawButton(state.buttons[state.buttonFocused], BUTTON_NORMAL, state.dbuf);
						}

						// If the button likes to flash when keypressed:
						if (state.buttons[i].flags & B_KEYPRESS_HIGHLIGHT) {
							// Depress the chosen button.
							drawButton(state.buttons[i], BUTTON_PRESSED, state.dbuf);

							// Update the display.
							// overlayDisplayBuffer(state.rbuf, NULL);
							// overlayDisplayBuffer(state.dbuf, NULL);

							// Wait for a little; then we're done.
							await pauseBrogue(50);
						}
					}

					state.buttonDepressed = i;
					buttonUsed = true;
					break;
				}
			}
		}

		if (!buttonUsed
			&& (theEvent.param1 == ESCAPE_KEY || theEvent.param1 == ACKNOWLEDGE_KEY)) {
			// If the player pressed escape, we're done.
			theEvent.canceled = true;
		}
	}

	if (buttonUsed) {
		state.buttonChosen = state.buttonDepressed;
		return state.buttonChosen;
	} else {
		return -1;
	}
}

// Displays a bunch of buttons and collects user input.
// Returns the index number of the chosen button, or -1 if the user cancels.
// A window region is described by winX, winY, winWidth and winHeight.
// Clicking outside of that region will constitute canceling.
async function buttonInputLoop(/* brogueButton */ buttons,
					  buttonCount,
					  winX,
					  winY,
					  winWidth,
					  winHeight,
            returnEvent)
{
  let x, y, button; // (x, y) keeps track of the mouse location
	let canceled;
	const theEvent = rogueEvent();
	const state = buttonState();

	// assureCosmeticRNG();

	canceled = false;
	x = y = -1;
	initializeButtonState(state, buttons, buttonCount, winX, winY, winWidth, winHeight);

	do {
		// Update the display.
		overlayDisplayBuffer(state.dbuf, NULL);

		// Get input.
		await nextBrogueEvent(theEvent, true, false, false);

		// Process the input.
		button = await processButtonInput(state, theEvent);

		// Revert the display.
		overlayDisplayBuffer(state.rbuf, NULL);

	} while (button == -1 && !theEvent.canceled);

	if (returnEvent) {
		returnEvent.copy(theEvent);
	}

	//overlayDisplayBuffer(dbuf, NULL); // hangs around

	// restoreRNG();

	return button;
}
/*
 *  Recordings.c
 *  Brogue
 *
 *  Created by Brian Walker on 8/8/10.
 *  Copyright 2012. All rights reserved.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

// #include <math.h>
// #include <time.h>
// #include <limits.h>
// #include "Rogue.h"
// #include "IncludeGlobals.h"

const RECORDING_HEADER_LENGTH	=	32;	// bytes at the start of the recording file to store global data

// #pragma mark Recording functions

// extern boolean noSaves;

// void recordChar(unsigned char c) {
// 	inputRecordBuffer[locationInRecordingBuffer++] = c;
// 	recordingLocation++;
// }
//
// void considerFlushingBufferToFile() {
//     if (locationInRecordingBuffer >= INPUT_RECORD_BUFFER) {
// 		flushBufferToFile();
// 	}
// }
//
// // compresses a uchar into a char, discarding stuff we don't need
// unsigned char compressKeystroke(uchar c) {
// 	const uchar ucharTable[] = {UP_ARROW, LEFT_ARROW, DOWN_ARROW, RIGHT_ARROW,
// 		ESCAPE_KEY, RETURN_KEY, ENTER_KEY, DELETE_KEY, TAB_KEY, NUMPAD_0, NUMPAD_1,
// 		NUMPAD_2, NUMPAD_3, NUMPAD_4, NUMPAD_5, NUMPAD_6, NUMPAD_7, NUMPAD_8, NUMPAD_9};
// 	short i;
//
// 	for (i=0; i<19; i++) {
// 		if (ucharTable[i] == c) {
// 			return (unsigned char) (128 + i);
// 		}
// 	}
// 	if (c < 256) {
// 		return (unsigned char) c;
// 	}
// 	return UNKNOWN_KEY;
// }
//
// void numberToString(unsigned long number, short numberOfBytes, unsigned char *recordTo) {
// 	short i;
// 	unsigned long n;
//
// 	n = number;
// 	for (i=numberOfBytes - 1; i >= 0; i--) {
// 		recordTo[i] = n % 256;
// 		n /= 256;
// 	}
// 	if (n > 0) {
// 		printf("\nError: the number %li does not fit in %i bytes.", number, numberOfBytes);
//         brogueAssert(false);
// 	}
// }
//
// // numberOfBytes can't be greater than 10
// void recordNumber(unsigned long number, short numberOfBytes) {
// 	short i;
// 	unsigned char c[10];
//
// 	numberToString(number, numberOfBytes, c);
// 	for (i=0; i<numberOfBytes; i++) {
// 		recordChar(c[i]);
// 	}
// }

// Events are recorded as follows:
// Keystrokes: Event type, keystroke value, modifier flags. (3 bytes.)
// All other events: Event type, x-coordinate of the event, y-coordinate of the event, modifier flags. (4 bytes.)
// Note: these must be sanitized, because user input may contain more than one byte per parameter.
function recordEvent( /* rogueEvent */ event) {
	// unsigned char c;
  //
	// if (rogue.playbackMode) {
	// 	return;
	// }
  //
	// recordChar((unsigned char) event->eventType);
  //
	// if (event->eventType == KEYSTROKE) {
	// 	// record which key
	// 	c = compressKeystroke(event->param1);
	// 	if (c == UNKNOWN_KEY) {
	// 		return;
	// 	}
	// 	recordChar(c);
	// } else {
	// 	recordChar((unsigned char) event->param1);
	// 	recordChar((unsigned char) event->param2);
	// }
  //
	// // record the modifier keys
	// c = 0;
	// if (event->controlKey) {
	// 	c += Fl(1);
	// }
	// if (event->shiftKey) {
	// 	c += Fl(2);
	// }
	// recordChar(c);
}

// For convenience.
function recordKeystroke(keystroke, controlKey, shiftKey) {
	const theEvent = rogueEvent();

	if (rogue.playbackMode) {
		return;
	}

	theEvent.eventType = KEYSTROKE;
	theEvent.param1 = keystroke;
	theEvent.controlKey = controlKey;
	theEvent.shiftKey = shiftKey;
	recordEvent(theEvent);
}

// record a series of keystrokes; string must end with a null terminator
function recordKeystrokeSequence(keystrokeSequence /* char[] */) {
	let i;
	for (i=0; keystrokeSequence[i]; i++) {
		recordKeystroke(keystrokeSequence[i], false, false);
	}
}

// For convenience.
function recordMouseClick(x, y, controlKey, shiftKey) {
	const theEvent = rogueEvent();

	if (rogue.playbackMode) {
		return;
	}

	theEvent.eventType = MOUSE_UP;
	theEvent.param1 = x;
	theEvent.param2 = y;
	theEvent.controlKey = controlKey;
	theEvent.shiftKey = shiftKey;
	recordEvent(theEvent);
}

// void writeHeaderInfo(char *path) {
// 	unsigned char c[RECORDING_HEADER_LENGTH];
// 	short i;
// 	FILE *recordFile;
//
// 	// Zero out the entire header to start.
// 	for (i=0; i<RECORDING_HEADER_LENGTH; i++) {
// 		c[i] = 0;
// 	}
//
// 	// Note the version string to gracefully deny compatibility when necessary.
// 	for (i = 0; BROGUE_VERSION_STRING[i] != '\0'; i++) {
// 		c[i] = BROGUE_VERSION_STRING[i];
// 	}
// 	i = 16;
// 	numberToString(rogue.seed, 4, &c[i]);
// 	i += 4;
// 	numberToString(rogue.playerTurnNumber, 4, &c[i]);
// 	i += 4;
// 	numberToString(rogue.deepestLevel, 4, &c[i]);
// 	i += 4;
// 	numberToString(lengthOfPlaybackFile, 4, &c[i]);
// 	i += 4;
//
// 	if (!fileExists(path)) {
// 		recordFile = fopen(path, "wb");
// 		if (recordFile) {
// 			fclose(recordFile);
// 		}
// 	}
//
// 	recordFile = fopen(path, "r+b");
// 	rewind(recordFile);
// 	for (i=0; i<RECORDING_HEADER_LENGTH; i++) {
// 		putc(c[i], recordFile);
// 	}
// 	if (recordFile) {
// 		fclose(recordFile);
// 	}
//
// 	if (lengthOfPlaybackFile < RECORDING_HEADER_LENGTH) {
// 		lengthOfPlaybackFile = RECORDING_HEADER_LENGTH;
// 	}
// }

function flushBufferToFile() {
	// short i;
	// FILE *recordFile;
	//
	// if (rogue.playbackMode) {
	// 	return;
	// }
	//
	// lengthOfPlaybackFile += locationInRecordingBuffer;
	// writeHeaderInfo(currentFilePath);
	//
	// if (locationInRecordingBuffer != 0) {
	//
	// 	recordFile = fopen(currentFilePath, "ab");
	//
	// 	for (i=0; i<locationInRecordingBuffer; i++) {
	// 		putc(inputRecordBuffer[i], recordFile);
	// 	}
	//
	// 	if (recordFile) {
	// 		fclose(recordFile);
	// 	}
	//
	// 	locationInRecordingBuffer = 0;
	// }
}

// #pragma mark Playback functions
//
// void fillBufferFromFile() {
// //	short i;
// 	FILE *recordFile;
//
// 	recordFile = fopen(currentFilePath, "rb");
// 	fseek(recordFile, positionInPlaybackFile, SEEK_SET);
//
// 	fread((void *) inputRecordBuffer, 1, INPUT_RECORD_BUFFER, recordFile);
//
// 	positionInPlaybackFile = ftell(recordFile);
// 	fclose(recordFile);
//
// 	locationInRecordingBuffer = 0;
// }
//
// unsigned char recallChar() {
// 	unsigned char c;
// 	if (recordingLocation > lengthOfPlaybackFile) {
// 		return END_OF_RECORDING;
// 	}
// 	c = inputRecordBuffer[locationInRecordingBuffer++];
// 	recordingLocation++;
// 	if (locationInRecordingBuffer >= INPUT_RECORD_BUFFER) {
// 		fillBufferFromFile();
// 	}
// 	return c;
// }
//
// uchar uncompressKeystroke(uchar c) {
// 	const uchar ucharTable[] = {UP_ARROW, LEFT_ARROW, DOWN_ARROW, RIGHT_ARROW,
// 		ESCAPE_KEY, RETURN_KEY, ENTER_KEY, DELETE_KEY, TAB_KEY, NUMPAD_0, NUMPAD_1,
// 		NUMPAD_2, NUMPAD_3, NUMPAD_4, NUMPAD_5, NUMPAD_6, NUMPAD_7, NUMPAD_8, NUMPAD_9};
//
// 	if (c >= 128 && c <= UNKNOWN_KEY) {
// 		return ucharTable[c - 128];
// 	}
// 	return (uchar) c;
// }
//
// unsigned long recallNumber(short numberOfBytes) {
// 	short i;
// 	unsigned long n;
//
// 	n = 0;
//
// 	for (i=0; i<numberOfBytes; i++) {
// 		n *= 256;
// 		n += (unsigned long) recallChar();
// 	}
// 	return n;
// }
//
// #define OOS_APOLOGY "Playback of the recording has diverged from the originally recorded game.\n\n\
// This could be caused by recording or playing the file on a modified version of Brogue, or it could \
// simply be the result of a bug.  (The recording feature is still in beta for this reason.)\n\n\
// If this is a different computer from the one on which the recording was saved, the recording \
// might succeed on the original computer."
//
// void playbackPanic() {
// 	cellDisplayBuffer rbuf[COLS][ROWS];
//
// 	if (!rogue.playbackOOS) {
// 		rogue.playbackFastForward = false;
// 		rogue.playbackPaused = true;
// 		rogue.playbackOOS = true;
//         blackOutScreen();
// 		displayLevel();
// 		refreshSideBar(-1, -1, false);
//
// 		confirmMessages();
// 		message("Playback is out of sync.", false);
//
// 		printTextBox(OOS_APOLOGY, 0, 0, 0, &white, &black, rbuf, NULL, 0);
//
// 		rogue.playbackMode = false;
// 		displayMoreSign();
// 		rogue.playbackMode = true;
//
// 		overlayDisplayBuffer(rbuf, 0);
//
// 		printf("\n\nPlayback panic at location %li!", recordingLocation - 1);
//
// 		overlayDisplayBuffer(rbuf, 0);
//
// 		mainInputLoop();
// 	}
// }
//
function recallEvent( /* rogueEvent */ event) {
	throw new Error('Should never happen!');
// 	unsigned char c;
// 	boolean tryAgain;
//
// 	do {
// 		tryAgain = false;
// 		c = recallChar();
// 		event->eventType = c;
//
// 		switch (c) {
// 			case KEYSTROKE:
// 				// record which key
// 				event->param1 = uncompressKeystroke(recallChar());
// 				event->param2 = 0;
// 				break;
// 			case SAVED_GAME_LOADED:
// 				tryAgain = true;
// 				flashTemporaryAlert(" Saved game loaded ", 1000);
// 				break;
// 			case MOUSE_UP:
// 			case MOUSE_DOWN:
// 			case MOUSE_ENTERED_CELL:
// 			case RIGHT_MOUSE_UP:
// 			case RIGHT_MOUSE_DOWN:
// 				event->param1 = recallChar();
// 				event->param2 = recallChar();
// 				break;
// 			case RNG_CHECK:
// 			case END_OF_RECORDING:
// 			case EVENT_ERROR:
// 			default:
// 				ERROR("Unrecognized event type in playback.", true);
//        printf("Unrecognized event type in playback: event ID %i", c);
// 				tryAgain = true;
// 				playbackPanic();
// 				break;
// 		}
// 	} while (tryAgain && !rogue.gameHasEnded);
//
// 	// record the modifier keys
// 	c = recallChar();
// 	event->controlKey = (c & Fl(1)) ? true : false;
// 	event->shiftKey =	(c & Fl(2)) ? true : false;
}
//
// void loadNextAnnotation() {
// 	unsigned long currentReadTurn;
// 	short i;
// 	FILE *annotationFile;
//
// 	if (rogue.nextAnnotationTurn == -1) {
// 		return;
// 	}
//
// 	annotationFile =  fopen(annotationPathname, "r");
// 	fseek(annotationFile, rogue.locationInAnnotationFile, SEEK_SET);
//
// 	for (;;) {
//
// 		// load turn number
// 		if (fscanf(annotationFile, "%lu\t", &(currentReadTurn)) != 1) {
// 			if (feof(annotationFile)) {
// 				rogue.nextAnnotation[0] = '\0';
// 				rogue.nextAnnotationTurn = -1;
// 				break;
// 			} else {
// 				// advance to the end of the line
// 				fgets(rogue.nextAnnotation, 5000, annotationFile);
// 				continue;
// 			}
// 		}
//
// 		// load description
// 		fgets(rogue.nextAnnotation, 5000, annotationFile);
//
// 		if (currentReadTurn > rogue.playerTurnNumber ||
// 			(currentReadTurn <= 1 && rogue.playerTurnNumber <= 1 && currentReadTurn >= rogue.playerTurnNumber)) {
// 			rogue.nextAnnotationTurn = currentReadTurn;
//
// 			// strip the newline off the end
// 			rogue.nextAnnotation[strlen(rogue.nextAnnotation) - 1] = '\0';
// 			// strip out any gremlins in the annotation
// 			for (i=0; i<5000 && rogue.nextAnnotation[i]; i++) {
// 				if (rogue.nextAnnotation[i] < ' '
// 					|| rogue.nextAnnotation[i] > '~') {
// 					rogue.nextAnnotation[i] = ' ';
// 				}
// 			}
// 			break;
// 		}
// 	}
// 	rogue.locationInAnnotationFile = ftell(annotationFile);
// 	fclose(annotationFile);
// }

function displayAnnotation() {
  // 	cellDisplayBuffer rbuf[COLS][ROWS];
  //
  // 	if (rogue.playbackMode
  // 		&& rogue.playerTurnNumber == rogue.nextAnnotationTurn) {
  //
  // 		if (!rogue.playbackFastForward) {
  // 			refreshSideBar(-1, -1, false);
  //
  // 			printTextBox(rogue.nextAnnotation, player.xLoc, 0, 0, &black, &white, rbuf, NULL, 0);
  //
  // 			rogue.playbackMode = false;
  // 			displayMoreSign();
  // 			rogue.playbackMode = true;
  //
  // 			overlayDisplayBuffer(rbuf, 0);
  // 		}
  //
  // 		loadNextAnnotation();
  // 	}
}

// #pragma mark Hybrid and miscellaneous
//
// // creates a game recording file, or if in playback mode,
// // initializes based on and starts reading from the recording file
// void initRecording() {
// 	short i;
// 	char versionString[16], buf[100];
// 	FILE *recordFile;
//
// 	//initializeBrogueSaveLocation();
//
// #ifdef AUDIT_RNG
// 	if (fileExists(RNG_LOG)) {
// 		remove(RNG_LOG);
// 	}
// 	RNGLogFile = fopen(RNG_LOG, "a");
// #endif
//
// 	locationInRecordingBuffer	= 0;
// 	positionInPlaybackFile		= 0;
// 	recordingLocation			= 0;
// 	maxLevelChanges				= 0;
// 	rogue.playbackOOS			= false;
// 	rogue.playbackOmniscience	= false;
// 	rogue.nextAnnotationTurn	= 0;
// 	rogue.nextAnnotation[0]		= '\0';
// 	rogue.locationInAnnotationFile	= 0;
//
// 	if (rogue.playbackMode) {
// 		lengthOfPlaybackFile		= 100000; // so recall functions don't freak out
// 		rogue.playbackDelayPerTurn	= DEFAULT_PLAYBACK_DELAY;
// 		rogue.playbackDelayThisTurn	= rogue.playbackDelayPerTurn;
// 		rogue.playbackPaused		= false;
//
// 		fillBufferFromFile();
//
// 		for (i=0; i<16; i++) {
// 			versionString[i] = recallChar();
// 		}
//
// 		if (strcmp(versionString, BROGUE_VERSION_STRING)) {
// 			rogue.playbackMode = false;
// 			rogue.playbackFastForward = false;
// 			sprintf(buf, "This file is from version %s and cannot be opened in version %s.", versionString, BROGUE_VERSION_STRING);
// 			dialogAlert(buf);
// 			rogue.playbackMode = true;
// 			rogue.playbackPaused = true;
// 			rogue.playbackFastForward = false;
// 			rogue.playbackOOS = false;
// 			rogue.gameHasEnded = true;
// 		}
// 		rogue.seed				= recallNumber(4);			// master random seed
// 		rogue.howManyTurns		= recallNumber(4);			// how many turns are in this recording
// 		maxLevelChanges			= recallNumber(4);			// how many times the player changes depths
// 		lengthOfPlaybackFile	= recallNumber(4);
// 		seedRandomGenerator(rogue.seed);
//         previousGameSeed = rogue.seed;
//
// 		if (fileExists(annotationPathname)) {
// 			loadNextAnnotation();
// 		} else {
// 			rogue.nextAnnotationTurn = -1;
// 		}
// 	} else {
// 		lengthOfPlaybackFile = 1;
// 		remove(currentFilePath);
// 		recordFile = fopen(currentFilePath, "wb"); // create the file
// 		fclose(recordFile);
//
// 		flushBufferToFile(); // header info never makes it into inputRecordBuffer when recording
// 	}
// 	rogue.currentTurnNumber = 0;
// }

// function OOSCheck(x, numberOfBytes) {
// 	let eventType;
// 	let recordedNumber;
//
// 	if (rogue.playbackMode) {
// 		eventType = recallChar();
// 		recordedNumber = recallNumber(numberOfBytes);
// 		if (eventType != RNG_CHECK || recordedNumber != x) {
// 			if (eventType != RNG_CHECK) {
// 				message("Event type mismatch in RNG check.", false);
//         playbackPanic();
// 			} else if (recordedNumber != x) {
//           printf("\nExpected RNG output of %li; got %i.", recordedNumber, (int) x);
//           playbackPanic();
//       }
// 		}
// 	} else {
// 		recordChar(RNG_CHECK);
// 		recordNumber(x, numberOfBytes);
//         considerFlushingBufferToFile();
// 	}
// }

// compare a random number once per player turn so we instantly know if we are out of sync during playback
function RNGCheck() {
// 	let oldRNG;
// 	let randomNumber;
//
// 	oldRNG = rogue.RNG;
// 	rogue.RNG = RNG_SUBSTANTIVE;
//
// //#ifdef AUDIT_RNG
// //reportRNGState();
// //#endif
//
// 	randomNumber = rand_range(0, 255);
// 	OOSCheck(randomNumber, 1);
//
// 	rogue.RNG = oldRNG;
}

// boolean unpause() {
// 	if (rogue.playbackOOS) {
// 		flashTemporaryAlert(" Out of sync ", 2000);
// 	} else if (rogue.playbackPaused) {
// 		rogue.playbackPaused = false;
// 		return true;
// 	}
// 	return false;
// }
//
// #define PLAYBACK_HELP_LINE_COUNT	19
//
// void printPlaybackHelpScreen() {
// 	short i, j;
// 	cellDisplayBuffer dbuf[COLS][ROWS], rbuf[COLS][ROWS];
// 	char helpText[PLAYBACK_HELP_LINE_COUNT][80] = {
// 		"Commands:",
// 		"",
// 		"         <space>: ****pause or unpause playback",
// 		"   k or up arrow: ****play back faster",
// 		" j or down arrow: ****play back slower",
// 		"               >: ****skip to next level",
// 		"             0-9: ****skip to specified turn number",
// 		"l or right arrow: ****advance one turn (shift for 5 turns; control for 20)",
// 		"",
// 		"           <tab>: ****enable or disable omniscience",
// 		"          return: ****examine surroundings",
// 		"               i: ****display inventory",
// 		"               D: ****display discovered items",
// 		"               V: ****view saved recording",
// 		"               O: ****open and resume saved game",
// 		"               N: ****begin a new game",
// 		"               Q: ****quit to title screen",
// 		"",
// 		"        -- press any key to continue --"
// 	};
//
// 	// Replace the "****"s with color escapes.
// 	for (i=0; i<PLAYBACK_HELP_LINE_COUNT; i++) {
// 		for (j=0; helpText[i][j]; j++) {
// 			if (helpText[i][j] == '*') {
// 				j = encodeMessageColor(helpText[i], j, &white);
// 			}
// 		}
// 	}
//
// 	clearDisplayBuffer(dbuf);
//
// 	for (i=0; i<PLAYBACK_HELP_LINE_COUNT; i++) {
// 		printString(helpText[i], mapToWindowX(5), mapToWindowY(i), &itemMessageColor, &black, dbuf);
// 	}
//
// 	for (i=0; i<COLS; i++) {
// 		for (j=0; j<ROWS; j++) {
// 			dbuf[i][j].opacity = (i < STAT_BAR_WIDTH ? 0 : INTERFACE_OPACITY);
// 		}
// 	}
// 	overlayDisplayBuffer(dbuf, rbuf);
//
// 	rogue.playbackMode = false;
// 	waitForAcknowledgment();
// 	rogue.playbackMode = true;
// 	overlayDisplayBuffer(rbuf, NULL);
// }
//
// void advanceToLocation(unsigned long destinationFrame) {
// 	unsigned long progressBarInterval, initialFrameNumber;
// 	rogueEvent theEvent;
//     boolean useProgressBar, omniscient, stealth, trueColors;
//
//     omniscient = rogue.playbackOmniscience;
//     stealth = rogue.displayAggroRangeMode;
//     trueColors = rogue.trueColorMode;
//     rogue.playbackOmniscience = false;
//     rogue.displayAggroRangeMode = false;
//     rogue.trueColorMode = false;
//
// 	cellDisplayBuffer dbuf[COLS][ROWS];
//
//     if (destinationFrame < rogue.playerTurnNumber) {
//         useProgressBar = (destinationFrame > 100 ? true : false);
//
//         // Start the recording over, and fast-forward to chosen frame.
//         freeEverything();
//         randomNumbersGenerated = 0;
//         rogue.playbackMode = true;
//         initializeRogue(0); // Seed argument is ignored because we're in playback.
//         startLevel(rogue.depthLevel, 1);
//         if (useProgressBar) {
//             blackOutScreen();
//         }
//     } else {
//         useProgressBar = (destinationFrame - rogue.playerTurnNumber > 100 ? true : false);
//     }
//
//     clearDisplayBuffer(dbuf);
//     rectangularShading((COLS - 20) / 2, ROWS / 2, 20, 1, &black, INTERFACE_OPACITY, dbuf);
//     overlayDisplayBuffer(dbuf, 0);
//     commitDraws();
//     displayMoreSign();
//
//     rogue.playbackFastForward = true;
//     progressBarInterval = max(1, (destinationFrame - rogue.playerTurnNumber) / 500);
//     initialFrameNumber = rogue.playerTurnNumber;
//
//     while (rogue.playerTurnNumber < destinationFrame && !rogue.gameHasEnded && !rogue.playbackOOS) {
//         if (useProgressBar && !(rogue.playerTurnNumber % progressBarInterval)) {
//             rogue.playbackFastForward = false;
//             printProgressBar((COLS - 20) / 2, ROWS / 2, "[     Loading...   ]",
//                              rogue.playerTurnNumber - initialFrameNumber,
//                              destinationFrame - initialFrameNumber, &darkPurple, false);
//             rogue.playbackFastForward = true;
//             pauseBrogue(1);
//         }
//
//         rogue.RNG = RNG_COSMETIC; // dancing terrain colors can't influence recordings
//         rogue.playbackDelayThisTurn = 0;
//         nextBrogueEvent(&theEvent, false, true, false);
//         rogue.RNG = RNG_SUBSTANTIVE;
//         executeEvent(&theEvent);
//     }
//
//     rogue.playbackOmniscience = omniscient;
//     rogue.displayAggroRangeMode = stealth;
//     rogue.trueColorMode = trueColors;
//
//     rogue.playbackPaused = true;
//     rogue.playbackFastForward = false;
//     confirmMessages();
//     updateMessageDisplay();
//     refreshSideBar(-1, -1, false);
//     displayLevel();
// }
//
// async void promptToAdvanceToLocation(short keystroke) {
// 	char entryText[30], buf[max(30, DCOLS)];
// 	unsigned long destinationFrame;
// 	boolean enteredText;
//
// 	if (!rogue.playbackPaused || unpause()) {
// 		buf[0] = (keystroke == '0' ? '\0' : keystroke);
// 		buf[1] = '\0';
//
// 		rogue.playbackMode = false;
//    entryText = await getInputTextString("Go to turn number: ", log10(ULONG_MAX) - 1, buf, "", TEXT_INPUT_NUMBERS, false);
// 		enteredText = entryText ? entryText.length : 0;
// 		confirmMessages();
// 		rogue.playbackMode = true;
//
// 		if (enteredText && entryText[0] != '\0') {
// 			sscanf(entryText, "%lu", &destinationFrame);
//
// 			if (destinationFrame >= rogue.howManyTurns) {
// 				flashTemporaryAlert(" Past end of recording ", 3000);
// 			} else if (destinationFrame == rogue.playerTurnNumber) {
// 				sprintf(buf, " Already at turn %li ", destinationFrame);
// 				flashTemporaryAlert(buf, 1000);
// 			} else {
//                 advanceToLocation(destinationFrame);
//             }
// 			rogue.playbackPaused = true;
// 		}
// 	}
// }
//
// void pausePlayback() {
//     short oldRNG;
// 	if (!rogue.playbackPaused) {
// 		rogue.playbackPaused = true;
// 		message(KEYBOARD_LABELS ? "recording paused. Press space to play." : "recording paused.",
//                          &teal, false);
// 		refreshSideBar(-1, -1, false);
//         oldRNG = rogue.RNG;
//         //rogue.RNG = RNG_SUBSTANTIVE;
// 		mainInputLoop();
// 		//rogue.RNG = oldRNG;
// 		message("recording unpaused.", &teal, false);
// 		rogue.playbackPaused = false;
// 		refreshSideBar(-1, -1, false);
// 		rogue.playbackDelayThisTurn = DEFAULT_PLAYBACK_DELAY;
// 	}
// }
//
// // Used to interact with playback -- e.g. changing speed, pausing.
async function executePlaybackInput( /* rogueEvent */ recordingInput) {
	throw new Error('Should never happen!');
// 	signed long key;
// 	short newDelay, frameCount, x, y, previousDeepestLevel;
// 	unsigned long destinationFrame;
// 	boolean pauseState, proceed;
// 	rogueEvent theEvent;
// 	char path[BROGUE_FILENAME_MAX];
//
// 	if (!rogue.playbackMode) {
// 		return false;
// 	}
//
// 	if (recordingInput->eventType == KEYSTROKE) {
// 		key = recordingInput->param1;
//         stripShiftFromMovementKeystroke(&key);
//
// 		switch (key) {
// 			case UP_ARROW:
// 			case UP_KEY:
// 				newDelay = max(1, min(rogue.playbackDelayPerTurn / 1.5, rogue.playbackDelayPerTurn - 1));
// 				if (newDelay != rogue.playbackDelayPerTurn) {
// 					flashTemporaryAlert(" Faster ", 300);
// 				}
// 				rogue.playbackDelayPerTurn = newDelay;
// 				break;
// 			case DOWN_ARROW:
// 			case DOWN_KEY:
// 				newDelay = min(3000, max(rogue.playbackDelayPerTurn * 1.5, rogue.playbackDelayPerTurn + 1));
// 				if (newDelay != rogue.playbackDelayPerTurn) {
// 					flashTemporaryAlert(" Slower ", 300);
// 				}
// 				rogue.playbackDelayPerTurn = newDelay;
// 				return true;
// 			case ACKNOWLEDGE_KEY:
// 				if (rogue.playbackOOS && rogue.playbackPaused) {
// 					flashTemporaryAlert(" Out of sync ", 2000);
// 				} else {
//                     rogue.playbackPaused = !rogue.playbackPaused;
// 				}
// 				return true;
// 			case TAB_KEY:
// 				rogue.playbackOmniscience = !rogue.playbackOmniscience;
// 				displayLevel();
// 				refreshSideBar(-1, -1, false);
// 				if (rogue.playbackOmniscience) {
// 					message("Omniscience enabled.", &teal, false);
// 				} else {
// 					message("Omniscience disabled.", &teal, false);
// 				}
// 				return true;
// 			case DESCEND_KEY:
// 				pauseState = rogue.playbackPaused;
//                 previousDeepestLevel = rogue.deepestLevel;
// 				if (!rogue.playbackPaused || unpause()) {
// 					if ((unsigned long) rogue.deepestLevel < maxLevelChanges) {
// 						displayCenteredAlert(" Loading... ");
// 						pauseBrogue(5);
// 						rogue.playbackFastForward = true;
// 						while ((rogue.deepestLevel <= previousDeepestLevel || !rogue.playbackBetweenTurns)
// 							   && !rogue.gameHasEnded) {
// 							rogue.RNG = RNG_COSMETIC; // dancing terrain colors can't influence recordings
// 							nextBrogueEvent(&theEvent, false, true, false);
// 							rogue.RNG = RNG_SUBSTANTIVE;
// 							executeEvent(&theEvent);
// 						}
// 						rogue.playbackFastForward = false;
//                         rogue.playbackPaused = pauseState;
// 						displayLevel();
// 						refreshSideBar(-1, -1, false);
//                         updateMessageDisplay();
// 					} else {
// 						flashTemporaryAlert(" Already reached deepest depth explored ", 1000);
// 					}
// 				}
// 				rogue.playbackPaused = pauseState;
// 				return true;
// 			case INVENTORY_KEY:
// 				rogue.playbackMode = false;
// 				displayInventory(ALL_ITEMS, 0, 0, true, false);
// 				rogue.playbackMode = true;
// 				return true;
// 			case RIGHT_KEY:
// 			case RIGHT_ARROW:
//             case LEFT_KEY:
//             case LEFT_ARROW:
//                 if (key == RIGHT_KEY || key == RIGHT_ARROW) {
//                     frameCount = 1;
//                 } else {
//                     frameCount = -1;
//                 }
// 				if (recordingInput->shiftKey) {
// 					frameCount *= 5;
// 					rogue.playbackFastForward = true;
// 				}
// 				if (recordingInput->controlKey) {
// 					frameCount *= 20;
// 					rogue.playbackFastForward = true;
// 				}
//
//                 if (frameCount < 0) {
//                     if ((unsigned long) (frameCount * -1) > rogue.playerTurnNumber) {
//                         destinationFrame = 0;
//                     } else {
//                         destinationFrame = rogue.playerTurnNumber + frameCount;
//                     }
//                 } else {
//                     destinationFrame = min(rogue.playerTurnNumber + frameCount, rogue.howManyTurns - 1);
//                 }
//
//                 if (destinationFrame == rogue.playerTurnNumber) {
//                     flashTemporaryAlert(" Already at end of recording ", 1000);
//                 } else if (frameCount < 0) {
//                     rogue.playbackMode = false;
//                     proceed = (rogue.playerTurnNumber < 100 || confirm("Rewind?", true));
//                     rogue.playbackMode = true;
//                     if (proceed) {
//                         advanceToLocation(destinationFrame);
//                     }
//                 } else {
//                     // advance by the right number of turns
//                     if (!rogue.playbackPaused || unpause()) {
//                         while (rogue.playerTurnNumber < destinationFrame && !rogue.gameHasEnded && !rogue.playbackOOS) {
//                             rogue.RNG = RNG_COSMETIC; // dancing terrain colors can't influence recordings
//                             rogue.playbackDelayThisTurn = 0;
//                             nextBrogueEvent(&theEvent, false, true, false);
//                             rogue.RNG = RNG_SUBSTANTIVE;
//                             executeEvent(&theEvent);
//                         }
//                         rogue.playbackPaused = true;
//                         if (rogue.playbackFastForward) {
//                             rogue.playbackFastForward = false;
//                             displayLevel();
//                             updateMessageDisplay();
//                         }
//                         refreshSideBar(-1, -1, false);
//                     }
//                 }
// 				return true;
// 			case HELP_KEY:
// 				printPlaybackHelpScreen();
// 				return true;
// 			case DISCOVERIES_KEY:
// 				rogue.playbackMode = false;
// 				printDiscoveriesScreen();
// 				rogue.playbackMode = true;
// 				return true;
// 			case MESSAGE_ARCHIVE_KEY:
// 				rogue.playbackMode = false;
// 				displayMessageArchive();
// 				rogue.playbackMode = true;
// 				return true;
// 			case VIEW_RECORDING_KEY:
// 				if (noSaves) {
//         	return false;
//         }
// 				confirmMessages();
// 				rogue.playbackMode = false;
// 				if (dialogChooseFile(path, RECORDING_SUFFIX, "View recording: ")) {
// 					if (fileExists(path)) {
// 						strcpy(rogue.nextGamePath, path);
// 						rogue.nextGame = NG_VIEW_RECORDING;
// 						rogue.gameHasEnded = true;
// 					} else {
// 						message("File not found.", false);
// 					}
// 				}
// 				rogue.playbackMode = true;
// 				return true;
// 			case LOAD_SAVED_GAME_KEY:
// 				if (noSaves) {
//         	return false;
//         }
// 				confirmMessages();
// 				rogue.playbackMode = false;
// 				if (dialogChooseFile(path, GAME_SUFFIX, "Open saved game: ")) {
// 					if (fileExists(path)) {
// 						strcpy(rogue.nextGamePath, path);
// 						rogue.nextGame = NG_OPEN_GAME;
// 						rogue.gameHasEnded = true;
// 					} else {
// 						message("File not found.", false);
// 					}
// 				}
// 				rogue.playbackMode = true;
// 				return true;
// 			case NEW_GAME_KEY:
// 				rogue.playbackMode = false;
// 				if (confirm("Close recording and begin a new game?", true)) {
// 					rogue.nextGame = NG_NEW_GAME;
// 					rogue.gameHasEnded = true;
// 				}
// 				rogue.playbackMode = true;
// 				return true;
// 			case QUIT_KEY:
// 				//freeEverything();
// 				rogue.gameHasEnded = true;
// 				rogue.playbackOOS = false;
//                 rogue.creaturesWillFlashThisTurn = false;
//
//       	//Notify the server that the recording is over
//         notifyEvent(GAMEOVER_RECORDING, 0, 0, "recording ended", "none");
//
// 				return true;
//             case TRUE_COLORS_KEY:
//                 rogue.trueColorMode = !rogue.trueColorMode;
//                 displayLevel();
//                 refreshSideBar(-1, -1, false);
//                 if (rogue.trueColorMode) {
//                     message(KEYBOARD_LABELS ? "Color effects disabled. Press '\\' again to enable." : "Color effects disabled.",
//                                      &teal, false);
//                 } else {
//                     message(KEYBOARD_LABELS ? "Color effects enabled. Press '\\' again to disable." : "Color effects enabled.",
//                                      &teal, false);
//                 }
//                 return true;
//             case AGGRO_DISPLAY_KEY:
//                 rogue.displayAggroRangeMode = !rogue.displayAggroRangeMode;
//                 displayLevel();
//                 refreshSideBar(-1, -1, false);
//                 if (rogue.displayAggroRangeMode) {
//                     message(KEYBOARD_LABELS ? "Stealth range displayed. Press ']' again to hide." : "Stealth range displayed.",
//                                      &teal, false);
//                 } else {
//                     message(KEYBOARD_LABELS ? "Stealth range hidden. Press ']' again to display." : "Stealth range hidden.",
//                                      &teal, false);
//                 }
//                 return true;
// 			case SEED_KEY:
// 				//rogue.playbackMode = false;
// 				//DEBUG {displayGrid(safetyMap); displayMoreSign(); displayLevel();}
// 				//rogue.playbackMode = true;
// 				printSeed();
// 				return true;
// 				break;
// 			default:
// 				if (key >= '0' && key <= '9'
// 					|| key >= NUMPAD_0 && key <= NUMPAD_9) {
//
// 					promptToAdvanceToLocation(key);
// 					return true;
// 				}
// 				break;
// 		}
// 	} else if (recordingInput->eventType == MOUSE_UP) {
// 		x = recordingInput->param1;
// 		y = recordingInput->param2;
// 		if (windowToMapX(x) >= 0 && windowToMapX(x) < DCOLS && y >= 0 && y < MESSAGE_LINES) {
// 			// If the click location is in the message block, display the message archive.
// 			rogue.playbackMode = false;
// 			displayMessageArchive();
// 			rogue.playbackMode = true;
// 			return true;
// 		}
// 	} else if (recordingInput->eventType == RIGHT_MOUSE_UP) {
// 		rogue.playbackMode = false;
// 		displayInventory(ALL_ITEMS, 0, 0, true, false);
// 		rogue.playbackMode = true;
// 		return true;
// 	}
//
// 	return false;
}

// // Pass in defaultPath (the file name WITHOUT suffix), and the suffix.
// // Get back either defaultPath, or "defaultPath N",
// // where N is the lowest counting number that doesn't collide with an existing file.
// void getAvailableFilePath(char *returnPath, const char *defaultPath, const char *suffix) {
// 	char fullPath[BROGUE_FILENAME_MAX];
// 	short fileNameIterator = 2;
//
// 	strcpy(returnPath, defaultPath);
// 	sprintf(fullPath, "%s%s", returnPath, suffix);
// 	while (fileExists(fullPath)) {
// 		sprintf(returnPath, "%s %i", defaultPath, fileNameIterator);
// 		sprintf(fullPath, "%s%s", returnPath, suffix);
// 		fileNameIterator++;
// 	}
// }

function characterForbiddenInFilename(theChar) {
    if (theChar == '/' || theChar == '\\' || theChar == ':') {
        return true;
    } else {
        return false;
    }
}

// async void saveGame() {
// 	char filePath[BROGUE_FILENAME_MAX], defaultPath[BROGUE_FILENAME_MAX];
// 	boolean askAgain;
//
// 	if (rogue.playbackMode) {
// 		return; // Call me paranoid, but I'd rather it be impossible to embed malware in a recording.
// 	}
//
// 	getAvailableFilePath(defaultPath, "Saved game", GAME_SUFFIX);
//
// 	deleteMessages();
// 	do {
// 		askAgain = false;
//    filePath = getInputTextString("Save game as (<esc> to cancel): ",
// 							   BROGUE_FILENAME_MAX - strlen(GAME_SUFFIX), defaultPath, GAME_SUFFIX, TEXT_INPUT_FILENAME, false);
// 		if (filePath && filePath.length) {
// 			strcat(filePath, GAME_SUFFIX);
// 			if (!fileExists(filePath) || confirm("File of that name already exists. Overwrite?", true)) {
// 				remove(filePath);
// 				flushBufferToFile();
// 				rename(currentFilePath, filePath);
// 				strcpy(currentFilePath, filePath);
// 				messageWithAck("Saved.");
// 				rogue.gameHasEnded = true;
// 			} else {
// 				askAgain = true;
// 			}
// 		}
// 	} while (askAgain);
// 	deleteMessages();
// }

function saveRecordingNoPrompt(filePath) {

	if (rogue.playbackMode) {
		return;
	}

	// getAvailableFilePath(filePath, "Recording", RECORDING_SUFFIX);
	// strcat(filePath, RECORDING_SUFFIX);
  //
	// remove(filePath);
	// rename(currentFilePath, filePath);
}

function saveRecording() {
	// char filePath[BROGUE_FILENAME_MAX], defaultPath[BROGUE_FILENAME_MAX];
	// boolean askAgain;

	if (rogue.playbackMode) {
		return;
	}

	// getAvailableFilePath(defaultPath, "Recording", RECORDING_SUFFIX);
  //
	// deleteMessages();
	// do {
	// 	askAgain = false;
  //  filePath = await getInputTextString("Save recording as (<esc> to cancel): ",
	// 						   BROGUE_FILENAME_MAX - strlen(RECORDING_SUFFIX), defaultPath, RECORDING_SUFFIX, TEXT_INPUT_FILENAME, false);
	// 	if (filePath && filePath.length) {
  //
	// 		strcat(filePath, RECORDING_SUFFIX);
	// 		if (!fileExists(filePath) || confirm("File of that name already exists. Overwrite?", true)) {
	// 			remove(filePath);
	// 			rename(currentFilePath, filePath);
	// 		} else {
	// 			askAgain = true;
	// 		}
	// 	} else { // Declined to save recording; save it anyway as LastRecording, and delete LastRecording if it already exists.
  //           strcpy(filePath, LAST_RECORDING_NAME);
	// 		strcat(filePath, RECORDING_SUFFIX);
	// 		if (fileExists(filePath)) {
	// 			remove(filePath);
	// 		}
  //           rename(currentFilePath, filePath);
	// 	}
	// } while (askAgain);
	// deleteMessages();
}

// void copyFile(char *fromFilePath, char *toFilePath, unsigned long fromFileLength) {
// 	unsigned long m, n;
// 	unsigned char fileBuffer[INPUT_RECORD_BUFFER];
// 	FILE *fromFile, *toFile;
//
// 	remove(toFilePath);
//
// 	fromFile	= fopen(fromFilePath, "rb");
// 	toFile		= fopen(toFilePath, "wb");
//
// 	for (n = 0; n < fromFileLength; n += m) {
// 		m = min(INPUT_RECORD_BUFFER, fromFileLength - n);
// 		fread((void *) fileBuffer, 1, m, fromFile);
// 		fwrite((void *) fileBuffer, 1, m, toFile);
// 	}
//
// 	fclose(fromFile);
// 	fclose(toFile);
// }
//
// // at the end of loading a saved game, this function transitions into active play mode.
// void switchToPlaying() {
//     char lastGamePath[BROGUE_FILENAME_MAX];
//
//     getAvailableFilePath(lastGamePath, LAST_GAME_NAME, GAME_SUFFIX);
//     strcat(lastGamePath, GAME_SUFFIX);
//
// 	rogue.playbackMode			= false;
// 	rogue.playbackFastForward	= false;
// 	rogue.playbackOmniscience	= false;
// 	locationInRecordingBuffer	= 0;
// 	copyFile(currentFilePath, lastGamePath, recordingLocation);
//
// #ifdef DELETE_SAVE_FILE_AFTER_LOADING
// 	remove(currentFilePath);
// #endif
//
// 	strcpy(currentFilePath, lastGamePath);
//
// 	blackOutScreen();
// 	refreshSideBar(-1, -1, false);
// 	updateMessageDisplay();
// 	displayLevel();
// }
//
// void loadSavedGame() {
// 	unsigned long progressBarInterval;
// 	rogueEvent theEvent;
//
// 	cellDisplayBuffer dbuf[COLS][ROWS];
//
// 	randomNumbersGenerated = 0;
// 	rogue.playbackMode = true;
// 	rogue.playbackFastForward = true;
// 	initializeRogue(0); // Calls initRecording(). Seed argument is ignored because we're initially in playback mode.
// 	if (!rogue.gameHasEnded) {
// 		blackOutScreen();
// 		startLevel(rogue.depthLevel, 1);
// 	}
//
// 	if (rogue.howManyTurns > 0) {
//
// 		progressBarInterval = max(1, lengthOfPlaybackFile / 100);
//
// 		clearDisplayBuffer(dbuf);
// 		rectangularShading((COLS - 20) / 2, ROWS / 2, 20, 1, &black, INTERFACE_OPACITY, dbuf);
//         rogue.playbackFastForward = false;
// 		overlayDisplayBuffer(dbuf, 0);
//         rogue.playbackFastForward = true;
//
// 		while (recordingLocation < lengthOfPlaybackFile
// 			   && rogue.playerTurnNumber < rogue.howManyTurns
// 			   && !rogue.gameHasEnded
// 			   && !rogue.playbackOOS) {
//
// 			rogue.RNG = RNG_COSMETIC;
// 			nextBrogueEvent(&theEvent, false, true, false);
// 			rogue.RNG = RNG_SUBSTANTIVE;
//
// 			executeEvent(&theEvent);
//
// 			if (!(recordingLocation % progressBarInterval) && !rogue.playbackOOS) {
// 				rogue.playbackFastForward = false; // so the progress bar redraws make it to the screen
// 				printProgressBar((COLS - 20) / 2, ROWS / 2, "[     Loading...   ]", recordingLocation, lengthOfPlaybackFile, &darkPurple, false);
// 				pauseBrogue(1);
// 				rogue.playbackFastForward = true;
// 			}
// 		}
// 	}
//
// 	if (!rogue.gameHasEnded && !rogue.playbackOOS) {
// 		switchToPlaying();
// 		recordChar(SAVED_GAME_LOADED);
// 	}
// }
//
// #pragma mark Debug functions
//
// // the following functions are used to create human-readable descriptions of playback files for debugging purposes
//
// void describeKeystroke(unsigned char key, char *description) {
// 	short i;
// 	uchar c;
// 	const uchar ucharList[52] =	{UP_KEY, DOWN_KEY, LEFT_KEY, RIGHT_KEY, UP_ARROW, LEFT_ARROW,
// 		DOWN_ARROW, RIGHT_ARROW, UPLEFT_KEY, UPRIGHT_KEY, DOWNLEFT_KEY, DOWNRIGHT_KEY,
// 		DESCEND_KEY, ASCEND_KEY, REST_KEY, AUTO_REST_KEY, SEARCH_KEY, INVENTORY_KEY,
// 		ACKNOWLEDGE_KEY, EQUIP_KEY, UNEQUIP_KEY, APPLY_KEY, THROW_KEY, RELABEL_KEY, DROP_KEY, CALL_KEY,
// 		//FIGHT_KEY, FIGHT_TO_DEATH_KEY,
// 		HELP_KEY, DISCOVERIES_KEY, RETURN_KEY,
// 		EXPLORE_KEY, AUTOPLAY_KEY, SEED_KEY, EASY_MODE_KEY, ESCAPE_KEY,
// 		RETURN_KEY, ENTER_KEY, DELETE_KEY, TAB_KEY, PERIOD_KEY, VIEW_RECORDING_KEY, NUMPAD_0,
// 		NUMPAD_1, NUMPAD_2, NUMPAD_3, NUMPAD_4, NUMPAD_5, NUMPAD_6, NUMPAD_7, NUMPAD_8,
// 		NUMPAD_9, UNKNOWN_KEY};
// 	const char descList[53][30] = {"up", "down", "left", "right", "up arrow", "left arrow",
// 		"down arrow", "right arrow", "upleft", "upright", "downleft", "downright",
// 		"descend", "ascend", "rest", "auto rest", "search", "inventory", "acknowledge",
// 		"equip", "unequip", "apply", "throw", "relabel", "drop", "call",
// 		//"fight", "fight to death",
// 		"help", "discoveries", "repeat travel", "explore", "autoplay", "seed",
// 		"easy mode", "escape", "return", "enter", "delete", "tab", "period", "open file",
// 		"numpad 0", "numpad 1", "numpad 2", "numpad 3", "numpad 4", "numpad 5", "numpad 6",
// 		"numpad 7", "numpad 8", "numpad 9", "unknown", "ERROR"};
//
// 	c = uncompressKeystroke(key);
// 	for (i=0; ucharList[i] != c && i < 53; i++);
// 	if (key >= 32 && key <= 126) {
// 		sprintf(description, "Key: %c\t(%s)", key, descList[i]);
// 	} else {
// 		sprintf(description, "Key: %i\t(%s)", key, descList[i]);
// 	}
// }
//
// void appendModifierKeyDescription(char *description) {
// 	unsigned char c = recallChar();
//
// 	if (c & Fl(1)) {
// 		strcat(description, " + CRTL");
// 	}
// 	if (c & Fl(2)) {
// 		strcat(description, " + SHIFT");
// 	}
// }
//
// // Deprecated! Only used to parse recordings, a debugging feature.
// boolean selectFile(char *prompt, char *defaultName, char *suffix) {
// 	boolean retval;
// 	char newFilePath[BROGUE_FILENAME_MAX];
//
// 	retval = false;
//
// 	if (chooseFile(newFilePath, prompt, defaultName, suffix)) {
// 		if (openFile(newFilePath)) {
// 			retval = true;
// 		} else {
// 			confirmMessages();
// 			message("File not found.", false);
// 			retval = false;
// 		}
// 	}
// 	return retval;
// }
//
// void parseFile() {
// 	FILE *descriptionFile;
// 	unsigned long oldFileLoc, oldRecLoc, oldLength, oldBufLoc, i, seed, numTurns, numDepths, fileLength, startLoc;
// 	unsigned char c;
// 	char description[1000], versionString[500];
// 	short x, y;
//
// 	if (selectFile("Parse recording: ", "Recording.broguerec", "")) {
//
// 		oldFileLoc = positionInPlaybackFile;
// 		oldRecLoc = recordingLocation;
// 		oldBufLoc = locationInRecordingBuffer;
// 		oldLength = lengthOfPlaybackFile;
//
// 		positionInPlaybackFile = 0;
// 		locationInRecordingBuffer = 0;
// 		recordingLocation = 0;
// 		lengthOfPlaybackFile = 10000000; // hack so that the recalls don't freak out
// 		fillBufferFromFile();
//
// 		descriptionFile = fopen("Recording Description.txt", "w");
//
// 		for (i=0; i<16; i++) {
// 			versionString[i] = recallChar();
// 		}
//
// 		seed		= recallNumber(4);
// 		numTurns	= recallNumber(4);
// 		numDepths	= recallNumber(4);
// 		fileLength	= recallNumber(4);
//
// 		fprintf(descriptionFile, "Parsed file \"%s\":\n\tVersion: %s\n\tSeed: %li\n\tNumber of turns: %li\n\tNumber of depth changes: %li\n\tFile length: %li\n",
// 				currentFilePath,
// 				versionString,
// 				seed,
// 				numTurns,
// 				numDepths,
// 				fileLength);
// 		for (i=0; recordingLocation < fileLength; i++) {
// 			startLoc = recordingLocation;
// 			c = recallChar();
// 			switch (c) {
// 				case KEYSTROKE:
// 					describeKeystroke(recallChar(), description);
// 					appendModifierKeyDescription(description);
// 					break;
// 				case MOUSE_UP:
// 				case MOUSE_DOWN:
// 				case MOUSE_ENTERED_CELL:
// 					x = (short) recallChar();
// 					y = (short) recallChar();
// 					sprintf(description, "Mouse click: (%i, %i)", x, y);
// 					appendModifierKeyDescription(description);
// 					break;
// 				case RNG_CHECK:
// 					sprintf(description, "\tRNG check: %i", (short) recallChar());
// 					break;
// 				case SAVED_GAME_LOADED:
// 					strcpy(description, "Saved game loaded");
// 					break;
// 				default:
// 					sprintf(description, "UNKNOWN EVENT TYPE: %i", (short) c);
// 					break;
// 			}
// 			fprintf(descriptionFile, "\nEvent %li, loc %li, length %li:%s\t%s", i, startLoc, recordingLocation - startLoc, (i < 10 ? " " : ""), description);
// 		}
//
// 		fclose(descriptionFile);
//
// 		positionInPlaybackFile = oldFileLoc;
// 		recordingLocation = oldRecLoc;
// 		lengthOfPlaybackFile = oldLength;
// 		locationInRecordingBuffer = oldBufLoc;
// 		message("File parsed.", false);
// 	} else {
// 		confirmMessages();
// 	}
// }
//
// void RNGLog(char *message) {
// #ifdef AUDIT_RNG
// 	fputs(message, RNGLogFile);
// #endif
// }
/*
 *  Buttons.c
 *  Brogue
 *
 *  Created by Brian Walker on 1/14/12.
 *  Copyright 2012. All rights reserved.
 *
 *  This file is part of Brogue.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

// #include "Rogue.h"
// #include "IncludeGlobals.h"
// #include <math.h>
// #include <time.h>
// #include <limits.h>

const MENU_FLAME_PRECISION_FACTOR =		10;
const MENU_FLAME_RISE_SPEED =					50;
const MENU_FLAME_SPREAD_SPEED =				20;
const MENU_FLAME_COLOR_DRIFT_SPEED =	500;
const MENU_FLAME_FADE_SPEED =					20;
const MENU_FLAME_UPDATE_DELAY =				50;
const MENU_FLAME_ROW_PADDING =				2;
const MENU_TITLE_OFFSET_X =						(-4);
const MENU_TITLE_OFFSET_Y =						(-1);

const MENU_FLAME_COLOR_SOURCE_COUNT =	1136;

const MENU_FLAME_DENOMINATOR =				(100 + MENU_FLAME_RISE_SPEED + MENU_FLAME_SPREAD_SPEED);

var noMenu = false;




function drawMenuFlames( flames /* short[COLS][(ROWS + MENU_FLAME_ROW_PADDING)][3] */,  mask /* char[COLS][ROWS] */) {
	let i, j, versionStringLength;
  const tempColor = color();
	const maskColor = black;
  let dchar;

  versionStringLength = strLenWithoutEscapes(BROGUE_VERSION_STRING);

	for (j=0; j<ROWS; j++) {
		for (i=0; i<COLS; i++) {
      if (j == ROWS - 1 && i >= COLS - versionStringLength) {
          dchar = BROGUE_VERSION_STRING[i - (COLS - versionStringLength)];
      } else {
          dchar = ' ';
      }

			if (mask[i][j] == 100) {
				plotCharWithColor(dchar, i, j, gray, maskColor);
        // this.canvas.drawText(i, j, dchar, darkGray, maskColor);
			} else {
        tempColor.copy(black);
				tempColor.red	= Math.round(flames[i][j][0] / MENU_FLAME_PRECISION_FACTOR);
				tempColor.green	= Math.round(flames[i][j][1] / MENU_FLAME_PRECISION_FACTOR);
				tempColor.blue	= Math.round(flames[i][j][2] / MENU_FLAME_PRECISION_FACTOR);
        // tempColor.red = 200;
				if (mask[i][j] > 0) {
					applyColorAverage(tempColor, maskColor, mask[i][j]);
				}
				plotCharWithColor(dchar, i, j, gray, tempColor);
        // this.canvas.drawText(i, j, dchar, darkGray, this.tempColor);
			}
		}
	}

}


function updateMenuFlames( colors /* color[COLS][(ROWS + MENU_FLAME_ROW_PADDING)] */,
						colorSources /* short[MENU_FLAME_COLOR_SOURCE_COUNT][4] */,
						flames /* short[COLS][(ROWS + MENU_FLAME_ROW_PADDING)][3] */)
{
	let i, j, k, l, x, y;
	let tempFlames = ARRAY(COLS, () => []); // short[COLS][3];
	let colorSourceNumber, rand;

	colorSourceNumber = 0;
	for (j=0; j<(ROWS + MENU_FLAME_ROW_PADDING); j++) {
		// Make a temp copy of the current row.
		for (i=0; i<COLS; i++) {
			for (k=0; k<3; k++) {
				tempFlames[i][k] = flames[i][j][k];
			}
		}

		for (i=0; i<COLS; i++) {
			// Each cell is the weighted average of the three color values below and itself.
			// Weight of itself: 100
			// Weight of left and right neighbors: MENU_FLAME_SPREAD_SPEED / 2 each
			// Weight of below cell: MENU_FLAME_RISE_SPEED
			// Divisor: 100 + MENU_FLAME_SPREAD_SPEED + MENU_FLAME_RISE_SPEED

			// Itself:
			for (k=0; k<3; k++) {
				flames[i][j][k] = Math.round(100 * flames[i][j][k] / MENU_FLAME_DENOMINATOR);
			}

			// Left and right neighbors:
			for (l = -1; l <= 1; l += 2) {
				x = i + l;
				if (x == -1) {
					x = COLS - 1;
				} else if (x == COLS) {
					x = 0;
				}
				for (k=0; k<3; k++) {
					flames[i][j][k] += Math.floor(MENU_FLAME_SPREAD_SPEED * tempFlames[x][k] / 2 / MENU_FLAME_DENOMINATOR);
				}
			}

			// Below:
			y = j + 1;
			if (y < (ROWS + MENU_FLAME_ROW_PADDING)) {
				for (k=0; k<3; k++) {
					flames[i][j][k] += Math.floor(MENU_FLAME_RISE_SPEED * flames[i][y][k] / MENU_FLAME_DENOMINATOR);
				}
			}

			// Fade a little:
			for (k=0; k<3; k++) {
				flames[i][j][k] = Math.floor((1000 - MENU_FLAME_FADE_SPEED) * flames[i][j][k] / 1000);
			}

			if (colors[i][j]) {
				// If it's a color source tile:

				// First, cause the color to drift a little.
				for (k=0; k<4; k++) {
					colorSources[colorSourceNumber][k] += rand_range(-MENU_FLAME_COLOR_DRIFT_SPEED, MENU_FLAME_COLOR_DRIFT_SPEED);
					colorSources[colorSourceNumber][k] = clamp(colorSources[colorSourceNumber][k], 0, 1000);
				}

				// Then, add the color to this tile's flames.
				rand = Math.floor(colors[i][j].rand * colorSources[colorSourceNumber][0] / 1000);
				flames[i][j][0] += Math.floor((colors[i][j].red	+ (colors[i][j].redRand	* colorSources[colorSourceNumber][1] / 1000) + rand) * MENU_FLAME_PRECISION_FACTOR);
				flames[i][j][1] += Math.floor((colors[i][j].green	+ (colors[i][j].greenRand	* colorSources[colorSourceNumber][2] / 1000) + rand) * MENU_FLAME_PRECISION_FACTOR);
				flames[i][j][2] += Math.floor((colors[i][j].blue	+ (colors[i][j].blueRand	* colorSources[colorSourceNumber][3] / 1000) + rand) * MENU_FLAME_PRECISION_FACTOR);

				colorSourceNumber++;
			}
		}
	}
}


// // Takes a grid of values, each of which is 0 or 100, and fills in some middle values in the interstices.
function antiAlias(mask /* char[COLS][ROWS] */) {
	let i, j, x, y, dir, nbCount;
	let intensity = [0, 0, 35, 50, 60];

	for (i=0; i<COLS; i++) {
		for (j=0; j<ROWS; j++) {
			if (mask[i][j] < 100) {
				nbCount = 0;
				for (dir=0; dir<4; dir++) {
					x = i + nbDirs[dir][0];
					y = j + nbDirs[dir][1];
					if (coordinatesAreInWindow(x, y) && mask[x][y] == 100) {
						nbCount++;
					}
				}
				mask[i][j] = intensity[nbCount];
			}
		}
	}
}



const BROGUE_TITLE = [
  "########   ########       ######         #######   ####     ###  #########",
  " ##   ###   ##   ###    ##     ###     ##      ##   ##       #    ##     #",
  " ##    ##   ##    ##   ##       ###   ##        #   ##       #    ##     #",
  " ##    ##   ##    ##   #    #    ##   #         #   ##       #    ##      ",
  " ##    ##   ##    ##  ##   ##     ## ##             ##       #    ##    # ",
  " ##   ##    ##   ##   ##   ###    ## ##             ##       #    ##    # ",
  " ######     ## ###    ##   ####   ## ##             ##       #    ####### ",
  " ##    ##   ##  ##    ##   ####   ## ##             ##       #    ##    # ",
  " ##     ##  ##   ##   ##    ###   ## ##      #####  ##       #    ##    # ",
  " ##     ##  ##   ##   ###    ##   ## ###       ##   ##       #    ##      ",
  " ##     ##  ##    ##   ##    #    #   ##       ##   ##       #    ##      ",
  " ##     ##  ##    ##   ###       ##   ###      ##   ###      #    ##     #",
  " ##    ##   ##     ##   ###     ##     ###    ###    ###    #     ##     #",
  "########   ####    ###    ######         #####        ######     #########",
  "                            ##                                            ",
  "                        ##########                                        ",
  "                            ##                                            ",
  "                            ##                                            ",
  "                           ####                                           ",
];


const MENU_TITLE_WIDTH =	BROGUE_TITLE[0].length;
const MENU_TITLE_HEIGHT =	BROGUE_TITLE.length;


function initializeMenuFlames(includeTitle,
	colors, 			// const color *[COLS][(ROWS + MENU_FLAME_ROW_PADDING)],
	colorStorage, // color[COLS],
	colorSources, // signed short [MENU_FLAME_COLOR_SOURCE_COUNT][4],
	flames, 			// signed short [COLS][(ROWS + MENU_FLAME_ROW_PADDING)][3],
	mask) 				// unsigned char [COLS][ROWS])
{

	let i, j, k;

	for (i=0; i<COLS; i++) {
		for (j=0; j<ROWS; j++) {
			mask[i][j] = 0;
		}
	}

	for (i=0; i<COLS; i++) {
		for (j=0; j<(ROWS + MENU_FLAME_ROW_PADDING); j++) {
			colors[i][j] = NULL;
			for (k=0; k<3; k++) {
				flames[i][j][k] = 0;
			}
		}
	}

	// Seed source color random components.
	for (i=0; i<MENU_FLAME_COLOR_SOURCE_COUNT; i++) {
		for (k=0; k<4; k++) {
			colorSources[i][k] = rand_range(0, 1000);
		}
	}

	// Put some flame source along the bottom row.
	let colorSourceCount = 0;
	for (i=0; i<COLS; i++) {
		Object.assign(colorStorage[colorSourceCount], flameSourceColor);
		applyColorAverage(colorStorage[colorSourceCount], flameSourceColorSecondary, 100 - (smoothHiliteGradient(i, COLS - 1) + 25));

		colors[i][(ROWS + MENU_FLAME_ROW_PADDING)-1] = colorStorage[colorSourceCount];
		colorSourceCount++;
	}

	if (includeTitle) {
		const title = BROGUE_TITLE;

		// Wreathe the title in flames, and mask it in black.
		for (i=0; i<MENU_TITLE_WIDTH; i++) {
			for (j=0; j<MENU_TITLE_HEIGHT; j++) {
				if (title[j][i] != ' ') {
					const thisCol = Math.round((COLS - MENU_TITLE_WIDTH)/2 + i + MENU_TITLE_OFFSET_X);
					const thisRow = Math.round((ROWS - MENU_TITLE_HEIGHT)/2 + j + MENU_TITLE_OFFSET_Y);
					colors[thisCol][thisRow] = flameTitleColor;
					colorSourceCount++;
					mask[thisCol][thisRow] = 100;
				}
			}
		}

		// Anti-alias the mask.
		antiAlias(mask);
	}

	brogueAssert(colorSourceCount <= MENU_FLAME_COLOR_SOURCE_COUNT);

	// Simulate the background flames for a while
	for (i=0; i<100; i++) {
		updateMenuFlames(colors, colorSources, flames);
	}
}



async function titleMenu() {
	const flames = GRID(COLS, ROWS + MENU_FLAME_ROW_PADDING, () => [0, 0, 0] );		// signed short[COLS][(ROWS + MENU_FLAME_ROW_PADDING)][3]; // red, green and blue
	const colorSources = ARRAY(MENU_FLAME_COLOR_SOURCE_COUNT, () => [0, 0, 0, 0] ); 	// signed short [MENU_FLAME_COLOR_SOURCE_COUNT][4]; // red, green, blue, and rand, one for each color source (no more than MENU_FLAME_COLOR_SOURCE_COUNT).
	const colors = GRID(COLS, ROWS + MENU_FLAME_ROW_PADDING, () => color() ); 	// const color *[COLS][(ROWS + MENU_FLAME_ROW_PADDING)];
  const colorStorage = ARRAY(COLS, () => color() ); 		// const color *[COLS];
	const mask = GRID(COLS, ROWS); // unsigned char[COLS][ROWS];
	let controlKeyWasDown = false;

	let i, b, x, y, button;
	const state = buttonState();
	const buttons = ARRAY(6, brogueButton ); // brogueButton[6];
	let whiteColorEscape  = STRING(); // char[10] = "";
	let goldColorEscape   = STRING(); // char[10] = "";
	let newGameText       = STRING();
	let customNewGameText = STRING();
	const theEvent = rogueEvent();
	// const buttonCommands = [NG_NEW_GAME, NG_OPEN_GAME, NG_VIEW_RECORDING, NG_HIGH_SCORES, NG_QUIT];
	const buttonCommands = [NG_NEW_GAME, NG_NEW_GAME_WITH_SEED, NG_VIEW_RECORDING, NG_HIGH_SCORES, NG_QUIT];

	const shadowBuf = GRID(COLS, ROWS, cellDisplayBuffer ); // cellDisplayBuffer[COLS][ROWS];

	// Initialize the RNG so the flames aren't always the same.

	seedRandomGenerator(0);

	// Empty nextGamePath and nextGameSeed so that the buttons don't try to load an old game path or seed.
	rogue.nextGamePath = '';
	rogue.nextGameSeed = 0;

  encodeMessageColor(whiteColorEscape, 0, white);
  encodeMessageColor(goldColorEscape, 0, KEYBOARD_LABELS ? itemMessageColor : white);
	// sprintf(newGameText, "      %{s}N%{s}ew Game      ", goldColorEscape, whiteColorEscape);
	// sprintf(customNewGameText, " %{s}N%{s}ew Game (custom) ", goldColorEscape, whiteColorEscape);
	b = 0;
	button = -1;

	initializeButton(buttons[b]);
  // strcpy(buttons[b].text, newGameText);
	sprintf(buttons[b].text, "      %{s}N%{s}ew Game      ", goldColorEscape, whiteColorEscape);
	buttons[b].hotkey[0] = 'n';
	buttons[b].hotkey[1] = 'N';
	b++;

	initializeButton(buttons[b]);
  // sprintf(buttons[b].text, "     %{s}O%{s}pen Game      ", goldColorEscape, whiteColorEscape);
	sprintf(buttons[b].text, " New Game with %{s}S%{s}eed ", goldColorEscape, whiteColorEscape);
	buttons[b].hotkey[0] = 's';
	buttons[b].hotkey[1] = 'S';
	b++;

	initializeButton(buttons[b]);
  sprintf(buttons[b].text, "   %{s}V%{s}iew Recording   ", goldColorEscape, whiteColorEscape);
	buttons[b].hotkey[0] = 'v';
	buttons[b].hotkey[1] = 'V';
	b++;

	initializeButton(buttons[b]);
  sprintf(buttons[b].text, "    %{s}H%{s}igh Scores     ", goldColorEscape, whiteColorEscape);
	buttons[b].hotkey[0] = 'h';
	buttons[b].hotkey[1] = 'H';
	b++;

	initializeButton(buttons[b]);
  sprintf(buttons[b].text, "        %{s}Q%{s}uit        ", goldColorEscape, whiteColorEscape);
	buttons[b].hotkey[0] = 'q';
	buttons[b].hotkey[1] = 'Q';
	b++;

	x = COLS - 1 - 20 - 2;
	y = ROWS - 1;
	for (i = b-1; i >= 0; i--) {
		y -= 2;
		buttons[i].x = x;
		buttons[i].y = y;
		buttons[i].buttonColor.copy(titleButtonColor);
		buttons[i].flags |= B_WIDE_CLICK_AREA;
	}

	blackOutScreen();
  clearDisplayBuffer(shadowBuf);
	initializeButtonState(state, buttons, b, x, y, 20, b*2-1);
  rectangularShading(x, y, 20, b*2-1, black, INTERFACE_OPACITY, shadowBuf);
	drawButtonsInState(state);

	initializeMenuFlames(true, colors, colorStorage, colorSources, flames, mask);
  rogue.creaturesWillFlashThisTurn = false; // total unconscionable hack

	do {
		// if (!controlKeyWasDown && controlKeyIsDown()) {
		// 	strcpy(state.buttons[0].text, customNewGameText);
		// 	drawButtonsInState(state);
		// 	buttonCommands[0] = NG_NEW_GAME_WITH_SEED;
		// 	controlKeyWasDown = true;
		// } else if (controlKeyWasDown && !controlKeyIsDown()) {
		// 	strcpy(state.buttons[0].text, newGameText);
		// 	drawButtonsInState(state);
		// 	buttonCommands[0] = NG_NEW_GAME;
		// 	controlKeyWasDown = false;
		// }

		// Update the display.
		updateMenuFlames(colors, colorSources, flames);
		drawMenuFlames(flames, mask);
		overlayDisplayBuffer(shadowBuf, NULL);
		overlayDisplayBuffer(state.dbuf, NULL);

		// Pause briefly.
		if (await pauseBrogue(MENU_FLAME_UPDATE_DELAY, true)) {
			// There was input during the pause! Get the input.
			await nextBrogueEvent(theEvent, true, false, true);

			// Process the input.
			button = await processButtonInput(state, theEvent);
		}

		// Revert the display.
		overlayDisplayBuffer(state.rbuf, NULL);

	} while (button == -1 && rogue.nextGame == NG_NOTHING);

	drawMenuFlames(flames, mask);
	if (button != -1) {
        // if (button == 0 && controlKeyIsDown()) {
        //     // Should fix an issue with Linux/Windows ports that require moving the mouse after
        //     // pressing control to get the button to change.
        //     rogue.nextGame = NG_NEW_GAME_WITH_SEED;
        // } else {
            rogue.nextGame = buttonCommands[button];
        // }
	}
}


async function dialogAlert(message) {
  const rbuf = GRID(COLS, ROWS, cellDisplayBuffer ); // cellDisplayBuffer[COLS][ROWS];

	const OKButton = brogueButton();
	initializeButton(OKButton);
  strcpy(OKButton.text, "     OK     ");
	OKButton.hotkey[0] = RETURN_KEY;
	OKButton.hotkey[1] = ENTER_KEY;
	OKButton.hotkey[2] = ACKNOWLEDGE_KEY;
	await printTextBox(message, Math.round(COLS/3), Math.round(ROWS/3), Math.round(COLS/3), white, interfaceBoxColor, rbuf, [OKButton], 1);
  overlayDisplayBuffer(rbuf, NULL);
}

//
// function stringsExactlyMatch(string1, string2) {
// 	// let i;
// 	// for (i=0; string1[i] && string2[i]; i++) {
// 	// 	if (string1[i] != string2[i]) {
// 	// 		return false;
// 	// 	}
// 	// }
// 	// return string1[i] == string2[i];
// 	return string1 == string2;
// }
//
//
// const FILES_ON_PAGE_MAX =				(min(26, ROWS - 7)); // Two rows (top and bottom) for flames, two rows for border, one for prompt, one for heading.
// const MAX_FILENAME_DISPLAY_LENGTH =		53;
//
//
// boolean dialogChooseFile(char *path, const char *suffix, const char *prompt) {
// 	short i, j, count, x, y, width, height, suffixLength, pathLength, maxPathLength, currentPageStart;
// 	brogueButton buttons[FILES_ON_PAGE_MAX + 2];
// 	fileEntry *files;
// 	boolean retval = false, again;
// 	cellDisplayBuffer dbuf[COLS][ROWS], rbuf[COLS][ROWS];
// 	color *dialogColor = &interfaceBoxColor;
// 	char *membuf;
//
// 	suffixLength = strlen(suffix);
// 	files = listFiles(&count, &membuf);
// 	copyDisplayBuffer(rbuf, displayBuffer);
// 	maxPathLength = strLenWithoutEscapes(prompt);
//
// 	// First, we want to filter the list by stripping out any filenames that do not end with suffix.
// 	// i is the entry we're testing, and j is the entry that we move it to if it qualifies.
// 	for (i=0, j=0; i<count; i++) {
// 		pathLength = strlen(files[i].path);
// 		//printf("\nString 1: %s", &(files[i].path[(max(0, pathLength - suffixLength))]));
// 		if (stringsExactlyMatch(&(files[i].path[(max(0, pathLength - suffixLength))]), suffix)) {
//
// 			// This file counts!
// 			if (i > j) {
// 				files[j] = files[i];
// 				//printf("\nMatching file: %s\twith date: %s", files[j].path, files[j].date);
// 			}
// 			j++;
//
// 			// Keep track of the longest length.
// 			if (min(pathLength, MAX_FILENAME_DISPLAY_LENGTH) + 10 > maxPathLength) {
// 				maxPathLength = min(pathLength, MAX_FILENAME_DISPLAY_LENGTH) + 10;
// 			}
// 		}
// 	}
// 	count = j;
//
// 	currentPageStart = 0;
//
// 	do { // Repeat to permit scrolling.
// 		again = false;
//
// 		for (i=0; i<min(count - currentPageStart, FILES_ON_PAGE_MAX); i++) {
// 			initializeButton(&(buttons[i]));
// 			buttons[i].flags &= ~(B_WIDE_CLICK_AREA | B_GRADIENT);
// 			buttons[i].buttonColor = *dialogColor;
//             if (KEYBOARD_LABELS) {
//                 sprintf(buttons[i].text, "%c) ", 'a' + i);
//             } else {
//                 buttons[i].text[0] = '\0';
//             }
// 			strncat(buttons[i].text, files[currentPageStart+i].path, MAX_FILENAME_DISPLAY_LENGTH);
//
// 			// Clip off the file suffix from the button text.
// 			buttons[i].text[strlen(buttons[i].text) - suffixLength] = '\0'; // Snip!
// 			buttons[i].hotkey[0] = 'a' + i;
// 			buttons[i].hotkey[1] = 'A' + i;
//
// 			// Clip the filename length if necessary.
// 			if (strlen(buttons[i].text) > MAX_FILENAME_DISPLAY_LENGTH) {
// 				strcpy(&(buttons[i].text[MAX_FILENAME_DISPLAY_LENGTH - 3]), "...");
// 			}
//
// 			//printf("\nFound file: %s, with date: %s", files[currentPageStart+i].path, files[currentPageStart+i].date);
// 		}
//
// 		x = (COLS - maxPathLength) / 2;
// 		width = maxPathLength;
// 		height = min(count - currentPageStart, FILES_ON_PAGE_MAX) + 2;
// 		y = max(4, (ROWS - height) / 2);
//
// 		for (i=0; i<min(count - currentPageStart, FILES_ON_PAGE_MAX); i++) {
// 			pathLength = strlen(buttons[i].text);
// 			for (j=pathLength; j<(width - 8); j++) {
// 				buttons[i].text[j] = ' ';
// 			}
// 			buttons[i].text[j] = '\0';
// 			strcpy(&(buttons[i].text[j]), files[currentPageStart+i].date);
// 			buttons[i].x = x;
// 			buttons[i].y = y + 1 + i;
// 		}
//
// 		if (count > FILES_ON_PAGE_MAX) {
// 			// Create up and down arrows.
// 			initializeButton(&(buttons[i]));
// 			strcpy(buttons[i].text, "     *     ");
// 			buttons[i].symbol[0] = UP_ARROW_CHAR;
// 			if (currentPageStart <= 0) {
// 				buttons[i].flags &= ~(B_ENABLED | B_DRAW);
// 			} else {
// 				buttons[i].hotkey[0] = UP_ARROW;
// 				buttons[i].hotkey[1] = NUMPAD_8;
// 				buttons[i].hotkey[2] = PAGE_UP_KEY;
// 			}
// 			buttons[i].x = x + (width - 11)/2;
// 			buttons[i].y = y;
//
// 			i++;
// 			initializeButton(&(buttons[i]));
// 			strcpy(buttons[i].text, "     *     ");
// 			buttons[i].symbol[0] = DOWN_ARROW_CHAR;
// 			if (currentPageStart + FILES_ON_PAGE_MAX >= count) {
// 				buttons[i].flags &= ~(B_ENABLED | B_DRAW);
// 			} else {
// 				buttons[i].hotkey[0] = DOWN_ARROW;
// 				buttons[i].hotkey[1] = NUMPAD_2;
// 				buttons[i].hotkey[2] = PAGE_DOWN_KEY;
// 			}
// 			buttons[i].x = x + (width - 11)/2;
// 			buttons[i].y = y + i;
// 		}
//
// 		if (count) {
// 			clearDisplayBuffer(dbuf);
// 			printString(prompt, x, y - 1, &itemMessageColor, dialogColor, dbuf);
// 			rectangularShading(x - 1, y - 1, width + 1, height + 1, dialogColor, INTERFACE_OPACITY, dbuf);
// 			overlayDisplayBuffer(dbuf, NULL);
//
// //			for (j=0; j<min(count - currentPageStart, FILES_ON_PAGE_MAX); j++) {
// //				printf("\nSanity check BEFORE: %s, with date: %s", files[currentPageStart+j].path, files[currentPageStart+j].date);
// //				printf("\n   (button name)Sanity check BEFORE: %s", buttons[j].text);
// //			}
//
// 			i = buttonInputLoop(buttons,
// 								min(count - currentPageStart, FILES_ON_PAGE_MAX) + (count > FILES_ON_PAGE_MAX ? 2 : 0),
// 								x,
// 								y,
// 								width,
// 								height,
// 								NULL);
//
// //			for (j=0; j<min(count - currentPageStart, FILES_ON_PAGE_MAX); j++) {
// //				printf("\nSanity check AFTER: %s, with date: %s", files[currentPageStart+j].path, files[currentPageStart+j].date);
// //				printf("\n   (button name)Sanity check AFTER: %s", buttons[j].text);
// //			}
//
// 			overlayDisplayBuffer(rbuf, NULL);
//
// 			if (i < min(count - currentPageStart, FILES_ON_PAGE_MAX)) {
// 				if (i >= 0) {
// 					retval = true;
// 					strcpy(path, files[currentPageStart+i].path);
// 				} else { // i is -1
// 					retval = false;
// 				}
// 			} else if (i == min(count - currentPageStart, FILES_ON_PAGE_MAX)) { // Up arrow
// 				again = true;
// 				currentPageStart -= FILES_ON_PAGE_MAX;
// 			} else if (i == min(count - currentPageStart, FILES_ON_PAGE_MAX) + 1) { // Down arrow
// 				again = true;
// 				currentPageStart += FILES_ON_PAGE_MAX;
// 			}
// 		}
//
// 	} while (again);
//
// 	free(files);
// 	free(membuf);
//
// 	if (count == 0) {
// 		dialogAlert("No applicable files found.");
// 		return false;
// 	} else {
// 		return retval;
// 	}
// }
//
// void scumMonster(creature *monst, FILE *logFile) {
//     char buf[500];
//     if (monst->bookkeepingFlags & MB_CAPTIVE) {
//         monsterName(buf, monst, false);
//         upperCase(buf);
//         fprintf(logFile, "\n        %s (captive)", buf);
//         if (monst->machineHome > 0) {
//             fprintf(logFile, " (vault %i)", monst->machineHome);
//         }
//     } else if (monst->creatureState == MONSTER_ALLY) {
//         monsterName(buf, monst, false);
//         upperCase(buf);
//         fprintf(logFile, "\n        %s (allied)", buf);
//         if (monst->machineHome) {
//             fprintf(logFile, " (vault %i)", monst->machineHome);
//         }
//     }
// }
//
// void scum(unsigned long startingSeed, short numberOfSeedsToScan, short scanThroughDepth) {
//     unsigned long theSeed;
//     char path[BROGUE_FILENAME_MAX];
//     item *theItem;
//     creature *monst;
//     char buf[500];
//     FILE *logFile;
//
//     logFile = fopen("Brogue seed catalog.txt", "w");
//     rogue.nextGame = NG_NOTHING;
//
//     getAvailableFilePath(path, LAST_GAME_NAME, GAME_SUFFIX);
//     strcat(path, GAME_SUFFIX);
//
//     fprintf(logFile, "Brogue seed catalog, seeds %li to %li, through depth %i.\n\n\
// To play one of these seeds, press control-N from the title screen \
// and enter the seed number. Knowing which items will appear on \
// the first %i depths will, of course, make the game significantly easier.",
//             startingSeed, startingSeed + numberOfSeedsToScan - 1, scanThroughDepth, scanThroughDepth);
//
//     for (theSeed = startingSeed; theSeed < startingSeed + numberOfSeedsToScan; theSeed++) {
//         fprintf(logFile, "\n\nSeed %li:", theSeed);
//         printf("\nScanned seed %li.", theSeed);
//         rogue.nextGamePath[0] = '\0';
//         randomNumbersGenerated = 0;
//
//         rogue.playbackMode = false;
//         rogue.playbackFastForward = false;
//         rogue.playbackBetweenTurns = false;
//
//         strcpy(currentFilePath, path);
//         initializeRogue(theSeed);
//         rogue.playbackOmniscience = true;
//         for (rogue.depthLevel = 1; rogue.depthLevel <= scanThroughDepth; rogue.depthLevel++) {
//             startLevel(rogue.depthLevel == 1 ? 1 : rogue.depthLevel - 1, 1); // descending into level n
//             fprintf(logFile, "\n    Depth %i:", rogue.depthLevel);
//             for (theItem = floorItems->nextItem; theItem != NULL; theItem = theItem->nextItem) {
//                 itemName(theItem, buf, true, true, NULL);
//                 upperCase(buf);
//                 fprintf(logFile, "\n        %s", buf);
//                 if (pmap[theItem->xLoc][theItem->yLoc].machineNumber > 0) {
//                     fprintf(logFile, " (vault %i)", pmap[theItem->xLoc][theItem->yLoc].machineNumber);
//                 }
//             }
//             for (monst = monsters->nextCreature; monst != NULL; monst = monst->nextCreature) {
//                 scumMonster(monst, logFile);
//             }
//             for (monst = dormantMonsters->nextCreature; monst != NULL; monst = monst->nextCreature) {
//                 scumMonster(monst, logFile);
//             }
//         }
//         freeEverything();
//         remove(currentFilePath); // Don't add a spurious LastGame file to the brogue folder.
//     }
//     fclose(logFile);
// }

// This is the basic program loop.
// When the program launches, or when a game ends, you end up here.
// If the player has already said what he wants to do next
// (by storing it in rogue.nextGame -- possibilities listed in enum NGCommands),
// we'll do it. The path (rogue.nextGamePath) is essentially a parameter for this command, and
// tells NG_VIEW_RECORDING and NG_OPEN_GAME which file to open. If there is a command but no
// accompanying path, and it's a command that should take a path, then pop up a dialog to have
// the player specify a path. If there is no command (i.e. if rogue.nextGame contains NG_NOTHING),
// then we'll display the title screen so the player can choose.
async function mainBrogueJunction() {
	const theEvent = rogueEvent();
	const path = STRING(), buf = STRING(), seedDefault = STRING();    // char[]
	const maxSeed = STRING(); // char [20];
	let i, j, k;
	let seedTooBig;

	// clear screen and display buffer
	for (i=0; i<COLS; i++) {
		for (j=0; j<ROWS; j++) {
			displayBuffer[i][j].char = ' ';
			displayBuffer[i][j].needsUpdate = false;
			displayBuffer[i][j].opacity = 100;
			for (k=0; k<3; k++) {
				displayBuffer[i][j].foreColorComponents[k] = 0;
				displayBuffer[i][j].backColorComponents[k] = 0;
			}
			plotCharWithColor(' ', i, j, black, black);
		}
	}

	// initializeLaunchArguments(rogue.nextGame, rogue.nextGamePath, rogue.nextGameSeed);

	do {
    rogue.gameHasEnded = false;
    rogue.playbackFastForward = false;
    rogue.playbackMode = false;
  	switch (rogue.nextGame) {
			case NG_NOTHING:
				if(noMenu) {
					//Abort the game after completing a game or playback
					rogue.nextGame = NG_QUIT;
				}
				else {
					// Run the main menu to get a decision out of the player.
        	await titleMenu();
				}
				break;
			case NG_NEW_GAME:
			case NG_NEW_GAME_WITH_SEED:
				rogue.nextGamePath = '';
				randomNumbersGenerated = 0;

				rogue.playbackMode = false;
				rogue.playbackFastForward = false;
				rogue.playbackBetweenTurns = false;

        // path = getAvailableFilePath(LAST_GAME_NAME, GAME_SUFFIX);
        // path += GAME_SUFFIX;
				// currentFilePath = path;

				if (rogue.nextGame == NG_NEW_GAME_WITH_SEED) {
					if (rogue.nextGameSeed == 0) { // Prompt for seed; default is the previous game's seed.
						sprintf(maxSeed, "%l", RAND_MAX_COMBO); // ULONG_MAX);
						if (previousGameSeed == 0) {
							strcpy(seedDefault, '');
						} else {
							sprintf(seedDefault, "%l", previousGameSeed);
						}
            await getInputTextString(buf, "Generate dungeon with seed number:",
											   log10(RAND_MAX_COMBO) + 1, // log10(ULONG_MAX) + 1,
											   seedDefault,
											   "",
											   TEXT_INPUT_NUMBERS,
											   true);
						if ( strlen(buf) ) {
							seedTooBig = false;
							if (strlen(buf) > strlen(maxSeed)) {
								seedTooBig = true;
							} else if ( strlen(buf) == strlen(maxSeed)) {
                if (Number.parseInt(buf.text) > Number.parseInt(maxSeed.text)) {
                  seedTooBig = true;
                }
							}
							if (seedTooBig) {
								rogue.nextGameSeed = RAND_MAX_COMBO;
							} else {
								rogue.nextGameSeed = Number.parseInt(buf.text);
							}
						} else {
							rogue.nextGame = NG_NOTHING;
							break; // Don't start a new game after all.
						}
					}
				} else {
					rogue.nextGameSeed = 0; // 123456; // Seed based on clock.
				}

				rogue.nextGame = NG_NOTHING;
				initializeRogue(rogue.nextGameSeed);
				await startLevel(rogue.depthLevel, 1); // descending into level 1

				await mainInputLoop();
				freeEverything();
				break;
			case NG_OPEN_GAME:
				rogue.nextGame = NG_NOTHING;
				await dialogAlert("Not implemented.");
				// path = '';
				// if (rogue.nextGamePath.length) {
				// 	path = rogue.nextGamePath;
				// 	rogue.nextGamePath = '';
				// } else {
				// 	path = await dialogChooseFile(GAME_SUFFIX, "Open saved game:");
				// 	//chooseFile(path, "Open saved game: ", "Saved game", GAME_SUFFIX);
				// }
        //
				// if (openFile(path)) {
				// 	loadSavedGame();
				// 	mainInputLoop();
				// 	freeEverything();
				// } else {
				// 	//dialogAlert("File not found.");
				// }
				// rogue.playbackMode = false;
				// rogue.playbackOOS = false;

				break;
			case NG_VIEW_RECORDING:
				rogue.nextGame = NG_NOTHING;
				await dialogAlert("Not implemented.");

        //
				// path[0] = '\0';
				// if (rogue.nextGamePath[0]) {
				// 	strcpy(path, rogue.nextGamePath);
				// 	rogue.nextGamePath[0] = '\0';
				// } else {
				// 	dialogChooseFile(path, RECORDING_SUFFIX, "View recording:");
				// 	//chooseFile(path, "View recording: ", "Recording", RECORDING_SUFFIX);
				// }
        //
				// if (openFile(path)) {
				// 	randomNumbersGenerated = 0;
				// 	rogue.playbackMode = true;
				// 	initializeRogue(0); // Seed argument is ignored because we're in playback.
				// 	if (!rogue.gameHasEnded) {
				// 		startLevel(rogue.depthLevel, 1);
        //                 rogue.playbackPaused = true;
				// 		displayAnnotation(); // in case there's an annotation for turn 0
				// 	}
        //
				// 	while(!rogue.gameHasEnded && rogue.playbackMode) {
        //                 if (rogue.playbackPaused) {
        //                     rogue.playbackPaused = false;
        //                     pausePlayback();
        //                 }
        //
				// 		rogue.RNG = RNG_COSMETIC; // dancing terrain colors can't influence recordings
				// 		rogue.playbackBetweenTurns = true;
				// 		nextBrogueEvent(&theEvent, false, true, false);
				// 		rogue.RNG = RNG_SUBSTANTIVE;
        //
				// 		executeEvent(&theEvent);
				// 	}
        //
				// 	freeEverything();
				// } else {
				// 	// announce file not found
				// }
				// rogue.playbackMode = false;
				// rogue.playbackOOS = false;

				break;
			case NG_HIGH_SCORES:
				rogue.nextGame = NG_NOTHING;
				await printHighScores(false);
				break;
      case NG_SCUM:
          // rogue.nextGame = NG_NOTHING;
          // scum(1, 1000, 5);
          break;
			case NG_QUIT:
				// No need to do anything.
				break;
			default:
				break;
		}
	} while (rogue.nextGame != NG_QUIT);
}

return {
};

}));

// EOF
